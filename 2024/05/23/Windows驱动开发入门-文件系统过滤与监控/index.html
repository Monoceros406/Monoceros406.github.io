<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Windows驱动开发入门-文件系统过滤与监控 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Windows驱动开发入门-文件系统过滤与监控碎碎念sfilter貌似已经过时，建议使用Minifilter写文件系统过滤。 当要求区分目录、涉及文件系统的要求时，存储设备驱动很难解决问题，需要使用文件系统过滤。FAT32的驱动为fastfat.sys，NTFS的驱动叫ntfs.sys，这俩都在Windows的drivers目录下。像这样的FS文件系统生成两类设备，一类CDO控制对象，用来修改这个">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows驱动开发入门-文件系统过滤与监控">
<meta property="og:url" content="http://monoceros.github.io/2024/05/23/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4%E4%B8%8E%E7%9B%91%E6%8E%A7/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="Windows驱动开发入门-文件系统过滤与监控碎碎念sfilter貌似已经过时，建议使用Minifilter写文件系统过滤。 当要求区分目录、涉及文件系统的要求时，存储设备驱动很难解决问题，需要使用文件系统过滤。FAT32的驱动为fastfat.sys，NTFS的驱动叫ntfs.sys，这俩都在Windows的drivers目录下。像这样的FS文件系统生成两类设备，一类CDO控制对象，用来修改这个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://monoceros.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-05-23T10:45:05.000Z">
<meta property="article:modified_time" content="2024-05-26T12:18:25.897Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="逆向工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://monoceros.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://monoceros.github.io/2024/05/23/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4%E4%B8%8E%E7%9B%91%E6%8E%A7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Windows驱动开发入门-文件系统过滤与监控',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-26 20:18:25'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="The Blog of Monoceros406" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">291</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/ycy')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Windows驱动开发入门-文件系统过滤与监控</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-23T10:45:05.000Z" title="发表于 2024-05-23 18:45:05">2024-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-26T12:18:25.897Z" title="更新于 2024-05-26 20:18:25">2024-05-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Windows驱动开发入门-文件系统过滤与监控"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Windows驱动开发入门-文件系统过滤与监控"><a href="#Windows驱动开发入门-文件系统过滤与监控" class="headerlink" title="Windows驱动开发入门-文件系统过滤与监控"></a>Windows驱动开发入门-文件系统过滤与监控</h1><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>sfilter貌似已经过时，建议使用Minifilter写文件系统过滤。</p>
<p>当要求区分目录、涉及文件系统的要求时，存储设备驱动很难解决问题，需要使用文件系统过滤。FAT32的驱动为fastfat.sys，NTFS的驱动叫ntfs.sys，这俩都在Windows的drivers目录下。像这样的FS文件系统生成两类设备，一类CDO控制对象，用来修改这个驱动内部配置，一个文件系统只对应一个CDO；另一类文件系统卷设备，一个卷对应一个逻辑盘。例如逻辑盘“C:”只是个符号链接，真正的设备名叫“\Device\HarddiskVolume1”。卷设备时卷管理器生成的，没名字，不能直接绑定，要不绑定的不是系统生成的卷设备而是真正的卷设备。对文件的读写IRP都发送到卷设备，不论卷文件系统是什么，一个卷一个卷设备。绑定卷设备前先绑定文件系统控制设备。</p>
<p>在文件过滤中，按照国际惯例应该把控制设备生成到“\FileSystem\Filters”下，但有些早期Windows系统没这个路径，所以直接生成到“\FileSystem”下。</p>
<p>这节代码太复杂了，不打算格式化了，可读性可能很低。这一节东西理解就好，用的时候大多不用修改。</p>
<h2 id="设备对象-分发函数"><a href="#设备对象-分发函数" class="headerlink" title="设备对象&amp;分发函数"></a>设备对象&amp;分发函数</h2><h3 id="控制设备生成"><a href="#控制设备生成" class="headerlink" title="控制设备生成"></a>控制设备生成</h3><p>驱动入口<code>DriverEntry</code>的主要工作：</p>
<ul>
<li>生成一个CDO并指定名字。</li>
<li>设置普通分发函数、快速IO分发函数。</li>
<li>实现一个文件系统变动回调函数，在其中绑定刚激活的FS CDO，并使用<code>IoRegsiterFsRegistrationChange</code>注册这个回调函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT DriverObject,IN PUNICODE_STRING RegistryPath)</span></span>&#123;</span><br><span class="line">    PFAST_IO_DISPATCH fastIoDispatch;</span><br><span class="line">    UNICODE_STRING nameString;</span><br><span class="line">    UNICODE_STRING path2K;</span><br><span class="line">    UNICODE_STRING pathXP;</span><br><span class="line">    WCHAR nameBuffer[MY_DEV_MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING userNameString;</span><br><span class="line">    WCHAR userNameBuffer[MY_DEV_MAX_NAME] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING syblnkString;</span><br><span class="line">    WCHAR syblnkBuffer[MY_DEV_MAX_NAME] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING dosDevicePrefix;</span><br><span class="line">    UNICODE_STRING dosDevice;</span><br><span class="line">    WCHAR dosDeviceBuffer[MY_DEV_MAX_NAME] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    ULONG i;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501</span></span><br><span class="line">    <span class="comment">//  Try to load the dynamic functions that may be available for our use.</span></span><br><span class="line">    <span class="built_in">SfLoadDynamicFunctions</span>();</span><br><span class="line">    <span class="comment">//  Now get the current OS version that we will use to determine what logic paths to take when this driver is built to run on various OS version.</span></span><br><span class="line">    <span class="built_in">SfGetCurrentVersion</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//  Get Registry values</span></span><br><span class="line">    <span class="built_in">SfReadDriverParameters</span>(RegistryPath);</span><br><span class="line">    <span class="comment">//  Save our Driver Object, set our UNLOAD routine</span></span><br><span class="line">    gSFilterDriverObject = DriverObject;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501</span></span><br><span class="line">    <span class="comment">//  MULTIVERSION <span class="doctag">NOTE:</span></span></span><br><span class="line">    <span class="comment">//  We can only support unload for testing environments if we can enumerate the outstanding device objects that our driver has.</span></span><br><span class="line">    <span class="comment">//  Unload is useful for development purposes. It is not recommended for production versions</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != gSfDynamicFunctions.EnumerateDeviceObjectList)</span><br><span class="line">        gSFilterDriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//  Setup other global variables</span></span><br><span class="line">    <span class="built_in">ExInitializeFastMutex</span>(&amp;gSfilterAttachLock);</span><br><span class="line">    <span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;nameString, nameBuffer, MY_DEV_MAX_PATH);</span><br><span class="line">    <span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;userNameString, userNameBuffer, MY_DEV_MAX_NAME);</span><br><span class="line">    <span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;syblnkString, syblnkBuffer, MY_DEV_MAX_NAME);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;pathXP, <span class="string">L&quot;\\FileSystem\\Filters\\&quot;</span>);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;path2K, <span class="string">L&quot;\\FileSystem\\&quot;</span>);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;dosDevicePrefix, <span class="string">L&quot;\\DosDevices\\&quot;</span>);</span><br><span class="line">    <span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;dosDevice, dosDeviceBuffer, MY_DEV_MAX_NAME);</span><br><span class="line">    <span class="built_in">RtlCopyUnicodeString</span>(&amp;dosDevice, &amp;dosDevicePrefix);</span><br><span class="line">    status = <span class="built_in">OnSfilterDriverEntry</span>(DriverObject, RegistryPath, &amp;userNameString, &amp;syblnkString, &amp;gUserExtensionSize);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    <span class="built_in">RtlCopyUnicodeString</span>(&amp;nameString, &amp;pathXP);</span><br><span class="line">    <span class="built_in">RtlAppendUnicodeStringToString</span>(&amp;nameString, &amp;userNameString);</span><br><span class="line">    <span class="comment">//  Create the Control Device Object (CDO).  This object represents this driver.  Note that it does not have a device extension.</span></span><br><span class="line">    <span class="comment">// 这是生成控制设备。</span></span><br><span class="line">    <span class="keyword">if</span> (g_cdo_for_all_users)</span><br><span class="line">        status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="number">0</span>, &amp;nameString, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;gSFilterControlDeviceObject); <span class="comment">//没有设备扩展</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 以下生成一个可以被任何用户打开读写的设备。但是这个guid是我手写固定的。不清楚如果在有多个基于本sfilter模块的驱动同时安装的时候，会不会导致出现guid重复的问题。</span></span><br><span class="line">        UNICODE_STRING sddlString;</span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;sddlString, <span class="string">L&quot;D:P(A;;GA;;;WD)&quot;</span>);</span><br><span class="line">        status = <span class="built_in">IoCreateDeviceSecure</span>(DriverObject, <span class="number">0</span>, &amp;nameString, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;sddlString, (LPCGUID)&amp;SFGUID_CLASS_MYCDO, &amp;gSFilterControlDeviceObject);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (status == STATUS_OBJECT_PATH_NOT_FOUND) &#123; <span class="comment">//路径没找到 生成失败</span></span><br><span class="line">        <span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;nameString, nameBuffer, MY_DEV_MAX_PATH);</span><br><span class="line">        <span class="built_in">RtlCopyUnicodeString</span>(&amp;nameString, &amp;path2K);</span><br><span class="line">        <span class="built_in">RtlAppendUnicodeStringToString</span>(&amp;nameString, &amp;userNameString);</span><br><span class="line">        <span class="comment">// 这是再次生成控制设备。</span></span><br><span class="line">        <span class="keyword">if</span> (g_cdo_for_all_users)</span><br><span class="line">            status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="number">0</span>, &amp;nameString, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;gSFilterControlDeviceObject); <span class="comment">//has no device extension</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 以下生成一个可以被任何用户打开读写的设备。但是这个guid是我手写固定的。不清楚如果在有多个基于本sfilter模块的驱动同时安装的时候，会不会导致出现guid重复的问题。</span></span><br><span class="line">            UNICODE_STRING sddlString;</span><br><span class="line">            <span class="built_in">RtlInitUnicodeString</span>(&amp;sddlString, <span class="string">L&quot;D:P(A;;GA;;;WD)&quot;</span>);</span><br><span class="line">            status = <span class="built_in">IoCreateDeviceSecure</span>(DriverObject, <span class="number">0</span>, &amp;nameString, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;sddlString, (LPCGUID)&amp;SFGUID_CLASS_MYCDO, &amp;gSFilterControlDeviceObject);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">            <span class="built_in">KdPrint</span>((<span class="string">&quot;SFilter!DriverEntry: Error creating control device object \&quot;%wZ\&quot;, status=%08x\n&quot;</span>, &amp;nameString, status));</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;SFilter!DriverEntry: Error creating control device object \&quot;%wZ\&quot;, status=%08x\n&quot;</span>, &amp;nameString, status));</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">RtlAppendUnicodeStringToString</span>(&amp;dosDevice, &amp;syblnkString);</span><br><span class="line">    <span class="built_in">IoDeleteSymbolicLink</span>(&amp;dosDevice);</span><br><span class="line">    status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;dosDevice, &amp;nameString);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;SFilter!DriverEntry: Error creating syblnk object \&quot;%wZ\&quot;, status=%08x\n&quot;</span>, &amp;syblnkString, status));</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(DriverObject-&gt;DeviceObject);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  Initialize the driver object with this device driver&#x27;s entry points.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++)</span><br><span class="line">        DriverObject-&gt;MajorFunction[i] = SfPassThrough;</span><br><span class="line">    <span class="comment">//  We will use SfCreate for all the create operations</span></span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = SfCreate;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CREATE_NAMED_PIPE] = SfCreate;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CREATE_MAILSLOT] = SfCreate;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = SfFsControl;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = SfCleanupClose;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = SfCleanupClose;</span><br><span class="line">    <span class="comment">//  Allocate fast I/O data structure and fill it in.</span></span><br><span class="line">    <span class="comment">//  <span class="doctag">NOTE:</span>  The following FastIo Routines are not supported:</span></span><br><span class="line">    <span class="comment">//      AcquireFileForNtCreateSection</span></span><br><span class="line">    <span class="comment">//      ReleaseFileForNtCreateSection</span></span><br><span class="line">    <span class="comment">//      AcquireForModWrite</span></span><br><span class="line">    <span class="comment">//      ReleaseForModWrite</span></span><br><span class="line">    <span class="comment">//      AcquireForCcFlush</span></span><br><span class="line">    <span class="comment">//      ReleaseForCcFlush</span></span><br><span class="line">    <span class="comment">//  For historical reasons these FastIO&#x27;s have never been sent to filtersby the NT I/O system.  Instead, they are sent directly to the base file system.  On Windows XP and later OS releases, you can use the new system routine &quot;FsRtlRegisterFileSystemFilterCallbacks&quot; if you need to intercept these callbacks (see below).</span></span><br><span class="line">    fastIoDispatch = <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="built_in">sizeof</span>(FAST_IO_DISPATCH), SFLT_POOL_TAG);</span><br><span class="line">    <span class="keyword">if</span> (!fastIoDispatch) &#123;</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(gSFilterControlDeviceObject);</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(fastIoDispatch, <span class="built_in">sizeof</span>(FAST_IO_DISPATCH));</span><br><span class="line">    fastIoDispatch-&gt;SizeOfFastIoDispatch = <span class="built_in">sizeof</span>(FAST_IO_DISPATCH);</span><br><span class="line">    fastIoDispatch-&gt;FastIoCheckIfPossible = SfFastIoCheckIfPossible;</span><br><span class="line">    fastIoDispatch-&gt;FastIoRead = SfFastIoRead;</span><br><span class="line">    fastIoDispatch-&gt;FastIoWrite = SfFastIoWrite;</span><br><span class="line">    fastIoDispatch-&gt;FastIoQueryBasicInfo = SfFastIoQueryBasicInfo;</span><br><span class="line">    fastIoDispatch-&gt;FastIoQueryStandardInfo = SfFastIoQueryStandardInfo;</span><br><span class="line">    fastIoDispatch-&gt;FastIoLock = SfFastIoLock;</span><br><span class="line">    fastIoDispatch-&gt;FastIoUnlockSingle = SfFastIoUnlockSingle;</span><br><span class="line">    fastIoDispatch-&gt;FastIoUnlockAll = SfFastIoUnlockAll;</span><br><span class="line">    fastIoDispatch-&gt;FastIoUnlockAllByKey = SfFastIoUnlockAllByKey;</span><br><span class="line">    fastIoDispatch-&gt;FastIoDeviceControl = SfFastIoDeviceControl;</span><br><span class="line">    fastIoDispatch-&gt;FastIoDetachDevice = SfFastIoDetachDevice;</span><br><span class="line">    fastIoDispatch-&gt;FastIoQueryNetworkOpenInfo = SfFastIoQueryNetworkOpenInfo;</span><br><span class="line">    fastIoDispatch-&gt;MdlRead = SfFastIoMdlRead;</span><br><span class="line">    fastIoDispatch-&gt;MdlReadComplete = SfFastIoMdlReadComplete;</span><br><span class="line">    fastIoDispatch-&gt;PrepareMdlWrite = SfFastIoPrepareMdlWrite;</span><br><span class="line">    fastIoDispatch-&gt;MdlWriteComplete = SfFastIoMdlWriteComplete;</span><br><span class="line">    fastIoDispatch-&gt;FastIoReadCompressed = SfFastIoReadCompressed;</span><br><span class="line">    fastIoDispatch-&gt;FastIoWriteCompressed = SfFastIoWriteCompressed;</span><br><span class="line">    fastIoDispatch-&gt;MdlReadCompleteCompressed = SfFastIoMdlReadCompleteCompressed;</span><br><span class="line">    fastIoDispatch-&gt;MdlWriteCompleteCompressed = SfFastIoMdlWriteCompleteCompressed;</span><br><span class="line">    fastIoDispatch-&gt;FastIoQueryOpen = SfFastIoQueryOpen;</span><br><span class="line">    DriverObject-&gt;FastIoDispatch = fastIoDispatch;</span><br><span class="line">    <span class="comment">//  VERSION <span class="doctag">NOTE:</span></span></span><br><span class="line">    <span class="comment">//  There are 6 FastIO routines for which file system filters are bypassed as the requests are passed directly to the base file system.  These 6 routines are AcquireFileForNtCreateSection, ReleaseFileForNtCreateSection, AcquireForModWrite, ReleaseForModWrite, AcquireForCcFlush, and ReleaseForCcFlush.</span></span><br><span class="line">    <span class="comment">//  In Windows XP and later, the FsFilter callbacks were introduced to allow filters to safely hook these operations.  See the IFS Kit documentation for more details on how these new interfaces work.</span></span><br><span class="line">    <span class="comment">//  MULTIVERSION <span class="doctag">NOTE:</span></span></span><br><span class="line">    <span class="comment">//  If built for Windows XP or later, this driver is built to run on multiple versions.  When this is the case, we will test for the presence of FsFilter callbacks registration API.  If we have it, then we will register for those callbacks, otherwise, we will not.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501</span></span><br><span class="line">    &#123;</span><br><span class="line">        FS_FILTER_CALLBACKS fsFilterCallbacks;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != gSfDynamicFunctions.RegisterFileSystemFilterCallbacks) &#123;</span><br><span class="line">            <span class="comment">//  Setup the callbacks for the operations we receive through the FsFilter interface.</span></span><br><span class="line">            <span class="comment">//  <span class="doctag">NOTE:</span>  You only need to register for those routines you really need to handle.  SFilter is registering for all routines simply to give an example of how it is done.</span></span><br><span class="line">            fsFilterCallbacks.SizeOfFsFilterCallbacks = <span class="built_in">sizeof</span>(FS_FILTER_CALLBACKS);</span><br><span class="line">            fsFilterCallbacks.PreAcquireForSectionSynchronization = SfPreFsFilterPassThrough;</span><br><span class="line">            fsFilterCallbacks.PostAcquireForSectionSynchronization = SfPostFsFilterPassThrough;</span><br><span class="line">            fsFilterCallbacks.PreReleaseForSectionSynchronization = SfPreFsFilterPassThrough;</span><br><span class="line">            fsFilterCallbacks.PostReleaseForSectionSynchronization = SfPostFsFilterPassThrough;</span><br><span class="line">            fsFilterCallbacks.PreAcquireForCcFlush = SfPreFsFilterPassThrough;</span><br><span class="line">            fsFilterCallbacks.PostAcquireForCcFlush = SfPostFsFilterPassThrough;</span><br><span class="line">            fsFilterCallbacks.PreReleaseForCcFlush = SfPreFsFilterPassThrough;</span><br><span class="line">            fsFilterCallbacks.PostReleaseForCcFlush = SfPostFsFilterPassThrough;</span><br><span class="line">            fsFilterCallbacks.PreAcquireForModifiedPageWriter = SfPreFsFilterPassThrough;</span><br><span class="line">            fsFilterCallbacks.PostAcquireForModifiedPageWriter = SfPostFsFilterPassThrough;</span><br><span class="line">            fsFilterCallbacks.PreReleaseForModifiedPageWriter = SfPreFsFilterPassThrough;</span><br><span class="line">            fsFilterCallbacks.PostReleaseForModifiedPageWriter = SfPostFsFilterPassThrough;</span><br><span class="line">            status = (gSfDynamicFunctions.RegisterFileSystemFilterCallbacks)(DriverObject, &amp;fsFilterCallbacks);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">                DriverObject-&gt;FastIoDispatch = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">ExFreePool</span>(fastIoDispatch);</span><br><span class="line">                <span class="built_in">IoDeleteDevice</span>(gSFilterControlDeviceObject);</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//  The registered callback routine &quot;SfFsNotification&quot; will be called whenever a new file systems is loaded or when any file system is unloaded.</span></span><br><span class="line">    <span class="comment">//  VERSION <span class="doctag">NOTE:</span></span></span><br><span class="line">    <span class="comment">//  On Windows XP and later this will also enumerate all existing file systems (except the RAW file systems).  On Windows 2000 this does notenumerate the file systems that were loaded before this filter was loaded.</span></span><br><span class="line">    status = <span class="built_in">IoRegisterFsRegistrationChange</span>(DriverObject, SfFsNotification); <span class="comment">//注册一个文件系统变动回调函数 当文件系统被激活或卸载时使用</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;SFilter!DriverEntry: Error registering FS change notification, status=%08x\n&quot;</span>, status));</span><br><span class="line">        DriverObject-&gt;FastIoDispatch = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">ExFreePool</span>(fastIoDispatch);</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(gSFilterControlDeviceObject);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  Attempt to attach to the appropriate RAW file system device objects since they are not enumerated by IoRegisterFsRegistrationChange.</span></span><br><span class="line">    &#123;</span><br><span class="line">        PDEVICE_OBJECT rawDeviceObject;</span><br><span class="line">        PFILE_OBJECT fileObject;</span><br><span class="line">        <span class="comment">//  Attach to RawDisk device</span></span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;nameString, <span class="string">L&quot;\\Device\\RawDisk&quot;</span>);</span><br><span class="line">        status = <span class="built_in">IoGetDeviceObjectPointer</span>(&amp;nameString, FILE_READ_ATTRIBUTES, &amp;fileObject, &amp;rawDeviceObject);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">            <span class="built_in">SfFsNotification</span>(rawDeviceObject, TRUE);</span><br><span class="line">            <span class="built_in">ObDereferenceObject</span>(fileObject);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  Attach to the RawCdRom device</span></span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;nameString, <span class="string">L&quot;\\Device\\RawCdRom&quot;</span>);</span><br><span class="line">        status = <span class="built_in">IoGetDeviceObjectPointer</span>(&amp;nameString, FILE_READ_ATTRIBUTES, &amp;fileObject, &amp;rawDeviceObject);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">            <span class="built_in">SfFsNotification</span>(rawDeviceObject, TRUE);</span><br><span class="line">            <span class="built_in">ObDereferenceObject</span>(fileObject);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  Clear the initializing flag on the control device object since we have now successfully initialized everything.</span></span><br><span class="line">    <span class="built_in">ClearFlag</span>(gSFilterControlDeviceObject-&gt;Flags, DO_DEVICE_INITIALIZING);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="普通分发函数"><a href="#普通分发函数" class="headerlink" title="普通分发函数"></a>普通分发函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SfPassThrough</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    SF_RET ret;</span><br><span class="line">    PVOID context;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="comment">//  Sfilter doesn&#x27;t allow handles to its control device object to be created,therefore, no other operation should be able to come through.</span></span><br><span class="line">    <span class="comment">//  所有的处理例程首先要判断是否是CDO的请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_MY_CONTROL_DEVICE_OBJECT</span>(DeviceObject)) &#123;</span><br><span class="line">        status = <span class="built_in">OnSfilterCDODispatch</span>(DeviceObject, Irp);</span><br><span class="line">        <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IS_MY_DEVICE_OBJECT</span>(DeviceObject)) &#123;</span><br><span class="line">        PVOID context = <span class="literal">NULL</span>;</span><br><span class="line">        ret = <span class="built_in">OnSfilterIrpPre</span>(DeviceObject, <span class="literal">NULL</span>, <span class="literal">NULL</span>, Irp, &amp;status, &amp;context);</span><br><span class="line">        <span class="built_in">ASSERT</span>(context == <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">ASSERT</span>(ret == SF_IRP_COMPLETED);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  Get this driver out of the driver stack and get to the next driver as quickly as possible.</span></span><br><span class="line">    <span class="comment">//  对于本地文件系统我们只过滤卷设备</span></span><br><span class="line">    <span class="keyword">if</span> ((DeviceObject-&gt;DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) &amp;&amp; (((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;StorageStackDeviceObject == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">IoSkipCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">IoCallDriver</span>(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;AttachedToDeviceObject, Irp);</span><br><span class="line">    &#125;;</span><br><span class="line">    ret = <span class="built_in">OnSfilterIrpPre</span>(DeviceObject, ((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;AttachedToDeviceObject, (PVOID)(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;UserExtension), Irp, &amp;status, &amp;context);</span><br><span class="line">    <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">case</span> SF_IRP_PASS: &#123;</span><br><span class="line">            <span class="built_in">IoSkipCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">IoCallDriver</span>(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;AttachedToDeviceObject, Irp);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> SF_IRP_COMPLETED:</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            KEVENT waitEvent;</span><br><span class="line">            <span class="built_in">KeInitializeEvent</span>(&amp;waitEvent, NotificationEvent, FALSE);</span><br><span class="line">            <span class="built_in">IoCopyCurrentIrpStackLocationToNext</span>(Irp);</span><br><span class="line">            <span class="built_in">IoSetCompletionRoutine</span>(Irp, SfCreateCompletion, &amp;waitEvent, TRUE, TRUE, TRUE);</span><br><span class="line">            status = <span class="built_in">IoCallDriver</span>(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;AttachedToDeviceObject, Irp);</span><br><span class="line">            <span class="keyword">if</span> (STATUS_PENDING == status) &#123;</span><br><span class="line">                NTSTATUS localStatus = <span class="built_in">KeWaitForSingleObject</span>(&amp;waitEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">ASSERT</span>(STATUS_SUCCESS == localStatus);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">ASSERT</span>(<span class="built_in">KeReadStateEvent</span>(&amp;waitEvent) || !<span class="built_in">NT_SUCCESS</span>(Irp-&gt;IoStatus.Status));</span><br><span class="line">            <span class="built_in">OnSfilterIrpPost</span>(DeviceObject, ((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;AttachedToDeviceObject, (PVOID)(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;UserExtension), Irp, status, context);</span><br><span class="line">            status = Irp-&gt;IoStatus.Status;</span><br><span class="line">            <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="快速IO分发函数"><a href="#快速IO分发函数" class="headerlink" title="快速IO分发函数"></a>快速IO分发函数</h3><p>一大堆东西，在<code>driver-&gt;FastIoDispatch</code>中没有空间，需要自己用<code>ExAllocatePoolWithTag</code>来分配非分页内存。串口、键盘、硬盘等驱动不需要注册这些回调函数，上层根本不会调用，但文件系统上层会，不注册就蓝屏。但有个方法可以糊弄过去，每个快速IO分发函数返回FALSE，这些请求都会通过IRP重新发送给普通分发函数来捕获，但有效率损失，但不大:)。</p>
<p>其中一个快速IO分发函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">SfFastIoCheckIfPossible</span><span class="params">(IN PFILE_OBJECT FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, IN BOOLEAN Wait, IN ULONG LockKey, IN BOOLEAN CheckForReadOperation, OUT PIO_STATUS_BLOCK IoStatus, IN PDEVICE_OBJECT DeviceObject)</span> </span>&#123;</span><br><span class="line">    PDEVICE_OBJECT nextDeviceObject;</span><br><span class="line">    PFAST_IO_DISPATCH fastIoDispatch;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="comment">// 如果是控制设备，不允许</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_MY_CONTROL_DEVICE_OBJECT</span>(DeviceObject))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 如果不是我的设备(影子设备可能发生这种情况)    </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IS_MY_DEVICE_OBJECT</span>(DeviceObject))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">if</span> (DeviceObject-&gt;DeviceExtension) &#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">IS_MY_DEVICE_OBJECT</span>(DeviceObject));</span><br><span class="line">        <span class="comment">//  Pass through logic for this type of Fast I/O</span></span><br><span class="line">        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;AttachedToDeviceObject; <span class="comment">//得到本驱动绑定的设备</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(nextDeviceObject);</span><br><span class="line">        fastIoDispatch = nextDeviceObject-&gt;DriverObject-&gt;FastIoDispatch; <span class="comment">//得到目标设备FastIo分发函数接口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">VALID_FAST_IO_DISPATCH_HANDLER</span>(fastIoDispatch, FastIoCheckIfPossible))</span><br><span class="line">            <span class="keyword">return</span> (fastIoDispatch-&gt;FastIoCheckIfPossible)(FileObject, FileOffset, Length, Wait, LockKey, CheckForReadOperation, IoStatus, nextDeviceObject); <span class="comment">//直接调用</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其他快速IO分发函数介绍：</p>
<ul>
<li><code>FastIoCheckIfPossible</code>：被<code>FsRtl</code>系列函数调用，用于确认读写操作是否可以用快速IO接口进行。</li>
<li><code>FastIoRead</code>&#x2F;<code>FastIoWrite</code>：读写处理。</li>
<li><code>FastIoQueryBasicInfo</code>、<code>FastIoQueryStandardInfo</code>：获取各种文件信息。</li>
<li><code>FastIoLock</code>、<code>FastIoUnlockSingle</code>、<code>FastIoUnlockAll</code>&#x2F;<code>FastIoUnlockAllByKey</code>：文件锁定操作。</li>
<li><code>FastIoDeviceControl</code>：提供<code>NtDeviceIoControlFile</code>的支持。</li>
<li><code>AcquireFileForNtCreateSection</code>&#x2F;<code>ReleaseFileForNtCreateSection</code>：NTFS映射文件内容到内存页面前进行的操作。</li>
<li><code>FastIoDetachDevice</code>：当可移除介质被拿走后把上层设备和将要销毁的设备解除绑定。</li>
<li><code>FastIoQueryNetworkOpenInfo</code>：CIFS（网上邻居&#x2F;网络重定向驱动）在NT4时传输协议增加了一个FileNetworkOpenInformation网络文件请求，FSD增加了这个接口用于在一次操作中获得所有文件信息。</li>
<li><code>FastIoAcquireForModWrite</code>：Modified Page Writer调用这个接口获取文件锁，实现这个接口时使文件锁范围减小到调用的指定位置。不实现这个接口时整个文件将被锁。</li>
<li><code>FastIoPrepareMdlWrite</code>：FSD提供MDL，向MDL写入数据代表向文件写入数据，参数中有用于描叙要写的目标文件。</li>
<li><code>FastIoMdlWriteComplete</code>：写操作完成，FSD回收MDL。</li>
<li><code>FastIoReadCompressed</code>：读压缩后的数据，调用者负责解压。</li>
<li><code>FastIoWriteCompressed</code>：将数据压缩后存储。</li>
<li><code>FastIoMdlReadCompressed</code>&#x2F;<code>FastIoMdlReadCompleteCompressed</code>：MDL版本压缩读，后者接口被调用时MDL必须释放。</li>
<li><code>FastIoMdlWriteCompressed</code>&#x2F;<code>FastIoMdlWriteCompleteCompressed</code>：同上，压缩写。</li>
<li><code>FastIoQueryOpen </code>：打开文件、获取文件基本信息并关闭文件。</li>
<li><code>FastIoReleaseForModWrite</code>：释放<code>FastIoAcquireForModWrite</code>占有的锁。</li>
<li><code>FastIoAcquireForCcFlush</code>&#x2F;<code>FastIoReleaseForCcFlush</code>：FsRtl调用此接口，在延迟写线程将要把修改后文件数据写入前调用，获取文件锁。</li>
</ul>
<h2 id="设备绑定"><a href="#设备绑定" class="headerlink" title="设备绑定"></a>设备绑定</h2><h3 id="动态绑定函数"><a href="#动态绑定函数" class="headerlink" title="动态绑定函数"></a>动态绑定函数</h3><p>例如<code>IoAttachDeviceToDeviceStackSafe</code>等函数在低版本系统中不存在，所以这里使用内核函数动态加载的方式。当动态获取某个函数指针时为空，则改为使用<code>IoAttachDeviceToDeviceStack</code>函数。<code>MmGetSystemRoutineAddress</code>可动态寻找一个内核函数指针，原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTKERNELAPI PVOID <span class="title">MmGetSystemRoutineAddress</span><span class="params">(IN PUNICODE_STRING SystemRoutineName)</span></span>; <span class="comment">//例如L&quot;IoAttachDeviceToDeviceStackSafe&quot;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SfAttachDeviceToDeviceStack</span><span class="params">(IN PDEVICE_OBJECT SourceDevice, IN PDEVICE_OBJECT TargetDevice, IN OUT PDEVICE_OBJECT* AttachedToDeviceObject)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_WINDOWSXP_OR_LATER</span>()) &#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="literal">NULL</span> != gSfDynamicFunctions.AttachDeviceToDeviceStackSafe);</span><br><span class="line">        <span class="keyword">return</span> (gSfDynamicFunctions.AttachDeviceToDeviceStackSafe)(SourceDevice, TargetDevice, AttachedToDeviceObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ASSERT( NULL == gSfDynamicFunctions.AttachDeviceToDeviceStackSafe );</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        *AttachedToDeviceObject = TargetDevice;</span><br><span class="line">        *AttachedToDeviceObject = <span class="built_in">IoAttachDeviceToDeviceStack</span>(SourceDevice, TargetDevice);</span><br><span class="line">        <span class="keyword">if</span> (*AttachedToDeviceObject == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> STATUS_NO_SUCH_DEVICE;</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="文件系统变动回调函数"><a href="#文件系统变动回调函数" class="headerlink" title="文件系统变动回调函数"></a>文件系统变动回调函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">SfFsNotification</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN BOOLEAN FsActive)</span> </span>&#123;</span><br><span class="line">    UNICODE_STRING name;</span><br><span class="line">    WCHAR nameBuffer[MAX_DEVNAME_LENGTH];</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="comment">//  Init local name buffer</span></span><br><span class="line">    <span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;name, nameBuffer, <span class="built_in">sizeof</span>(nameBuffer));</span><br><span class="line">    <span class="built_in">SfGetObjectName</span>(DeviceObject, &amp;name);</span><br><span class="line">    <span class="comment">//  Display the names of all the file system we are notified of</span></span><br><span class="line">    <span class="built_in">SF_LOG_PRINT</span>(SFDEBUG_DISPLAY_ATTACHMENT_NAMES, (<span class="string">&quot;SFilter!SfFsNotification:                    %s   %p \&quot;%wZ\&quot; (%s)\n&quot;</span>, (FsActive) ? <span class="string">&quot;Activating file system  &quot;</span> : <span class="string">&quot;Deactivating file system&quot;</span>, DeviceObject, &amp;name, <span class="built_in">GET_DEVICE_TYPE_NAME</span>(DeviceObject-&gt;DeviceType)));</span><br><span class="line">    <span class="comment">//  Handle attaching/detaching from the given file system.</span></span><br><span class="line">    <span class="keyword">if</span> (FsActive)</span><br><span class="line">        <span class="built_in">SfAttachToFileSystemDevice</span>(DeviceObject, &amp;name); <span class="comment">//绑定文件系统控制设备</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">SfDetachFromFileSystemDevice</span>(DeviceObject); <span class="comment">//注销 解除绑定</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="文件系统识别器"><a href="#文件系统识别器" class="headerlink" title="文件系统识别器"></a>文件系统识别器</h3><p>只关心磁盘文件系统、光盘、网络文件系统：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Macro to test for device types we want to attach to</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_DESIRED_DEVICE_TYPE(_type) (((_type) == FILE_DEVICE_DISK_FILE_SYSTEM) || ((_type) == FILE_DEVICE_CD_ROM_FILE_SYSTEM) || ((_type) == FILE_DEVICE_NETWORK_FILE_SYSTEM))</span></span><br></pre></td></tr></table></figure>

<p>当新的物理存储媒介进入系统后，IO管理器会加载各种文件系统的文件系统识别器对他进行识别，识别成功后加载真正的对应文件系统驱动，并卸载掉文件系统识别器。文件系统识别器的CDO很像文件系统的CDO，绑定他可能出现问题，最好放弃绑定。Windows标注文件系统识别器由驱动“\FileSystem\Fs_Rec”生成，当然也有些不是，这些文件系统控制请求过滤中有相应处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SfAttachToFileSystemDevice</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PUNICODE_STRING DeviceName)</span> </span>&#123;</span><br><span class="line">    PDEVICE_OBJECT newDeviceObject;</span><br><span class="line">    PSFILTER_DEVICE_EXTENSION devExt;</span><br><span class="line">    UNICODE_STRING fsrecName;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    UNICODE_STRING fsName;</span><br><span class="line">    WCHAR tempNameBuffer[MAX_DEVNAME_LENGTH];</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="comment">//  See if this is a file system type we care about.  If not, return.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IS_DESIRED_DEVICE_TYPE</span>(DeviceObject-&gt;DeviceType)) <span class="comment">//检查设备类型</span></span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    <span class="comment">//  always init NAME buffer</span></span><br><span class="line">    <span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;fsName, tempNameBuffer, <span class="built_in">sizeof</span>(tempNameBuffer));</span><br><span class="line">    <span class="comment">//  See if we should attach to the standard file system recognizer device or not</span></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;fsrecName, <span class="string">L&quot;\\FileSystem\\Fs_Rec&quot;</span>);</span><br><span class="line">    <span class="built_in">SfGetObjectName</span>(DeviceObject-&gt;DriverObject, &amp;fsName);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">FlagOn</span>(SfDebug, SFDEBUG_ATTACH_TO_FSRECOGNIZER)) <span class="comment">//根据我们是否要绑定识别器来决定是否跳过文件系统识别器</span></span><br><span class="line">        <span class="comment">//  See if this is one of the standard Microsoft file system recognizer devices (see if this device is in the FS_REC driver).  If so skip it.  We no longer attach to file system recognizer devices, we simply wait for the real file system driver to load.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">RtlCompareUnicodeString</span>(&amp;fsName, &amp;fsrecName, TRUE) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> STATUS_SUCCESS; <span class="comment">//放弃绑定 直接返回成功即可</span></span><br><span class="line">    <span class="comment">//  We want to attach to this file system.  Create a new device object we can attach with.</span></span><br><span class="line">    status = <span class="built_in">IoCreateDevice</span>(gSFilterDriverObject, <span class="built_in">sizeof</span>(SFILTER_DEVICE_EXTENSION) + gUserExtensionSize, <span class="literal">NULL</span>, DeviceObject-&gt;DeviceType, <span class="number">0</span>, FALSE, &amp;newDeviceObject); <span class="comment">//生成新的设备 准备绑定目标设备</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OnSfilterAttachPre</span>(newDeviceObject, DeviceObject, &amp;fsName, (PVOID)(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;UserExtension))) <span class="comment">//最后一节讲 询问用户是否要绑定</span></span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">//  Propagate flags from Device Object we are trying to attach to. Note that we do this before the actual attachment to make sure the flags are properly set once we are attached (since an IRP can come in immediately after attachment but before the flags would be set).</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FlagOn</span>(DeviceObject-&gt;Flags, DO_BUFFERED_IO)) <span class="comment">//复制各种标志</span></span><br><span class="line">        <span class="built_in">SetFlag</span>(newDeviceObject-&gt;Flags, DO_BUFFERED_IO);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FlagOn</span>(DeviceObject-&gt;Flags, DO_DIRECT_IO))</span><br><span class="line">        <span class="built_in">SetFlag</span>(newDeviceObject-&gt;Flags, DO_DIRECT_IO);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FlagOn</span>(DeviceObject-&gt;Characteristics, FILE_DEVICE_SECURE_OPEN))</span><br><span class="line">        <span class="built_in">SetFlag</span>(newDeviceObject-&gt;Characteristics, FILE_DEVICE_SECURE_OPEN);</span><br><span class="line">    <span class="comment">//  Do the attachment</span></span><br><span class="line">    devExt = newDeviceObject-&gt;DeviceExtension;</span><br><span class="line">    status = <span class="built_in">SfAttachDeviceToDeviceStack</span>(newDeviceObject, DeviceObject, &amp;devExt-&gt;AttachedToDeviceObject); <span class="comment">//绑定</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="keyword">goto</span> ErrorCleanupDevice;</span><br><span class="line">    <span class="comment">//  Set the name</span></span><br><span class="line">    devExt-&gt;TypeFlag = SFLT_POOL_TAG;</span><br><span class="line">    <span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;devExt-&gt;DeviceName, devExt-&gt;DeviceNameBuffer, <span class="built_in">sizeof</span>(devExt-&gt;DeviceNameBuffer)); <span class="comment">//设备名字记录到设备扩展中</span></span><br><span class="line">    <span class="built_in">RtlCopyUnicodeString</span>(&amp;devExt-&gt;DeviceName, DeviceName);        <span class="comment">//Save Name</span></span><br><span class="line">    <span class="comment">//  Mark we are done initializing</span></span><br><span class="line">    <span class="built_in">ClearFlag</span>(newDeviceObject-&gt;Flags, DO_DEVICE_INITIALIZING);</span><br><span class="line">    <span class="comment">//  Display who we have attached to</span></span><br><span class="line">    <span class="built_in">SF_LOG_PRINT</span>(SFDEBUG_DISPLAY_ATTACHMENT_NAMES, (<span class="string">&quot;SFilter!SfAttachToFileSystemDevice:          Attaching to file system   %p \&quot;%wZ\&quot; (%s)\n&quot;</span>, DeviceObject, &amp;devExt-&gt;DeviceName, <span class="built_in">GET_DEVICE_TYPE_NAME</span>(newDeviceObject-&gt;DeviceType)));</span><br><span class="line">    <span class="comment">//  VERSION <span class="doctag">NOTE:</span></span></span><br><span class="line">    <span class="comment">//  In Windows XP, the IO Manager provided APIs to safely enumerate all the device objects for a given driver.  This allows filters to attach to all mounted volumes for a given file system at some time after the volume has been mounted.  There is no support for this functionality in Windows 2000.</span></span><br><span class="line">    <span class="comment">//  MULTIVERSION <span class="doctag">NOTE:</span></span></span><br><span class="line">    <span class="comment">//  If built for Windows XP or later, this driver is built to run on multiple versions.  When this is the case, we will test for the presence of the new IO Manager routines that allow for volume  enumeration.  If they are not present, we will not enumerate the volumes when we attach to a new file system.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_WINDOWSXP_OR_LATER</span>()) &#123; </span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="literal">NULL</span> != gSfDynamicFunctions.EnumerateDeviceObjectList &amp;&amp; <span class="literal">NULL</span> != gSfDynamicFunctions.GetDiskDeviceObject &amp;&amp; <span class="literal">NULL</span> != gSfDynamicFunctions.GetDeviceAttachmentBaseRef &amp;&amp; <span class="literal">NULL</span> != gSfDynamicFunctions.GetLowerDeviceObject);</span><br><span class="line">        <span class="comment">//  Enumerate all the mounted devices that currently exist for this file system and attach to them.</span></span><br><span class="line">        status = <span class="built_in">SfEnumerateFileSystemVolumes</span>(DeviceObject, &amp;fsName); <span class="comment">//枚举所有的卷 逐个绑定</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">            <span class="built_in">IoDetachDevice</span>(devExt-&gt;AttachedToDeviceObject);</span><br><span class="line">            <span class="keyword">goto</span> ErrorCleanupDevice;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">OnSfilterAttachPost</span>(newDeviceObject, DeviceObject, devExt-&gt;AttachedToDeviceObject, (PVOID)(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;UserExtension), STATUS_SUCCESS); <span class="comment">//最后一节讲 绑定后处理回调函数</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    <span class="comment">//                  Cleanup error handling</span></span><br><span class="line">ErrorCleanupDevice: <span class="comment">//错误处理</span></span><br><span class="line">    <span class="built_in">SfCleanupMountedDevice</span>(newDeviceObject);</span><br><span class="line">    <span class="built_in">IoDeleteDevice</span>(newDeviceObject);</span><br><span class="line">    <span class="built_in">OnSfilterAttachPost</span>(newDeviceObject, DeviceObject, <span class="literal">NULL</span>, (PVOID)(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;UserExtension), status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="FS-CDO绑定"><a href="#FS-CDO绑定" class="headerlink" title="FS-CDO绑定"></a>FS-CDO绑定</h2><h3 id="FS-CDO绑定-1"><a href="#FS-CDO绑定-1" class="headerlink" title="FS-CDO绑定"></a>FS-CDO绑定</h3><p>sfilter过滤设备的设备扩展定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SFILTER_DEVICE_EXTENSION</span> &#123; <span class="comment">//文件过滤系统驱动的设备扩展</span></span><br><span class="line">    ULONG TypeFlag;</span><br><span class="line">    PDEVICE_OBJECT AttachedToDeviceObject; <span class="comment">//绑定的文件系统设备（真实设备）</span></span><br><span class="line">    PDEVICE_OBJECT StorageStackDeviceObject; <span class="comment">//与文件系统设备相关的真实设备（磁盘） 在绑定时用</span></span><br><span class="line">    UNICODE_STRING DeviceName; <span class="comment">//如果绑定了一个卷 那么这是物理磁盘卷名 否则是绑定的CDO名</span></span><br><span class="line">    WCHAR DeviceNameBuffer[MAX_DEVNAME_LENGTH]; <span class="comment">//保存名字的缓冲区</span></span><br><span class="line">    <span class="comment">// The extension used by other user.</span></span><br><span class="line">    UCHAR UserExtension[<span class="number">1</span>];</span><br><span class="line">&#125; SFILTER_DEVICE_EXTENSION, * PSFILTER_DEVICE_EXTENSION;</span><br></pre></td></tr></table></figure>

<p>为了让系统看起来过滤驱动和文件系统一样的话，有些标志位需要复制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">FlagOn</span>(DeviceObject-&gt;Flags, DO_BUFFERED_IO))</span><br><span class="line">    <span class="built_in">SetFlag</span>(newDeviceObject-&gt;Flags, DO_BUFFERED_IO);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FlagOn</span>(DeviceObject-&gt;Flags, DO_DIRECT_IO))</span><br><span class="line">    <span class="built_in">SetFlag</span>(newDeviceObject-&gt;Flags, DO_DIRECT_IO);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FlagOn</span>(DeviceObject-&gt;Characteristics, FILE_DEVICE_SECURE_OPEN))</span><br><span class="line">    <span class="built_in">SetFlag</span>(newDeviceObject-&gt;Characteristics, FILE_DEVICE_SECURE_OPEN);</span><br></pre></td></tr></table></figure>

<p>上文的<code>SfAttachToFileSystemDevice</code>即为代码。</p>
<h3 id="利用文件系统控制请求"><a href="#利用文件系统控制请求" class="headerlink" title="利用文件系统控制请求"></a>利用文件系统控制请求</h3><p>当有卷设备被挂载或解挂载时，<code>SfFsControl</code>会被系统回调。从这个回调函数中获取卷设备相关信息并绑定它，才能捕获各种针对文件的IRP，从而获得监控各种文件操作的能力。主功能号为IRP_MJ_FILE_SYSTEM_CONTROL时，下面这几个次功能号IRP要被处理：</p>
<ul>
<li>IRP_MN_MOUNT_VOLUMN：一个卷被挂载，这时要调用<code>SfFsControlMountVolume</code>来绑定一个卷。</li>
<li>IRP_MN_LOAD_FILE_SYSTEM：文件系统识别器要求加载真正的文件系统。</li>
<li>IRP_MN_USER_FS_REQUEST：此时可以从<code>irpSp-&gt;Parameters.FileSystemControl.FsControlCode</code>中获得一个控制码，当控制码为FSCTL_DISMOUNT_VOLUME时说明是个磁盘解挂载。捕获U盘手工拔出太复杂了，但解挂载后sfilter不删除过滤设备也问题不大，除了一点内存泄露。</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SfFsControl</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</span> </span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION irpSp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="comment">//  Sfilter doesn&#x27;t allow handles to its control device object to be created, therefore, no other operation should be able to come through.</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(!<span class="built_in">IS_MY_CONTROL_DEVICE_OBJECT</span>(DeviceObject));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IS_MY_DEVICE_OBJECT</span>(DeviceObject)) &#123;</span><br><span class="line">        PVOID context = <span class="literal">NULL</span>;</span><br><span class="line">        NTSTATUS status;</span><br><span class="line">        SF_RET ret = <span class="built_in">OnSfilterIrpPre</span>(DeviceObject, <span class="literal">NULL</span>, <span class="literal">NULL</span>, Irp, &amp;status, &amp;context);</span><br><span class="line">        <span class="built_in">ASSERT</span>(context == <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">ASSERT</span>(ret == SF_IRP_COMPLETED);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  Process the minor function code.</span></span><br><span class="line">    <span class="keyword">switch</span> (irpSp-&gt;MinorFunction) &#123;</span><br><span class="line">        <span class="keyword">case</span> IRP_MN_MOUNT_VOLUME:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">SfFsControlMountVolume</span>(DeviceObject, Irp);</span><br><span class="line">        <span class="keyword">case</span> IRP_MN_LOAD_FILE_SYSTEM:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">SfFsControlLoadFileSystem</span>(DeviceObject, Irp);</span><br><span class="line">        <span class="keyword">case</span> IRP_MN_USER_FS_REQUEST: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (irpSp-&gt;Parameters.FileSystemControl.FsControlCode) &#123;</span><br><span class="line">                <span class="keyword">case</span> FSCTL_DISMOUNT_VOLUME: &#123; <span class="comment">//事实证明 不知道为啥这个请求根本不会出现 所以随便写写就行了</span></span><br><span class="line">                    PSFILTER_DEVICE_EXTENSION devExt = DeviceObject-&gt;DeviceExtension;</span><br><span class="line">                    <span class="built_in">SF_LOG_PRINT</span>(SFDEBUG_DISPLAY_ATTACHMENT_NAMES, (<span class="string">&quot;SFilter!SfFsControl:                         Dismounting volume         %p \&quot;%wZ\&quot;\n&quot;</span>, devExt-&gt;AttachedToDeviceObject, &amp;devExt-&gt;DeviceName));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  Pass all other file system control requests through.</span></span><br><span class="line">    <span class="built_in">IoSkipCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">IoCallDriver</span>(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;AttachedToDeviceObject, Irp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当一个文件识别器决定加载真正的文件系统时，如果已经绑定了文件系统识别器，那么现在就应该解除绑定并销毁设备，同时生成新的设备去绑定真的文件系统。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SfFsControlLoadFileSystem</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</span> </span>&#123;</span><br><span class="line">    PSFILTER_DEVICE_EXTENSION devExt = DeviceObject-&gt;DeviceExtension;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    PFSCTRL_COMPLETION_CONTEXT completionContext;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="comment">//  This is a &quot;load file system&quot; request being sent to a file system recognizer device object.  This IRP_MN code is only sent to file system recognizers.</span></span><br><span class="line">    <span class="comment">//  <span class="doctag">NOTE:</span>  Since we no longer are attaching to the standard Microsoft file system recognizers we will normally never execute this code. However, there might be 3rd party file systems which have their own recognizer which may still trigger this IRP.</span></span><br><span class="line">    <span class="built_in">SF_LOG_PRINT</span>(SFDEBUG_DISPLAY_ATTACHMENT_NAMES, (<span class="string">&quot;SFilter!SfFscontrolLoadFileSystem:           Loading File System, Detaching from \&quot;%wZ\&quot;\n&quot;</span>, &amp;devExt-&gt;DeviceName));</span><br><span class="line">    <span class="comment">//  VERSION <span class="doctag">NOTE:</span></span></span><br><span class="line">    <span class="comment">//  On Windows 2000, we cannot simply synchronize back to the dispatch routine to do our post-load filesystem processing.  We need to do this work at passive level, so we will queue that work to a worker thread from the completion routine.</span></span><br><span class="line">    <span class="comment">//  For Windows XP and later, we can safely synchronize back to the dispatch routine.  The code below shows both methods.  Admittedly, the code would be simplified if you chose to only use one method or the other, but you should be able to easily adapt this for your needs.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_WINDOWSXP_OR_LATER</span>()) &#123;</span><br><span class="line">        KEVENT waitEvent;</span><br><span class="line">        <span class="built_in">KeInitializeEvent</span>(&amp;waitEvent, NotificationEvent, FALSE);</span><br><span class="line">        <span class="built_in">IoCopyCurrentIrpStackLocationToNext</span>(Irp);</span><br><span class="line">        <span class="built_in">IoSetCompletionRoutine</span>(Irp, SfFsControlCompletion, &amp;waitEvent, TRUE, TRUE, TRUE); <span class="comment">//context parameter</span></span><br><span class="line">        status = <span class="built_in">IoCallDriver</span>(devExt-&gt;AttachedToDeviceObject, Irp);</span><br><span class="line">        <span class="comment">//  Wait for the operation to complete</span></span><br><span class="line">        <span class="keyword">if</span> (STATUS_PENDING == status) &#123;</span><br><span class="line">            status = <span class="built_in">KeWaitForSingleObject</span>(&amp;waitEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">ASSERT</span>(STATUS_SUCCESS == status);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  Verify the IoCompleteRequest was called</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">KeReadStateEvent</span>(&amp;waitEvent) || !<span class="built_in">NT_SUCCESS</span>(Irp-&gt;IoStatus.Status));</span><br><span class="line">        status = <span class="built_in">SfFsControlLoadFileSystemComplete</span>(DeviceObject, Irp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line">        <span class="comment">//  Set a completion routine so we can delete the device object when the load is complete.</span></span><br><span class="line">        completionContext = <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="built_in">sizeof</span>(FSCTRL_COMPLETION_CONTEXT), SFLT_POOL_TAG);</span><br><span class="line">        <span class="keyword">if</span> (completionContext == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//  If we cannot allocate our completion context, we will just pass through the operation.  If your filter must be present for data access to this volume, you should consider failing the operation if memory cannot be allocated here.</span></span><br><span class="line">            <span class="built_in">IoSkipCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">            status = <span class="built_in">IoCallDriver</span>(devExt-&gt;AttachedToDeviceObject, Irp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ExInitializeWorkItem</span>(&amp;completionContext-&gt;WorkItem, SfFsControlLoadFileSystemCompleteWorker, completionContext);</span><br><span class="line">            completionContext-&gt;DeviceObject = DeviceObject;</span><br><span class="line">            completionContext-&gt;Irp = Irp;</span><br><span class="line">            completionContext-&gt;NewDeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">IoCopyCurrentIrpStackLocationToNext</span>(Irp);</span><br><span class="line">            <span class="built_in">IoSetCompletionRoutine</span>(Irp, SfFsControlCompletion, completionContext, TRUE, TRUE, TRUE);</span><br><span class="line">            <span class="comment">//  Detach from the file system recognizer device object.</span></span><br><span class="line">            <span class="built_in">IoDetachDevice</span>(devExt-&gt;AttachedToDeviceObject);</span><br><span class="line">            <span class="comment">//  Call the driver</span></span><br><span class="line">            status = <span class="built_in">IoCallDriver</span>(devExt-&gt;AttachedToDeviceObject, Irp);</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501        </span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>   </span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="绑定文件系统卷"><a href="#绑定文件系统卷" class="headerlink" title="绑定文件系统卷"></a>绑定文件系统卷</h2><h3 id="VPB"><a href="#VPB" class="headerlink" title="VPB"></a>VPB</h3><p>在主功能号IRP_MJ_FILE_SYSTEM_CONTROL，次功能号为IRP_MN_MOUNT_VOLUME的IRP请求处理中，调用<code>SfFsControlMountVolume</code>绑定卷设备。指针<code>irpSp-&gt;Parameters.MountVolume.Vpb</code>是个VBP，VBP为卷参数块，作用是把实际存储媒介设备对象和文件系统卷设备对象联系起来。卷设备在<code>irpSp-&gt;Parameters.MountVolume.Vpb-&gt;DeviceObject</code>，存储设备对象在<code>irpSp-&gt;Parameters.MountVolume.Vpb-&gt;RealDevice</code>。</p>
<p>但这里有个问题，<code>irpSp-&gt;Parameters.MountVolume.Vpb-&gt;DeviceObject</code>在这个请求完成前还没有意义，所以要先保存<code>irpSp-&gt;Parameters.MountVolume.Vpb-&gt;RealDevice</code>，然后再从这个存储设备对象中获取卷设备才对。</p>
<p>代码下面再讲。</p>
<h3 id="设置IRP完成函数"><a href="#设置IRP完成函数" class="headerlink" title="设置IRP完成函数"></a>设置IRP完成函数</h3><p>等待IRP完成的方法同之前几篇。拷贝当前栈空间后向下发送请求，在此之前给IRP分配一个完成函数，IRP完成后自动调用完成函数。完成函数在Dispatch中断级，但有些系统调用需要在Passive中断级调用，具体哪些系统调用可以参看WDK，有的API会标注“irq level&#x3D;PASSIVE”。</p>
<p>如果代码执行是由于应用程序&#x2F;上层调用，则在Passive中断级，例如上层发来IRP的分发函数。如果代码执行时由于下层硬件引发，则在Dispatch中断级，例如网卡的OnReceive和硬盘读写完毕返回回调函数等。这不是绝对的，但应随时做好最坏的准备。</p>
<p>卷影和磁盘数据恢复相关的特殊设备，可过滤也可不过滤。</p>
<p>同步方法：初始化一个KEVENT事件，并通过上下文传递给完成回调函数，完成函数设置这个事件，本函数等待这个事件。</p>
<p>完成函数的中断级为Dispatch，不适合直接绑定设备，应该使用工作任务将某个函数插入到某个线程中执行，这时拥有Passive中断级。用<code>ExInitializeWorkItem</code>初始化一个工作任务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ExInitializeWorkItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PWORK_QUEUE_ITEM Item, <span class="comment">//要初始化的工作任务</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PWORKER_THREAD_ROUTINE Routine, <span class="comment">//有待执行的函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PVOID Context <span class="comment">//上下文指针 完全用户自定义</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>再用<code>ExQueueWorkItem</code>将某个工作任务插入到某个队列中，Windows内核依次执行这些队列中的工作任务，且确保中断级别为Passive：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ExQueueWorkItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PWORK_QUEUE_ITEM WorkItem, <span class="comment">//工作任务指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN WORK_QUEUE_TYPE QueueType <span class="comment">//CriticalWorkQueue执行优先级高 DelayedWorkQueue优先级自动调整 Passive中断级一般就DelayedWorkQueue</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SfFsControlMountVolume</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</span> </span>&#123;</span><br><span class="line">    PSFILTER_DEVICE_EXTENSION devExt = DeviceObject-&gt;DeviceExtension;</span><br><span class="line">    PIO_STACK_LOCATION irpSp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">    PDEVICE_OBJECT newDeviceObject;</span><br><span class="line">    PDEVICE_OBJECT storageStackDeviceObject;</span><br><span class="line">    PSFILTER_DEVICE_EXTENSION newDevExt;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    BOOLEAN isShadowCopyVolume;</span><br><span class="line">    PFSCTRL_COMPLETION_CONTEXT completionContext;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">IS_MY_DEVICE_OBJECT</span>(DeviceObject));</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">IS_DESIRED_DEVICE_TYPE</span>(DeviceObject-&gt;DeviceType));</span><br><span class="line">    <span class="comment">//  Get the real device object (also known as the storage stack device object or the disk device object) pointed to by the vpb parameter because this vpb may be changed by the underlying file system. Both FAT and CDFS may change the VPB address if the volume being mounted is one they recognize from a previous mount.</span></span><br><span class="line">    storageStackDeviceObject = irpSp-&gt;Parameters.MountVolume.Vpb-&gt;RealDevice; <span class="comment">//保存下来RealDevice</span></span><br><span class="line">    <span class="comment">//  Determine if this is a shadow copy volume.  If so don&#x27;t attach to it.</span></span><br><span class="line">    <span class="comment">//  <span class="doctag">NOTE:</span>  There is no reason sfilter shouldn&#x27;t attach to these volumes, this is simply a sample of how to not attach if you don&#x27;t want to</span></span><br><span class="line">    status = <span class="built_in">SfIsShadowCopyVolume</span>(storageStackDeviceObject, &amp;isShadowCopyVolume); <span class="comment">//判断是否是卷影</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status) &amp;&amp; isShadowCopyVolume &amp;&amp; !<span class="built_in">FlagOn</span>(SfDebug, SFDEBUG_ATTACH_TO_SHADOW_COPIES)) &#123; <span class="comment">//不打算绑定卷影就跳过去</span></span><br><span class="line">        UNICODE_STRING shadowDeviceName;</span><br><span class="line">        WCHAR shadowNameBuffer[MAX_DEVNAME_LENGTH];</span><br><span class="line">        <span class="comment">//  Get the name for the debug display</span></span><br><span class="line">        <span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;shadowDeviceName, shadowNameBuffer, <span class="built_in">sizeof</span>(shadowNameBuffer));</span><br><span class="line">        <span class="built_in">SfGetObjectName</span>(storageStackDeviceObject, &amp;shadowDeviceName);</span><br><span class="line">        <span class="built_in">SF_LOG_PRINT</span>(SFDEBUG_DISPLAY_ATTACHMENT_NAMES, (<span class="string">&quot;SFilter!SfFsControlMountVolume               Not attaching to Volume    %p \&quot;%wZ\&quot;, shadow copy volume\n&quot;</span>, storageStackDeviceObject, &amp;shadowDeviceName));</span><br><span class="line">        <span class="comment">//  Go to the next driver</span></span><br><span class="line">        <span class="built_in">IoSkipCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">IoCallDriver</span>(devExt-&gt;AttachedToDeviceObject, Irp);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  This is a mount request.  Create a device object that can be attached to the file system&#x27;s volume device object if this request is successful.  We allocate this memory now since we can not return an error in the completion routine.  </span></span><br><span class="line">    <span class="comment">//  Since the device object we are going to attach to has not yet been created (it is created by the base file system) we are going to use the type of the file system control device object.  We are assuming that the file system control device object will have the same type as the volume device objects associated with it.</span></span><br><span class="line">    status = <span class="built_in">IoCreateDevice</span>(gSFilterDriverObject, <span class="built_in">sizeof</span>(SFILTER_DEVICE_EXTENSION) + gUserExtensionSize, <span class="literal">NULL</span>, DeviceObject-&gt;DeviceType, <span class="number">0</span>, FALSE, &amp;newDeviceObject); <span class="comment">//预先生成过滤设备 虽然没到绑定的时候</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="comment">//  If we can not attach to the volume, then don&#x27;t allow the volume to be mounted.</span></span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;SFilter!SfFsControlMountVolume: Error creating volume device object, status=%08x\n&quot;</span>, status));</span><br><span class="line">        Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">        Irp-&gt;IoStatus.Status = status;</span><br><span class="line">        <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  We need to save the RealDevice object pointed to by the vpb parameter because this vpb may be changed by the underlying file system.  Both FAT and CDFS may change the VPB address if the volume being mounted is one they recognize from a previous mount.</span></span><br><span class="line">    newDevExt = newDeviceObject-&gt;DeviceExtension; <span class="comment">//填写设备扩展 RealDevice被保存在这里</span></span><br><span class="line">    newDevExt-&gt;StorageStackDeviceObject = storageStackDeviceObject;</span><br><span class="line">    newDevExt-&gt;TypeFlag = SFLT_POOL_TAG;</span><br><span class="line">    <span class="comment">//  Get the name of this device</span></span><br><span class="line">    <span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;newDevExt-&gt;DeviceName, newDevExt-&gt;DeviceNameBuffer, <span class="built_in">sizeof</span>(newDevExt-&gt;DeviceNameBuffer));</span><br><span class="line">    <span class="built_in">SfGetObjectName</span>(storageStackDeviceObject, &amp;newDevExt-&gt;DeviceName);</span><br><span class="line">    <span class="comment">//  VERSION <span class="doctag">NOTE:</span></span></span><br><span class="line">    <span class="comment">//  On Windows 2000, we cannot simply synchronize back to the dispatch routine to do our post-mount processing.  We need to do this work at passive level, so we will queue that work to a worker thread from the completion routine.</span></span><br><span class="line">    <span class="comment">//  For Windows XP and later, we can safely synchronize back to the dispatch routine.  The code below shows both methods.  Admittedly, the code would be simplified if you chose to only use one method or the other,  but you should be able to easily adapt this for your needs.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_WINDOWSXP_OR_LATER</span>()) &#123;</span><br><span class="line">        KEVENT waitEvent;</span><br><span class="line">        <span class="built_in">KeInitializeEvent</span>(&amp;waitEvent, NotificationEvent, FALSE); <span class="comment">//初始化事件</span></span><br><span class="line">        <span class="built_in">IoCopyCurrentIrpStackLocationToNext</span>(Irp); <span class="comment">//因为要等待完成 所以拷贝当前调用栈</span></span><br><span class="line">        <span class="built_in">IoSetCompletionRoutine</span>(Irp, SfFsControlCompletion, &amp;waitEvent, TRUE, TRUE, TRUE); <span class="comment">//设置完成函数 waitEvent当作上下文传入</span></span><br><span class="line">        status = <span class="built_in">IoCallDriver</span>(devExt-&gt;AttachedToDeviceObject, Irp); <span class="comment">//发送IRP并等待事件完成</span></span><br><span class="line">        <span class="comment">//  Wait for the operation to complete</span></span><br><span class="line">        <span class="keyword">if</span> (STATUS_PENDING == status) &#123;</span><br><span class="line">            status = <span class="built_in">KeWaitForSingleObject</span>(&amp;waitEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">ASSERT</span>(STATUS_SUCCESS == status);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  Verify the IoCompleteRequest was called</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">KeReadStateEvent</span>(&amp;waitEvent) || !<span class="built_in">NT_SUCCESS</span>(Irp-&gt;IoStatus.Status));</span><br><span class="line">        status = <span class="built_in">SfFsControlMountVolumeComplete</span>(DeviceObject, Irp, newDeviceObject); <span class="comment">//请求完成 调用函数绑定卷</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">//  Initialize our completion routine</span></span><br><span class="line">        completionContext = <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="built_in">sizeof</span>(FSCTRL_COMPLETION_CONTEXT), SFLT_POOL_TAG);</span><br><span class="line">        <span class="keyword">if</span> (completionContext == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//  If we cannot allocate our completion context, we will just pass through the operation.  If your filter must be present for data access to this volume, you should consider failing the operation if memory cannot be allocated here.</span></span><br><span class="line">            <span class="built_in">IoSkipCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">            status = <span class="built_in">IoCallDriver</span>(devExt-&gt;AttachedToDeviceObject, Irp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ExInitializeWorkItem</span>(&amp;completionContext-&gt;WorkItem, SfFsControlMountVolumeCompleteWorker, completionContext); <span class="comment">//初始化工作任务</span></span><br><span class="line">            completionContext-&gt;DeviceObject = DeviceObject; <span class="comment">//写入上下文</span></span><br><span class="line">            completionContext-&gt;Irp = Irp;</span><br><span class="line">            completionContext-&gt;NewDeviceObject = newDeviceObject;</span><br><span class="line">            <span class="built_in">IoCopyCurrentIrpStackLocationToNext</span>(Irp); <span class="comment">//拷贝调用栈</span></span><br><span class="line">            <span class="built_in">IoSetCompletionRoutine</span>(Irp, SfFsControlCompletion, &amp;completionContext-&gt;WorkItem, TRUE, TRUE, TRUE); <span class="comment">//context parameter</span></span><br><span class="line">            <span class="comment">//  Call the driver</span></span><br><span class="line">            status = <span class="built_in">IoCallDriver</span>(devExt-&gt;AttachedToDeviceObject, Irp);</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完成函数中应取得上下文并当作个事件指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SfFsControlCompletion</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DeviceObject);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Irp);</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">IS_MY_DEVICE_OBJECT</span>(DeviceObject));</span><br><span class="line">    <span class="built_in">ASSERT</span>(Context != <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_WINDOWSXP_OR_LATER</span>())</span><br><span class="line">        <span class="comment">//  On Windows XP or later, the context passed in will be an event to signal.</span></span><br><span class="line">        <span class="built_in">KeSetEvent</span>((PKEVENT)Context, IO_NO_INCREMENT, FALSE);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">//  For Windows 2000, if we are not at passive level, we should queue this work to a worker thread using the workitem that is in Context.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">KeGetCurrentIrql</span>() &gt; PASSIVE_LEVEL) <span class="comment">//中断级别过高 工作任务放到DelayedWorkQueue队列中执行</span></span><br><span class="line">            <span class="comment">//  We are not at passive level, but we need to be to do our work, so queue off to the worker thread.</span></span><br><span class="line">            <span class="built_in">ExQueueWorkItem</span>((PWORK_QUEUE_ITEM)Context, DelayedWorkQueue);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//否则直接执行</span></span><br><span class="line">            PWORK_QUEUE_ITEM workItem = Context;</span><br><span class="line">            <span class="comment">//  We are already at passive level, so we will just call our worker routine directly.</span></span><br><span class="line">            (workItem-&gt;WorkerRoutine)(workItem-&gt;Parameter);</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> STATUS_MORE_PROCESSING_REQUIRED;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="绑定卷"><a href="#绑定卷" class="headerlink" title="绑定卷"></a>绑定卷</h3><p><code>SfFsControlMountVolumeCompleteWorker</code>就是调用<code>SfFsControlMountVolumeComplete</code>绑定卷设备：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SfFsControlMountVolumeComplete</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PDEVICE_OBJECT NewDeviceObject)</span> </span>&#123;</span><br><span class="line">    PVPB vpb;</span><br><span class="line">    PSFILTER_DEVICE_EXTENSION newDevExt;</span><br><span class="line">    PIO_STACK_LOCATION irpSp;</span><br><span class="line">    PDEVICE_OBJECT attachedDeviceObject;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    newDevExt = NewDeviceObject-&gt;DeviceExtension;</span><br><span class="line">    irpSp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">    <span class="comment">//  Get the correct VPB from the real device object saved in our device extension.  We do this because the VPB in the IRP stack may not be the correct VPB when we get here.  The underlying file system may change VPBs if it detects a volume it has mounted previously.</span></span><br><span class="line">    vpb = newDevExt-&gt;StorageStackDeviceObject-&gt;Vpb; <span class="comment">//获取之前保存的VPB</span></span><br><span class="line">    <span class="comment">//  Display a message when we detect that the VPB for the given device object has changed.</span></span><br><span class="line">    <span class="keyword">if</span> (vpb != irpSp-&gt;Parameters.MountVolume.Vpb)</span><br><span class="line">        <span class="built_in">SF_LOG_PRINT</span>(SFDEBUG_DISPLAY_ATTACHMENT_NAMES, (<span class="string">&quot;SFilter!SfFsControlMountVolume:              VPB in IRP stack changed   %p IRPVPB=%p VPB=%p\n&quot;</span>, vpb-&gt;DeviceObject, irpSp-&gt;Parameters.MountVolume.Vpb, vpb));</span><br><span class="line">    <span class="comment">//  See if the mount was successful.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Irp-&gt;IoStatus.Status)) &#123;</span><br><span class="line">        <span class="comment">//  Acquire lock so we can atomically test if we area already attached and if not, then attach.  This prevents a double attach race condition.</span></span><br><span class="line">        <span class="built_in">ExAcquireFastMutex</span>(&amp;gSfilterAttachLock); <span class="comment">//获得互斥体 判断是否绑定过一个卷设备 防止重复绑定</span></span><br><span class="line">        <span class="comment">//  The mount succeeded.  If we are not already attached, attach to the device object.  Note: one reason we could already be attached is if the underlying file system revived a previous mount.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">SfIsAttachedToDevice</span>(vpb-&gt;DeviceObject, &amp;attachedDeviceObject)) &#123; <span class="comment">//判断是否绑定过了</span></span><br><span class="line">            <span class="comment">//  Attach to the new mounted volume.  The file system device object that was just mounted is pointed to by the VPB.</span></span><br><span class="line">            status = <span class="built_in">SfAttachToMountedDevice</span>(vpb-&gt;DeviceObject, NewDeviceObject); <span class="comment">//绑定</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">                <span class="comment">//  The attachment failed, cleanup.  Since we are in the post-mount phase, we can not fail this operation. We simply won&#x27;t be attached.  The only reason this should ever happen at this point is if somebody already started dismounting the volume therefore not attaching should not be a problem.</span></span><br><span class="line">                <span class="built_in">SfCleanupMountedDevice</span>(NewDeviceObject);</span><br><span class="line">                <span class="built_in">IoDeleteDevice</span>(NewDeviceObject);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">ASSERT</span>(<span class="literal">NULL</span> == attachedDeviceObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  We were already attached, handle it</span></span><br><span class="line">            <span class="built_in">SF_LOG_PRINT</span>(SFDEBUG_DISPLAY_ATTACHMENT_NAMES, (<span class="string">&quot;SFilter!SfFsControlMountVolume               Mount volume failure for   %p \&quot;%wZ\&quot;, already attached\n&quot;</span>, ((PSFILTER_DEVICE_EXTENSION)attachedDeviceObject-&gt;DeviceExtension)-&gt;AttachedToDeviceObject, &amp;newDevExt-&gt;DeviceName));</span><br><span class="line">            <span class="comment">//  Cleanup and delete the device object we created</span></span><br><span class="line">            <span class="built_in">SfCleanupMountedDevice</span>(NewDeviceObject); <span class="comment">//已绑定过 放弃</span></span><br><span class="line">            <span class="built_in">IoDeleteDevice</span>(NewDeviceObject);</span><br><span class="line">            <span class="comment">//  Dereference the returned attached device object</span></span><br><span class="line">            <span class="built_in">ObDereferenceObject</span>(attachedDeviceObject);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  Release the lock</span></span><br><span class="line">        <span class="built_in">ExReleaseFastMutex</span>(&amp;gSfilterAttachLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  The mount request failed, handle it.</span></span><br><span class="line">        <span class="built_in">SF_LOG_PRINT</span>(SFDEBUG_DISPLAY_ATTACHMENT_NAMES, (<span class="string">&quot;SFilter!SfFsControlMountVolume:              Mount volume failure for   %p \&quot;%wZ\&quot;, status=%08x\n&quot;</span>, DeviceObject, &amp;newDevExt-&gt;DeviceName, Irp-&gt;IoStatus.Status));</span><br><span class="line">        <span class="comment">//  Cleanup and delete the device object we created</span></span><br><span class="line">        <span class="built_in">SfCleanupMountedDevice</span>(NewDeviceObject);</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(NewDeviceObject);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  Complete the request.  </span></span><br><span class="line">    <span class="comment">//  <span class="doctag">NOTE:</span>  We must save the status before completing because after completing the IRP we can not longer access it (it might be freed).</span></span><br><span class="line">    status = Irp-&gt;IoStatus.Status; <span class="comment">//完成请求</span></span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如何绑定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SfAttachToMountedDevice</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PDEVICE_OBJECT SFilterDeviceObject)</span> </span>&#123;</span><br><span class="line">    PSFILTER_DEVICE_EXTENSION newDevExt = SFilterDeviceObject-&gt;DeviceExtension;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    ULONG i;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">IS_MY_DEVICE_OBJECT</span>(SFilterDeviceObject));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0501    </span></span><br><span class="line">    <span class="built_in">ASSERT</span>(!<span class="built_in">SfIsAttachedToDevice</span>(DeviceObject, <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OnSfilterAttachPre</span>(SFilterDeviceObject, DeviceObject, <span class="literal">NULL</span>, (PVOID)(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;UserExtension))) <span class="comment">//最后一节讲 询问用户是否要绑定</span></span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">//  Propagate flags from Device Object we are trying to attach to. Note that we do this before the actual attachment to make sure the flags are properly set once we are attached (since an IRP can come in immediately after attachment but before the flags would be set).</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FlagOn</span>(DeviceObject-&gt;Flags, DO_BUFFERED_IO)) <span class="comment">//复制设备标记</span></span><br><span class="line">        <span class="built_in">SetFlag</span>(SFilterDeviceObject-&gt;Flags, DO_BUFFERED_IO);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FlagOn</span>(DeviceObject-&gt;Flags, DO_DIRECT_IO))</span><br><span class="line">        <span class="built_in">SetFlag</span>(SFilterDeviceObject-&gt;Flags, DO_DIRECT_IO);</span><br><span class="line">    <span class="comment">//  It is possible for this attachment request to fail because this device object has not finished initializing.  This can occur if this filter loaded just as this volume was being mounted.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123; <span class="comment">//反复8次尝试绑定</span></span><br><span class="line">        LARGE_INTEGER interval;</span><br><span class="line">        <span class="comment">//  Attach our device object to the given device object The only reason this can fail is if someone is trying to dismount this volume while we are attaching to it.</span></span><br><span class="line">        status = <span class="built_in">SfAttachDeviceToDeviceStack</span>(SFilterDeviceObject, DeviceObject, &amp;newDevExt-&gt;AttachedToDeviceObject);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">            <span class="built_in">OnSfilterAttachPost</span>(SFilterDeviceObject, DeviceObject, newDevExt-&gt;AttachedToDeviceObject, (PVOID)(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;UserExtension), status);</span><br><span class="line">            <span class="comment">//  Finished all initialization of the new device object,  so clear the initializing flag now.  This allows other filters to now attach to our device object.</span></span><br><span class="line">            <span class="built_in">ClearFlag</span>(SFilterDeviceObject-&gt;Flags, DO_DEVICE_INITIALIZING);</span><br><span class="line">            <span class="comment">//  Display the name</span></span><br><span class="line">            <span class="built_in">SF_LOG_PRINT</span>(SFDEBUG_DISPLAY_ATTACHMENT_NAMES, (<span class="string">&quot;SFilter!SfAttachToMountedDevice:             Attaching to volume        %p \&quot;%wZ\&quot;\n&quot;</span>, newDevExt-&gt;AttachedToDeviceObject, &amp;newDevExt-&gt;DeviceName));</span><br><span class="line">            <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  Delay, giving the device object a chance to finish its initialization so we can try again</span></span><br><span class="line">        interval.QuadPart = (<span class="number">500</span> * DELAY_ONE_MILLISECOND);      <span class="comment">//delay 1/2 second</span></span><br><span class="line">        <span class="built_in">KeDelayExecutionThread</span>(KernelMode, FALSE, &amp;interval); <span class="comment">//这个线程延迟500ms后再继续</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">OnSfilterAttachPost</span>(SFilterDeviceObject, DeviceObject, <span class="literal">NULL</span>, (PVOID)(((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;UserExtension), status); <span class="comment">//最后一节讲 绑定后处理回调函数</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="操作过滤"><a href="#操作过滤" class="headerlink" title="操作过滤"></a>操作过滤</h2><p>注意：以下部分没有实例代码，看看就行了。</p>
<h3 id="读请求"><a href="#读请求" class="headerlink" title="读请求"></a>读请求</h3><p>从硬盘上获得数据，必须请求结束后才存在于输出缓冲区。比写请求麻烦，写请求数据由上层程序填写，请求完成前已存在于输入缓冲区中。</p>
<p>先要判断设备对象是个啥，如果是绑定在文件系统卷设备上，则这确实是个读写请求。如果绑定在FS-CDO上的就不是。这一点通过设备扩展中的<code>StorageDev</code>字段判断。</p>
<p>在<code>DriverEntry</code>里加一条：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_READ] = SfRead;</span><br></pre></td></tr></table></figure>

<p>判断是否为卷设备：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PSFILTER_DEVICE_EXTENSION devExt = DeviceObject-&gt;DeviceExtension;</span><br><span class="line"><span class="keyword">if</span> (devExt-&gt;StorageDev != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">//卷设备 对文件的写操作</span></span><br></pre></td></tr></table></figure>

<p>写操作处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SfRead</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</span> </span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION irpsp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">    PFILE_OBJECT file_object = irpsp-&gt;FileObject;</span><br><span class="line">    PSFILTER_DEVICE_EXTENSION devExt = DeviceObject-&gt;DeviceExtension;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_MY_CONTROL_DEVICE_OBJECT</span>(DeviceObject)) &#123; <span class="comment">//控制设备操作直接返回失败</span></span><br><span class="line">        Irp-&gt;IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;</span><br><span class="line">        Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (devExt-&gt;StorageDev != <span class="literal">NULL</span>) <span class="comment">//对文件系统其他设备的操作 直接下发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SfPassThrough</span>(DeviceObject, Irp);</span><br><span class="line">    <span class="comment">//到这里说明是对卷设备的操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解析读请求"><a href="#解析读请求" class="headerlink" title="解析读请求"></a>解析读请求</h3><p>读请求中读取的偏移量和读取的文件内容长度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PIO_STACK_LOCATION irpsp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(irp);</span><br><span class="line">LARGE_INTEGER offset;</span><br><span class="line">ULONG length;</span><br><span class="line">offset.QuadPart = irpsp-&gt;Parameters.Read.ByteOffset.QuadPart;</span><br><span class="line">length = irpsp-&gt;Parameters.Read.Length;</span><br></pre></td></tr></table></figure>

<p>如果是写请求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PIO_STACK_LOCATION irpsp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(irp);</span><br><span class="line">LARGE_INTEGER offset;</span><br><span class="line">ULONG length;</span><br><span class="line">offset.QuadPart = irpsp-&gt;Parameters.Write.ByteOffset.QuadPart;</span><br><span class="line">length = irpsp-&gt;Parameters.Write.Length;</span><br></pre></td></tr></table></figure>

<p>总结一下处理IRP请求的四种方式：</p>
<ul>
<li>如果对IRP完成后的事情无兴趣，直接用<code>IoSkipCurrentIrpStackLocation</code>来忽略当前IO_STACK_LOCATION，然后向下传递并返回<code>IoCallDriver</code>的返回状态。</li>
<li>如果对IRP完成后的事情无兴趣且不打算继续传递，打算立即返回成功或失败时，直接填写IRP的状态参数后调用<code>IoCompleteRequest</code>并返回自己想返回的结果。</li>
<li>如果对IRP完成后的事情有兴趣，并打算在完成函数中处理时，先使用<code>IoCopyCurrentIrpStackLocationToNext</code>来拷贝当前IO_STACK_LOCATION，然后完成指定函数，返回<code>IoCallDriver</code>的返回状态。（在完成函数中没必要调用<code>IoCompleteRequest</code>，直接返回IRP状态即可）。</li>
<li>同上一个情况时，还有可能把任务塞进系统工作线程中或希望在另外的线程中完成IRP，那么完成函数应返回STATUS_MORE_PROCESSING_REQUIRED，并在完成时调用<code>IoCompleteRequest</code>。另一种方法在分发函数中等待，在完成函数中设置事件，操作相同。</li>
</ul>
<p>至于怎么获取读取到的内容，IRP缓冲区放在哪儿取决于这个操作的IO方式：BufferIO方式、DirectIO方式、NeitherIO方式。</p>
<ul>
<li>BufferIO方式：在文件操作读写请求中不会出现，但会在串口过滤中出现。把发出请求的应用程序的用户空间的缓冲区拷贝一份到内核空间，解决了不同进程间地址失效问题。但因为要拷贝，所以既费时又费力。</li>
<li>DirectIO方式：使用MDL传递缓冲区，大约就是直接把用户空间范围直接映射到内核空间。缓冲区MDL指针在<code>Irp-&gt;MdlAddress</code>中，再用<code>MmGetSystemAddressForMdl</code>转换得到实际缓冲区指针。</li>
<li>NeitherIO方式：直接把用户空间指针传进来，即<code>Irp-&gt;UserBuffer</code>。这可以在请求处理回调函数中直接使用，但不能在其他线程中处理。</li>
</ul>
<p>读操作代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">KEVENT waitEvent;</span><br><span class="line">PVOID buf;</span><br><span class="line">ULONG length;</span><br><span class="line"><span class="built_in">KeInitializeEvent</span>(&amp;waitEvent, NotificationEvent, FALSE);</span><br><span class="line"><span class="built_in">IoCopyCurrentIrpStackLocationToNext</span>(Irp);</span><br><span class="line"><span class="built_in">IoSetCompletionRoutine</span>(Irp, SfReadCompletion, &amp;waitEvent, TRUE, TRUE, TRUE);</span><br><span class="line">status = <span class="built_in">IoCallDriver</span>(devExt-&gt;AttachedToDeviceObject, Irp);</span><br><span class="line"><span class="keyword">if</span> (STATUS_PENDING == status) &#123;</span><br><span class="line">    status = <span class="built_in">KeWaitForSingleObject</span>(&amp;waitEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">ASSERT</span>(STATUS_SUCCESS == status);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (irp.IoStatus.Status == STATUS_SUCCESS) &#123; <span class="comment">//获取到的内容在buf</span></span><br><span class="line">    <span class="keyword">if</span> (irp-&gt;MdlAddress != <span class="literal">NULL</span>)</span><br><span class="line">        buf = <span class="built_in">MmGetSystemAddressForMdl</span>(Irp-&gt;MdlAddress);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buf = Irp-&gt;UserBuffer;</span><br><span class="line">    length = IoStatus.Information; <span class="comment">//内容长度的获取</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>次功能号获取：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PIO_STACK_LOCATION irpsp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(irp);</span><br><span class="line">UCHAR minor_code = irpsp-&gt;MinorFunction;</span><br></pre></td></tr></table></figure>

<p>主功能号为IRP_MJ_READ时，次功能号有这些情况：</p>
<ul>
<li>IRP_MN_NORMAL：缓冲区在<code>Irp-&gt;MdlAddress</code>或<code>Irp-&gt;UserBuffer</code>中返回。</li>
<li>IRP_MN_MDL：收到这个次功能号时，上述两个缓冲区都为空，要求分配一个MDL并返回上层，当之后收到IRP_MN_MDL_COMPLETE时，可以释放MDL了。</li>
</ul>
<p>分配、释放MDL方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_inline PMDL <span class="title">MyMdlAllocate</span><span class="params">(PVOID buf, ULONG length)</span> </span>&#123; <span class="comment">//分配MDL buf必须用户预先分配好</span></span><br><span class="line">    PMDL pmdl = <span class="built_in">IoAllocateMdl</span>(buf, length, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pmdl == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">MmBuildMdlForNonPagedPool</span>(pmdl);</span><br><span class="line">    <span class="keyword">return</span> pmdl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">_inline PMDL <span class="title">MyMdlMemoryAllocate</span><span class="params">(ULONG length)</span> </span>&#123; <span class="comment">//分配MDL 并带有一块内存</span></span><br><span class="line">    PMDL mdl;</span><br><span class="line">    PVOID buffer = <span class="built_in">ExAllocatePool</span>(NonPagedPool, length);</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    mdl = <span class="built_in">MyMdlAllocate</span>(buffer, length);</span><br><span class="line">    <span class="keyword">if</span> (mdl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ExFreePool</span>(buffer);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> mdl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">_inline VOID <span class="title">MyMdlMemoryFree</span><span class="params">(PMDL mdl)</span> </span>&#123; <span class="comment">//释放MDL 并释放MDL所带内存</span></span><br><span class="line">    PVOID buffer = <span class="built_in">MmGetSystemAddressForMdlSafe</span>(mdl, NormalPagePriority);</span><br><span class="line">    <span class="built_in">IoFreeMdl</span>(mdl);</span><br><span class="line">    <span class="built_in">ExFreePool</span>(buffer);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>读请求IRP的处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (irpsp-&gt;MinorFunction) &#123;</span><br><span class="line">    <span class="keyword">case</span> IRP_MN_NORMAL: &#123; <span class="comment">//先保留文件的偏移位置</span></span><br><span class="line">        PVOID buffer;</span><br><span class="line">        <span class="keyword">if</span> (irp-&gt;MdlAddress != <span class="literal">NULL</span>)</span><br><span class="line">            buffer = <span class="built_in">MmGetSystemAddressForMdlSafe</span>(irp-&gt;MdlAddress, NormalPagePriority);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            buffer = Irp-&gt;UserBuffer;</span><br><span class="line">        <span class="comment">//如果有资源 就往buffer中写入</span></span><br><span class="line">        irp-&gt;IoStatus.Information = length;</span><br><span class="line">        irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">        irp-&gt;FileObject-&gt;CurrentByteOffset.Quat = offset.Quat + length;</span><br><span class="line">        <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">case</span> IRP_MN_MDL: &#123;</span><br><span class="line">        <span class="comment">//先分配MDL</span></span><br><span class="line">        PMDL mdl = <span class="built_in">MyMdlMemoryAllocate</span>(length);</span><br><span class="line">        <span class="keyword">if</span> (mdl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//资源不足</span></span><br><span class="line">        &#125;;</span><br><span class="line">        irp-&gt;MdlAddress = mdl;</span><br><span class="line">        <span class="comment">//如果有资源 就往MDL的buffer中写入</span></span><br><span class="line">        irp-&gt;IoStatus.Information = length;</span><br><span class="line">        irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">        irp-&gt;FileObject-&gt;CurrentByteOffset.Quat = offset.Quat + length;</span><br><span class="line">        <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">case</span> IRP_MN_MDL_COMPLETE: &#123;</span><br><span class="line">        <span class="comment">//释放MDL</span></span><br><span class="line">        irp-&gt;IoStatus.Information = length;</span><br><span class="line">        irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">        irp-&gt;FileObject-&gt;CurrentByteOffset.Quat = offset.Quat + length;</span><br><span class="line">        <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="comment">//其他情况不过滤</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="文件对象生存周期"><a href="#文件对象生存周期" class="headerlink" title="文件对象生存周期"></a>文件对象生存周期</h3><p>应用层使用的文件句柄直接对应于内核中的文件对象，二者可以互相转换，一个文件对象可以获得多个文件句柄。文件对象在主功能号为IRP_MJ_CREATE的IRP完成后诞生的（获得IRP但没完成时文件对象指针可用但没真正打开文件，是个无效的文件对象），在IRP_MJ_CLOSE的IRP完成后被销毁。这样从IRP中获得文件对象指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PIO_STACK_LOCATION irpsp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(irp);</span><br><span class="line">PFILE_OBJECT file_obj = irpsp-&gt;FileObject;</span><br></pre></td></tr></table></figure>

<h3 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h3><p>判断一个已存在的文件对象是一个文件还是一个目录：收到文件打开IRP时先获得当前IO_STACK_LOCATION，其中<code>irpsp-&gt;Parameters.Create</code>的结构如下，这些参数与应用层<code>CreateFile</code>的参数一一对应：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    PIO_SECURITY_CONTEXT SecurityContext;</span><br><span class="line">    ULONG Options;</span><br><span class="line">    USHORT FileAttributes;</span><br><span class="line">    USHORT ShareAccess;</span><br><span class="line">    ULONG EaLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可能生成或打开时该文件对象已经存在了，这时无法判断是个文件还是个目录。所以要手动你维护一个哈希表（或者链表、数组等），新打开的判断是否为目录并插入哈希表，这样所有打开的目录都被保存。改动读请求的完成函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SfCreateComplete</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PIRP irp, IN PVOID context)</span> </span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION irpsp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(irp);</span><br><span class="line">    PFILE_OBJECT file = irpsp-&gt;FileObject;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DeviceObject);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(irp-&gt;IoStatus.Status))</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="literal">NULL</span> &amp;&amp; (irpsp-&gt;Parameters.Create.Options &amp; FILE_DIRECTORY_FILE) != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">MyAddObjToSet</span>(file); <span class="comment">//成功则把这个文件对象记录到集合里 这是刚刚打开或生成的目录</span></span><br><span class="line">    <span class="keyword">return</span> irp-&gt;IoStatus.Status;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="文件的删除"><a href="#文件的删除" class="headerlink" title="文件的删除"></a>文件的删除</h3><p>分三步走：</p>
<ul>
<li>发送一个请求打开文件，打开时需设置为有删除的访问权限，打开失败时将直接导致无法删除文件。</li>
<li>发出一个IRP_MJ_SET_INFORMATION设置请求，表示这个文件将被删除。</li>
<li>关闭时文件被系统删除。</li>
</ul>
<p>有些临时文件在打开时便被设置了关闭时删除，不需要再设置请求，关闭后被删除。</p>
<p>文件关闭前这个文件依然存在，但对文件的大部分操作（读、写、查询）等都被返回文件再删除中错误。</p>
<p>上述过程为彻底删除，移动到回收站只是一种改名操作。主功能号也是IRP_MJ_SET_INFORMATION，但<code>Irpsp-&gt;Paramters.SetFile.FileInformationClass</code>不同。</p>
<p>在上述<code>irpsp-&gt;Parameters.Create</code>结构的第一个域的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typdef <span class="keyword">struct</span> <span class="title class_">_IO_SECURITY_CONTEXT</span> &#123;</span><br><span class="line">    PSECURITY_QUALITY_OF_SERVICE SecurityQos;</span><br><span class="line">    PACCESS_STATE AccessState;</span><br><span class="line">    ACCESS_MASK DesiredAccess;</span><br><span class="line">    ULONG FullCreateOptions;</span><br><span class="line">&#125; IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;</span><br></pre></td></tr></table></figure>

<p>具体步骤如下：</p>
<ul>
<li><p>将上述的<code>DesiredAccess</code>设置DELETE位。</p>
</li>
<li><p>发送一个IRP_MJ_SET_INFORMATION，其中<code>irpsp-&gt;Parameters.SetFile.FileInformationClass</code>应该为<code>FileDispositioninformation</code>，然后<code>irp-&gt;AssociatedIrp.SystemBuffer</code>指向这个结构，其中<code>DeleteFile</code>应为TRUE：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FILE_DISPOSITION_INFORMATION</span> &#123;</span><br><span class="line">    BOOLEAN DeleteFile;</span><br><span class="line">&#125; FILE_DISPOSITION_INFORMATION;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="路径过滤"><a href="#路径过滤" class="headerlink" title="路径过滤"></a>路径过滤</h2><p>根据文件路径决定是否要过滤这个文件。</p>
<h3 id="打开成功后获取路径"><a href="#打开成功后获取路径" class="headerlink" title="打开成功后获取路径"></a>打开成功后获取路径</h3><p>用<code>ObQueryNameString</code>通过文件对象获取文件路径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObQueryNameString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PVOID Object, <span class="comment">//文件对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OUT POBJECT_NAME_INFORMATION ObjectNameInfo, <span class="comment">//接收返回名字信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PULONG ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中OBJECT_NAME_INFORMATION结构长这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OBJECT_NAME_INFORMATION</span>&#123;</span><br><span class="line">    UNICODE_STRING Name;</span><br><span class="line">&#125; OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>这个也要用调用两次的方法，先第一次调用试探缓冲区长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UCHAR buf[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">//猜测只要64字节</span></span><br><span class="line">PUCHAR new_buf = <span class="literal">NULL</span>;</span><br><span class="line">ULONG length = <span class="number">64</span>, ret_length;</span><br><span class="line">POBJECT_NAME_INFORMATION name_infor = (POBJECT_NAME_INFORMATION)buf;</span><br><span class="line">NTSTATUS status = <span class="built_in">ObQueryNameString</span>(file_obj, name_infor, length, &amp;ret_length); <span class="comment">//第一次调用用默认的64字节</span></span><br><span class="line"><span class="keyword">if</span> (status == STATUS_INFO_LENGTH_MISMATCH) &#123;</span><br><span class="line">    new_buf = <span class="built_in">ExAllocatePool</span>(nonPagedPool, ret_length); <span class="comment">//第二次调用 重新分配长度</span></span><br><span class="line">    <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//内存不足 错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        name_infor = (POBJECT_NAME_INFORMATION)new_buf;</span><br><span class="line">        status = <span class="built_in">ObQueryNameString</span>(file_obj, name_infor, length, &amp;ret_length);</span><br><span class="line">        <span class="comment">//这里当status为STATUS_SUCCESS时 name_infor-&gt;Name就是要获得的名字了</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (new_buf != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">ExFreePool</span>(new_buf);</span><br></pre></td></tr></table></figure>

<p>例如获取文件“MyFile.Name”文件结果为“\Device\HardDiskVolume1\MyDirectory\MyFile.Name”，但必须在IRP_MJ_CREATE完成后进行，否则只能获得盘符“\Device\HardDiskVolume1”，且<code>ObQueryNameString</code>只能在IRP_MJ_CREATE、IRP_MJ_CLEANUP、IRP_MJ_CLOSE的处理中使用，否则Windows有个bug会锁死。</p>
<p>在其他时候，如改名、查询、设置、读、写时没有特别稳定的方法，有两种说法如下。最好在打开时进行哈希表等方法记录，然后在任意时刻即可查询。</p>
<ul>
<li>可以直接向下层设备发送IRP_MJ_QUERY_INFORMATION，但这个IRP具体怎么写Windows没有公开。</li>
<li>存在<code>FileObject-&gt;FileName</code>，但任何过滤层都可以修改它，所以在文件被打开后就认为失效了。</li>
</ul>
<h3 id="打开请求完成前获取路径"><a href="#打开请求完成前获取路径" class="headerlink" title="打开请求完成前获取路径"></a>打开请求完成前获取路径</h3><p>如何在IRP_MJ_CREATE处理前得到路径名。</p>
<p>只能通过<code>FileObject-&gt;FileName</code>来获取，但当<code>FileObject-&gt;RelatedObject</code>不为空时，<code>FileName</code>是<code>RelatedObject</code>目录的相对路径。用<code>ObQueryNameString</code>查询全路径后要和<code>FileName</code>组合，组合时还要判断要不要插入一个“\”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TAG <span class="string">&quot;mymt&quot;</span></span></span><br><span class="line"><span class="function">ULONG <span class="title">MyFileFullPathPreCreate</span><span class="params">(PFILE_OBJECT file, PUNICODE_STRING path)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    POBJECT_NAME_INFORMATION obj_name_info = <span class="literal">NULL</span>;</span><br><span class="line">    WCHAR buf[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PVOID obj_ptr;</span><br><span class="line">    ULONG length = <span class="number">0</span>;</span><br><span class="line">    BOOLEAN need_split = FALSE;</span><br><span class="line">    <span class="built_in">ASSERT</span>(file != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;FileName.Buffer == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    obj_name_info = (POBJECT_NAME_INFORMATION)buf;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;RelatedFileObject != <span class="literal">NULL</span>)</span><br><span class="line">            obj_ptr = (PVOID)file-&gt;RelatedFileObject;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            obj_ptr = (PVOID)file-&gt;DeviceObject;</span><br><span class="line">        status = <span class="built_in">ObQueryNameString</span>(obj_ptr, obj_name_info, <span class="number">64</span> * <span class="built_in">sizeof</span>(WCHAR), &amp;length);</span><br><span class="line">        <span class="keyword">if</span> (status == STATUS_INFO_LENGTH_MISMATCH) &#123;</span><br><span class="line">            obj_name_info = <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, length, MEM_TAG);</span><br><span class="line">            <span class="keyword">if</span> (obj_name_info == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>(obj_name_info, length);</span><br><span class="line">            status = <span class="built_in">ObQueryNameString</span>(obj_ptr, obj_name_info, length, &amp;length);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) <span class="comment">//失败了直接跳出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;FileName.Length &gt; <span class="number">2</span> &amp;&amp; file-&gt;FileName.Buffer[<span class="number">0</span>] != <span class="built_in">TEXT</span>(<span class="string">&#x27;\\&#x27;</span>) &amp;&amp; obj_name_info-&gt;Name.Buffer[obj_name_info-&gt;Name.Length / <span class="built_in">sizeof</span>(WCHAR) - <span class="number">1</span>] != <span class="built_in">TEXT</span>(<span class="string">&#x27;\\&#x27;</span>)) <span class="comment">//FileName第一个字符不是斜杠 obj_name_info最后一个不是斜杠</span></span><br><span class="line">            need_split = TRUE;</span><br><span class="line">        length = obj_name_info-&gt;Name.Length + file-&gt;FileName.Length; <span class="comment">//获取总体名字长度 长度不足直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (need_split)</span><br><span class="line">            length += <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line">        <span class="keyword">if</span> (path-&gt;MaximumLength &lt; length)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">RtlCopyUnicodeString</span>(path, &amp;obj_name_info-&gt;Name); <span class="comment">//设备名</span></span><br><span class="line">        <span class="keyword">if</span> (need_split)</span><br><span class="line">            <span class="built_in">RtlAppendUnicodeToString</span>(path, <span class="built_in">TEXT</span>(<span class="string">&quot;\\&quot;</span>)); <span class="comment">//追加斜杠</span></span><br><span class="line">        <span class="built_in">RtlAppendUnicodeStringToString</span>(path, &amp;file-&gt;FileName); <span class="comment">//追加FileName</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((PVOID)obj_name_info != (PVOID)buf) <span class="comment">//分配过空间就释放掉</span></span><br><span class="line">        <span class="built_in">ExFreePool</span>(obj_name_info);</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="短名转长名"><a href="#短名转长名" class="headerlink" title="短名转长名"></a>短名转长名</h3><p>用<code>FileObject-&gt;FileName</code>获得的文件名有可能是DOSF风格短名，但没有简单的方法能够短名转长名。</p>
<p>例如短名路径“\aaaaaa~1\bbbbbb~1\cccccc~1\dddddd~1.txt”，先分解为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\</span><br><span class="line">aaaaaa~1</span><br><span class="line">bbbbbb~1</span><br><span class="line">cccccc~1</span><br><span class="line">dddddd~1.txt</span><br></pre></td></tr></table></figure>

<p>用<code>ZwCreateFile</code>打开第一个目录，这不可能需要长短转换，再调用<code>ZwQueryDirectoryFile</code>枚举下面所有文件和目录，用FileIdBothDirectoryInformation查询类别进行查询，会得到一组FILE_ID_BOTH_DIR_INFORMATION，代表下面每个文件和目录，结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FILE_ID_BOTH_DIR_INFORMATION</span> &#123;</span><br><span class="line">    ULONG NextEntryOffset;</span><br><span class="line">    ULONG FileIndex;</span><br><span class="line">    LARGE_INTEGER CreationTime;</span><br><span class="line">    LARGE_INTEGER LastAccessTime;</span><br><span class="line">    LARGE_INTEGER LastWriteTime;</span><br><span class="line">    LARGE_INTEGER ChangeTime;</span><br><span class="line">    LARGE_INTEGER EndOfFile;</span><br><span class="line">    LARGE_INTEGER AllocationSize;</span><br><span class="line">    ULONG FileAttribtues;</span><br><span class="line">    ULONG FileNameLength;</span><br><span class="line">    ULONG EaSize;</span><br><span class="line">    CCHAR ShortNameLength;</span><br><span class="line">    WCHAR ShortName[<span class="number">12</span>]; <span class="comment">//短名</span></span><br><span class="line">    LARGE_INTEGER FileId;</span><br><span class="line">    WCHAR FileName[<span class="number">1</span>]; <span class="comment">//长名</span></span><br><span class="line">&#125; FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>这个代码自己去写。</p>
<h2 id="sfilter的封装"><a href="#sfilter的封装" class="headerlink" title="sfilter的封装"></a>sfilter的封装</h2><p>sfilter太复杂了，要是改起来就太抽象了。一般将sfilter原封不动编译成.lib，导出一些接口后链接生成用。这节讲sfilter怎样导出了哪些接口。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>初始化回调：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> NTSTATUS <span class="title">OnSfilterDriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PDRIVER_OBJECT DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PUNICODE_STRING RegistryPath,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PUNICODE_STRING userNameString, <span class="comment">//控制设备的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PUNICODE_STRING syblnkString, <span class="comment">//控制设备符号链接名</span></span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PULONG extensionSize <span class="comment">//每个设备的设备扩展长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个回调函数的插入在上文最开始<code>DriverEntry</code>中实现了。</p>
<h3 id="绑定回调"><a href="#绑定回调" class="headerlink" title="绑定回调"></a>绑定回调</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> BOOLEAN <span class="title">OnSfilterAttachPre</span><span class="params">( <span class="comment">//每当有设备要被绑定时调用 用户返回TRUE表示同意绑定 反之不同意绑定</span></span></span></span><br><span class="line"><span class="params"><span class="function">	IN PDEVICE_OBJECT ourDevice, <span class="comment">//已生成好的过滤设备</span></span></span></span><br><span class="line"><span class="params"><span class="function">	IN PDEVICE_OBJECT theDeviceToAttach, <span class="comment">//要被绑定的真实设备</span></span></span></span><br><span class="line"><span class="params"><span class="function">	IN PUNICODE_STRING DeviceName, <span class="comment">//设备名</span></span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID extension <span class="comment">//设备扩展指针 设备扩展大小在OnSfilterDriverEntry中决定</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> VOID <span class="title">OnSfilterAttachPost</span><span class="params">( <span class="comment">//用户决定绑定 绑定完成后无论成功与否都调用这个函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	IN PDEVICE_OBJECT ourDevice, <span class="comment">//参数都同上</span></span></span></span><br><span class="line"><span class="params"><span class="function">	IN PDEVICE_OBJECT theDeviceToAttach,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PDEVICE_OBJECT theDeviceToAttached,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID extension,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN NTSTATUS status <span class="comment">//STATUS_SUCCESS绑定成功</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="插入请求回调"><a href="#插入请求回调" class="headerlink" title="插入请求回调"></a>插入请求回调</h3><p>请求预处理为在IRP还未下发前过滤这个IRP，请求后处理为在IRP完成后修改结果。</p>
<p>请求预处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">	SF_IRP_GO_ON = <span class="number">0</span>, <span class="comment">//本驱动要继续处理这个IRP 下发后OnSfilterIrpPost会被调用</span></span><br><span class="line">	SF_IRP_COMPLETED = <span class="number">1</span>, <span class="comment">//本驱动完成了这个请求 不会继续发送了</span></span><br><span class="line">	SF_IRP_PASS = <span class="number">2</span> <span class="comment">//这个IRP将下发并不调用完成后处理函数 本驱动不管了</span></span><br><span class="line">&#125; SF_RET;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> SF_RET <span class="title">OnSfilterIrpPre</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PDEVICE_OBJECT DeviceObject,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PDEVICE_OBJECT NextObject,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID extension,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PIRP Irp,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PNTSTATUS status,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID* context <span class="comment">//上下文指针 会被传递到后处理函数中</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>请求后处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> VOID <span class="title">OnSfilterIrpPost</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PDEVICE_OBJECT DeviceObject,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PDEVICE_OBJECT NextObject,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID extension,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PIRP Irp,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN NTSTATUS status,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID context</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>插入请求回调在sfilter中的实现在<code>SfPassThrough</code>中。</p>
<h3 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h3><p>编译发行版本的驱动必须链接发行版本的库，编译调试版本的驱动必须链接调试版本的库，库和驱动编译时指定的目标操作系统必须一样，编译用的WDK或DDK也必须一致。</p>
<p>该静态链接库的使用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;..\inc\sfilter\sfilter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">SF_RET <span class="title">OnSfilterIrpPre</span><span class="params">(IN PDEVICE_OBJECT dev, IN PDEVICE_OBJECT next_dev, IN PVOID extension, IN PIRP irp, OUT PNTSTATUS status, PVOID* context)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获得当前调用栈</span></span><br><span class="line">	PIO_STACK_LOCATION irpsp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(irp);</span><br><span class="line">	PFILE_OBJECT file = irpsp-&gt;FileObject;</span><br><span class="line">	<span class="comment">// 我仅仅过滤文件请求。 FileObject不存在的情况一律passthru.</span></span><br><span class="line">	<span class="keyword">if</span> (file == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> SF_IRP_PASS;</span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;IRP: file name = %wZ major function = %x\r\n&quot;</span>, &amp;file-&gt;FileName));</span><br><span class="line">	<span class="keyword">return</span> SF_IRP_PASS;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">OnSfilterIrpPost</span><span class="params">(IN PDEVICE_OBJECT dev, IN PDEVICE_OBJECT next_dev, IN PVOID extension, IN PIRP irp, IN NTSTATUS status, PVOID context)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 什么都不用做</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">OnSfilterDriverEntry</span><span class="params">(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath, OUT PUNICODE_STRING userNameString, OUT PUNICODE_STRING syblnkString, OUT PULONG extensionSize)</span> </span>&#123;</span><br><span class="line">	UNICODE_STRING user_name, syb_name;</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	<span class="comment">// 确定控制设备的名字和符号链接。</span></span><br><span class="line">	<span class="built_in">RtlInitUnicodeString</span>(&amp;user_name, <span class="string">L&quot;sflt_smpl_cdo&quot;</span>);</span><br><span class="line">	<span class="built_in">RtlInitUnicodeString</span>(&amp;syb_name, <span class="string">L&quot;sflt_smpl_cdo_syb&quot;</span>);</span><br><span class="line">	<span class="built_in">RtlCopyUnicodeString</span>(userNameString, &amp;user_name);</span><br><span class="line">	<span class="built_in">RtlCopyUnicodeString</span>(syblnkString, &amp;syb_name);</span><br><span class="line">	<span class="comment">// 设置控制设备为所有用户可用</span></span><br><span class="line">	<span class="built_in">sfilterSetCdoAccessForAll</span>();</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">OnSfilterDriverUnload</span><span class="params">(VOID)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 没什么要做的...;</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">OnSfilterCDODispatch</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">OnSfilterAttachPre</span><span class="params">(IN PDEVICE_OBJECT ourDevice, IN PDEVICE_OBJECT theDeviceToAttach, IN PUNICODE_STRING DeviceName, IN PVOID extension)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 直接返回TRUE，所有设备都绑定</span></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">OnSfilterAttachPost</span><span class="params">(IN PDEVICE_OBJECT ourDevice, IN PDEVICE_OBJECT theDeviceToAttach, IN PDEVICE_OBJECT theDeviceToAttached, IN PVOID extension, IN NTSTATUS status)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 不需要做什么。</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://Monoceros.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://monoceros.github.io/2024/05/23/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4%E4%B8%8E%E7%9B%91%E6%8E%A7/">http://monoceros.github.io/2024/05/23/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4%E4%B8%8E%E7%9B%91%E6%8E%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Monoceros.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/">逆向工程</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/26/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-sfilter%E6%BA%90%E4%BB%A3%E7%A0%81/" title="Windows驱动开发入门-sfilter源代码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Windows驱动开发入门-sfilter源代码</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/22/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E7%A3%81%E7%9B%98%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8/" title="Windows驱动开发入门-磁盘过滤驱动"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Windows驱动开发入门-磁盘过滤驱动</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/16/Angr%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/" title="Angr做题笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-16</div><div class="title">Angr做题笔记</div></div></a></div><div><a href="/2023/10/29/Angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%AC%94%E8%AE%B0/" title="Angr符号执行笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">Angr符号执行笔记</div></div></a></div><div><a href="/2024/01/13/Artfuscator%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" title="Artfuscator使用方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-13</div><div class="title">Artfuscator使用方法</div></div></a></div><div><a href="/2023/11/09/C-%E7%97%85%E6%AF%92%E6%8A%80%E6%9C%AF/" title="C++病毒技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-09</div><div class="title">C++病毒技术</div></div></a></div><div><a href="/2024/03/10/C-%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="C#逆向常见题型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-10</div><div class="title">C#逆向常见题型</div></div></a></div><div><a href="/2024/01/28/CheatEngine%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="CheatEngine基本操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="title">CheatEngine基本操作</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">智邮普创工作室安全组（退役）/Nepnep联合战队</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">291</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://monoceros406.github.io/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">QQ:1295625063（不找对象）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="toc-number">1.</span> <span class="toc-text">Windows驱动开发入门-文件系统过滤与监控</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%8E%E7%A2%8E%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">碎碎念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1-%E5%88%86%E5%8F%91%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">设备对象&amp;分发函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AE%BE%E5%A4%87%E7%94%9F%E6%88%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">控制设备生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%88%86%E5%8F%91%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">普通分发函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9FIO%E5%88%86%E5%8F%91%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">快速IO分发函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.</span> <span class="toc-text">设备绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">动态绑定函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E5%8A%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">文件系统变动回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AF%86%E5%88%AB%E5%99%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">文件系统识别器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FS-CDO%E7%BB%91%E5%AE%9A"><span class="toc-number">1.4.</span> <span class="toc-text">FS-CDO绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FS-CDO%E7%BB%91%E5%AE%9A-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">FS-CDO绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E8%AF%B7%E6%B1%82"><span class="toc-number">1.4.2.</span> <span class="toc-text">利用文件系统控制请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8D%B7"><span class="toc-number">1.5.</span> <span class="toc-text">绑定文件系统卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VPB"><span class="toc-number">1.5.1.</span> <span class="toc-text">VPB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEIRP%E5%AE%8C%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">设置IRP完成函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%8D%B7"><span class="toc-number">1.5.3.</span> <span class="toc-text">绑定卷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%BF%87%E6%BB%A4"><span class="toc-number">1.6.</span> <span class="toc-text">操作过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%AF%B7%E6%B1%82"><span class="toc-number">1.6.1.</span> <span class="toc-text">读请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%AF%BB%E8%AF%B7%E6%B1%82"><span class="toc-number">1.6.2.</span> <span class="toc-text">解析读请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.</span> <span class="toc-text">其他操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">文件对象生存周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-number">1.7.2.</span> <span class="toc-text">文件的打开与关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.3.</span> <span class="toc-text">文件的删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%BF%87%E6%BB%A4"><span class="toc-number">1.8.</span> <span class="toc-text">路径过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%88%90%E5%8A%9F%E5%90%8E%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84"><span class="toc-number">1.8.1.</span> <span class="toc-text">打开成功后获取路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%E5%89%8D%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84"><span class="toc-number">1.8.2.</span> <span class="toc-text">打开请求完成前获取路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E5%90%8D%E8%BD%AC%E9%95%BF%E5%90%8D"><span class="toc-number">1.8.3.</span> <span class="toc-text">短名转长名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sfilter%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">1.9.</span> <span class="toc-text">sfilter的封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83"><span class="toc-number">1.9.1.</span> <span class="toc-text">回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%9B%9E%E8%B0%83"><span class="toc-number">1.9.2.</span> <span class="toc-text">绑定回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%AF%B7%E6%B1%82%E5%9B%9E%E8%B0%83"><span class="toc-number">1.9.3.</span> <span class="toc-text">插入请求回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">1.9.4.</span> <span class="toc-text">静态链接库</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/09/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8-Android%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/" title="安卓逆向入门-Android后端开发入门">安卓逆向入门-Android后端开发入门</a><time datetime="2024-11-09T05:24:38.000Z" title="发表于 2024-11-09 13:24:38">2024-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/09/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/" title="Linux二进制分析入门">Linux二进制分析入门</a><time datetime="2024-11-09T05:24:04.000Z" title="发表于 2024-11-09 13:24:04">2024-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/28/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8-DEX%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%9D%E6%8E%A2/" title="安卓逆向入门-DEX文件格式初探">安卓逆向入门-DEX文件格式初探</a><time datetime="2024-10-28T11:03:36.000Z" title="发表于 2024-10-28 19:03:36">2024-10-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/28/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8-Unidbg%E5%85%A5%E9%97%A8/" title="安卓逆向入门-Unidbg入门">安卓逆向入门-Unidbg入门</a><time datetime="2024-10-28T11:02:59.000Z" title="发表于 2024-10-28 19:02:59">2024-10-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/28/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8-Unicorn%E5%85%A5%E9%97%A8/" title="安卓逆向入门-Unicorn入门">安卓逆向入门-Unicorn入门</a><time datetime="2024-10-28T11:02:18.000Z" title="发表于 2024-10-28 19:02:18">2024-10-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>