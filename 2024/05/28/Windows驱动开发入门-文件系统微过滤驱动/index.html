<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Windows驱动开发入门-文件系统微过滤驱动 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Windows驱动开发入门-文件系统微过滤驱动本节讲文件系统微&#x2F;小过滤驱动Minifilter，是sfilter（遗留过滤驱动）的新型替代品，使用比sfilter方便，因为不需要手动构造IRP、维护设备对象等，但也有些局限性，更底层的功能完全实现不了。 系统内部有个叫做过滤管理器的遗留过滤驱动，用来管理小过滤驱动。每个小过滤驱动都有自身高度值，该值确定它在设备栈中相对位置，从大到小顺序调">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows驱动开发入门-文件系统微过滤驱动">
<meta property="og:url" content="https://monoceros406.github.io/2024/05/28/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BE%AE%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="Windows驱动开发入门-文件系统微过滤驱动本节讲文件系统微&#x2F;小过滤驱动Minifilter，是sfilter（遗留过滤驱动）的新型替代品，使用比sfilter方便，因为不需要手动构造IRP、维护设备对象等，但也有些局限性，更底层的功能完全实现不了。 系统内部有个叫做过滤管理器的遗留过滤驱动，用来管理小过滤驱动。每个小过滤驱动都有自身高度值，该值确定它在设备栈中相对位置，从大到小顺序调">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://monoceros406.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-05-28T01:10:50.000Z">
<meta property="article:modified_time" content="2024-11-27T06:29:47.293Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="逆向工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://monoceros406.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://monoceros406.github.io/2024/05/28/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BE%AE%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Windows驱动开发入门-文件系统微过滤驱动',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-27 14:29:47'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="The Blog of Monoceros406" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/ycy')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Windows驱动开发入门-文件系统微过滤驱动</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-28T01:10:50.000Z" title="发表于 2024-05-28 09:10:50">2024-05-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-27T06:29:47.293Z" title="更新于 2024-11-27 14:29:47">2024-11-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Windows驱动开发入门-文件系统微过滤驱动"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Windows驱动开发入门-文件系统微过滤驱动"><a href="#Windows驱动开发入门-文件系统微过滤驱动" class="headerlink" title="Windows驱动开发入门-文件系统微过滤驱动"></a>Windows驱动开发入门-文件系统微过滤驱动</h1><p>本节讲文件系统微&#x2F;小过滤驱动Minifilter，是sfilter（遗留过滤驱动）的新型替代品，使用比sfilter方便，因为不需要手动构造IRP、维护设备对象等，但也有些局限性，更底层的功能完全实现不了。</p>
<p>系统内部有个叫做过滤管理器的遗留过滤驱动，用来管理小过滤驱动。每个小过滤驱动都有自身高度值，该值确定它在设备栈中相对位置，从大到小顺序调用。当某些小过滤驱动高度会比遗留过滤驱动要高而某些要低，此时系统装入多个驱动管理器实例（称为帧），每个实例管理自己的小过滤驱动。</p>
<p>本节例子是限制notepad.exe文件的操作，使其无法被双击执行、无法被复制、无法被改名、无法被删除。</p>
<p>微软把Minifilter框架从VS2022的WDK中删除了，从这里找：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/samples/file-system-driver-samples%E3%80%82">https://learn.microsoft.com/en-us/windows-hardware/drivers/samples/file-system-driver-samples。</a></p>
<p>这里有个很好的示例：<a target="_blank" rel="noopener" href="https://github.com/hkx3upper/FOKS-TROT%E3%80%82">https://github.com/hkx3upper/FOKS-TROT。</a></p>
<h2 id="编程框架"><a href="#编程框架" class="headerlink" title="编程框架"></a>编程框架</h2><h3 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h3><p>用来装入的用户模式API是<code>FilterLoad</code>，需要传递驱动名，即HKLM\System\CurrentControlSet\Services\drivername下键值。系统内部用内核API<code>FltLoadFilter</code>，语义一样。若从用户模式调用，则调用者令牌中必须包含SeLoadDriverPrivilege权限，该权限默认在管理员令牌中存在，标准用户令牌中不存在。</p>
<p>小过滤驱动的卸载回调可让卸载请求失败而将自身保留在系统中。</p>
<h3 id="微文件系统过滤注册"><a href="#微文件系统过滤注册" class="headerlink" title="微文件系统过滤注册"></a>微文件系统过滤注册</h3><p>用这个内核API注册：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltRegisterFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PDRIVER_OBJECT Driver, <span class="comment">//本驱动对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN CONST PFLT_REGISTRATION Registration, <span class="comment">//微过滤器注册结构 宣告注册信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PFLT_FILTER* RetFilter <span class="comment">//返回注册成功的微过滤器句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>开启微过滤器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltStartFiltering</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PFLT_FILTER Filter <span class="comment">//微过滤器句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span><span class="comment">//一般总会成功 失败只能放弃过滤别无他法</span></span></span><br></pre></td></tr></table></figure>

<p>驱动没必要自己设置IRP分发例程，因为小过滤驱动不直接在I&#x2F;O路径上，过滤管理器才是。</p>
<h3 id="微过滤器注册结构"><a href="#微过滤器注册结构" class="headerlink" title="微过滤器注册结构"></a>微过滤器注册结构</h3><p>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FLT_REGISTRATION</span> &#123;</span><br><span class="line">    USHORT Size; <span class="comment">//结构的大小 就是sizeof(FLT_REGISTRATION)</span></span><br><span class="line">    USHORT Version; <span class="comment">//结构的版本 一般FLT_REGISTRATION_VERSION</span></span><br><span class="line">    FLT_REGISTRATION_FLAGS Flags; <span class="comment">//标志位</span></span><br><span class="line">        <span class="comment">//当FLTFL_REGISTRATION_DO_NOT_SUPPORT_SERVICE_STOP时停止服务后Minifilter不会响应且不会调用FilterUnloadCallback 即不支持停止请求</span></span><br><span class="line">        <span class="comment">//FLTFL_REGISTRATION_SUPPORT_NPFS_MSFS时驱动支持命名管道和邮件槽并过滤针对这些文件系统的请求 </span></span><br><span class="line">        <span class="comment">//FLTFL_REGISTRATION_SUPPORT_DAX_VOLUME时驱动支持直接附加到直接访问卷DAX</span></span><br><span class="line">    CONST FLT_CONTEXT_REGISTRATION *ContextRegistration; <span class="comment">//上下文处理函数注册</span></span><br><span class="line">    CONST FLT_OPERATION_REGISTRATION *OperationRegistration; <span class="comment">//操作回调函数集</span></span><br><span class="line">    PFLT_FILTER_UNLOAD_CALLBACK FilterUnloadCallback; <span class="comment">//卸载回调函数 NULL则无法卸载</span></span><br><span class="line">    PFLT_INSTANCE_SETUP_CALLBACK InstanceSetupCallback; <span class="comment">//卷实例安装回调 STATUS_SUCCESS允许附加 STATUS_FLT_DO_NOT_ATTACH拒绝 可NULL</span></span><br><span class="line">    PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK InstanceQueryTeardownCallback; <span class="comment">//控制实例销毁函数 在一个手工解除绑定的请求时调用 对应FltDetachVolume和FilterDetach 可NULL则失败</span></span><br><span class="line">    PFLT_INSTANCE_TEARDOWN_CALLBACK InstanceTeardownStartCallback; <span class="comment">//实例解绑定函数 开始脱离时调用 为NULL不会阻止脱离</span></span><br><span class="line">    PFLT_INSTANCE_TEARDOWN_CALLBACK InstanceTeardownCompleteCallback; <span class="comment">//实例解绑定完成函数 可NULL</span></span><br><span class="line">    <span class="comment">//剩下这些不常用</span></span><br><span class="line">    PFLT_GENERATE_FILE_NAME GenerateFileNameCallback; <span class="comment">//生成文件名回调</span></span><br><span class="line">    PFLT_NORMALIZE_NAME_COMPONENT NormalizeNameComponentCallback; <span class="comment">//格式化名字组件回调</span></span><br><span class="line">    PFLT_NORMALIZE_CONTEXT_CLEANUP NormalizeContextCleanupCallback; <span class="comment">//格式化上下文清理回调</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FLT_MGR_LONGHORN</span></span><br><span class="line">    PFLT_TRANSACTION_NOTIFICATION_CALLBACK TransactionNotificationCallback;</span><br><span class="line">    PFLT_NORMALIZE_NAME_COMPONENT_EX NormalizeNameComponentExCallback;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FLT_MGR_LONGHORN</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FLT_MGR_WIN8</span></span><br><span class="line">    PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK SectionNotificationCallback;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FLT_MGR_WIN8</span></span></span><br><span class="line">&#125; FLT_REGISTRATION, *PFLT_REGISTRATION;</span><br></pre></td></tr></table></figure>

<p>一个可行的设置例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  This defines what we want to filter with FltMgr</span></span><br><span class="line"><span class="type">const</span> FLT_REGISTRATION FilterRegistration = &#123;</span><br><span class="line">    <span class="built_in">sizeof</span>( FLT_REGISTRATION ),         <span class="comment">//  Size</span></span><br><span class="line">    FLT_REGISTRATION_VERSION,           <span class="comment">//  Version</span></span><br><span class="line">    <span class="number">0</span>,                                  <span class="comment">//  Flags</span></span><br><span class="line">    <span class="literal">NULL</span>,                               <span class="comment">//  Context</span></span><br><span class="line">    Callbacks,                          <span class="comment">//  Operation callbacks</span></span><br><span class="line">    NPUnload,                           <span class="comment">//  MiniFilterUnload</span></span><br><span class="line">    NPInstanceSetup,                    <span class="comment">//  InstanceSetup</span></span><br><span class="line">    NPInstanceQueryTeardown,            <span class="comment">//  InstanceQueryTeardown</span></span><br><span class="line">    NPInstanceTeardownStart,            <span class="comment">//  InstanceTeardownStart</span></span><br><span class="line">    NPInstanceTeardownComplete,         <span class="comment">//  InstanceTeardownComplete</span></span><br><span class="line">    <span class="literal">NULL</span>,                               <span class="comment">//  GenerateFileName</span></span><br><span class="line">    <span class="literal">NULL</span>,                               <span class="comment">//  GenerateDestinationFileName</span></span><br><span class="line">    <span class="literal">NULL</span>                                <span class="comment">//  NormalizeNameComponent</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面FLT_OPERATION_REGISTRATION结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FLT_OPERATION_REGISTRATION</span> &#123;</span><br><span class="line">    UCHAR MajorFunction;</span><br><span class="line">    FLT_OPERATION_REGISTRATION_FLAGS Flags;</span><br><span class="line">        <span class="comment">//FLTFL_OPERATION_REGISTRATION_SKIP_CHCHED_IO 缓存I/O（如快速I/O操作）则不调用回调函数</span></span><br><span class="line">        <span class="comment">//FLTFL_OPERATION_REGISTRATION_SKIP_PAGING_IO 对换页I/O（IRP操作）不调用回调函数</span></span><br><span class="line">        <span class="comment">//FLTFL_OPERATION_REGISTRATION_SKIP_NON_DASD_IO 直接访问卷则不调用回调函数</span></span><br><span class="line">    PFLT_PRE_OPERATION_CALLBACK PreOperation; <span class="comment">//这俩至少一个不为NULL</span></span><br><span class="line">    PFLT_POST_OPERATION_CALLBACK PostOperation;</span><br><span class="line">    PVOID Reserved1;</span><br><span class="line">&#125; FLT_OPERATION_REGISTRATION, *PFLT_OPERATION_REGISTRATION;</span><br></pre></td></tr></table></figure>

<p>OperationRegistration域的设置例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  operation registration</span></span><br><span class="line"><span class="type">const</span> FLT_OPERATION_REGISTRATION Callbacks[] = &#123;</span><br><span class="line">    &#123; IRP_MJ_CREATE, <span class="comment">//请求的主功能号</span></span><br><span class="line">      <span class="number">0</span>, <span class="comment">//标志位 生成请求处理用0 FLTFL_OPERATION_REGISTRATION_SKIP_CACHED_IO不过滤缓冲读写请求 FLTFL_OPERATION_REGISTRATION_SKIP_PAGING_IO不过滤分页读写请求</span></span><br><span class="line">      NPPreCreate, <span class="comment">//生成预操作回调函数</span></span><br><span class="line">      NPPostCreate <span class="comment">//生成后操作回调函数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//填写要过滤的定义集合...</span></span><br><span class="line">    &#123; IRP_MJ_OPERATION_END &#125; <span class="comment">//最后一个必须填这个</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>DRIVER_OBJECT的FastIoDispatch成员指向一个FAST_IO_DISPATCH结构，包含一堆快速I&#x2F;O回调。快速I&#x2F;O用于对有缓存的文件进行同步I&#x2F;O操作，在用户缓冲区和系统缓存之间传递数据，跳过文件系统和存储驱动栈。例如NTFS文件系统：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">3: kd&gt; .reload /f ntfs.sys</span><br><span class="line">3: kd&gt; !drvobj \filesystem\ntfs f</span><br><span class="line">Driver object (ffff968918893da0) is for:</span><br><span class="line"> \FileSystem\Ntfs</span><br><span class="line"></span><br><span class="line">Driver Extension List: (id , addr)</span><br><span class="line"></span><br><span class="line">Device Object list:</span><br><span class="line">ffff96891680d030  ffff968918887950  </span><br><span class="line"></span><br><span class="line">DriverEntry:   fffff8027bc14010    Ntfs!GsDriverEntry</span><br><span class="line">DriverStartIo: 00000000    </span><br><span class="line">DriverUnload:  00000000    </span><br><span class="line">AddDevice:     00000000    </span><br><span class="line"></span><br><span class="line">Dispatch routines: //MajorFunction成员</span><br><span class="line">[00] IRP_MJ_CREATE                      fffff8027babbf30    Ntfs!NtfsFsdCreate //创建或打开文件/目录</span><br><span class="line">[01] IRP_MJ_CREATE_NAMED_PIPE           fffff80279291250    nt!IopInvalidDeviceRequest</span><br><span class="line">[02] IRP_MJ_CLOSE                       fffff8027baba380    Ntfs!NtfsFsdClose</span><br><span class="line">[03] IRP_MJ_READ                        fffff8027b983ed0    Ntfs!NtfsFsdRead //从文件中读</span><br><span class="line">[04] IRP_MJ_WRITE                       fffff8027b992c10    Ntfs!NtfsFsdWrite //写到文件中</span><br><span class="line">[05] IRP_MJ_QUERY_INFORMATION           fffff8027babc550    Ntfs!NtfsFsdDispatchWait</span><br><span class="line">[06] IRP_MJ_SET_INFORMATION             fffff8027ba78da0    Ntfs!NtfsFsdSetInformation //设置文件信息 如删除/重命名等</span><br><span class="line">[07] IRP_MJ_QUERY_EA                    fffff8027babc550    Ntfs!NtfsFsdDispatchWait //读取文件/目录扩展属性</span><br><span class="line">[08] IRP_MJ_SET_EA                      fffff8027babc550    Ntfs!NtfsFsdDispatchWait</span><br><span class="line">[09] IRP_MJ_FLUSH_BUFFERS               fffff8027bad0d70    Ntfs!NtfsFsdFlushBuffers</span><br><span class="line">[0a] IRP_MJ_QUERY_VOLUME_INFORMATION    fffff8027bace480    Ntfs!NtfsFsdDispatch</span><br><span class="line">[0b] IRP_MJ_SET_VOLUME_INFORMATION      fffff8027bace480    Ntfs!NtfsFsdDispatch</span><br><span class="line">[0c] IRP_MJ_DIRECTORY_CONTROL           fffff8027bab73c0    Ntfs!NtfsFsdDirectoryControl //发给目录的请求</span><br><span class="line">[0d] IRP_MJ_FILE_SYSTEM_CONTROL         fffff8027ba5e2e0    Ntfs!NtfsFsdFileSystemControl //文件系统的设备I/O控制请求</span><br><span class="line">[0e] IRP_MJ_DEVICE_CONTROL              fffff8027ba5e160    Ntfs!NtfsFsdDeviceControl</span><br><span class="line">[0f] IRP_MJ_INTERNAL_DEVICE_CONTROL     fffff80279291250    nt!IopInvalidDeviceRequest</span><br><span class="line">[10] IRP_MJ_SHUTDOWN                    fffff8027bbd23c0    Ntfs!NtfsFsdShutdown</span><br><span class="line">[11] IRP_MJ_LOCK_CONTROL                fffff8027b9cb010    Ntfs!NtfsFsdLockControl</span><br><span class="line">[12] IRP_MJ_CLEANUP                     fffff8027babad20    Ntfs!NtfsFsdCleanup</span><br><span class="line">[13] IRP_MJ_CREATE_MAILSLOT             fffff80279291250    nt!IopInvalidDeviceRequest</span><br><span class="line">[14] IRP_MJ_QUERY_SECURITY              fffff8027bace480    Ntfs!NtfsFsdDispatch</span><br><span class="line">[15] IRP_MJ_SET_SECURITY                fffff8027bace480    Ntfs!NtfsFsdDispatch</span><br><span class="line">[16] IRP_MJ_POWER                       fffff80279291250    nt!IopInvalidDeviceRequest</span><br><span class="line">[17] IRP_MJ_SYSTEM_CONTROL              fffff80279291250    nt!IopInvalidDeviceRequest</span><br><span class="line">[18] IRP_MJ_DEVICE_CHANGE               fffff80279291250    nt!IopInvalidDeviceRequest</span><br><span class="line">[19] IRP_MJ_QUERY_QUOTA                 fffff8027babc550    Ntfs!NtfsFsdDispatchWait</span><br><span class="line">[1a] IRP_MJ_SET_QUOTA                   fffff8027babc550    Ntfs!NtfsFsdDispatchWait</span><br><span class="line">[1b] IRP_MJ_PNP                         fffff8027bae05c0    Ntfs!NtfsFsdPnp</span><br><span class="line">//此外还有：</span><br><span class="line">//IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION 节将被打开</span><br><span class="line">//IRP_MJ_OPERATION_END 已到达操作回调数组末尾</span><br><span class="line"></span><br><span class="line">Fast I/O routines:</span><br><span class="line">FastIoCheckIfPossible                   fffff8027bbb45f0    Ntfs!NtfsFastIoCheckIfPossible</span><br><span class="line">FastIoRead                              fffff8027bab9cf0    Ntfs!NtfsCopyReadA</span><br><span class="line">FastIoWrite                             fffff8027bab94a0    Ntfs!NtfsCopyWriteA</span><br><span class="line">FastIoQueryBasicInfo                    fffff8027bacb260    Ntfs!NtfsFastQueryBasicInfo</span><br><span class="line">FastIoQueryStandardInfo                 fffff8027bab81e0    Ntfs!NtfsFastQueryStdInfo</span><br><span class="line">FastIoLock                              fffff8027bacd460    Ntfs!NtfsFastLock</span><br><span class="line">FastIoUnlockSingle                      fffff8027bacdb70    Ntfs!NtfsFastUnlockSingle</span><br><span class="line">FastIoUnlockAll                         fffff8027bbb1990    Ntfs!NtfsFastUnlockAll</span><br><span class="line">FastIoUnlockAllByKey                    fffff8027bbb1c40    Ntfs!NtfsFastUnlockAllByKey</span><br><span class="line">ReleaseFileForNtCreateSection           fffff8027b9a21c0    Ntfs!NtfsReleaseForCreateSection</span><br><span class="line">FastIoQueryNetworkOpenInfo              fffff8027baa99a0    Ntfs!NtfsFastQueryNetworkOpenInfo</span><br><span class="line">AcquireForModWrite                      fffff8027b9a42b0    Ntfs!NtfsAcquireFileForModWrite</span><br><span class="line">MdlRead                                 fffff8027ba755f0    Ntfs!NtfsMdlReadA</span><br><span class="line">MdlReadComplete                         fffff8027926ca30    nt!FsRtlMdlReadCompleteDev</span><br><span class="line">PrepareMdlWrite                         fffff8027badc1b0    Ntfs!NtfsPrepareMdlWriteA</span><br><span class="line">MdlWriteComplete                        fffff80279653980    nt!FsRtlMdlWriteCompleteDev</span><br><span class="line">FastIoQueryOpen                         fffff8027bab8470    Ntfs!NtfsNetworkOpenCreate</span><br><span class="line">ReleaseForModWrite                      fffff8027b9a7410    Ntfs!NtfsReleaseFileForModWrite</span><br><span class="line">AcquireForCcFlush                       fffff8027b992320    Ntfs!NtfsAcquireFileForCcFlush</span><br><span class="line">ReleaseForCcFlush                       fffff8027b9a58f0    Ntfs!NtfsReleaseFileForCcFlush</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Device Object stacks:</span><br><span class="line"></span><br><span class="line">!devstack ffff96891680d030 :</span><br><span class="line">  !DevObj           !DrvObj            !DevExt           ObjectName</span><br><span class="line">  ffff9689167b5790  \FileSystem\FltMgr ffff9689167b58e0  </span><br><span class="line">&gt; ffff96891680d030  \FileSystem\Ntfs   ffff96891680d180  </span><br><span class="line"></span><br><span class="line">!devstack ffff968918887950 :</span><br><span class="line">  !DevObj           !DrvObj            !DevExt           ObjectName</span><br><span class="line">  ffff9689166bfd20  \FileSystem\FltMgr ffff9689166bfe70  </span><br><span class="line">&gt; ffff968918887950  \FileSystem\Ntfs   00000000  Ntfs</span><br><span class="line"></span><br><span class="line">Processed 2 device objects.</span><br></pre></td></tr></table></figure>

<p>接下来注册：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  This defines what we want to filter with FltMgr</span></span><br><span class="line">CONST FLT_REGISTRATION FilterRegistration = &#123;</span><br><span class="line">    <span class="built_in">sizeof</span>(FLT_REGISTRATION),</span><br><span class="line">    FLT_REGISTRATION_VERSION,</span><br><span class="line">    <span class="number">0</span>,                       <span class="comment">//  Flags</span></span><br><span class="line">    <span class="literal">nullptr</span>,                 <span class="comment">//  Context</span></span><br><span class="line">    Callbacks,               <span class="comment">//  Operation callbacks</span></span><br><span class="line">    DelProtectUnload,                   <span class="comment">//  MiniFilterUnload</span></span><br><span class="line">    DelProtectInstanceSetup,            <span class="comment">//  InstanceSetup</span></span><br><span class="line">    DelProtectInstanceQueryTeardown,    <span class="comment">//  InstanceQueryTeardown</span></span><br><span class="line">    DelProtectInstanceTeardownStart,    <span class="comment">//  InstanceTeardownStart</span></span><br><span class="line">    DelProtectInstanceTeardownComplete, <span class="comment">//  InstanceTeardownComplete</span></span><br><span class="line">&#125;;</span><br><span class="line">PFLT_FILTER FilterHandle;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(_In_ PDRIVER_OBJECT DriverObject,_In_ PUNICODE_STRING RegistryPath)</span></span>&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    status=<span class="built_in">FltRegisterFilter</span>(DriverObject,&amp;FIlterRegistration,&amp;FilterHandle);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">NT_SUCCESS</span>(status))&#123;</span><br><span class="line">        status=<span class="built_in">FltStartingFiltering</span>(FilterHandle);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="built_in">FltUnregisterFilter</span>(FilterHandle);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>命名管道是一个单向或双向的通信机制，从一个服务器到一个或多个客户端，实现为一个文件系统npfs.sys。用<code>CreateNamedPipe</code>创建一个命名管道服务器，可用<code>CreateFile</code>加上“\\服务名\pipe\管道名”方式连接到服务器。邮件槽是个单向通信机制，实现为一个文件系统msfs.sys。用<code>CreateMailslot</code>创建邮件槽，用“\\服务名\mailslot\邮件槽名”连接。</p>
<p>高度值不需要在注册时提供，在驱动安装时，高度值被写入注册表适当位置，如FileInfo小过滤驱动位置“HKEY_LOCAL_MACHIINE\SYSTEM\CurrentControlSet\Services\FileInfo\Instance\FileInfo\Altitude”。为得到一个适当高度，驱动发行者需要给fsfcomm@microsoft.com发送一封Email，请求基于这个驱动面向的目标分配一个高度值。完整高度范围列表为<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ifs/allocated-altitudes">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ifs/allocated-altitudes</a> ，申请高度的邮件需要的详细信息有<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ifs/minifilter-altitude-request">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ifs/minifilter-altitude-request</a> 。</p>
<h3 id="卸载回调函数"><a href="#卸载回调函数" class="headerlink" title="卸载回调函数"></a>卸载回调函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NPUnload</span><span class="params">(__in FLT_FILTER_UNLOAD_FLAGS Flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Flags);</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="built_in">PT_DBG_PRINT</span>(PTDBG_TRACE_ROUTINES, (<span class="string">&quot;NPminifilter!NPUnload: Entered\n&quot;</span>));</span><br><span class="line">    <span class="built_in">FltCloseCommunicationPort</span>(gServerPort);</span><br><span class="line">    <span class="built_in">FltUnregisterFilter</span>(gFilterHandle);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="预操作回调函数"><a href="#预操作回调函数" class="headerlink" title="预操作回调函数"></a>预操作回调函数</h3><p>第一个参数FLT_CALLBACK_DATA为回调数据包，包含请求相关全部信息，所以不用直接读取IRP信息了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FLT_PREOP_CALLBACK_STATUS <span class="title">NPPreCreate</span><span class="params">(__inout PFLT_CALLBACK_DATA Data, __in PCFLT_RELATED_OBJECTS FltObjects, __deref_out_opt PVOID* CompletionContext)</span> </span>&#123; <span class="comment">//操作前回调原型 CompletionContext传给操作后回调</span></span><br><span class="line">    <span class="type">char</span> FileName[<span class="number">260</span>] = <span class="string">&quot;X:&quot;</span>; <span class="comment">//缓冲区 用来获得文件名</span></span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    PFLT_FILE_NAME_INFORMATION nameInfo;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(FltObjects);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(CompletionContext);</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>(); <span class="comment">//检测可分页代码</span></span><br><span class="line">    __try &#123;</span><br><span class="line">        status = <span class="built_in">FltGetFileNameInformation</span>(Data, FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT, &amp;nameInfo); <span class="comment">//获取文件名信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status)) &#123; <span class="comment">//如果成功则解析文件名信息 比较是否有NOTEPAD.EXE子字符串</span></span><br><span class="line">            <span class="keyword">if</span> (gCommand == ENUM_BLOCK) &#123;</span><br><span class="line">                <span class="built_in">FltParseFileNameInformation</span>(nameInfo);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">NPUnicodeStringToChar</span>(&amp;nameInfo-&gt;Name, FileName)) <span class="comment">//字符串转CHAR大写利于比对字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strstr</span>(FileName, <span class="string">&quot;NOTEPAD.EXE&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Data-&gt;IoStatus.Status = STATUS_ACCESS_DENIED; <span class="comment">//拒绝</span></span><br><span class="line">                        Data-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">FltReleaseFileNameInformation</span>(nameInfo);</span><br><span class="line">                        <span class="keyword">return</span> FLT_PREOP_COMPLETE; <span class="comment">//请求结束 不用再下传了</span></span><br><span class="line">                    &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//release resource</span></span><br><span class="line">            <span class="built_in">FltReleaseFileNameInformation</span>(nameInfo); <span class="comment">//释放名字资源</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;NPPreCreate EXCEPTION_EXECUTE_HANDLER\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FLT_PREOP_SUCCESS_WITH_CALLBACK;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中回调数据包Data参数的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FLT_CALLBACK_DATA</span> &#123;</span><br><span class="line">    FLT_CALLBACK_DATA_FLAGS Flags; <span class="comment">//标志</span></span><br><span class="line">    PETHREAD CONST Thread; <span class="comment">//请求该操作的线程</span></span><br><span class="line">    PFLT_IO_PARAMETER_BLOCK CONST Iopb;</span><br><span class="line">    IO_STATUS_BLOCK IoStatus; <span class="comment">//该请求状态 前回调可设置 后回调可查看</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_FLT_TAG_DATA_BUFFER</span> *TagData;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            LIST_ENTRY QueueLinks;</span><br><span class="line">            PVOID QueueContext[<span class="number">2</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">        PVOID FilterContext[<span class="number">4</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    KPROCESSOR_MODE RequestorMode; <span class="comment">//请求者来自用户模式UserMode还是内核模式KernelMode</span></span><br><span class="line">&#125; FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;</span><br></pre></td></tr></table></figure>

<p>Flags标志可以为：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FLTFL_CALLBACK_DATA_DIRTY</td>
<td>驱动修改了该结构并调用了<code>FltSetCallbackDataDirty</code>，该结构除Thread和RequestMode都能改。</td>
</tr>
<tr>
<td>FLTFL_CALLBACK_DATA_FAST_IO_OPERATION</td>
<td>这是个快速I&#x2F;O操作</td>
</tr>
<tr>
<td>FLTFL_CALLBACK_DATA_IRP_OPERATION</td>
<td>这是个基于IRP的操作</td>
</tr>
<tr>
<td>FLTFL_CALLBACK_DATA_GENERATED_IO</td>
<td>这是由另一个小过滤驱动生成的操作</td>
</tr>
<tr>
<td>FLTFL_CALLBACK_DATA_POST_OPERATION</td>
<td>这是一个操作后回调</td>
</tr>
</tbody></table>
<p>注意Iopb域，这里有我们需要的信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FLT_IO_PARAMETER_BLOCK</span> &#123;</span><br><span class="line">    ULONG IrpFlags;</span><br><span class="line">    UCHAR MajorFunction;</span><br><span class="line">    UCHAR MinorFunction;</span><br><span class="line">    UCHAR OperationFlags;</span><br><span class="line">    UCHAR Reserved;</span><br><span class="line">    PFILE_OBJECT TargetFileObject; <span class="comment">//本操作的目标文件对象</span></span><br><span class="line">    PFLT_INSTANCE TargetInstance;</span><br><span class="line">    FLT_PARAMETERS Parameters;</span><br><span class="line">&#125; FLT_IO_PARAMETER_BLOCK, *PFLT_IO_PARAMETER_BLOCK;</span><br></pre></td></tr></table></figure>

<p>这里包括主功能号、次功能号、文件对象指针等，还有个FLT_PARAMETERS参数域，这个域根据不同主功能号而变化，比如写请求的写入位置、长度、缓冲区等参数，这个太长了，在fltkernel.h中自己去看吧。</p>
<p>操作预回调常用返回值有：</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FLT_PREOP_COMPLETE</td>
<td>完成操作，不调用操作后回调，不将请求转发给下层小过滤驱动</td>
</tr>
<tr>
<td>FLT_PREOP_SUCCESS_NO_CALLBACK</td>
<td>完成当前请求，允许继续传递到下一个过滤器，不调用操作后回调</td>
</tr>
<tr>
<td>FLT_PREOP_SUCCESS_WITH_CALLBACK</td>
<td>同上，但调用操作后回调</td>
</tr>
<tr>
<td>FLT_PREOP_PENDING</td>
<td>驱动挂起该请求并不继续处理，直到驱动调用<code>FltCompletePendedPreOperation</code>为止</td>
</tr>
<tr>
<td>FLT_PREOP_SYNCHRONIZE</td>
<td>类似FLT_PREOP_SUCCESS_WITH_CALLBACK，但驱动请求过滤管理器在同一线程中调用操作后回调，IRQL≤APC_LEVEL。</td>
</tr>
</tbody></table>
<p>操作前回调的第二个参数类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FLT_RELATED_OBJECTS</span> &#123;</span><br><span class="line">    USHORT CONST Size;</span><br><span class="line">    USHORT CONST TransactionContext;            <span class="comment">//TxF mini-version</span></span><br><span class="line">    PFLT_FILTER CONST Filter;</span><br><span class="line">    PFLT_VOLUME CONST Volume;</span><br><span class="line">    PFLT_INSTANCE CONST Instance;</span><br><span class="line">    PFILE_OBJECT CONST FileObject;</span><br><span class="line">    PKTRANSACTION CONST Transaction;</span><br><span class="line">&#125; FLT_RELATED_OBJECTS, *PFLT_RELATED_OBJECTS;</span><br></pre></td></tr></table></figure>

<p>取得一个文件或目录的文件名信息结构用<code>FltGetFileNameInformation</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltGetFileNameInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PFLT_CALLBACK_DATA CallbackData,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN FLT_FILE_NAME_OPTIONS NameOptions, <span class="comment">//请求文件格式 FLT_FILE_NAME_NORMALIZED全路径名 FLT_FILE_NAME_QUERY_DEFAULT先缓存中找再文件系统查询</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PFLT_FILE_NAME_INFORMATION *FileNameInformation <span class="comment">//结果</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FLT_FILE_NAME_INFORMATION</span> &#123;</span><br><span class="line">    USHORT Size;</span><br><span class="line">    <span class="comment">//  For each bit that is set in the NamesParsed flags field, the corresponding substring from Name has been appropriately parsed into one of the unicode strings below.</span></span><br><span class="line">    FLT_FILE_NAME_PARSED_FLAGS NamesParsed;</span><br><span class="line">    <span class="comment">//  The name format that this FLT_FILE_NAME_INFORMATION structure represents.</span></span><br><span class="line">    FLT_FILE_NAME_OPTIONS Format;</span><br><span class="line">    <span class="comment">//  For normalized and opened names, this name contains the version of name in the following format:</span></span><br><span class="line">    <span class="comment">//    [Volume name][Full path to file][File name][Stream Name]</span></span><br><span class="line">    <span class="comment">//    For example, the above components would map to this example name as follows:</span></span><br><span class="line">    <span class="comment">//    \Device\HarddiskVolume1\Documents and Settings\MyUser\My Documents\Test Results.txt:stream1</span></span><br><span class="line">    <span class="comment">//    [Volume name] = &quot;\Device\HarddiskVolume1&quot;</span></span><br><span class="line">    <span class="comment">//    [Full path to file] = &quot;\Documents and Settings\MyUser\My Documents\&quot;</span></span><br><span class="line">    <span class="comment">//    [File name] = &quot;Test Results.txt&quot;</span></span><br><span class="line">    <span class="comment">//    [Stream name] = &quot;:stream1&quot;</span></span><br><span class="line">    <span class="comment">//  For short names, only the short name for the final name component is returned in the Name unicode string.  Therefore, if you requested the short name of the file object representing an open on the file:</span></span><br><span class="line">    <span class="comment">//    \Device\HarddiskVolume1\Documents and Settings\MyUser\My Documents\Test Results.txt</span></span><br><span class="line">    <span class="comment">//  The name returned in Name will be at most 8 characters followed by a &#x27;.&#x27; then at most 3 more characters, like:</span></span><br><span class="line">    <span class="comment">//    testre~1.txt</span></span><br><span class="line">    UNICODE_STRING Name;</span><br><span class="line">    <span class="comment">//  The Volume is only filled in for name requested in normalized and opened formats.</span></span><br><span class="line">    UNICODE_STRING Volume; <span class="comment">//符号链接映射的实际设备名 如C:为\Device\HarddiskVolume3</span></span><br><span class="line">    <span class="comment">//  The share component of the file name requested.  This will only be set for normalized and opened name formats on files that opened across redirectors.  For local files, this string will always be 0 length.</span></span><br><span class="line">    UNICODE_STRING Share; <span class="comment">//一般为空</span></span><br><span class="line">    <span class="comment">//  To exemplify what each of the following substrings refer to, let&#x27;s look again at the first example string from above:</span></span><br><span class="line">    <span class="comment">//    \Device\HarddiskVolume1\Documents and Settings\MyUser\My Documents\Test Results.txt:stream1</span></span><br><span class="line">    <span class="comment">//  Extension = &quot;txt&quot;</span></span><br><span class="line">    <span class="comment">//  Stream = &quot;:stream1&quot;</span></span><br><span class="line">    <span class="comment">//  FinalComponent = &quot;Test Results.txt:stream1&quot;</span></span><br><span class="line">    <span class="comment">//  ParentDir = &quot;\Documents and Settings\MyUser\My Documents\&quot;</span></span><br><span class="line">    <span class="comment">//  This can be parsed from a normalized, opened, or short name.</span></span><br><span class="line">    UNICODE_STRING Extension; <span class="comment">//文件扩展名 如txt</span></span><br><span class="line">    <span class="comment">//  The following parse formats are only available for normalized and opened name formats, but not short names.</span></span><br><span class="line">    UNICODE_STRING Stream;</span><br><span class="line">    UNICODE_STRING FinalComponent; <span class="comment">//文件名和流名（如果不是默认流） 如myfile.txt</span></span><br><span class="line">    UNICODE_STRING ParentDir; <span class="comment">//目录 如\mydir1\mydir2\</span></span><br><span class="line"><span class="comment">&#125; FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;</span></span><br></pre></td></tr></table></figure>

<p>上述FileNameInformation需要用<code>FltReleaseFileNameInformation</code>释放。</p>
<p>NTFS中，文件数据是$DATA流（默认流），也是保存在同一文件里。资源管理器等工具不会查看别的流，<code>GetFileSize</code>等标准API也不返回。但可用<code>DeleteFile</code>删除、用<code>FindFirstStream</code>和<code>FindNextStream</code>枚举。</p>
<p><code>FltGetFileNameInformation</code>只填充上面结构的Name字段，<code>FltParseFileNameInformation</code>用来将该结构Name拆成多个成员，获取含有路径名称与文件名的结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltParseFileNameInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN OUT PFLT_FILE_NAME_INFORMATION FileNameInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>此时可以对FLT_FILE_NAME_INFORMATION做一个RAII包装器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">FileNameOptions</span> &#123;</span><br><span class="line">    Normalized	= FLT_FILE_NAME_NORMALIZED,</span><br><span class="line">    Opened		= FLT_FILE_NAME_OPENED,</span><br><span class="line">    Short		= FLT_FILE_NAME_SHORT,</span><br><span class="line">    QueryDefault		= FLT_FILE_NAME_QUERY_DEFAULT,</span><br><span class="line">    QueryCacheOnly		= FLT_FILE_NAME_QUERY_CACHE_ONLY,</span><br><span class="line">    QueryFileSystemOnly = FLT_FILE_NAME_QUERY_FILESYSTEM_ONLY,</span><br><span class="line">    RequestFromCurrentProvider	= FLT_FILE_NAME_REQUEST_FROM_CURRENT_PROVIDER,</span><br><span class="line">    DoNotCache					= FLT_FILE_NAME_DO_NOT_CACHE,</span><br><span class="line">    AllowQueryOnReparse			= FLT_FILE_NAME_ALLOW_QUERY_ON_REPARSE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">DEFINE_ENUM_FLAG_OPERATORS</span>(FileNameOptions);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FilterFileNameInformation</span> &#123;</span><br><span class="line">    <span class="built_in">FilterFileNameInformation</span>(PFLT_CALLBACK_DATA data, FileNameOptions options = FileNameOptions::QueryDefault | FileNameOptions::Normalized);</span><br><span class="line">    ~<span class="built_in">FilterFileNameInformation</span>();</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _info != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PFLT_FILE_NAME_INFORMATION <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">PFLT_FILE_NAME_INFORMATION</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    PFLT_FILE_NAME_INFORMATION <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> _info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">NTSTATUS <span class="title">Parse</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PFLT_FILE_NAME_INFORMATION _info;</span><br><span class="line">&#125;;</span><br><span class="line">FilterFileNameInformation::<span class="built_in">FilterFileNameInformation</span>(PFLT_CALLBACK_DATA data, FileNameOptions options) &#123;</span><br><span class="line">    <span class="keyword">auto</span> status = <span class="built_in">FltGetFileNameInformation</span>(data, (FLT_FILE_NAME_OPTIONS)options, &amp;_info);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        _info = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">FilterFileNameInformation::~<span class="built_in">FilterFileNameInformation</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_info)</span><br><span class="line">        <span class="built_in">FltReleaseFileNameInformation</span>(_info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">FilterFileNameInformation::Parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FltParseFileNameInformation</span>(_info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用如下</span></span><br><span class="line"><span class="function">FilterFileNameInformation <span class="title">nameInfo</span><span class="params">(Data)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(nameinfo)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">NT_SUCCESS</span>(nameInfo.<span class="built_in">Parse</span>()))&#123;</span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;%wZ\n&quot;</span>,&amp;nameInfo-&gt;FinalComponent));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后操作回调函数"><a href="#后操作回调函数" class="headerlink" title="后操作回调函数"></a>后操作回调函数</h3><p>IRQL过高时，驱动不能访问分页内存、不能使用某些内核API、不能获取同步原语（如互斥量、快速互斥量、执行体资源、信号量、事件等，但可以获取自旋锁）、不能设置、取得或删除上下文（可释放上下文）。</p>
<p>当需要推迟到一个在IRQL低于DISPATCH_LEVEL的例程时，有两种途径：</p>
<ul>
<li>驱动用<code>FltDoCompletionProcessingWhenSafe</code>设置一个回调，降到DISPATCH_LEVEL后调用。但这方法不能用于IRP_MJ_READ、IRP_MJ_WRITE或IRP_MJ_FLUSH_BUFFERS，若这些操作在下层被同步完成则可能引起死锁。这方法只能在基于IRP的操作中使用，可用<code>FLT_IS_IRP_OPERATION</code>检查。</li>
<li>驱动用<code>FltQueueDeferredIoWorkItem</code>发送一个工作项并排队，最终在PASSIVE_LEVEL执行。工作项回调中最终调用<code>FltCompletePendedPostOperation</code>以通知过滤管理器操作后回调已完成。</li>
</ul>
<p>操作后回调返回FLT_POSTOP_FINISHED_PROCESSING表示驱动已完成该操作。若驱动需要在工作项的高IRQL上执行某些工作，可返回FLT_POSTOP_MORE_PROCESSING_REQUIRED通知过滤管理器操作处于等待完成阶段，直到工作项中用<code>FltCompletePendedPostOperation</code>通知过滤管理器可继续处理请求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FLT_POSTOP_CALLBACK_STATUS <span class="title">NPPostCreate</span><span class="params">(__inout PFLT_CALLBACK_DATA Data, __in PCFLT_RELATED_OBJECTS FltObjects, __in_opt PVOID CompletionContext, __in FLT_POST_OPERATION_FLAGS Flags)</span> </span>&#123; <span class="comment">//操作后回调原型</span></span><br><span class="line">    FLT_POSTOP_CALLBACK_STATUS returnStatus = FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">    PFLT_FILE_NAME_INFORMATION nameInfo;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(CompletionContext);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Flags);</span><br><span class="line">    <span class="comment">//  If this create was failing anyway, don&#x27;t bother scanning now.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Data-&gt;IoStatus.Status) || (STATUS_REPARSE == Data-&gt;IoStatus.Status))</span><br><span class="line">        <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">    <span class="comment">//  Check if we are interested in this file.</span></span><br><span class="line">    status = <span class="built_in">FltGetFileNameInformation</span>(Data, FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT, &amp;nameInfo); <span class="comment">//回调包中获得名字信息</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING; <span class="comment">//完成I/O所有处理 返回控制给过滤管理器</span></span><br><span class="line">    <span class="keyword">return</span> returnStatus;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其他回调函数"><a href="#其他回调函数" class="headerlink" title="其他回调函数"></a>其他回调函数</h3><p>一般这些回调函数都不需要实现什么功能，可直接在微过滤器注册结构中设置为NULL即可。</p>
<h4 id="InstanceSetupCallback"><a href="#InstanceSetupCallback" class="headerlink" title="InstanceSetupCallback"></a>InstanceSetupCallback</h4><p>让开发者决定哪个卷需要绑定，哪个卷不需要绑定。这个回调函数在下列情况下被调用：</p>
<ul>
<li>当一个微过滤器加载时，每个存在的卷都会导致这个调用。</li>
<li>当一个新的卷被挂载时。</li>
<li>当<code>FltAttachVolume</code>被内核模式调用时。</li>
<li>当<code>FltAttachVolumeAtAltitude</code>被内核模式调用时。</li>
<li>当<code>FilterAttach</code>被用户模式调用时。</li>
<li>当<code>FilterAttachAtAltitude</code>被用户模式调用时。</li>
</ul>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NPInstanceSetup</span><span class="params">(__in PCFLT_RELATED_OBJECTS FltObjects, __in FLT_INSTANCE_SETUP_FLAGS Flags, __in DEVICE_TYPE VolumeDeviceType, __in FLT_FILESYSTEM_TYPE VolumeFilesystemType)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(FltObjects);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Flags);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(VolumeDeviceType);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(VolumeFilesystemType);</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="built_in">PT_DBG_PRINT</span>(PTDBG_TRACE_ROUTINES, (<span class="string">&quot;NPminifilter!NPInstanceSetup: Entered\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中FltObjects结构含有指向微过滤器、卷和实例的指针，这个实例是将要在该函数内生成的实例。</p>
<p>Flags标记是什么操作出发了这个函数：</p>
<ul>
<li>FLTFL_INSTANCE_SETUP_AUTOMATIC_ATTACHMENT：一个微过滤器注册时自动的绑定通知。</li>
<li>FLTFL_INSTANCE_SETUP_MANUAL_ATTACHMENT：通过调用用户态<code>FilterAttach</code>或用户态<code>FilterAttachVolumeAtAltitude</code>或内核态<code>FltAttachVolume</code>发起的手工请求。</li>
<li>FLTFL_INSTANCE_SETUP_NEWLY_MOUNTED_VOLUME：文件系统刚刚挂载了一个卷。</li>
</ul>
<p>还通过得到VolumeDeviceType卷设备类型和VolumeFilesystemType卷文件系统类型来判断这个卷是否是过滤器所感兴趣的。微过滤器还可以用<code>FltGetVolumeProperties</code>获取卷属性、用<code>FltSetInstanceContext</code>在实例上设置上下文、在卷上打开关闭文件等。如果这个回调函数返回STATUS_SUCCESS或被设置为NULL时将这个实例绑定到卷上，如果返回警告或错误则不绑定。</p>
<h4 id="InstanceQueryTeardownCallback"><a href="#InstanceQueryTeardownCallback" class="headerlink" title="InstanceQueryTeardownCallback"></a>InstanceQueryTeardownCallback</h4><p>控制实例销毁函数，只有在一个手工解除绑定时被调用。手工解除绑定有两种可能：</p>
<ul>
<li>内核模式调试<code>FltDetachVolume</code>。</li>
<li>用户模式调试<code>FilterDetach</code>。</li>
</ul>
<p>如果过滤器不提供这个，不允许手工解除绑定，但卷和过滤器的卸载仍然可以。如果调用成功，那么<code>InstanceTeardownStartCallback</code>和<code>InstanceTeardownCompleteCallback</code>将会被调用。返回错误时手工解除绑定失败，推荐错误代码STATUS_FLT_DO_NOT_DETACH。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NPInstanceQueryTeardown</span><span class="params">(__in PCFLT_RELATED_OBJECTS FltObjects, __in FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(FltObjects);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Flags);</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="built_in">PT_DBG_PRINT</span>(PTDBG_TRACE_ROUTINES, (<span class="string">&quot;NPminifilter!NPInstanceQueryTeardown: Entered\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="InstanceTeardownStartCallback"><a href="#InstanceTeardownStartCallback" class="headerlink" title="InstanceTeardownStartCallback"></a>InstanceTeardownStartCallback</h4><p>解除绑定回调函数，在决定解除绑定时完成这些东西：</p>
<ul>
<li>重设所有未决I&#x2F;O操作，包括预操作和后操作。</li>
<li>保证不会有新的I&#x2F;O操作进入未决。</li>
<li>对刚刚到达的操作开始最少的工作。</li>
<li>关闭所有打开的文件。</li>
<li>取消所有本过滤器发起的I&#x2F;O请求。</li>
<li>停止将新的工作任务排队。</li>
</ul>
<p>该函数完成后微过滤器把控制权交还给过滤管理器来继续它的销毁过程。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">NPInstanceTeardownStart</span><span class="params">(__in PCFLT_RELATED_OBJECTS FltObjects, __in FLT_INSTANCE_TEARDOWN_FLAGS Flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(FltObjects);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Flags);</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="built_in">PT_DBG_PRINT</span>(PTDBG_TRACE_ROUTINES, (<span class="string">&quot;NPminifilter!NPInstanceTeardownStart: Entered\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>FltObjects同上，有微过滤器、卷和实例。</p>
<p>Reason指明这次销毁原因，可能是以下标记的组合：</p>
<ul>
<li>FLTFL_INSTANCE_TEARDOWN_MANUAL：这次销毁操作是一个手工的请求，即<code>FilterDetach</code>或<code>FltDetachVolume</code>。</li>
<li>FLTFL_INSTANCE_TEARDOWN_FILTER_UNLOAD：微过滤器执行卸载或选择把卸载请求失败掉导致的。</li>
<li>FLTFL_INSTANCE_TEARDOWN_MANDATORY_FILTER_UNLOAD：强制卸载导致的，不能把卸载请求失败掉。</li>
<li>FLTFL_INSTANCE_TEARDOWN_VOLUME_DISMOUNT：因为一个卷被解除挂载。</li>
<li>FLTFL_INSTANCE_TEARDOWN_INTERNAL_ERROR：安装实例时内部错误导致的，如内存不足。</li>
</ul>
<p>该回调函数不能失败，过滤管理器保证运行在Passive中断级。</p>
<h4 id="InstanceTeardownCompleteCallback"><a href="#InstanceTeardownCompleteCallback" class="headerlink" title="InstanceTeardownCompleteCallback"></a>InstanceTeardownCompleteCallback</h4><p>实例解除绑定完成函数。当所有与这个实例相关的操作都排除干净或完成时，该函数被调用。过滤管理器保证此时此实例存在的所有操作回调都完成了，这时微过滤器必须关闭这个实例打开的所有文件。</p>
<p>函数原型完全同上<code>InstanceTeardownStart</code>，例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">NPInstanceTeardownComplete</span><span class="params">(__in PCFLT_RELATED_OBJECTS FltObjects, __in FLT_INSTANCE_TEARDOWN_FLAGS Flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(FltObjects);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Flags);</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="built_in">PT_DBG_PRINT</span>(PTDBG_TRACE_ROUTINES, (<span class="string">&quot;NPminifilter!NPInstanceTeardownComplete: Entered\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该回调函数不能失败，过滤管理器保证运行在Passive中断级。</p>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>微过滤驱动提供上下文结构，将一些数据附加到文件系统实体上，如卷和文件，能被任何文件系统对象设置和取得。</p>
<p>用FLT_CONTEXT_REGISTRATION声明驱动需要什么样的上下文，以及用于哪种类型对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FLT_CONTEXT_REGISTRATION</span> &#123;</span><br><span class="line">    <span class="comment">//  Identifies the type of this context</span></span><br><span class="line">    FLT_CONTEXT_TYPE ContextType; <span class="comment">//标识上下文附加到什么类型对象上</span></span><br><span class="line">    <span class="comment">//  Local flags</span></span><br><span class="line">    FLT_CONTEXT_REGISTRATION_FLAGS Flags;</span><br><span class="line">    <span class="comment">//  Routine to call to cleanup the context before it is deleted. This may be NULL if not cleanup is needed.</span></span><br><span class="line">    PFLT_CONTEXT_CLEANUP_CALLBACK ContextCleanupCallback;</span><br><span class="line">    <span class="comment">//  Defines the size &amp; pool tag the mini-filter wants for the given context. FLT_VARIABLE_SIZED_CONTEXTS may be specified for the size if variable sized contexts are used.  A size of zero is valid.  If an empty pooltag value is specified, the FLTMGR will use a context type specific tag.</span></span><br><span class="line">    <span class="comment">//  If an explicit size is specified, the FLTMGR internally optimizes the allocation of that entry.</span></span><br><span class="line">    <span class="comment">//  <span class="doctag">NOTE:</span>  These fields are ignored if Allocate &amp; Free routines are specifed.</span></span><br><span class="line">    SIZE_T Size;</span><br><span class="line">    ULONG PoolTag; <span class="comment">//分配池标记</span></span><br><span class="line">    <span class="comment">//  Specifies the ALLOCATE and FREE routines that should be used when allocating a context for this mini-filter.</span></span><br><span class="line">    <span class="comment">//  <span class="doctag">NOTE:</span> The above size &amp; PoolTag fields are ignored when these routinesare defined.</span></span><br><span class="line">    PFLT_CONTEXT_ALLOCATE_CALLBACK ContextAllocateCallback; <span class="comment">//分配回调函数</span></span><br><span class="line">    PFLT_CONTEXT_FREE_CALLBACK ContextFreeCallback; <span class="comment">//释放回调函数</span></span><br><span class="line">    <span class="comment">//  Reserved for future expansion</span></span><br><span class="line">    PVOID Reserved1;</span><br><span class="line">&#125; FLT_CONTEXT_REGISTRATION, *PFLT_CONTEXT_REGISTRATION;</span><br><span class="line"><span class="comment">//ContextType取值：</span></span><br><span class="line"><span class="keyword">typedef</span> USHORT FLT_CONTEXT_TYPE;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FLT_VOLUME_CONTEXT          0x0001 <span class="comment">//卷 如磁盘分区</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FLT_INSTANCE_CONTEXT        0x0002 <span class="comment">//过滤器实例 小过滤驱动可运行多个实例 每个实例附加到不同卷上</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FLT_FILE_CONTEXT            0x0004 <span class="comment">//一般意义文件</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FLT_STREAM_CONTEXT          0x0008 <span class="comment">//文件流 FAT等单一流数据文件系统把这个看作FLT_FILE_CONTEXT</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FLT_STREAMHANDLE_CONTEXT    0x0010 <span class="comment">//流句柄 可附加到FILE_OBJECT流上</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FLT_TRANSACTION_CONTEXT     0x0020 <span class="comment">//事务 附加在正在进行的文件系统事务上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FLT_MGR_WIN8</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FLT_SECTION_CONTEXT         0x0040 <span class="comment">//节 附加到由FltCreateSectionForDataScan创建的节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FLT_MGR_WIN8</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FLT_CONTEXT_END             0xffff</span></span><br></pre></td></tr></table></figure>

<p>上下文的大小可在Size字段中指定，也可设为FLT_VARIABLE_SIZED_CONTEXTS使用可变大小。</p>
<p>一个构建上下文注册结构数组的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FileContext</span> &#123;</span><br><span class="line">    Mutex Lock;</span><br><span class="line">    UNICODE_STRING FileName;</span><br><span class="line">    BOOLEAN Written;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> FLT_CONTEXT_REGISTRATION Contexts[] = &#123;</span><br><span class="line">    &#123; FLT_FILE_CONTEXT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="built_in">sizeof</span>(FileContext), DRIVER_CONTEXT_TAG &#125;,</span><br><span class="line">    &#123; FLT_CONTEXT_END &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用<code>FltAllocateContext</code>分配：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltAllocateContet</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PFLT_FILTER Filter, <span class="comment">//过滤器指针 FltRegisterFilter返回或FLT_RELATED_OBJECTS结构中有</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ FLT_CONTEXT_TYPE ContextType, <span class="comment">//上下文类型宏</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T ContextSize, <span class="comment">//上下文大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ POOL_TYPE PoolType, <span class="comment">//PagedPool或NonPagedPool 卷上下文必须NonPagedPool</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Outptr_ PFLT_CONTEXT* ReturnedContext <span class="comment">//返回分配的上下文</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上下文分配完成后，驱动可在其中保存任何想要的数据，然后驱动必须将上下文附加到一个对象上，此时需要调用的为<code>FltSetXxxContext</code>。其中“Xxx”可以是File、Instance、Volume、Stream、StreamHandle或Transaction中的一个。节上下文需要用<code>FltCreateSectionForDataScan</code>设置。这些函数构造形式相同，以File的举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltSetFileContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PFLT_INSTANCE Instance,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ FLT_SET_CONTEXT_OPERATION Operation, <span class="comment">//FLT_SET_CONTEXT_REPLACE_IF_EXISTS或FLT_SET_CONTEXT_KEEP_IF_EXISTS</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PFLT_CONTEXT NewContext, <span class="comment">//要设置的上下文</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Outptr_ PFLT_CONTEXT* OldContext <span class="comment">//FLT_SET_CONTEXT_REPLACE_IF_EXISTS时接收旧上下文</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上下文是引用计数的，分配和设置上下文都增加引用计数。<code>FltReleaseContext</code>较少引用计数。一般不用<code>FltDeleteContext</code>手动删除上下文，一般等对应文件系统对象被销毁时自动被过滤管理器删除。</p>
<p>别的回调想获取该上下文时，用<code>FltGetXxxContext</code>，这里“Xxx”可以是File、Instance、Volume、Stream、StreamHandle、Transaction或Section之一，并将上下文引用计数加一，用完后要调用<code>FltReleaseContext</code>。</p>
<h3 id="I-O请求"><a href="#I-O请求" class="headerlink" title="I&#x2F;O请求"></a>I&#x2F;O请求</h3><p>一般内核代码用<code>ZwCreateFile</code>等打开文件句柄，用<code>ZwReadFile</code>、<code>ZwWriteFile</code>和<code>ZwDeviceIoControlFile</code>等进行I&#x2F;O操作。但对于微过滤驱动的回调中进行I&#x2F;O操作，用上面这方法则I&#x2F;O操作从最顶端过滤驱动往下朝着文件系统本身方向进行，半路会遇到当前小过滤驱动本身，造成重入。此时微过滤驱动直接用过滤管理器例程进行I&#x2F;O操作，发送到下一层过滤驱动。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltCreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ FLT_FILTER Filter, <span class="comment">// filter object 过滤器对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PFLT_INSTANCE Instance, <span class="comment">// filter instance 实例对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHANDLE FileHandle, <span class="comment">// resulting handle 返回打开的文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ACCESS_MASK DesiredAccess, <span class="comment">// access mask 访问掩码</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ POBJECT_ATTRIBUTES ObjectAttributes, <span class="comment">// object attributes</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PIO_STATUS_BLOCK IoStatusBlock, <span class="comment">// resulting status</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PLARGE_INTEGER AllocationSize, <span class="comment">// allocation size</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG FileAttributes, <span class="comment">// file attributes</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG ShareAccess, <span class="comment">// share flags</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG CreateDisposition, <span class="comment">// create disposition</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG CreateOptions, <span class="comment">// create options (sync I/O) 创建选项 FILE_SYNCHRONOUS_IO_NONALERT表示文件句柄进行同步操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer, <span class="comment">// extended attributes</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG EaLength, <span class="comment">// EA length</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG Flags <span class="comment">// flags 标志 IO_IGNORE_SHARED_ACCESS_CHECK表示文件系统对该请求忽略共享访问检查</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后驱动那这返回的句柄去用标准I&#x2F;O的API，如<code>ZwReadFile</code>和<code>ZwWriteFile</code>等，这些仍只针对下面的驱动层次。另一种方法是用<code>FltCreateFileEx</code>或<code>FltCreateFileEx2</code>返回的FILE_OBJECT调用<code>FltReadFile</code>或<code>FltWriteFile</code>。</p>
<p>操作完成后要将返回的句柄用<code>FltClose</code>，若文件对象也返回了，也要用<code>ObDeferenceObject</code>减少引用计数。</p>
<h2 id="Minifilter与应用通信"><a href="#Minifilter与应用通信" class="headerlink" title="Minifilter与应用通信"></a>Minifilter与应用通信</h2><h3 id="建立通信端口"><a href="#建立通信端口" class="headerlink" title="建立通信端口"></a>建立通信端口</h3><p>之前用<code>DeviceIoControl</code>方式，但这样必须由用户模式客户程序初始化通信，若驱动想主动发送给客户程序则无法做到。</p>
<p>微过滤驱动用<code>FltCreateCommunicationPort</code>创建一个过滤器通信端口，为来自客户程序的连接和消息注册回调。用户模式客户程序用<code>FilterConnectCommunicationPort</code>连接到这个端口，得到端口的一个句柄。定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltCreateCommunicationPort</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PFLT_FILTER Filter, <span class="comment">//FilterRegisterFilter返回的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Outptr_ PFLT_PORT* ServerPort, <span class="comment">//输出句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ POBJECT_ATTRIBUTES ObjectAttributes, <span class="comment">//属性结构</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PVOID ServerPortCookie, <span class="comment">//驱动自定义指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PFLT_CONNECT_NOTIFY ConnectNotifyCallback, <span class="comment">//新客户连接到端口回调</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PFLT_DISCONNECT_NOTIFY DisconnectNotifyCallback, <span class="comment">//用户从端口断开连接回调</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PFLT_MESSAGE_NOTIFY MessageNotifyCallback, <span class="comment">//有消息到达端口回调</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LONG MaxConnections <span class="comment">//能连接到端口的最大客户数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>微过滤驱动用<code>FltSendMessage</code>想用户模式客户程序发送一条消息，用户模式客户程序用<code>FilterGetMessage</code>等待消息到达，或用<code>FilterSendMessage</code>给驱动发送消息。若驱动期望等到一个回应，用户模式客户程序用<code>FilterReplyMessage</code>发送回应。</p>
<p>建立通信端口的方法如下，安全描述符可用<code>FltBuildDefaultSecurityDescriptor</code>创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(_In_ PDRIVER_OBJECT DriverObject,_In_ PUNICODE_STRING RegistryPath)</span></span>&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(RegistryPath);</span><br><span class="line">    <span class="built_in">PT_DBG_PRINT</span>(PTDBG_TRACE_ROUTINES,(<span class="string">&quot;FileBackup!DriverEntry: Entered\n&quot;</span>));</span><br><span class="line">    <span class="comment">//  Register with FltMgr to tell it our callback routines</span></span><br><span class="line">    status = <span class="built_in">FltRegisterFilter</span>(DriverObject,&amp;FilterRegistration,&amp;gFilterHandle);</span><br><span class="line">    <span class="built_in">FLT_ASSERT</span>(<span class="built_in">NT_SUCCESS</span>(status));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        UNICODE_STRING name = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;\\FileBackupPort&quot;</span>);</span><br><span class="line">        PSECURITY_DESCRIPTOR sd;</span><br><span class="line">        status = <span class="built_in">FltBuildDefaultSecurityDescriptor</span>(&amp;sd, FLT_PORT_ALL_ACCESS);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        OBJECT_ATTRIBUTES attr;</span><br><span class="line">        <span class="built_in">InitializeObjectAttributes</span>(&amp;attr, &amp;name, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class="literal">nullptr</span>, sd); <span class="comment">//初始化对象属性</span></span><br><span class="line">        status = <span class="built_in">FltCreateCommunicationPort</span>(gFilterHandle, &amp;FilterPort, &amp;attr, <span class="literal">nullptr</span>, PortConnectNotify, PortDisconnectNotify, PortMessageNotify, <span class="number">1</span><span class="comment">/*只允许一个客户程序连接到端口*/</span>);</span><br><span class="line">        <span class="built_in">FltFreeSecurityDescriptor</span>(sd);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//  Start filtering i/o</span></span><br><span class="line">        status = <span class="built_in">FltStartFiltering</span>(gFilterHandle);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="built_in">FltUnregisterFilter</span>(gFilterHandle);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户模式客户程序用<code>FilterConnectCommunicationPort</code>连接一个打开了的端口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT WINAPI <span class="title">FilterConnectCommunicationPort</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN LPCWSTR lpPortName, <span class="comment">//通信端口名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN DWORD dwOptions, <span class="comment">//一般FLT_PORT_FLAG_SYNC_HANDLE指定句柄只能同步使用</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN OPTIONAL LPVOID lpContext, <span class="comment">//连接时发送一个缓冲区到驱动 如用于身份验证</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN DWORD dwSizeOfContext, <span class="comment">//lpContext缓冲区大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN OPTIONAL LPSECURITY_ATTRIBUTES lpSecurityAttributes, <span class="comment">//一般NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PHANDLE hPort <span class="comment">//输出句柄 客户程序用它发送接收数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>FilterConnectCommunicationPort</code>会引起驱动的客户连接通知回调，回调函数原型如下。若驱动同意接受客户程序连接，则返回STATUS_SUCCESS，否则客户程序在<code>FilterConnectCommunicationPort</code>返回值得到一个失败HRESULT。当该API调用成功，客户程序便可以与驱动通信。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PortConnectNotify</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PFLT_PORT ClientPort, <span class="comment">//客户端口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PVOID ServerPortCookie, <span class="comment">//创建端口时指定的那个</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_reads_bytes_opt_(SizeOfContext) PVOID ConnectionContext, <span class="comment">//客户程序发来的可选缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG SizeOfContext, <span class="comment">//ConnectionContext大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Outptr_result_maybenull_ PVOID* ConnectionPortCookie <span class="comment">//该值将被传到客户断开连接和消息通知例程</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>微过滤驱动用<code>FltSendMessage</code>向客户程序发消息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS FLTAPI <span class="title">FltSendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PFLT_FILTER Filter,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PFLT_PORT* ClientPort,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PVOID SenderBuffer, <span class="comment">//发送缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG SenderBufferLength, <span class="comment">//长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PVOID ReplyBuffer, <span class="comment">//回应缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_opt_ PULONG ReplyLength, <span class="comment">//回应最大长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PLARGE_INTEGER Timeout <span class="comment">//驱动在消息到达客户程序并等待回应之前等待时间 NULL永远等待 正的则为1601年1月1日午夜算起的绝对时间值 负的则为相对时间 单位100ns</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>客户程序接收到的缓冲区有个FILTER_MESSAGE_HEADER结构，后面跟着驱动发送的实际数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FILTER_MESSAGE_HEADER</span>&#123;</span><br><span class="line">    ULONG ReplyLength, <span class="comment">//可回应的最多期望字节数</span></span><br><span class="line">    ULONGLONG MessageId; <span class="comment">//用于区别不同消息 FilterReplyMessage时用</span></span><br><span class="line">&#125; FILTER_MESSAGE_HEADER,*PFILTER_MESSAGE_HEADER;</span><br></pre></td></tr></table></figure>

<p>WDK定义的<code>FilterSendMessage</code>原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT WINAPI <span class="title">FilterSendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN HANDLE hPort, <span class="comment">//连接端口名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN OPTIONAL LPVOID lpInBuffer, <span class="comment">//输入缓冲区 自定义结构</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN DWORD dwInBufferSize, <span class="comment">//输入缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN OUT OPTIONAL LPVOID lpOutBuffer, <span class="comment">//输出缓冲区 可传入也可获得</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN DWORD dwOutBufferSize, <span class="comment">//输出缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OUT LPDWORD lpBytesReturned <span class="comment">//调用成功时返回lpOutBuffer大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="通过DLL使用通信端口"><a href="#通过DLL使用通信端口" class="headerlink" title="通过DLL使用通信端口"></a>通过DLL使用通信端口</h3><p>一般情况下，编写一个DLL专门用来与内核层Minifilter驱动程序通信，应用程序调用这个与内核通信。其中编写这个DLL时需要包含WDK头文件FltUser.h，还要搞到fltLib.lib和fltMgr.lib。</p>
<p>NPdll.h中的一些声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FltUser.h&gt;</span> <span class="comment">//注意要这个</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;fltLib.lib&quot;</span>) <span class="comment">//还有这俩</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;fltMgr.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntoskrnl.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;hal.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> HANDLE g_hPort; <span class="comment">//通信端口句柄</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPMINI_NAME            <span class="string">L&quot;NPminifilter&quot;</span> <span class="comment">//微过滤器名字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPMINI_PORT_NAME       <span class="string">L&quot;\\NPMiniPort&quot;</span> <span class="comment">//通信端口名字</span></span></span><br><span class="line"></span><br><span class="line">__declspec(dllexport)    <span class="function"><span class="type">int</span> <span class="title">InitialCommunicationPort</span><span class="params">(VOID)</span></span>; <span class="comment">//导出函数</span></span><br><span class="line">__declspec(dllexport)   <span class="function"><span class="type">int</span> <span class="title">NPSendMessage</span><span class="params">(PVOID InputBuffer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_NPMINI_COMMAND</span> &#123;</span><br><span class="line">    ENUM_PASS = <span class="number">0</span>, <span class="comment">//不过滤</span></span><br><span class="line">    ENUM_BLOCK <span class="comment">//过滤</span></span><br><span class="line">&#125; NPMINI_COMMAND;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_COMMAND_MESSAGE</span> &#123;</span><br><span class="line">    NPMINI_COMMAND     Command;   <span class="comment">//储存列举NPMINI_COMMAND命令的结构</span></span><br><span class="line">&#125; COMMAND_MESSAGE, *PCOMMAND_MESSAGE;</span><br></pre></td></tr></table></figure>

<p>DLL主程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NPdll.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hPort = INVALID_HANDLE_VALUE; <span class="comment">//初始化句柄</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MANAGED</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> managed(push, off)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call) &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH: <span class="comment">//载入DLL成功时呼叫此功能码</span></span><br><span class="line">            <span class="built_in">InitialCommunicationPort</span>(); <span class="comment">//初始化通信端口</span></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH: <span class="comment">//卸载DLL成功时呼叫此功能码</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MANAGED</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> managed(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitialCommunicationPort</span><span class="params">(VOID)</span> </span>&#123;</span><br><span class="line">    DWORD hResult = <span class="built_in">FilterConnectCommunicationPort</span>(NPMINI_PORT_NAME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;g_hPort);</span><br><span class="line">    <span class="keyword">if</span> (hResult != S_OK)</span><br><span class="line">        <span class="keyword">return</span> hResult; <span class="comment">//连接失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NPSendMessage</span><span class="params">(PVOID InputBuffer)</span> </span>&#123; <span class="comment">//传送数据</span></span><br><span class="line">    DWORD bytesReturned = <span class="number">0</span>; <span class="comment">//返回的结构大小</span></span><br><span class="line">    DWORD hResult = <span class="number">0</span>; <span class="comment">//返回值</span></span><br><span class="line">    PCOMMAND_MESSAGE commandMessage = (PCOMMAND_MESSAGE)InputBuffer;</span><br><span class="line">    hResult = <span class="built_in">FilterSendMessage</span>(g_hPort, commandMessage, <span class="built_in">sizeof</span>(COMMAND_MESSAGE), <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;bytesReturned);</span><br><span class="line">    <span class="keyword">if</span> (hResult != S_OK)</span><br><span class="line">        <span class="keyword">return</span> hResult;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="应用层的编写"><a href="#应用层的编写" class="headerlink" title="应用层的编写"></a>应用层的编写</h3><p>NPapp.c：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NPapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(__stdcall* pNPSendMessage)(PVOID pInBuffer);</span><br><span class="line"><span class="built_in">int</span>(__stdcall* pInitialCommunicationPort)(VOID);</span><br><span class="line"></span><br><span class="line">CNPApp::<span class="built_in">CNPApp</span>() &#123;</span><br><span class="line">    m_hModule = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">LoadNPminifilterDll</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CNPApp::~<span class="built_in">CNPApp</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_hModule)</span><br><span class="line">        <span class="built_in">FreeLibrary</span>(m_hModule);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CNPApp::LoadNPminifilterDll</span><span class="params">(VOID)</span> </span>&#123;</span><br><span class="line">    m_hModule = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;minifilter_dll.dll&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (m_hModule != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pNPSendMessage = (<span class="built_in">int</span>(__stdcall*)(PVOID)) <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;minifilter_dll.dll&quot;</span>)), <span class="string">&quot;NPSendMessage&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pNPSendMessage)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">CNPApp::NPMessage</span><span class="params">(COMMAND_MESSAGE data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_hModule == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LoadNPminifilterDll</span>() == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">pNPSendMessage</span>(&amp;data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc,_TCHAR* argv[]) &#123;</span><br><span class="line">    CNPApp ControlObj;</span><br><span class="line">    <span class="type">char</span> input;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter &#x27;a&#x27; for PASS MODE, &#x27;b&#x27; for BLOCKMODE or &#x27;q&#x27; to EXIT&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; input;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&#x27;a&#x27;</span> || input == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            COMMAND_MESSAGE data;</span><br><span class="line">            data.Command = ENUM_PASS;</span><br><span class="line">            ControlObj.<span class="built_in">NPMessage</span>(data);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;==&gt;NOTEPAD.EXE PASS MODE\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (input == <span class="string">&#x27;b&#x27;</span> || input == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            COMMAND_MESSAGE data;</span><br><span class="line">            data.Command = ENUM_BLOCK;</span><br><span class="line">            ControlObj.<span class="built_in">NPMessage</span>(data);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;==&gt;NOTEPAD.EXE BLOCK MODE\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (input == <span class="string">&#x27;q&#x27;</span> || input == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;EXIT\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Wrong Parameter!!!\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>NPapp.h：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_NPMINI_COMMAND</span> &#123;</span><br><span class="line">    ENUM_PASS = <span class="number">0</span>,</span><br><span class="line">    ENUM_BLOCK</span><br><span class="line">&#125; NPMINI_COMMAND;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_COMMAND_MESSAGE</span> &#123;</span><br><span class="line">    NPMINI_COMMAND 	Command;</span><br><span class="line">&#125; COMMAND_MESSAGE, * PCOMMAND_MESSAGE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CNPApp</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CNPApp</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CNPApp</span>();</span><br><span class="line">    <span class="function">VOID <span class="title">NPMessage</span><span class="params">(COMMAND_MESSAGE data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HINSTANCE m_hModule;</span><br><span class="line">    <span class="function">BOOL <span class="title">LoadNPminifilterDll</span><span class="params">(VOID)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Minifilter的安装"><a href="#Minifilter的安装" class="headerlink" title="Minifilter的安装"></a>Minifilter的安装</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>要链接fltMgr.lib文件，方法是项目属性-&gt;链接器-&gt;输入-&gt;附加依赖项中加上fltMgr.lib。</p>
<h3 id="编写INF文件"><a href="#编写INF文件" class="headerlink" title="编写INF文件"></a>编写INF文件</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Version]</span></span><br><span class="line"><span class="attr">Signature</span>   = <span class="string">&quot;$Windows NT$&quot;</span> <span class="comment">;必须这个</span></span><br><span class="line"><span class="attr">Class</span>       = <span class="string">&quot;ActivityMonitor&quot;</span> <span class="comment">;设备集合 类别名称视要注册的过滤器功能而定</span></span><br><span class="line"><span class="attr">ClassGuid</span>   = &#123;b86dff51-a31e-<span class="number">4</span>bac-b3cf-e8cfe75c9fc2&#125; <span class="comment">;GUID 这个数值视类别种类而定</span></span><br><span class="line"><span class="attr">Provider</span>    = %Msft% <span class="comment">;驱动发布者名 引用String节的Msft键值</span></span><br><span class="line"><span class="attr">DriverVer</span>   = <span class="number">06</span>/<span class="number">16</span>/<span class="number">2007</span>,<span class="number">1.0</span>.<span class="number">0.1</span> <span class="comment">;版本日期时间 留空则设为构建日期版本</span></span><br><span class="line"><span class="attr">CatalogFile</span> = NPminifilter.cat <span class="comment">;目录文件 其中保存有数字签名</span></span><br><span class="line"></span><br><span class="line"><span class="section">[DestinationDirs]</span></span><br><span class="line"><span class="attr">DefaultDestDir</span>          = <span class="number">12</span> <span class="comment">;默认drivers目录</span></span><br><span class="line"><span class="attr">MiniFilter.DriverFiles</span>  = <span class="number">12</span> <span class="comment">;代表%windir%\system32\drivers</span></span><br><span class="line"></span><br><span class="line"><span class="section">[DefaultInstall]</span></span><br><span class="line"><span class="attr">OptionDesc</span>          = %ServiceDescription% <span class="comment">;简单描述</span></span><br><span class="line"><span class="attr">CopyFiles</span>           = MiniFilter.DriverFiles</span><br><span class="line"></span><br><span class="line"><span class="section">[DefaultInstall.Services]</span></span><br><span class="line"><span class="attr">AddService</span>          = %ServiceName%,,MiniFilter.Service <span class="comment">;指向的节指出要写入注册表名为%ServiceName%键中的信息 中间是0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[DefaultUninstall]</span></span><br><span class="line"><span class="attr">DelFiles</span>   = MiniFilter.DriverFiles</span><br><span class="line"></span><br><span class="line"><span class="section">[DefaultUninstall.Services]</span></span><br><span class="line"><span class="attr">DelService</span> = %ServiceName%,<span class="number">0</span>x200 <span class="comment">;服务停止后才删除</span></span><br><span class="line"></span><br><span class="line"><span class="section">[MiniFilter.Service]</span></span><br><span class="line"><span class="attr">DisplayName</span>      = %ServiceName%</span><br><span class="line"><span class="attr">Description</span>      = %ServiceDescription%</span><br><span class="line"><span class="attr">ServiceBinary</span>    = %<span class="number">12</span>%\%DriverName%.sys        <span class="comment">;%windir%\system32\drivers</span></span><br><span class="line"><span class="attr">Dependencies</span>     = <span class="string">&quot;FltMgr&quot;</span>                     <span class="comment">;依赖服务/驱动列表 这里依赖过滤管理器本身</span></span><br><span class="line"><span class="attr">ServiceType</span>      = <span class="number">2</span>                            <span class="comment">;文件系统相关驱动类型 SERVICE_FILE_SYSTEM_DRIVER 标准驱动为1</span></span><br><span class="line"><span class="attr">StartType</span>        = <span class="number">3</span>                            <span class="comment">;启动类型 3为SERVICE_DEMAND_START表示当有需求加载时才启动此驱动功能 0为SERVICE_BOOT_START表示开机启动时自动加载</span></span><br><span class="line"><span class="attr">ErrorControl</span>     = <span class="number">1</span>                            <span class="comment">;SERVICE_ERROR_NORMAL</span></span><br><span class="line"><span class="attr">LoadOrderGroup</span>   = <span class="string">&quot;FSFilter Activity Monitor&quot;</span> <span class="comment">;必须这个 小过滤驱动分组名</span></span><br><span class="line"><span class="attr">AddReg</span>           = MiniFilter.AddRegistry <span class="comment">;指向注册表入口指示节</span></span><br><span class="line"></span><br><span class="line"><span class="section">[MiniFilter.AddRegistry]</span></span><br><span class="line">HKR,,&quot;DebugFlags&quot;,0x00010001 ,0x0 <span class="comment">;HKR为本服务所在子键HKLM\System\CurrentControlSet\Services\Sample</span></span><br><span class="line">HKR,,&quot;SupportedFeatures&quot;,0x00010001,0x3</span><br><span class="line">HKR,&quot;Instances&quot;,&quot;DefaultInstance&quot;,0x00000000,%DefaultInstance%</span><br><span class="line">HKR,&quot;Instances\&quot;%Instance1.Name%,&quot;Altitude&quot;,0x00000000,%Instance1.Altitude%</span><br><span class="line">HKR,&quot;Instances\&quot;%Instance1.Name%,&quot;Flags&quot;,0x00010001,%Instance1.Flags%</span><br><span class="line"></span><br><span class="line"><span class="section">[MiniFilter.DriverFiles]</span></span><br><span class="line">%DriverName%.sys <span class="comment">;需要复制这些文件</span></span><br><span class="line"></span><br><span class="line"><span class="section">[SourceDisksFiles]</span></span><br><span class="line"><span class="attr">NPminifilter.sys</span> = <span class="number">1</span>,,</span><br><span class="line"></span><br><span class="line"><span class="section">[SourceDisksNames]</span></span><br><span class="line"><span class="attr">1</span> = %DiskId1%,,,</span><br><span class="line"></span><br><span class="line"><span class="section">[Strings]</span></span><br><span class="line"><span class="attr">Msft</span>                    = <span class="string">&quot;Microsoft Corporation&quot;</span> <span class="comment">;改成自己名字</span></span><br><span class="line"><span class="attr">ServiceDescription</span>      = <span class="string">&quot;NPminifilter Mini-Filter Driver&quot;</span></span><br><span class="line"><span class="attr">ServiceName</span>             = <span class="string">&quot;NPminifilter&quot;</span> <span class="comment">;服务名</span></span><br><span class="line"><span class="attr">DriverName</span>              = <span class="string">&quot;NPminifilter&quot;</span> <span class="comment">;驱动名</span></span><br><span class="line"><span class="attr">DiskId1</span>                 = <span class="string">&quot;NPminifilter Device Installation Disk&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">DefaultInstance</span>         = <span class="string">&quot;NPminifilter Instance&quot;</span></span><br><span class="line"><span class="attr">Instance1.Name</span>          = <span class="string">&quot;NPminifilter Instance&quot;</span></span><br><span class="line"><span class="attr">Instance1.Altitude</span>      = <span class="string">&quot;370030&quot;</span>         <span class="comment">;高度值 要在ActivityMonitor分组高度范围内</span></span><br><span class="line"><span class="attr">Instance1.Flags</span>         = <span class="number">0</span>x0              <span class="comment">; Allow all attachments</span></span><br></pre></td></tr></table></figure>

<p>上述Class可在各个HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Class\GUID键值\Class处找到，也可用 <a target="_blank" rel="noopener" href="https://github.com/zodiacon/AllTools">https://github.com/zodiacon/AllTools</a> 中的FSClass工具查看系统中存在的所有类别。</p>
<p>对于DestinationDirs节的目录魔数，完整有<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/install/using-dirids">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/install/using-dirids</a> 。当这些数字作为路径一部分时，需要百分号括起来，如%10%\Config。</p>
<p>一个驱动程序包应至少包含SYS、INF和CAT文件。右键INF安装这个驱动，该.sys便安装到%windir%\system32\drivers下，可用OSR Driver Loader检查已安装的Minifilter在系统上的Load Group顺序。该安装过程实际用了<code>InstallHInfFile</code>。</p>
<h3 id="启动安装后的Minifilter"><a href="#启动安装后的Minifilter" class="headerlink" title="启动安装后的Minifilter"></a>启动安装后的Minifilter</h3><p>在INF的目录下敲命令：</p>
<p>第一种：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start 驱动名称</span><br><span class="line">net stop 驱动名称</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fltmc <span class="comment">#查看已存在的小过滤驱动 分别有驱动名、实例数（每个卷一个实例）、高度、所在过滤管理器帧</span></span><br><span class="line">fltmc load 驱动名称</span><br><span class="line">fltmc unload 驱动名称</span><br><span class="line">fltmc instances <span class="comment">#每个驱动所有实例</span></span><br><span class="line">fltmc volumes <span class="comment">#系统挂载的所有文件系统卷</span></span><br></pre></td></tr></table></figure>

<p>文件驱动和过滤驱动创建在对象管理器名字空间的FileSystem目录下，WinObj能看。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; .load fltkd //加载fltkd.dll调试扩展</span><br><span class="line">2: kd&gt; !help //命令列表</span><br><span class="line">   Filter Manager Debugger Extensions:</span><br><span class="line">       For the following extensions, [detail] is a value from 0 to 1 which specifies</span><br><span class="line">       the level of detail to show.  The default detail level is 0.</span><br><span class="line"></span><br><span class="line">       For the following extensions, [flags] allows you to control what information is displayed</span><br><span class="line">       for the given object.  The default flags is 0, so minimal information is shown.</span><br><span class="line"></span><br><span class="line">   cbd [addr] [flags] [detail]               Dump IRP_CTRL or CALLBACK_DATA</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Extended detail on each completion stack</span><br><span class="line"></span><br><span class="line">   irpctrl [addr] [flags] [detail]           Dump IRP_CTRL or CALLBACK_DATA</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Extended detail on each completion stack</span><br><span class="line"></span><br><span class="line">   contextlist [addr] [detail]               Dump CONTEXT_LIST_CTRL</span><br><span class="line"></span><br><span class="line">   ctx [addr] [detail]                       Dump CONTEXT_NODE</span><br><span class="line"></span><br><span class="line">   fileList [addr] [flags] [detail]          Dump FILE_LIST_CTRL given fileObject or FileList address</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 File list ctrl&#x27;s file context info</span><br><span class="line"></span><br><span class="line">   filter [addr] [flags] [detail]            Dump FLT_FILTER</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Basic filter information</span><br><span class="line">         0x00000002 Filter&#x27;s context registration information</span><br><span class="line">         0x00000004 Filter&#x27;s context usage information</span><br><span class="line">         0x00000008 Filter&#x27;s object usage/reference information</span><br><span class="line">         0x00000010 Filter&#x27;s Verifier information</span><br><span class="line">         0x00000020 Filter&#x27;s Port information</span><br><span class="line"></span><br><span class="line">   filters [flags] [detail]                  Dumps all the filters registered in the system</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Basic filter information</span><br><span class="line">         0x00000002 Filter&#x27;s context registration information</span><br><span class="line">         0x00000004 Filter&#x27;s context usage information</span><br><span class="line">         0x00000008 Filter&#x27;s object usage/reference information</span><br><span class="line">         0x00000010 Filter&#x27;s Verifier information</span><br><span class="line">         0x00000020 Filter&#x27;s Port information</span><br><span class="line"></span><br><span class="line">   fltobj [addr] [detail]                    Dump FLT_OBJECT</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Basic object information</span><br><span class="line">         0x00000002 Rundown log information on the object</span><br><span class="line"></span><br><span class="line">   frame [addr] [flags] [detail]             Dump FLTP_FRAME</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Basic frame information</span><br><span class="line">         0x00000002 Frame&#x27;s PRCB information</span><br><span class="line">         0x00000004 Frame&#x27;s VOLUME information</span><br><span class="line"></span><br><span class="line">   frames [flags] [detail]                   Dumps all the frames in the system</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Basic frame information</span><br><span class="line">         0x00000002 Frame&#x27;s PRCB information</span><br><span class="line">         0x00000004 Frame&#x27;s VOLUME information</span><br><span class="line"></span><br><span class="line">   instance [addr] [flags] [detail]          Dump FLT_INSTANCE</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Basic instance information</span><br><span class="line">         0x00000002 Instance&#x27;s context information</span><br><span class="line">         0x00000004 Instance&#x27;s operation callbacks</span><br><span class="line">         0x00000008 Instance&#x27;s completion node information</span><br><span class="line"></span><br><span class="line">   msgq [addr] [flags] [detail]              Dumps supplied message queue</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Extended detail on each message</span><br><span class="line"></span><br><span class="line">   namecachelist [addr] [detail]             Dump NAME_CACHE_LIST_CTRL</span><br><span class="line"></span><br><span class="line">   oplock [addr] [flags]                     Dump oplock given address of owning FILE_OBJECT or stuck IRP (tells you what oplock it is waiting for)</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 [addr] points to an OPLOCK (default is FILE_OBJECT or IRP)</span><br><span class="line"></span><br><span class="line">   port [addr]                               Dumps connection port</span><br><span class="line"></span><br><span class="line">   portlist [filter object addr] [flags] [detail]  Dumps all port connections of specified filter</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Extended detail on each port</span><br><span class="line"></span><br><span class="line">   relobjs [addr]                            Dump IRP_CTRL</span><br><span class="line"></span><br><span class="line">   tree [addr] [detail]                      Dump tree</span><br><span class="line"></span><br><span class="line">   streamList [addr] [flags] [detail]        Dump STREAM_LIST_CTRL given fileObject or StreamList address</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Stream list ctrl&#x27;s stream context info</span><br><span class="line">         0x00000002 Stream list ctrl&#x27;s stream handle context info</span><br><span class="line">         0x00000004 Stream list ctrl&#x27;s normalized name info</span><br><span class="line">         0x00000008 Stream list ctrl&#x27;s opened name info</span><br><span class="line">         0x00000010 Stream list ctrl&#x27;s short name info</span><br><span class="line">         0x00000020 Stream list ctrl&#x27;s section context info</span><br><span class="line"></span><br><span class="line">   traceflags [flags]                        Sets trace flags. Displays current setting if not supplied</span><br><span class="line"></span><br><span class="line">   tracelevel [level]                        Sets trace level. Displays current setting if not supplied</span><br><span class="line"></span><br><span class="line">   volume [addr] [flags] [detail]            Dump FLT_VOLUME given deviceObject or FltVolume address</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Basic volume information</span><br><span class="line">         0x00000002 Volume&#x27;s context information</span><br><span class="line">         0x00000004 Volume&#x27;s operation callbacks</span><br><span class="line">         0x00000008 Volume&#x27;s name cache information</span><br><span class="line">         0x00000010 Volume&#x27;s stream list control information</span><br><span class="line">         0x00000020 Volume&#x27;s file list control information</span><br><span class="line"></span><br><span class="line">   volumes [flags] [detail]                  Dump all the volumes to which the filter manager is attached</span><br><span class="line">      where [flags] specify what information to dump:</span><br><span class="line">         0x00000001 Basic volume information</span><br><span class="line">         0x00000002 Volume&#x27;s context information</span><br><span class="line">         0x00000004 Volume&#x27;s operation callbacks</span><br><span class="line">         0x00000008 Volume&#x27;s name cache information</span><br><span class="line">         0x00000010 Volume&#x27;s stream list control information</span><br><span class="line">         0x00000020 Volume&#x27;s file list control information</span><br><span class="line"></span><br><span class="line">   work [detail]                             Dump Throttled worker queue information</span><br><span class="line"></span><br><span class="line">   stats                                     Dumps statistics</span><br><span class="line">1: kd&gt; !filters //所有已装入微过滤驱动</span><br><span class="line"></span><br><span class="line">Filter List: ffff8c8e719170d0 &quot;Frame 0&quot; </span><br><span class="line">   FLT_FILTER: ffff8c8e738844d0 &quot;wcifs&quot; &quot;189900&quot;</span><br><span class="line">   FLT_FILTER: ffff8c8e7373d530 &quot;CldFlt&quot; &quot;180451&quot;</span><br><span class="line">   FLT_FILTER: ffff8c8e7208c260 &quot;FileCrypt&quot; &quot;141100&quot;</span><br><span class="line">   FLT_FILTER: ffff8c8e720d65b0 &quot;npsvctrig&quot; &quot;46000&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e7230c9f0 &quot;npsvctrig&quot; &quot;46000&quot;</span><br><span class="line">   FLT_FILTER: ffff8c8e73db98a0 &quot;Wof&quot; &quot;40700&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e720629a0 &quot;Wof Instance&quot; &quot;40700&quot;</span><br><span class="line">   FLT_FILTER: ffff8c8e73db88a0 &quot;FileInfo&quot; &quot;40500&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e720028e0 &quot;FileInfo&quot; &quot;40500&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e720619a0 &quot;FileInfo&quot; &quot;40500&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e72311010 &quot;FileInfo&quot; &quot;40500&quot;</span><br><span class="line">0: kd&gt; !filter ffff8c8e73db88a0 //指定地址微过滤驱动信息</span><br><span class="line"></span><br><span class="line">FLT_FILTER: ffff8c8e73db88a0 &quot;FileInfo&quot; &quot;40500&quot;</span><br><span class="line">   FLT_OBJECT: ffff8c8e73db88a0  [02000000] Filter</span><br><span class="line">      RundownRef               : 0x0000000000003800 (7168)</span><br><span class="line">      PointerCount             : 0x00000001 </span><br><span class="line">      PrimaryLink              : [ffff8c8e719170d0-ffff8c8e73db98b0] </span><br><span class="line">   Frame                    : ffff8c8e71917020 &quot;Frame 0&quot; </span><br><span class="line">   Flags                    : [00000032] FilteringInitiated +30!!</span><br><span class="line">   DriverObject             : ffff8c8e73db78f0 </span><br><span class="line">   FilterLink               : [ffff8c8e719170d0-ffff8c8e73db98b0] </span><br><span class="line">   PreVolumeMount           : 0000000000000000  (null) </span><br><span class="line">   PostVolumeMount          : 0000000000000000  (null) </span><br><span class="line">   FilterUnload             : fffff8066af23e30  fileinfo!FIUnload </span><br><span class="line">   InstanceSetup            : 0000000000000000  (null) </span><br><span class="line">   InstanceQueryTeardown    : 0000000000000000  (null) </span><br><span class="line">   InstanceTeardownStart    : 0000000000000000  (null) </span><br><span class="line">   InstanceTeardownComplete : 0000000000000000  (null) </span><br><span class="line">   ActiveOpens              : (ffff8c8e73db8a58)  mCount=0 </span><br><span class="line">   Communication Port List  : (ffff8c8e73db8aa8)  mCount=0 </span><br><span class="line">   Client Port List         : (ffff8c8e73db8af8)  mCount=0 </span><br><span class="line">   VerifierExtension        : 0000000000000000 </span><br><span class="line">   Operations               : ffff8c8e73db8b50 </span><br><span class="line">   OldDriverUnload          : 0000000000000000  (null) </span><br><span class="line">   SupportedContexts        : (ffff8c8e73db89d0)</span><br><span class="line">      VolumeContexts           : (ffff8c8e73db89d0)</span><br><span class="line">      InstanceContexts         : (ffff8c8e73db89d8)</span><br><span class="line">         ALLOCATE_CONTEXT_NODE: ffff8c8e73db7ab0 &quot;FileInfo&quot; [01] LookasideList (size=672)</span><br><span class="line">      FileContexts             : (ffff8c8e73db89e0)</span><br><span class="line">      StreamContexts           : (ffff8c8e73db89e8)</span><br><span class="line">         ALLOCATE_CONTEXT_NODE: ffff8c8e73db7bf0 &quot;FileInfo&quot; [01] LookasideList (size=80)</span><br><span class="line">      StreamHandleContexts     : (ffff8c8e73db89f0)</span><br><span class="line">      TransactionContext       : (ffff8c8e73db89f8)</span><br><span class="line">      (null)                   : (ffff8c8e73db8a00)</span><br><span class="line">   InstanceList             : (ffff8c8e73db8908)</span><br><span class="line">      FLT_INSTANCE: ffff8c8e720028e0 &quot;FileInfo&quot; &quot;40500&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e720619a0 &quot;FileInfo&quot; &quot;40500&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e72311010 &quot;FileInfo&quot; &quot;40500&quot;</span><br><span class="line">1: kd&gt; !portlist ffff8c8e73db88a0 //指定过滤服务器端口列表</span><br><span class="line"></span><br><span class="line">FLT_FILTER: ffff8c8e73db88a0 </span><br><span class="line">   Client Port List         : Mutex (ffff8c8e73db8af8) List [ffff8c8e73db8b30-ffff8c8e73db8b30] mCount=0 </span><br><span class="line">2: kd&gt; !port ffff8c8e73db8af8 //指定客户端口信息</span><br><span class="line"></span><br><span class="line">FLT_PORT_OBJECT: ffff8c8e73db8af8 </span><br><span class="line">   FilterLink               : [0000000000000001-0000000000000000] </span><br><span class="line">   ServerPort               : 0000000000000000 </span><br><span class="line">   Cookie                   : 0000000000060001 </span><br><span class="line">   Lock                     : (ffff8c8e73db8b20)</span><br><span class="line">   MsgQ                     : (ffff8c8e73db8b58)  NumEntries=897091712 Enabled</span><br><span class="line">   MessageId                : 0x0000000000000000 </span><br><span class="line">   DisconnectEvent          : (ffff8c8e73db8c30)</span><br><span class="line">   Disconnected             : FALSE </span><br><span class="line">1: kd&gt; !instance ffff8c8e7230c9f0 //指定地址实例信息</span><br><span class="line"></span><br><span class="line">FLT_INSTANCE: ffff8c8e7230c9f0 &quot;npsvctrig&quot; &quot;46000&quot;</span><br><span class="line">   FLT_OBJECT: ffff8c8e7230c9f0  [01000000] Instance</span><br><span class="line">      RundownRef               : 0x0000000000000000 (0)</span><br><span class="line">      PointerCount             : 0x00000002 </span><br><span class="line">      PrimaryLink              : [ffff8c8e72246118-ffff8c8e72246118] </span><br><span class="line">   OperationRundownRef      : ffff8c8e720ec680 </span><br><span class="line">      Number                   : 4 </span><br><span class="line">      PoolToFree               : ffff8c8e722f3c00 </span><br><span class="line">      OperationsRefs           : ffff8c8e722f3c00  (18)</span><br><span class="line">         PerProcessor Ref[0]      : 0x0000000000000006 (3)</span><br><span class="line">         PerProcessor Ref[1]      : 0x000000000000000e (7)</span><br><span class="line">         PerProcessor Ref[2]      : 0x0000000000000012 (9)</span><br><span class="line">         PerProcessor Ref[3]      : 0xfffffffffffffffe (-1)</span><br><span class="line">   Flags                    : [00000000]</span><br><span class="line">   Volume                   : ffff8c8e72246010 &quot;\Device\NamedPipe&quot;</span><br><span class="line">   Filter                   : ffff8c8e720d65b0 &quot;npsvctrig&quot;</span><br><span class="line">   TrackCompletionNodes     : ffff8c8e722f5280 </span><br><span class="line">   ContextLock              : (ffff8c8e7230ca70)</span><br><span class="line">   Context                  : ffffe08dae046c70 </span><br><span class="line">   CallbackNodes            : (ffff8c8e7230ca90)</span><br><span class="line">   VolumeLink               : [ffff8c8e72246118-ffff8c8e72246118] </span><br><span class="line">   FilterLink               : [ffff8c8e720d6680-ffff8c8e720d6680] </span><br><span class="line">2: kd&gt; !volumes //所有卷对象</span><br><span class="line"></span><br><span class="line">Volume List: ffff8c8e71917150 &quot;Frame 0&quot; </span><br><span class="line">   FLT_VOLUME: ffff8c8e7200e010 &quot;\Device\Mup&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e720028e0 &quot;FileInfo&quot; &quot;40500&quot;</span><br><span class="line">   FLT_VOLUME: ffff8c8e72009010 &quot;\Device\HarddiskVolume3&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e720629a0 &quot;Wof Instance&quot; &quot;40700&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e720619a0 &quot;FileInfo&quot; &quot;40500&quot;</span><br><span class="line">   FLT_VOLUME: ffff8c8e72246010 &quot;\Device\NamedPipe&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e7230c9f0 &quot;npsvctrig&quot; &quot;46000&quot;</span><br><span class="line">   FLT_VOLUME: ffff8c8e72245050 &quot;\Device\Mailslot&quot;</span><br><span class="line">   FLT_VOLUME: ffff8c8e7222e010 &quot;\Device\HarddiskVolume1&quot;</span><br><span class="line">      FLT_INSTANCE: ffff8c8e72311010 &quot;FileInfo&quot; &quot;40500&quot;</span><br><span class="line">2: kd&gt; !volume ffff8c8e7200e010 //指定地址的卷详细信息</span><br><span class="line"></span><br><span class="line">FLT_VOLUME: ffff8c8e7200e010 &quot;\Device\Mup&quot;</span><br><span class="line">   FLT_OBJECT: ffff8c8e7200e010  [04000000] Volume</span><br><span class="line">      RundownRef               : 0x0000000000000004 (2)</span><br><span class="line">      PointerCount             : 0x00000001 </span><br><span class="line">      PrimaryLink              : [ffff8c8e72009020-ffff8c8e71917150] </span><br><span class="line">   Frame                    : ffff8c8e71917020 &quot;Frame 0&quot; </span><br><span class="line">   Flags                    : [000000e5] NetworkFS SetupNotifyCalled EnableNameCaching FilterAttached StandardLinkInfoNotSupported</span><br><span class="line">   FileSystemType           : [0000000d] FLT_FSTYPE_MUP</span><br><span class="line">   VolumeLink               : [ffff8c8e72009020-ffff8c8e71917150] </span><br><span class="line">   DeviceObject             : ffff8c8e71fe12d0 </span><br><span class="line">   DiskDeviceObject         : 0000000000000000 </span><br><span class="line">   FrameZeroVolume          : ffff8c8e7200e010 </span><br><span class="line">   VolumeInNextFrame        : 0000000000000000 </span><br><span class="line">   Guid                     : &quot;&quot; </span><br><span class="line">   CDODeviceName            : &quot;\Device\Mup&quot; </span><br><span class="line">   CDODriverName            : &quot;\FileSystem\Mup&quot; </span><br><span class="line">   TargetedOpenCount        : 0 </span><br><span class="line">   Callbacks                : (ffff8c8e7200e130)</span><br><span class="line">   ContextLock              : (ffff8c8e7200e518)</span><br><span class="line">   VolumeContexts           : (ffff8c8e7200e520)  Count=0</span><br><span class="line">   StreamListCtrls          : (ffff8c8e7200e528)  rCount=1 </span><br><span class="line">   FileListCtrls            : (ffff8c8e7200e5a8)  rCount=0 </span><br><span class="line">   NameCacheCtrl            : (ffff8c8e7200e628)</span><br><span class="line">   InstanceList             : (ffff8c8e7200e0b0)</span><br><span class="line">      FLT_INSTANCE: ffff8c8e720028e0 &quot;FileInfo&quot; &quot;40500&quot;</span><br></pre></td></tr></table></figure>



<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="防cmd-exe删除文件"><a href="#防cmd-exe删除文件" class="headerlink" title="防cmd.exe删除文件"></a>防cmd.exe删除文件</h3><p>删除文件时有两种方法，一种是用IRP_MJ_SET_INFORMATION；另一种是FILE_DELETE_ON_CLOSE打开文件，所有句柄关闭后文件被删除。第二种方法可直接在用户模式将FILE_FLAG_DELETE_ON_CLOSE传入<code>CreateFile</code>。所以此时修改FLT_OPERATION_REGISTRATION数组以支持这两种选择：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONST FLT_OPERATION_REGISTRATION Callbacks[] = &#123;</span><br><span class="line">    &#123; IRP_MJ_CREATE, <span class="number">0</span>, DelProtectPreCreate, <span class="literal">nullptr</span> &#125;,</span><br><span class="line">    &#123; IRP_MJ_SET_INFORMATION, <span class="number">0</span>, DelProtectPreSetInformation, <span class="literal">nullptr</span> &#125;,</span><br><span class="line">    &#123; IRP_MJ_OPERATION_END &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建前回调处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">ZwQueryInformationProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_      HANDLE           ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_      PROCESSINFOCLASS ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_     PVOID            ProcessInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_      ULONG            ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ PULONG           ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">_Use_decl_annotations_ FLT_PREOP_CALLBACK_STATUS <span class="title">DelProtectPreCreate</span><span class="params">(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID*)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(FltObjects);</span><br><span class="line">    <span class="keyword">if</span> (Data-&gt;RequestorMode == KernelMode) <span class="comment">//来自内核模式则直接继续</span></span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="keyword">auto</span>&amp; params = Data-&gt;Iopb-&gt;Parameters.Create;</span><br><span class="line">    <span class="keyword">auto</span> returnStatus = FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="keyword">if</span> (params.Options &amp; FILE_DELETE_ON_CLOSE) &#123; <span class="comment">//检查FILE_DELETE_ON_CLOSE标志是否存在于创建请求中</span></span><br><span class="line">        <span class="comment">// delete operation</span></span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;Delete on close: %wZ\n&quot;</span>, &amp;Data-&gt;Iopb-&gt;TargetFileObject-&gt;FileName));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IsDeleteAllowed</span>(<span class="built_in">PsGetCurrentProcess</span>())) &#123;</span><br><span class="line">            Data-&gt;IoStatus.Status = STATUS_ACCESS_DENIED;</span><br><span class="line">            returnStatus = FLT_PREOP_COMPLETE;</span><br><span class="line">            <span class="built_in">KdPrint</span>((<span class="string">&quot;Prevent delete from IRP_MJ_CREATE by cmd.exe\n&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnStatus;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsDeleteAllowed</span><span class="params">(<span class="type">const</span> PEPROCESS Process)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> currentProcess = <span class="built_in">PsGetCurrentProcess</span>() == Process;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    <span class="keyword">if</span> (currentProcess)</span><br><span class="line">        hProcess = <span class="built_in">NtCurrentProcess</span>();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> status = <span class="built_in">ObOpenObjectByPointer</span>(Process, OBJ_KERNEL_HANDLE, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, KernelMode, &amp;hProcess);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> size = <span class="number">300</span>;</span><br><span class="line">    <span class="type">bool</span> allowDelete = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> processName = (UNICODE_STRING*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, size, DRIVER_TAG);</span><br><span class="line">    <span class="keyword">if</span> (processName) &#123;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(processName, size);	<span class="comment">// ensure string will be NULL-terminated</span></span><br><span class="line">        <span class="keyword">auto</span> status = <span class="built_in">ZwQueryInformationProcess</span>(hProcess, ProcessImageFileName, processName, size - <span class="built_in">sizeof</span>(WCHAR), <span class="literal">nullptr</span>); <span class="comment">//获取当前进程映像名</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">            <span class="built_in">KdPrint</span>((<span class="string">&quot;Delete operation from %wZ\n&quot;</span>, processName));</span><br><span class="line">            <span class="keyword">if</span> (processName-&gt;Length &gt;<span class="number">0</span> &amp;&amp; <span class="built_in">wcsstr</span>(processName-&gt;Buffer, <span class="string">L&quot;\\System32\\cmd.exe&quot;</span>) != <span class="literal">nullptr</span> || <span class="built_in">wcsstr</span>(processName-&gt;Buffer, <span class="string">L&quot;\\SysWOW64\\cmd.exe&quot;</span>) != <span class="literal">nullptr</span>) <span class="comment">//这里只防cmd.exe删文件</span></span><br><span class="line">                allowDelete = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ExFreePool</span>(processName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!currentProcess)</span><br><span class="line">        <span class="built_in">ZwClose</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> allowDelete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面那段params变量的结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    PIO_SECURITY_CONTEXT SecurityContext;</span><br><span class="line">    <span class="comment">//  The low 24 bits contains CreateOptions flag values.</span></span><br><span class="line">    <span class="comment">//  The high 8 bits contains the CreateDisposition values.</span></span><br><span class="line">    ULONG Options;</span><br><span class="line">    USHORT POINTER_ALIGNMENT FileAttributes;</span><br><span class="line">    USHORT ShareAccess;</span><br><span class="line">    ULONG POINTER_ALIGNMENT EaLength;</span><br><span class="line">    PVOID EaBuffer;                 <span class="comment">//Not in IO_STACK_LOCATION parameters list</span></span><br><span class="line">    LARGE_INTEGER AllocationSize;   <span class="comment">//Not in IO_STACK_LOCATION parameters list</span></span><br><span class="line">&#125; Create;</span><br></pre></td></tr></table></figure>

<p>上面用的<code>ObOpenObjectByPointer</code>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObOpenObjectByPointer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PVOID Object, <span class="comment">//要获取句柄的对象 啥对象都行</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG HandleAttributes, <span class="comment">//标志 OBJ_KERNEL_HANDLE返回内核句柄 可用于任何进程上下文</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PACCESS_STATE PassedAccessState, <span class="comment">//一般NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ACCESS_MASK DesiredAccess, <span class="comment">//访问掩码 若AccessMode为KernelMode 则该参数为0则返回的句柄有全部功能</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ POBJECT_TYPE ObjectType, <span class="comment">//将对象与该类型比较 可以是*PsProcessType、*PsThreadType等</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ KPROCESSOR_MODE AccessMode, <span class="comment">//一般KernelMode</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHANDLE Handle <span class="comment">//返回句柄指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>设置信息前回调：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FLT_PREOP_CALLBACK_STATUS <span class="title">DelProtectPreSetInformation</span><span class="params">(_Inout_ PFLT_CALLBACK_DATA Data, _In_ PCFLT_RELATED_OBJECTS FltObjects, PVOID*)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(FltObjects);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Data);</span><br><span class="line">    <span class="keyword">auto</span>&amp; params = Data-&gt;Iopb-&gt;Parameters.SetFileInformation;</span><br><span class="line">    <span class="keyword">if</span> (params.FileInformationClass != FileDispositionInformation &amp;&amp; params.FileInformationClass != FileDispositionInformationEx) <span class="comment">//检查是不是删除操作</span></span><br><span class="line">        <span class="comment">// not a delete operation</span></span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="keyword">auto</span> info = (FILE_DISPOSITION_INFORMATION*)params.InfoBuffer;</span><br><span class="line">    <span class="keyword">if</span> (!info-&gt;DeleteFile) <span class="comment">//这个也要检查</span></span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="keyword">auto</span> returnStatus = FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="comment">// what process did this originate from?</span></span><br><span class="line">    <span class="keyword">auto</span> process = <span class="built_in">PsGetThreadProcess</span>(Data-&gt;Thread);</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>(process);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsDeleteAllowed</span>(process)) &#123;</span><br><span class="line">        Data-&gt;IoStatus.Status = STATUS_ACCESS_DENIED;</span><br><span class="line">        returnStatus = FLT_PREOP_COMPLETE;</span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;Prevent delete from IRP_MJ_SET_INFORMATION by cmd.exe\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时params结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    ULONG Length;</span><br><span class="line">    FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass; <span class="comment">//本实例代表的操作类型</span></span><br><span class="line">    PFILE_OBJECT ParentOfTarget;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            BOOLEAN ReplaceIfExists;</span><br><span class="line">            BOOLEAN AdvanceOnly;</span><br><span class="line">        &#125;;</span><br><span class="line">        ULONG ClusterCount;</span><br><span class="line">        HANDLE DeleteHandle;</span><br><span class="line">    &#125;;</span><br><span class="line">    PVOID InfoBuffer;       <span class="comment">//Not in IO_STACK_LOCATION parameters list</span></span><br><span class="line">&#125; SetFileInformation;</span><br></pre></td></tr></table></figure>

<p>接下来暴露一个控制设备对象CDO：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_DELPROTECT_ADD_EXE    CTL_CODE(0x8000, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_DELPROTECT_REMOVE_EXE CTL_CODE(0x8000, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_DELPROTECT_CLEAR        CTL_CODE(0x8000, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxExecutables = <span class="number">32</span>;</span><br><span class="line">WCHAR* ExeNames[MaxExecutables];</span><br><span class="line"><span class="type">int</span> ExeNamesCount;</span><br><span class="line">FastMutex ExeNamesLock;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(_In_ PDRIVER_OBJECT DriverObject,_In_ PUNICODE_STRING RegistryPath)</span></span>&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(RegistryPath);</span><br><span class="line">    <span class="built_in">PT_DBG_PRINT</span>(PTDBG_TRACE_ROUTINES,(<span class="string">&quot;DelProtect!DriverEntry: Entered\n&quot;</span>));</span><br><span class="line">    <span class="comment">// create a standard device object and symbolic link</span></span><br><span class="line">    PDEVICE_OBJECT DeviceObject = <span class="literal">nullptr</span>;</span><br><span class="line">    UNICODE_STRING devName = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;\\device\\delprotect&quot;</span>);</span><br><span class="line">    UNICODE_STRING symLink = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;\\??\\delprotect&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> symLinkCreated = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="number">0</span>, &amp;devName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, FALSE, &amp;DeviceObject);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;symLink, &amp;devName);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        symLinkCreated = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//  Register with FltMgr to tell it our callback routines</span></span><br><span class="line">        status = <span class="built_in">FltRegisterFilter</span>(DriverObject, &amp;FilterRegistration, &amp;gFilterHandle);</span><br><span class="line">        <span class="built_in">FLT_ASSERT</span>(<span class="built_in">NT_SUCCESS</span>(status));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        DriverObject-&gt;DriverUnload = DelProtectUnloadDriver;</span><br><span class="line">        DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = DelProtectCreateClose;</span><br><span class="line">        DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DelProtectDeviceControl;</span><br><span class="line">        ExeNamesLock.<span class="built_in">Init</span>();</span><br><span class="line">        <span class="comment">//  Start filtering i/o</span></span><br><span class="line">        status = <span class="built_in">FltStartFiltering</span>(gFilterHandle);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gFilterHandle)</span><br><span class="line">            <span class="built_in">FltUnregisterFilter</span>(gFilterHandle);</span><br><span class="line">        <span class="keyword">if</span> (symLinkCreated)</span><br><span class="line">            <span class="built_in">IoDeleteSymbolicLink</span>(&amp;symLink);</span><br><span class="line">        <span class="keyword">if</span> (DeviceObject)</span><br><span class="line">            <span class="built_in">IoDeleteDevice</span>(DeviceObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设备控制分发例程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DelProtectDeviceControl</span><span class="params">(PDEVICE_OBJECT, PIRP Irp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> stack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">    <span class="keyword">auto</span> status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">switch</span> (stack-&gt;Parameters.DeviceIoControl.IoControlCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_DELPROTECT_ADD_EXE: &#123;</span><br><span class="line">            <span class="keyword">auto</span> name = (WCHAR*)Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">            <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">                status = STATUS_INVALID_PARAMETER;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FindExecutable</span>(name))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="function">AutoLock <span class="title">locker</span><span class="params">(ExeNamesLock)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (ExeNamesCount == MaxExecutables) &#123;</span><br><span class="line">                status = STATUS_TOO_MANY_NAMES;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxExecutables; i++)</span><br><span class="line">                <span class="keyword">if</span> (ExeNames[i] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> len = (::<span class="built_in">wcslen</span>(name) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line">                    <span class="keyword">auto</span> buffer = (WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, len, DRIVER_TAG);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">                        status = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ::<span class="built_in">wcscpy_s</span>(buffer, len / <span class="built_in">sizeof</span>(WCHAR), name);</span><br><span class="line">                    ExeNames[i] = buffer;</span><br><span class="line">                    ++ExeNamesCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_DELPROTECT_REMOVE_EXE: &#123;</span><br><span class="line">            <span class="keyword">auto</span> name = (WCHAR*)Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">            <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">                status = STATUS_INVALID_PARAMETER;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">AutoLock <span class="title">locker</span><span class="params">(ExeNamesLock)</span></span>;</span><br><span class="line">            <span class="keyword">auto</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxExecutables; i++)</span><br><span class="line">                <span class="keyword">if</span> (::_wcsicmp(ExeNames[i], name) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">ExFreePool</span>(ExeNames[i]);</span><br><span class="line">                    ExeNames[i] = <span class="literal">nullptr</span>;</span><br><span class="line">                    --ExeNamesCount;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (!found)</span><br><span class="line">                status = STATUS_NOT_FOUND;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_DELPROTECT_CLEAR:</span><br><span class="line">            <span class="built_in">ClearAll</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            status = STATUS_INVALID_DEVICE_REQUEST;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Irp-&gt;IoStatus.Status = status;</span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FindExecutable</span><span class="params">(PCWSTR name)</span> </span>&#123;</span><br><span class="line">    <span class="function">AutoLock <span class="title">locker</span><span class="params">(ExeNamesLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ExeNamesCount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxExecutables; i++)</span><br><span class="line">        <span class="keyword">if</span> (ExeNames[i] &amp;&amp; ::_wcsicmp(ExeNames[i], name) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">AutoLock <span class="title">locker</span><span class="params">(ExeNamesLock)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxExecutables; i++)</span><br><span class="line">        <span class="keyword">if</span> (ExeNames[i]) &#123;</span><br><span class="line">            <span class="built_in">ExFreePool</span>(ExeNames[i]);</span><br><span class="line">            ExeNames[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ExeNamesCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保护某目录中文件不被删除"><a href="#保护某目录中文件不被删除" class="headerlink" title="保护某目录中文件不被删除"></a>保护某目录中文件不被删除</h3><p>保存目录的数据结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DirectoryEntry</span> &#123;</span><br><span class="line">    UNICODE_STRING DosName; <span class="comment">//DOS名</span></span><br><span class="line">    UNICODE_STRING NtName; <span class="comment">//NT名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Free</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DosName.Buffer) &#123;</span><br><span class="line">            <span class="built_in">ExFreePool</span>(DosName.Buffer);</span><br><span class="line">            DosName.Buffer = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (NtName.Buffer) &#123;</span><br><span class="line">            <span class="built_in">ExFreePool</span>(NtName.Buffer);</span><br><span class="line">            NtName.Buffer = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxDirectories = <span class="number">32</span>;</span><br><span class="line">DirectoryEntry DirNames[MaxDirectories];</span><br><span class="line"><span class="type">int</span> DirNamesCount;</span><br><span class="line">FastMutex DirNamesLock;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_DELPROTECT_ADD_DIR    CTL_CODE(0x8000, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_DELPROTECT_REMOVE_DIR CTL_CODE(0x8000, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_DELPROTECT_CLEAR        CTL_CODE(0x8000, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DelProtectDeviceControl</span><span class="params">(PDEVICE_OBJECT, PIRP Irp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> stack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">    <span class="keyword">auto</span> status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">switch</span> (stack-&gt;Parameters.DeviceIoControl.IoControlCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_DELPROTECT_ADD_DIR: &#123;</span><br><span class="line">            <span class="keyword">auto</span> name = (WCHAR*)Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">            <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">                status = STATUS_INVALID_PARAMETER;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> bufferLen = stack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">            <span class="keyword">if</span> (bufferLen &gt; <span class="number">1024</span>) &#123;</span><br><span class="line">                <span class="comment">// just too long for a directory</span></span><br><span class="line">                status = STATUS_INVALID_PARAMETER;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// make sure there is a NULL terminator somewhere</span></span><br><span class="line">            name[bufferLen / <span class="built_in">sizeof</span>(WCHAR) - <span class="number">1</span>] = <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">auto</span> dosNameLen = ::<span class="built_in">wcslen</span>(name);</span><br><span class="line">            <span class="keyword">if</span> (dosNameLen &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                status = STATUS_BUFFER_TOO_SMALL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">AutoLock <span class="title">locker</span><span class="params">(DirNamesLock)</span></span>;</span><br><span class="line">            UNICODE_STRING strName;</span><br><span class="line">            <span class="built_in">RtlInitUnicodeString</span>(&amp;strName, name);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FindDirectory</span>(&amp;strName, <span class="literal">true</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DirNamesCount == MaxDirectories) &#123;</span><br><span class="line">                status = STATUS_TOO_MANY_NAMES;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxDirectories; i++) &#123; <span class="comment">//找个空位</span></span><br><span class="line">                <span class="keyword">if</span> (DirNames[i].DosName.Buffer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> len = (dosNameLen + <span class="number">2</span>) * <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line">                    <span class="keyword">auto</span> buffer = (WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, len, DRIVER_TAG);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">                        status = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ::<span class="built_in">wcscpy_s</span>(buffer, len / <span class="built_in">sizeof</span>(WCHAR), name);</span><br><span class="line">                    <span class="comment">// append a backslash if it&#x27;s missing</span></span><br><span class="line">                    <span class="keyword">if</span> (name[dosNameLen - <span class="number">1</span>] != <span class="string">L&#x27;\\&#x27;</span>)</span><br><span class="line">                        ::<span class="built_in">wcscat_s</span>(buffer, dosNameLen + <span class="number">2</span>, <span class="string">L&quot;\\&quot;</span>);</span><br><span class="line">                    status = <span class="built_in">ConvertDosNameToNtName</span>(buffer, &amp;DirNames[i].NtName);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">                        <span class="built_in">ExFreePool</span>(buffer);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">RtlInitUnicodeString</span>(&amp;DirNames[i].DosName, buffer);</span><br><span class="line">                    <span class="built_in">KdPrint</span>((<span class="string">&quot;Add: %wZ &lt;=&gt; %wZ\n&quot;</span>, &amp;DirNames[i].DosName, &amp;DirNames[i].NtName));</span><br><span class="line">                    ++DirNamesCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_DELPROTECT_REMOVE_DIR: &#123;</span><br><span class="line">            <span class="keyword">auto</span> name = (WCHAR*)Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">            <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">                status = STATUS_INVALID_PARAMETER;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> bufferLen = stack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">            <span class="keyword">if</span> (bufferLen &gt; <span class="number">1024</span>) &#123;</span><br><span class="line">                <span class="comment">// just too long for a directory</span></span><br><span class="line">                status = STATUS_INVALID_PARAMETER;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// make sure there is a NULL terminator somewhere</span></span><br><span class="line">            name[bufferLen / <span class="built_in">sizeof</span>(WCHAR) - <span class="number">1</span>] = <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">auto</span> dosNameLen = ::<span class="built_in">wcslen</span>(name);</span><br><span class="line">            <span class="keyword">if</span> (dosNameLen &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                status = STATUS_BUFFER_TOO_SMALL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">AutoLock <span class="title">locker</span><span class="params">(DirNamesLock)</span></span>;</span><br><span class="line">            UNICODE_STRING strName;</span><br><span class="line">            <span class="built_in">RtlInitUnicodeString</span>(&amp;strName, name);</span><br><span class="line">            <span class="type">int</span> found = <span class="built_in">FindDirectory</span>(&amp;strName, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (found &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                DirNames[found].<span class="built_in">Free</span>();</span><br><span class="line">                DirNamesCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                status = STATUS_NOT_FOUND;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_DELPROTECT_CLEAR:</span><br><span class="line">            <span class="built_in">ClearAll</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            status = STATUS_INVALID_DEVICE_REQUEST;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Irp-&gt;IoStatus.Status = status;</span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindDirectory</span><span class="params">(PCUNICODE_STRING name, <span class="type">bool</span> dosName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DirNamesCount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxDirectories; i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; dir = dosName ? DirNames[i].DosName : DirNames[i].NtName;</span><br><span class="line">        <span class="keyword">if</span> (dir.Buffer &amp;&amp; <span class="built_in">RtlEqualUnicodeString</span>(name, &amp;dir, TRUE))</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后DOS名转NT名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ConvertDosNameToNtName</span><span class="params">(_In_ PCWSTR dosName, _Out_ PUNICODE_STRING ntName)</span> </span>&#123;</span><br><span class="line">    ntName-&gt;Buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> dosNameLen = ::<span class="built_in">wcslen</span>(dosName);</span><br><span class="line">    <span class="keyword">if</span> (dosNameLen &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_BUFFER_TOO_SMALL;</span><br><span class="line">    <span class="comment">// make sure we have a driver letter</span></span><br><span class="line">    <span class="keyword">if</span> (dosName[<span class="number">2</span>] != <span class="string">L&#x27;\\&#x27;</span> || dosName[<span class="number">1</span>] != <span class="string">L&#x27;:&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    <span class="function">kstring <span class="title">symLink</span><span class="params">(<span class="string">L&quot;\\??\\&quot;</span>, PagedPool, DRIVER_TAG)</span></span>;</span><br><span class="line">    symLink.<span class="built_in">Append</span>(dosName, <span class="number">2</span>);		<span class="comment">// driver letter and colon 驱动器字母</span></span><br><span class="line">    <span class="comment">// prepare to open symbolic link</span></span><br><span class="line">    UNICODE_STRING symLinkFull;</span><br><span class="line">    symLink.<span class="built_in">GetUnicodeString</span>(&amp;symLinkFull);</span><br><span class="line">    OBJECT_ATTRIBUTES symLinkAttr;</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;symLinkAttr, &amp;symLinkFull, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>); <span class="comment">//初始化OBJECT_ATTRIBUTES</span></span><br><span class="line">    HANDLE hSymLink = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// open symbolic link</span></span><br><span class="line">        status = <span class="built_in">ZwOpenSymbolicLinkObject</span>(&amp;hSymLink, GENERIC_READ, &amp;symLinkAttr); <span class="comment">//打开符号链接</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        USHORT maxLen = <span class="number">1024</span>;	<span class="comment">// arbitrary</span></span><br><span class="line">        ntName-&gt;Buffer = (WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, maxLen, DRIVER_TAG);</span><br><span class="line">        <span class="keyword">if</span> (!ntName-&gt;Buffer) &#123;</span><br><span class="line">            status = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ntName-&gt;MaximumLength = maxLen;</span><br><span class="line">        <span class="comment">// read target of symbolic link</span></span><br><span class="line">        status = <span class="built_in">ZwQuerySymbolicLinkObject</span>(hSymLink, ntName, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="keyword">if</span> (ntName-&gt;Buffer) &#123;</span><br><span class="line">            <span class="built_in">ExFreePool</span>(ntName-&gt;Buffer);</span><br><span class="line">            ntName-&gt;Buffer = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">RtlAppendUnicodeToString</span>(ntName, dosName + <span class="number">2</span>);	<span class="comment">// directory</span></span><br><span class="line">    <span class="keyword">if</span> (hSymLink)</span><br><span class="line">        <span class="built_in">ZwClose</span>(hSymLink);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否处于受保护目录：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsDeleteAllowed</span><span class="params">(_In_ PFLT_CALLBACK_DATA Data)</span> </span>&#123;</span><br><span class="line">    PFLT_FILE_NAME_INFORMATION nameInfo = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> allow = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> status = <span class="built_in">FltGetFileNameInformation</span>(Data, FLT_FILE_NAME_QUERY_DEFAULT | FLT_FILE_NAME_NORMALIZED, &amp;nameInfo);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        status = <span class="built_in">FltParseFileNameInformation</span>(nameInfo);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// concatenate volume+share+directory</span></span><br><span class="line">        UNICODE_STRING path;</span><br><span class="line">        path.Length = path.MaximumLength = nameInfo-&gt;Volume.Length + nameInfo-&gt;Share.Length + nameInfo-&gt;ParentDir.Length;</span><br><span class="line">        path.Buffer = nameInfo-&gt;Volume.Buffer;</span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;Checking directory: %wZ\n&quot;</span>, &amp;path));</span><br><span class="line">        <span class="function">AutoLock <span class="title">locker</span><span class="params">(DirNamesLock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FindDirectory</span>(&amp;path, <span class="literal">false</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            allow = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">KdPrint</span>((<span class="string">&quot;File not allowed to delete: %wZ\n&quot;</span>, &amp;nameInfo-&gt;Name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (nameInfo)</span><br><span class="line">        <span class="built_in">FltReleaseFileNameInformation</span>(nameInfo);</span><br><span class="line">    <span class="keyword">return</span> allow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建前回调和信息前回调：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_Use_decl_annotations_ FLT_PREOP_CALLBACK_STATUS <span class="title">DelProtectPreCreate</span><span class="params">(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID*)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(FltObjects);</span><br><span class="line">    <span class="keyword">if</span> (Data-&gt;RequestorMode == KernelMode)</span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="keyword">auto</span>&amp; params = Data-&gt;Iopb-&gt;Parameters.Create;</span><br><span class="line">    <span class="keyword">if</span> (params.Options &amp; FILE_DELETE_ON_CLOSE) &#123;</span><br><span class="line">        <span class="comment">// delete operation</span></span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;Delete on close: %wZ\n&quot;</span>, &amp;FltObjects-&gt;FileObject-&gt;FileName));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IsDeleteAllowed</span>(Data)) &#123;</span><br><span class="line">            Data-&gt;IoStatus.Status = STATUS_ACCESS_DENIED;</span><br><span class="line">            <span class="keyword">return</span> FLT_PREOP_COMPLETE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">_Use_decl_annotations_ FLT_PREOP_CALLBACK_STATUS <span class="title">DelProtectPreSetInformation</span><span class="params">(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID* CompletionContext)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(FltObjects);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(CompletionContext);</span><br><span class="line">    <span class="keyword">if</span> (Data-&gt;RequestorMode == KernelMode)</span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="keyword">auto</span>&amp; params = Data-&gt;Iopb-&gt;Parameters.SetFileInformation;</span><br><span class="line">    <span class="keyword">if</span> (params.FileInformationClass != FileDispositionInformation &amp;&amp; params.FileInformationClass != FileDispositionInformationEx)</span><br><span class="line">        <span class="comment">// not a delete operation</span></span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="keyword">auto</span> info = (FILE_DISPOSITION_INFORMATION*)params.InfoBuffer;</span><br><span class="line">    <span class="keyword">if</span> (!info-&gt;DeleteFile)</span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsDeleteAllowed</span>(Data))</span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    Data-&gt;IoStatus.Status = STATUS_ACCESS_DENIED;</span><br><span class="line">    <span class="keyword">return</span> FLT_PREOP_COMPLETE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h3><p>当文件以写访问方式打开，则在写入前自动对文件备份，需要时可把文件恢复到前一个状态。备份放在文件的另一个流中，需要时将该流内容与默认流交换，相当于恢复。</p>
<p>驱动不应附加到非NTFS卷上，可通过修改微过滤驱动的项目模板中的实例设置回调：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FileBackupInstanceSetup</span><span class="params">(_In_ PCFLT_RELATED_OBJECTS FltObjects,_In_ FLT_INSTANCE_SETUP_FLAGS Flags,_In_ DEVICE_TYPE VolumeDeviceType,_In_ FLT_FILESYSTEM_TYPE VolumeFilesystemType)</span></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(FltObjects);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Flags);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(VolumeDeviceType);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(VolumeFilesystemType);</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="keyword">if</span> (VolumeFilesystemType != FLT_FSTYPE_NTFS) &#123;</span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;Not attaching to non-NTFS volume\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> STATUS_FLT_DO_NOT_ATTACH; <span class="comment">//拒绝附加到指定卷</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来要截取写操作，需要一个IRP_MJ_WRITE的操作前回调，还需要一个文件上下文跟踪一些状态。驱动可能需要处理创建后回调和IRP_MJ_CLEANUP清除操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CONST FLT_OPERATION_REGISTRATION Callbacks[] = &#123;</span><br><span class="line">    &#123; IRP_MJ_CREATE, <span class="number">0</span>, <span class="literal">nullptr</span>, FileBackupPostCreate &#125;,</span><br><span class="line">    &#123; IRP_MJ_WRITE, FLTFL_OPERATION_REGISTRATION_SKIP_PAGING_IO, FileBackupPreWrite &#125;,</span><br><span class="line">    &#123; IRP_MJ_CLEANUP, <span class="number">0</span>, <span class="literal">nullptr</span>, FileBackupPostCleanup &#125;,</span><br><span class="line">    &#123; IRP_MJ_OPERATION_END &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FileContext</span> &#123; <span class="comment">//跟踪写操作是否已在特定打开文件上进行过</span></span><br><span class="line">    Mutex Lock; <span class="comment">//用于同步的互斥量</span></span><br><span class="line">    UNICODE_STRING FileName; <span class="comment">//文件名</span></span><br><span class="line">    BOOLEAN Written; <span class="comment">//文件是否已备份</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> FLT_CONTEXT_REGISTRATION Contexts[] = &#123;</span><br><span class="line">    &#123; FLT_FILE_CONTEXT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="built_in">sizeof</span>(FileContext), DRIVER_CONTEXT_TAG &#125;,</span><br><span class="line">    &#123; FLT_CONTEXT_END &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CONST FLT_REGISTRATION FilterRegistration = &#123;</span><br><span class="line">    <span class="built_in">sizeof</span>(FLT_REGISTRATION),         <span class="comment">//  Size</span></span><br><span class="line">    FLT_REGISTRATION_VERSION,         <span class="comment">//  Version</span></span><br><span class="line">    <span class="number">0</span>,                                <span class="comment">//  Flags</span></span><br><span class="line">    Contexts,                         <span class="comment">//  Context</span></span><br><span class="line">    Callbacks,                        <span class="comment">//  Operation callbacks</span></span><br><span class="line">    FileBackupUnload,                 <span class="comment">//  MiniFilterUnload</span></span><br><span class="line">    FileBackupInstanceSetup,</span><br><span class="line">    FileBackupInstanceQueryTeardown,</span><br><span class="line">    FileBackupInstanceTeardownStart,</span><br><span class="line">    FileBackupInstanceTeardownComplete,</span><br><span class="line">    <span class="literal">nullptr</span>,    <span class="comment">//  GenerateFileName</span></span><br><span class="line">    <span class="literal">nullptr</span>,    <span class="comment">//  GenerateDestinationFileName</span></span><br><span class="line">    <span class="literal">nullptr</span>     <span class="comment">//  NormalizeNameComponent</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>设置创建后回调，用它为感兴趣的文件分配文件上下文。之所以不使用操作前回调，是因为可不考虑打开文件操作会不会由于别的驱动的操作前回调而失败。只有当文件成功打开了，驱动才去检查文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FLT_POSTOP_CALLBACK_STATUS <span class="title">FileBackupPostCreate</span><span class="params">(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID CompletionContext, FLT_POST_OPERATION_FLAGS Flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(CompletionContext);</span><br><span class="line">    <span class="keyword">if</span> (Flags &amp; FLTFL_POST_OPERATION_DRAINING)</span><br><span class="line">        <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; params = Data-&gt;Iopb-&gt;Parameters.Create; <span class="comment">//创建操作的参数</span></span><br><span class="line">    <span class="keyword">if</span> (Data-&gt;RequestorMode == KernelMode || (params.SecurityContext-&gt;DesiredAccess &amp; FILE_WRITE_DATA) == <span class="number">0</span> || Data-&gt;IoStatus.Information == FILE_DOES_NOT_EXIST) <span class="comment">//非写访问、来自内核模式、新创建的文件跳过</span></span><br><span class="line">        <span class="comment">// kernel caller, not write access or a new file - skip</span></span><br><span class="line">        <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">    <span class="comment">// get file name</span></span><br><span class="line">    <span class="function">FilterFileNameInformation <span class="title">fileNameInfo</span><span class="params">(Data)</span></span>; <span class="comment">//之前讲的RAII包装器</span></span><br><span class="line">    <span class="keyword">if</span> (!fileNameInfo)</span><br><span class="line">        <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(fileNameInfo.<span class="built_in">Parse</span>()))</span><br><span class="line">        <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsBackupDirectory</span>(&amp;fileNameInfo-&gt;ParentDir)) <span class="comment">//判断是否是感兴趣的目录</span></span><br><span class="line">        <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">    <span class="comment">// if it&#x27;s not the default stream, we don&#x27;t care</span></span><br><span class="line">    <span class="keyword">if</span> (fileNameInfo-&gt;Stream.Length &gt; <span class="number">0</span>) <span class="comment">//打开的不是默认流 不处理</span></span><br><span class="line">        <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">    <span class="comment">// allocate and initialize a file context</span></span><br><span class="line">    FileContext* context;</span><br><span class="line">    <span class="keyword">auto</span> status = <span class="built_in">FltAllocateContext</span>(FltObjects-&gt;Filter, FLT_FILE_CONTEXT, <span class="built_in">sizeof</span>(FileContext), PagedPool, (PFLT_CONTEXT*)&amp;context);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;Failed to allocate file context (0x%08X)\n&quot;</span>, status));</span><br><span class="line">        <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">    &#125;</span><br><span class="line">    context-&gt;Written = FALSE;</span><br><span class="line">    context-&gt;FileName.MaximumLength = fileNameInfo-&gt;Name.Length;</span><br><span class="line">    context-&gt;FileName.Buffer = (WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, fileNameInfo-&gt;Name.Length, DRIVER_TAG);</span><br><span class="line">    <span class="keyword">if</span> (!context-&gt;FileName.Buffer) &#123;</span><br><span class="line">        <span class="built_in">FltReleaseContext</span>(context);</span><br><span class="line">        <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RtlCopyUnicodeString</span>(&amp;context-&gt;FileName, &amp;fileNameInfo-&gt;Name);</span><br><span class="line">    context-&gt;Lock.<span class="built_in">Init</span>(); <span class="comment">//快速互斥量会导致IRQL提到APC_LEVEL 这里用传统互斥量</span></span><br><span class="line">    status = <span class="built_in">FltSetFileContext</span>(FltObjects-&gt;Instance, FltObjects-&gt;FileObject, FLT_SET_CONTEXT_KEEP_IF_EXISTS, context, <span class="literal">nullptr</span>); <span class="comment">//附加到文件上</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;Failed to set file context (0x%08X)\n&quot;</span>, status));</span><br><span class="line">        <span class="built_in">ExFreePool</span>(context-&gt;FileName.Buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FltReleaseContext</span>(context); <span class="comment">//释放上下文</span></span><br><span class="line">    <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBackupDirectory</span><span class="params">(_In_ PCUNICODE_STRING directory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// no counted version of wcsstr :(</span></span><br><span class="line">    ULONG maxSize = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">if</span> (directory-&gt;Length &gt; maxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy = (WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, maxSize + <span class="built_in">sizeof</span>(WCHAR), DRIVER_TAG);</span><br><span class="line">    <span class="keyword">if</span> (!copy)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(copy, maxSize + <span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line">    <span class="built_in">wcsncpy_s</span>(copy, <span class="number">1</span> + maxSize / <span class="built_in">sizeof</span>(WCHAR), directory-&gt;Buffer, directory-&gt;Length / <span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line">    _wcslwr(copy); <span class="comment">//转小写</span></span><br><span class="line">    <span class="type">bool</span> doBackup = <span class="built_in">wcsstr</span>(copy, <span class="string">L&quot;\\pictures\\&quot;</span>) || <span class="built_in">wcsstr</span>(copy, <span class="string">L&quot;\\documents\\&quot;</span>);</span><br><span class="line">    <span class="built_in">ExFreePool</span>(copy);</span><br><span class="line">    <span class="keyword">return</span> doBackup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于写前回调，要在真正写操作前复制一份文件数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FLT_PREOP_CALLBACK_STATUS <span class="title">FileBackupPreWrite</span><span class="params">(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID* CompletionContext)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(CompletionContext);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Data);</span><br><span class="line">    <span class="comment">// get the file context if exists</span></span><br><span class="line">    FileContext* context;</span><br><span class="line">    <span class="keyword">auto</span> status = <span class="built_in">FltGetFileContext</span>(FltObjects-&gt;Instance, FltObjects-&gt;FileObject, (PFLT_CONTEXT*)&amp;context);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status) || context == <span class="literal">nullptr</span>) <span class="comment">//上下文不存在 则为不感兴趣的文件</span></span><br><span class="line">        <span class="comment">// no context, continue normally</span></span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// acquire the fast mutex in case of multiple writes</span></span><br><span class="line">        <span class="function">AutoLock&lt;Mutex&gt; <span class="title">locker</span><span class="params">(context-&gt;Lock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!context-&gt;Written) &#123; <span class="comment">//若备份未创建</span></span><br><span class="line">            status = <span class="built_in">BackupFile</span>(&amp;context-&gt;FileName, FltObjects); <span class="comment">//内核中没有文件复制API 要自己写</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">                <span class="built_in">KdPrint</span>((<span class="string">&quot;Failed to backup file! (0x%X)\n&quot;</span>, status));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// send message to user mode</span></span><br><span class="line">                <span class="keyword">if</span> (SendClientPort) &#123; <span class="comment">//检查是否有客户程序连接</span></span><br><span class="line">                    USHORT nameLen = context-&gt;FileName.Length;</span><br><span class="line">                    USHORT len = <span class="built_in">sizeof</span>(FileBackupPortMessage) + nameLen;</span><br><span class="line">                    <span class="keyword">auto</span> msg = (FileBackupPortMessage*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, len, DRIVER_TAG);</span><br><span class="line">                    <span class="keyword">if</span> (msg) &#123;</span><br><span class="line">                        msg-&gt;FileNameLength = nameLen / <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line">                        <span class="built_in">RtlCopyMemory</span>(msg-&gt;FileName, context-&gt;FileName.Buffer, nameLen); <span class="comment">//复制文件名到缓冲区</span></span><br><span class="line">                        LARGE_INTEGER timeout;</span><br><span class="line">                        timeout.QuadPart = <span class="number">-10000</span> * <span class="number">100</span>;	<span class="comment">// 100msec</span></span><br><span class="line">                        <span class="built_in">FltSendMessage</span>(gFilterHandle, &amp;SendClientPort, msg, len, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line">                        <span class="built_in">ExFreePool</span>(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            context-&gt;Written = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FltReleaseContext</span>(context);</span><br><span class="line">    <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">BackupFile</span><span class="params">(_In_ PUNICODE_STRING FileName, _In_ PCFLT_RELATED_OBJECTS FltObjects)</span> </span>&#123;</span><br><span class="line">    HANDLE hTargetFile = <span class="literal">nullptr</span>; <span class="comment">//目标文件</span></span><br><span class="line">    HANDLE hSourceFile = <span class="literal">nullptr</span>; <span class="comment">//源文件</span></span><br><span class="line">    IO_STATUS_BLOCK ioStatus;</span><br><span class="line">    <span class="keyword">auto</span> status = STATUS_SUCCESS;</span><br><span class="line">    <span class="type">void</span>* buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// get source file size</span></span><br><span class="line">    LARGE_INTEGER fileSize;</span><br><span class="line">    status = <span class="built_in">FsRtlGetFileSize</span>(FltObjects-&gt;FileObject, &amp;fileSize); <span class="comment">//获取文件大小</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status) || fileSize.QuadPart == <span class="number">0</span>) <span class="comment">//大小为0直接跳过</span></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// open source file</span></span><br><span class="line">        OBJECT_ATTRIBUTES sourceFileAttr;</span><br><span class="line">        <span class="built_in">InitializeObjectAttributes</span>(&amp;sourceFileAttr, FileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        status = <span class="built_in">FltCreateFile</span>(FltObjects-&gt;Filter, FltObjects-&gt;Instance, &amp;hSourceFile, FILE_READ_DATA | SYNCHRONIZE, &amp;sourceFileAttr, &amp;ioStatus, <span class="literal">nullptr</span>, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY, <span class="literal">nullptr</span>, <span class="number">0</span>, IO_IGNORE_SHARE_ACCESS_CHECK);	</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// open target file</span></span><br><span class="line">        UNICODE_STRING targetFileName;</span><br><span class="line">        <span class="type">const</span> WCHAR backupStream[] = <span class="string">L&quot;:backup&quot;</span>; <span class="comment">//备份流名</span></span><br><span class="line">        targetFileName.MaximumLength = FileName-&gt;Length + <span class="built_in">sizeof</span>(backupStream);</span><br><span class="line">        targetFileName.Buffer = (WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, targetFileName.MaximumLength, DRIVER_TAG);</span><br><span class="line">        <span class="keyword">if</span> (targetFileName.Buffer == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">        <span class="built_in">RtlCopyUnicodeString</span>(&amp;targetFileName, FileName);</span><br><span class="line">        <span class="built_in">RtlAppendUnicodeToString</span>(&amp;targetFileName, backupStream);</span><br><span class="line">        OBJECT_ATTRIBUTES targetFileAttr;</span><br><span class="line">        <span class="built_in">InitializeObjectAttributes</span>(&amp;targetFileAttr, &amp;targetFileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        status = <span class="built_in">FltCreateFile</span>(FltObjects-&gt;Filter, FltObjects-&gt;Instance, &amp;hTargetFile, GENERIC_WRITE | SYNCHRONIZE, &amp;targetFileAttr, &amp;ioStatus, <span class="literal">nullptr</span>, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//获得目标文件句柄</span></span><br><span class="line">        <span class="built_in">ExFreePool</span>(targetFileName.Buffer);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// allocate buffer for copying purposes</span></span><br><span class="line">        ULONG size = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;	<span class="comment">// 2 MB</span></span><br><span class="line">        buffer = <span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, size, DRIVER_TAG);</span><br><span class="line">        <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">            status = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// loop - read from source, write to target</span></span><br><span class="line">        LARGE_INTEGER offset = &#123; <span class="number">0</span> &#125;;		<span class="comment">// read</span></span><br><span class="line">        LARGE_INTEGER writeOffset = &#123; <span class="number">0</span> &#125;;	<span class="comment">// write</span></span><br><span class="line">        ULONG bytes;</span><br><span class="line">        <span class="keyword">auto</span> saveSize = fileSize;</span><br><span class="line">        <span class="keyword">while</span> (fileSize.QuadPart &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            status = <span class="built_in">ZwReadFile</span>(hSourceFile, <span class="literal">nullptr</span><span class="comment">/*optional KEVENT*/</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span><span class="comment">/*no APC*/</span>, &amp;ioStatus, buffer, (ULONG)<span class="built_in">min</span>((LONGLONG)size, fileSize.QuadPart)<span class="comment">/*# of bytes*/</span>, &amp;offset<span class="comment">/*offset*/</span>, <span class="literal">nullptr</span><span class="comment">/*optional key*/</span>);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            bytes = (ULONG)ioStatus.Information;</span><br><span class="line">            <span class="comment">// write to target file</span></span><br><span class="line">            status = <span class="built_in">ZwWriteFile</span>(hTargetFile<span class="comment">/*target handle*/</span>, <span class="literal">nullptr</span><span class="comment">/*optional KEVENT*/</span>, <span class="literal">nullptr</span><span class="comment">/*APC routine*/</span>, <span class="literal">nullptr</span><span class="comment">/*APC context*/</span>, &amp;ioStatus<span class="comment">/*I/O status result*/</span>, buffer<span class="comment">/*data to write*/</span>, bytes<span class="comment">/*# bytes to write*/</span>, &amp;writeOffset<span class="comment">/*offset*/</span>, <span class="literal">nullptr</span><span class="comment">/*optional key*/</span>);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// update byte count and offsets</span></span><br><span class="line">            offset.QuadPart += bytes;</span><br><span class="line">            writeOffset.QuadPart += bytes;</span><br><span class="line">            fileSize.QuadPart -= bytes;</span><br><span class="line">        &#125;</span><br><span class="line">        FILE_END_OF_FILE_INFORMATION info;</span><br><span class="line">        info.EndOfFile = saveSize;</span><br><span class="line">        <span class="built_in">NT_VERIFY</span>(<span class="built_in">NT_SUCCESS</span>(<span class="built_in">ZwSetInformationFile</span>(hTargetFile, &amp;ioStatus, &amp;info, <span class="built_in">sizeof</span>(info), FileEndOfFileInformation))); <span class="comment">//将目标文件结束指针设为当前偏移</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (buffer)</span><br><span class="line">        <span class="built_in">ExFreePool</span>(buffer);</span><br><span class="line">    <span class="keyword">if</span> (hSourceFile)</span><br><span class="line">        <span class="built_in">FltClose</span>(hSourceFile);</span><br><span class="line">    <span class="keyword">if</span> (hTargetFile)</span><br><span class="line">        <span class="built_in">FltClose</span>(hTargetFile);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户程序关闭文件时，就不用上下文了，此时释放，由此需要清理后回调。IRP_MJ_CLOSE在文件最后一个句柄关闭时调用，由于缓存可能不总是被即使调用。这里用IRP_MJ_CLEANUP，他在文件对象不再被需要了，即使最后一个句柄未关闭时调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FLT_POSTOP_CALLBACK_STATUS <span class="title">FileBackupPostCleanup</span><span class="params">(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID CompletionContext, FLT_POST_OPERATION_FLAGS Flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Flags);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(CompletionContext);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(Data);</span><br><span class="line">    FileContext* context;</span><br><span class="line">    <span class="keyword">auto</span> status = <span class="built_in">FltGetFileContext</span>(FltObjects-&gt;Instance, FltObjects-&gt;FileObject, (PFLT_CONTEXT*)&amp;context); <span class="comment">//获得文件上下文</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status) || context == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="comment">// no context, continue normally</span></span><br><span class="line">        <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">    <span class="keyword">if</span> (context-&gt;FileName.Buffer)</span><br><span class="line">        <span class="built_in">ExFreePool</span>(context-&gt;FileName.Buffer);</span><br><span class="line">    <span class="built_in">FltReleaseContext</span>(context);</span><br><span class="line">    <span class="built_in">FltDeleteContext</span>(context);</span><br><span class="line">    <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恢复备份的工作放到用户模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">wchar_t</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: FileRestore &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// locate the backup stream</span></span><br><span class="line">    <span class="function">std::wstring <span class="title">stream</span><span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">    stream += <span class="string">L&quot;:backup&quot;</span>;</span><br><span class="line">    HANDLE hSource = ::<span class="built_in">CreateFile</span>(stream.<span class="built_in">c_str</span>(), GENERIC_READ, FILE_SHARE_READ, <span class="literal">nullptr</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSource == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Error</span>(<span class="string">&quot;Failed to locate backup&quot;</span>);</span><br><span class="line">    HANDLE hTarget = ::<span class="built_in">CreateFile</span>(argv[<span class="number">1</span>], GENERIC_WRITE, <span class="number">0</span>, <span class="literal">nullptr</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (hTarget == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Error</span>(<span class="string">&quot;Failed to locate file&quot;</span>);</span><br><span class="line">    LARGE_INTEGER size;</span><br><span class="line">    <span class="keyword">if</span> (!::<span class="built_in">GetFileSizeEx</span>(hSource, &amp;size))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Error</span>(<span class="string">&quot;Failed to get file size&quot;</span>);</span><br><span class="line">    ULONG bufferSize = (ULONG)<span class="built_in">min</span>((LONGLONG)<span class="number">1</span> &lt;&lt; <span class="number">21</span>, size.QuadPart);</span><br><span class="line">    <span class="type">void</span>* buffer = <span class="built_in">VirtualAlloc</span>(<span class="literal">nullptr</span>, bufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!buffer)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Error</span>(<span class="string">&quot;Failed to allocate buffer&quot;</span>);</span><br><span class="line">    DWORD bytes;</span><br><span class="line">    <span class="keyword">while</span> (size.QuadPart &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!::<span class="built_in">ReadFile</span>(hSource, buffer, (DWORD)(<span class="built_in">min</span>((LONGLONG)bufferSize, size.QuadPart)), &amp;bytes, <span class="literal">nullptr</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Error</span>(<span class="string">&quot;Failed to read data&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!::<span class="built_in">WriteFile</span>(hTarget, buffer, bytes, &amp;bytes, <span class="literal">nullptr</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Error</span>(<span class="string">&quot;Failed to write data&quot;</span>);</span><br><span class="line">        size.QuadPart -= bytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Restore successful!\n&quot;</span>);</span><br><span class="line">    ::<span class="built_in">CloseHandle</span>(hSource);</span><br><span class="line">    ::<span class="built_in">CloseHandle</span>(hTarget);</span><br><span class="line">    ::<span class="built_in">VirtualFree</span>(buffer, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解决用户模式通信问题。其中<code>DriverEntry</code>例程上文有。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PFLT_PORT FilterPort; <span class="comment">//服务器端口</span></span><br><span class="line">PFLT_PORT SendClientPort; <span class="comment">//客户程序连接端口</span></span><br><span class="line"><span class="comment">//DriverEntry部分略...</span></span><br><span class="line"><span class="function">_Use_decl_annotations_ NTSTATUS <span class="title">PortConnectNotify</span><span class="params">(PFLT_PORT ClientPort, PVOID ServerPortCookie, PVOID ConnectionContext, ULONG SizeOfContext, PVOID* ConnectionPortCookie)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(ServerPortCookie);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(ConnectionContext);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(SizeOfContext);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(ConnectionPortCookie);</span><br><span class="line">    SendClientPort = ClientPort; <span class="comment">//保存端口并返回 只有这里能获取端口</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PortDisconnectNotify</span><span class="params">(PVOID ConnectionCookie)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(ConnectionCookie);</span><br><span class="line">    <span class="built_in">FltCloseClientPort</span>(gFilterHandle, &amp;SendClientPort); <span class="comment">//否则驱动无法卸载</span></span><br><span class="line">    SendClientPort = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里不期望用户模式发送消息 PostMessageNotify回调为空</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FileBackupPortMessage</span> &#123; <span class="comment">//消息结构 驱动与客户程序共用</span></span><br><span class="line">    USHORT FileNameLength; <span class="comment">//文件名常</span></span><br><span class="line">    WCHAR FileName[<span class="number">1</span>]; <span class="comment">//文件名本身</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//FileBackupPreWrite上文有 略...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PortDisconnectNotify</span><span class="params">(PVOID ConnectionCookie)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(ConnectionCookie);</span><br><span class="line">    <span class="built_in">FltCloseClientPort</span>(gFilterHandle, &amp;SendClientPort); <span class="comment">//关闭过滤器通信端口</span></span><br><span class="line">    SendClientPort = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再搞一个客户程序，打开端口并倾听文件备份消息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;..\FileBackup\FileBackupCommon.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;fltlib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleMessage</span><span class="params">(<span class="type">const</span> BYTE* buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> msg = (FileBackupPortMessage*)buffer;</span><br><span class="line">    <span class="function">std::wstring <span class="title">filename</span><span class="params">(msg-&gt;FileName, msg-&gt;FileNameLength)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file backed up: %ws\n&quot;</span>, filename.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hPort;</span><br><span class="line">    <span class="keyword">auto</span> hr = ::<span class="built_in">FilterConnectCommunicationPort</span>(<span class="string">L&quot;\\FileBackupPort&quot;</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, &amp;hPort); <span class="comment">//打开通信端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error connecting to port (HR=0x%08X)\n&quot;</span>, hr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BYTE buffer[<span class="number">1</span> &lt;&lt; <span class="number">12</span>];	<span class="comment">// 4 KB 消息缓冲区</span></span><br><span class="line">    <span class="keyword">auto</span> message = (FILTER_MESSAGE_HEADER*)buffer;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        hr = ::<span class="built_in">FilterGetMessage</span>(hPort, message, <span class="built_in">sizeof</span>(buffer), <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error receiving message (0x%08X)\n&quot;</span>, hr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">HandleMessage</span>(buffer + <span class="built_in">sizeof</span>(FILTER_MESSAGE_HEADER)); <span class="comment">//跳过消息头解析</span></span><br><span class="line">    &#125;</span><br><span class="line">    ::<span class="built_in">CloseHandle</span>(hPort);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io/2024/05/28/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BE%AE%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8/">https://monoceros406.github.io/2024/05/28/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BE%AE%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://monoceros406.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/">逆向工程</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/28/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-Minifilter%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/" title="Windows驱动开发入门-Minifilter示例代码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Windows驱动开发入门-Minifilter示例代码</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/27/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%80%8F%E6%98%8E%E5%8A%A0%E5%AF%86%E6%BA%90%E7%A0%81/" title="Windows驱动开发入门-文件系统透明加密源码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Windows驱动开发入门-文件系统透明加密源码</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/16/Angr%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/" title="Angr做题笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-16</div><div class="title">Angr做题笔记</div></div></a></div><div><a href="/2023/10/29/Angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%AC%94%E8%AE%B0/" title="Angr符号执行笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">Angr符号执行笔记</div></div></a></div><div><a href="/2024/01/13/Artfuscator%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" title="Artfuscator使用方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-13</div><div class="title">Artfuscator使用方法</div></div></a></div><div><a href="/2023/11/09/C-%E7%97%85%E6%AF%92%E6%8A%80%E6%9C%AF/" title="C++病毒技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-09</div><div class="title">C++病毒技术</div></div></a></div><div><a href="/2024/03/10/C-%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="C#逆向常见题型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-10</div><div class="title">C#逆向常见题型</div></div></a></div><div><a href="/2024/01/28/CheatEngine%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="CheatEngine基本操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="title">CheatEngine基本操作</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">智邮普创工作室安全组（退役）/Nepnep联合战队</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://monoceros406.github.io/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哪里排版出锅了请告诉我QwQ  QQ:1295625063</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BE%AE%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">Windows驱动开发入门-文件系统微过滤驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="toc-number">1.1.</span> <span class="toc-text">编程框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E5%85%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">装入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4%E6%B3%A8%E5%86%8C"><span class="toc-number">1.1.2.</span> <span class="toc-text">微文件系统过滤注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E6%B3%A8%E5%86%8C%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">微过滤器注册结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">卸载回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E6%93%8D%E4%BD%9C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.5.</span> <span class="toc-text">预操作回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E6%93%8D%E4%BD%9C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.6.</span> <span class="toc-text">后操作回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.7.</span> <span class="toc-text">其他回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InstanceSetupCallback"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">InstanceSetupCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InstanceQueryTeardownCallback"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">InstanceQueryTeardownCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InstanceTeardownStartCallback"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">InstanceTeardownStartCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InstanceTeardownCompleteCallback"><span class="toc-number">1.1.7.4.</span> <span class="toc-text">InstanceTeardownCompleteCallback</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.1.8.</span> <span class="toc-text">上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E8%AF%B7%E6%B1%82"><span class="toc-number">1.1.9.</span> <span class="toc-text">I&#x2F;O请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minifilter%E4%B8%8E%E5%BA%94%E7%94%A8%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.</span> <span class="toc-text">Minifilter与应用通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E9%80%9A%E4%BF%A1%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text">建立通信端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87DLL%E4%BD%BF%E7%94%A8%E9%80%9A%E4%BF%A1%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">通过DLL使用通信端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E7%BC%96%E5%86%99"><span class="toc-number">1.2.3.</span> <span class="toc-text">应用层的编写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minifilter%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.</span> <span class="toc-text">Minifilter的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">1.3.1.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99INF%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">编写INF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84Minifilter"><span class="toc-number">1.3.3.</span> <span class="toc-text">启动安装后的Minifilter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">1.4.</span> <span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2cmd-exe%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">防cmd.exe删除文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%9F%90%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%96%87%E4%BB%B6%E4%B8%8D%E8%A2%AB%E5%88%A0%E9%99%A4"><span class="toc-number">1.4.2.</span> <span class="toc-text">保护某目录中文件不被删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD"><span class="toc-number">1.4.3.</span> <span class="toc-text">文件备份</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/07/OpenSSL%E5%85%A5%E9%97%A8-%E6%9D%82%E5%87%91%E5%87%BD%E6%95%B0/" title="OpenSSL入门-杂凑函数">OpenSSL入门-杂凑函数</a><time datetime="2024-12-07T13:20:16.000Z" title="发表于 2024-12-07 21:20:16">2024-12-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/05/WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%86%85%E6%A0%B8%E6%9E%9A%E4%B8%BE/" title="WindowsAPI编程核心技术-内核枚举">WindowsAPI编程核心技术-内核枚举</a><time datetime="2024-12-05T01:34:52.000Z" title="发表于 2024-12-05 09:34:52">2024-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/30/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/" title="Windows驱动开发入门-安全进阶">Windows驱动开发入门-安全进阶</a><time datetime="2024-11-30T08:52:59.000Z" title="发表于 2024-11-30 16:52:59">2024-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/29/UEFI%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA/" title="UEFI编程入门-图形与文字显示">UEFI编程入门-图形与文字显示</a><time datetime="2024-11-29T00:55:25.000Z" title="发表于 2024-11-29 08:55:25">2024-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/" title="机器学习入门">机器学习入门</a><time datetime="2024-11-28T07:06:20.000Z" title="发表于 2024-11-28 15:06:20">2024-11-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>