<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WindowsAPI查缺补漏-文件驱动器目录 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="WindowsAPI查缺补漏-文件驱动器目录碎碎念硬盘容量&#x3D;柱面数（磁道数）*磁头数（盘面数）*每磁道扇区数*每扇区字节数。 目录SetCurrentDirectory设置当前目录： 123BOOL SetCurrentDirectory(	LPCTSTR lpPathName)  GetCurrentDirectory获取当前目录： 1234DWORD GetCurrentDirect">
<meta property="og:type" content="article">
<meta property="og:title" content="WindowsAPI查缺补漏-文件驱动器目录">
<meta property="og:url" content="http://monoceros.github.io/2024/06/12/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E6%96%87%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9B%AE%E5%BD%95/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="WindowsAPI查缺补漏-文件驱动器目录碎碎念硬盘容量&#x3D;柱面数（磁道数）*磁头数（盘面数）*每磁道扇区数*每扇区字节数。 目录SetCurrentDirectory设置当前目录： 123BOOL SetCurrentDirectory(	LPCTSTR lpPathName)  GetCurrentDirectory获取当前目录： 1234DWORD GetCurrentDirect">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://monoceros.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-06-12T13:04:28.000Z">
<meta property="article:modified_time" content="2024-07-07T14:30:37.735Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="逆向工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://monoceros.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://monoceros.github.io/2024/06/12/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E6%96%87%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9B%AE%E5%BD%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WindowsAPI查缺补漏-文件驱动器目录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-07 22:30:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">248</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">WindowsAPI查缺补漏-文件驱动器目录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-12T13:04:28.000Z" title="发表于 2024-06-12 21:04:28">2024-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-07T14:30:37.735Z" title="更新于 2024-07-07 22:30:37">2024-07-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="WindowsAPI查缺补漏-文件驱动器目录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="WindowsAPI查缺补漏-文件驱动器目录"><a href="#WindowsAPI查缺补漏-文件驱动器目录" class="headerlink" title="WindowsAPI查缺补漏-文件驱动器目录"></a>WindowsAPI查缺补漏-文件驱动器目录</h1><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>硬盘容量&#x3D;柱面数（磁道数）*磁头数（盘面数）*每磁道扇区数*每扇区字节数。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="SetCurrentDirectory"><a href="#SetCurrentDirectory" class="headerlink" title="SetCurrentDirectory"></a>SetCurrentDirectory</h3><p>设置当前目录：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetCurrentDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCTSTR lpPathName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="GetCurrentDirectory"><a href="#GetCurrentDirectory" class="headerlink" title="GetCurrentDirectory"></a>GetCurrentDirectory</h3><p>获取当前目录：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetCurrentDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD nBufferLength, <span class="comment">//缓冲区大小 单位字符</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPTSTR lpBuffer <span class="comment">//返回当前目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="GetFullPathName"><a href="#GetFullPathName" class="headerlink" title="GetFullPathName"></a>GetFullPathName</h3><p>获取一个文件完整路径：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">GetFullPathName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpFileName, <span class="comment">//文件名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD nBufferLength, <span class="comment">//缓冲区大小 单位字符</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPTSTR lpBuffer, <span class="comment">//返回完整路径文件名</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Outptr_opt_ LPTSTR* lpFilePart <span class="comment">//返回文件名起始地址指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="CreateFile"><a href="#CreateFile" class="headerlink" title="CreateFile"></a>CreateFile</h3><p>创建或打开文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpFileName, <span class="comment">//要创建或打开的文件名称字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwDesiredAccess, <span class="comment">//文件访问权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwShareMode, <span class="comment">//文件共享模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPSECURITY_ATTRIBUTES lpSecruityAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwCreationDisposition, <span class="comment">//创建或打开标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwFlagsAndAttributes, <span class="comment">//文件标志和系统属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ HANDLE hTemplateFile <span class="comment">//模板文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">//成功返回文件对象句柄 失败返回INVALID_HANDLE_VALUE</span></span></span><br></pre></td></tr></table></figure>

<p>对于lpFileName参数，ANSI路径名限制MAX_PATH个字符，Unicode版本路径名称字符串限制为32767个字符。</p>
<p>对于dwDesiredAccess参数，指定对文件的访问权限，有GENERICE_WRITE和GENERIC_READ。</p>
<p>对于dwShareMode参数，表示文件在被打开后是否允许其他进程或线程再次打开文件：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>独占文件，不允许被再次打开</td>
</tr>
<tr>
<td>FILE_SHARE_READ</td>
<td>允许读</td>
</tr>
<tr>
<td>FILE_SHARE_WRITE</td>
<td>允许写</td>
</tr>
<tr>
<td>FILE_SHARE_DELETE</td>
<td>允许删除</td>
</tr>
</tbody></table>
<p>对于dwCreationDisposition参数，决定文件已经存在或不存在所采取的操作，用<code>GetLastError</code>获取错误码。</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CREATE_NEW</td>
<td>文件不存在时创建一个新文件。已存在则失败，错误码ERROR_FILE_EXISTS</td>
</tr>
<tr>
<td>CREATE_ALWAYS</td>
<td>始终创建新文件。成功创建错误码0。已存在但不可写则清空并覆盖，错误码ERROR_ALREADY_EXISTS</td>
</tr>
<tr>
<td>OPEN_EXISTING</td>
<td>仅打开已存在文件。不存在失败，错误码ERROR_FILE_NOT_FOUND</td>
</tr>
<tr>
<td>OPEN_ALWAYS</td>
<td>始终打开文件。已存在成功，错误码ERROR_ALREADY_EXISTS。有效路径不存在则创建且成功，错误码0</td>
</tr>
<tr>
<td>TRUNCATE_EXISTING</td>
<td>打开文件并截断，存在时使其大小为0。不存在则失败，错误码ERROR_FILE_NOT_FOUND</td>
</tr>
</tbody></table>
<p>对于dwFlagsAndAttributes参数，分为文件标志和系统属性，文件标志：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_ATTRIBUTE_NORMAL</td>
<td>普通文件</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_READONLY</td>
<td>只读</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_HIDDEN</td>
<td>隐藏</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_SYSTEM</td>
<td>操作系统文件</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_ARCHIVE</td>
<td>待备份&#x2F;删除</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_TEMPORARY</td>
<td>临时存储，尽量在内存中，不久将删除</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_ENCRYPTED</td>
<td>已加密</td>
</tr>
</tbody></table>
<p>文件标志：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_FLAG_DELETE_ON_CLOSE</td>
<td>关闭句柄后立刻删除文件</td>
</tr>
<tr>
<td>FILE_FLAG_OVERLAPPED</td>
<td>异步I&#x2F;O</td>
</tr>
<tr>
<td>FILE_FLAG_NO_BUFFERING</td>
<td>写操作不用系统缓存</td>
</tr>
<tr>
<td>FILE_FLAG_WRITE_THROUGH</td>
<td>写操作不通过中间缓存，修改直接写入硬盘</td>
</tr>
</tbody></table>
<p>打开已经存在的文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hFile;</span><br><span class="line">hFile = <span class="built_in">CreateFile</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;D:\\Test.txt&quot;</span>), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">	<span class="comment">//函数调用失败</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新建文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hFile = <span class="built_in">CreateFile</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;D:\\Test.txt&quot;</span>), GENERIC_READ | GENERIC_WRTIE, FILE_SHARE_READ, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">	<span class="comment">//函数调用失败</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关闭文件对象句柄用<code>CloseHandle</code>。</p>
<h3 id="ReadFile"><a href="#ReadFile" class="headerlink" title="ReadFile"></a>ReadFile</h3><p>从指定文件读取数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hFile, <span class="comment">//文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPVOID lpBuffer, <span class="comment">//接收文件数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD nNumberOfBytesToRead, <span class="comment">//要读取的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPDWORD lpNumberOfBytesRead, <span class="comment">//实际读到的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ LPOVERLAPPED lpOverlapped <span class="comment">//异步文件操作 不用就NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">//成功TRUE 失败FALSE</span></span></span><br></pre></td></tr></table></figure>

<p>当还没读完nNumberOfBytesToRead时读到文件尾，则返回TRUE，但*lpNumberOfBytesRead为0，通过这个判断是否读到文件末尾。</p>
<p>使用异步I&#x2F;O时，<code>CreateFile</code>的dwFlagsAndAttributes应指定FILE_FLAG_OVERLAPPED。</p>
<h3 id="WriteFile"><a href="#WriteFile" class="headerlink" title="WriteFile"></a>WriteFile</h3><p>向指定文件写入数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hFIle, <span class="comment">//文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCVOID lpBuffer, <span class="comment">//要写入文件的数据缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD nNumberOfBytesToWrite, <span class="comment">//要写入字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPDWORD lpNumberOfBytesWritten, <span class="comment">//返回成功写入字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ LPOVERLAPPED lpOverlapped <span class="comment">//异步用 不用NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="FlushFileBuffers"><a href="#FlushFileBuffers" class="headerlink" title="FlushFileBuffers"></a>FlushFileBuffers</h3><p>用<code>WriteFile</code>写入文件时，写入的数据可能只保存在高速缓存里。为保证所有数据正确写入硬盘，需要用<code>CloseHandle</code>关闭文件句柄，或用这个函数。但把关键数据即时写入硬盘可能需要多次调用这个函数，所以最好是在<code>CreateFile</code>时指定FILE_FLAG_NO_BUFFERING和FILE_FLAG_WRITE_THROUGH标志。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">FlushFileBuffers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hFile</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="SetFilePointerEx"><a href="#SetFilePointerEx" class="headerlink" title="SetFilePointerEx"></a>SetFilePointerEx</h3><p>调整文件指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">SetFilePointerEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hFile, <span class="comment">//文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LARGE_INTEGER liDistanceToMove, <span class="comment">//文件指针要移动的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ PLARGE_INTEGER lpNewFilePointer, <span class="comment">//返回新文件指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwMoveMethod <span class="comment">//文件指针移动起点</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>对于dwMoveMethod参数，可以是：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_BEGIN</td>
<td>文件开头</td>
</tr>
<tr>
<td>FILE_CURRENT</td>
<td>文件指针当前位置</td>
</tr>
<tr>
<td>FILE_END</td>
<td>文件末尾</td>
</tr>
</tbody></table>
<p>dwMothMethod指定的位置加上liDistanceToMove就是新文件指针位置，liDistanceToMove正数为向文件尾移动，负数向文件头移动。当从文件尾继续向后移动时，表示拓展文件大小。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TCHAR szStr[] = <span class="built_in">TEXT</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="type">static</span> HANDLE hFile;</span><br><span class="line">LARGE_INTEGER liDistanceToMove = &#123; <span class="number">900</span> &#125;;</span><br><span class="line">LARGE_INTEGER liNewFilePointer;</span><br><span class="line">hFile = <span class="built_in">CreateFile</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;D:\\Test.txt&quot;</span>), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">	<span class="built_in">SetFilePointerEx</span>(hFile, liDistanceToMove, &amp;liNewFilePointer, FILE_END);</span><br><span class="line">	<span class="built_in">WriteFile</span>(hFile, szStr, _tcslen(szStr) * <span class="built_in">sizeof</span>(TCHAR), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要获取当前文件指针时，把liDistanceToMove值设为0，dwMoveMethod设为FILE_CURRENT，从lpNewFilePointer返回当前文件指针。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LARGE_INTEGER liDistanceToMove = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">SetFilePointerEx</span>(hFile, liDistanceToMove, &amp;liNewFilePointer, FILE_CURRENT);</span><br></pre></td></tr></table></figure>

<h3 id="SetEndOfFile"><a href="#SetEndOfFile" class="headerlink" title="SetEndOfFile"></a>SetEndOfFile</h3><p>把文件结尾设置为文件指针当前位置，可实现文件截断或扩展。例如设置文件指针为扩展后的大小，并调用该函数即可扩展文件大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">SetEndOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hFile</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>例如文件大小扩展为8GB：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> HANDLE hFile;</span><br><span class="line">LARGE_INTEGER liDistanceToMove;</span><br><span class="line">liDistanceToMove.QuadPart = (LONGLONG)<span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">LARGE_INTEGER liNewFilePointer;</span><br><span class="line">hFile = <span class="built_in">CreateFile</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;D:\\Test.txt&quot;</span>), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">	<span class="built_in">SetFilePointerEx</span>(hFile, liDistanceToMove, &amp;liNewFilePointer, FILE_BEGIN);</span><br><span class="line">	<span class="built_in">SetEndOfFile</span>(hFile);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><h3 id="GetFileSizeEx"><a href="#GetFileSizeEx" class="headerlink" title="GetFileSizeEx"></a>GetFileSizeEx</h3><p>获取文件大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">GetFileSizeEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE  hFile, <span class="comment">//文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ PLARGE_INTEGER lpFileSize <span class="comment">//返回文件大小字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="GetFileType"><a href="#GetFileType" class="headerlink" title="GetFileType"></a>GetFileType</h3><p>获取文件类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">GetFileType</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hFile</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_TYPE_UNKNOW</td>
<td>未知文件类型或调用失败。</td>
</tr>
<tr>
<td>FILE_TYPE_DISK</td>
<td>磁盘文件。</td>
</tr>
<tr>
<td>FILE_TYPE_CHAR</td>
<td>字符文件如LPT设备或控制台。</td>
</tr>
<tr>
<td>FILE_TYPE_PIPE</td>
<td>套接字、命名管道或匿名管道。</td>
</tr>
</tbody></table>
<h3 id="GetFileTime"><a href="#GetFileTime" class="headerlink" title="GetFileTime"></a>GetFileTime</h3><p>获取文件创建&#x2F;最后访问&#x2F;最后修改时间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetFileTime</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPFILETIME lpCreationTime, <span class="comment">//文件创建时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPFILETIME lpLastAccessTime, <span class="comment">//最后访问时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPFILETIME lpLastWriteTime <span class="comment">//最后修改时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>FILETIME用<code>FileTimeToSystemTime</code>转为SYSTEMTIME结构，这里不讲。</p>
<h3 id="SetFileTime"><a href="#SetFileTime" class="headerlink" title="SetFileTime"></a>SetFileTime</h3><p>设置文件创建&#x2F;最后访问&#x2F;最后修改时间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">SetFileTime</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ CONST LPFILETIME lpCreationTime, <span class="comment">//文件创建时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ CONST LPFILETIME lpLastAccessTime, <span class="comment">//最后访问时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ CONST LPFILETIME lpLastWriteTime <span class="comment">//最后修改时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>SYSTEMTIME用<code>SystemTimeToFileTime</code>转为FILETIME结构，这里不讲。</p>
<h3 id="GetFileAttributes-SetFileAttributes"><a href="#GetFileAttributes-SetFileAttributes" class="headerlink" title="GetFileAttributes&#x2F;SetFileAttributes"></a>GetFileAttributes&#x2F;SetFileAttributes</h3><p>获取&#x2F;设置文件系统属性，文件系统属性指<code>CreateFile</code>的dwFlagsAndAttributes指定的FILE_ATTRIBUTES_*值。已废弃用<code>GetFileInformationByHandle</code>&#x2F;<code>SetFileInformationByHandle</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">GetFileAttrbutes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">//返回FILE_ATTRIBUTES_*</span></span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">SetFileAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwFileAttributes <span class="comment">//指定FILE_ATTRIBUTES_*</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="GetFileAttributesEx"><a href="#GetFileAttributesEx" class="headerlink" title="GetFileAttributesEx"></a>GetFileAttributesEx</h3><p>比<code>GetFileAttributes</code>更全面，已废弃用<code>GetFileInformationByHandle</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetFileAttributesEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ GET_FILEEX_INFO_LEVELS fInfoLevelId,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPVOID lpFileInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>其中GET_FILEEX_INFO_LEVELS结构如下，只能为GetFileExInfoStandard，且lpFileInformation为WIN32_FILE_ATTRIBUTE_DATA结构指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_GET_FILEEX_INFO_LEVELS</span> &#123;</span><br><span class="line">    GetFileExInfoStandard,</span><br><span class="line">    GetFileExMaxInfoLevel</span><br><span class="line">&#125; GET_FILEEX_INFO_LEVELS;</span><br></pre></td></tr></table></figure>

<p>WIN32_FILE_ATTRIBUTES_DATA结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WIN32_FILE_ATTRIBUTE_DATA</span> &#123;</span><br><span class="line">    DWORD dwFileAttributes; <span class="comment">//文件系统属性信息 FILE_ATTRIBUTE_*值的组合</span></span><br><span class="line">    FILETIME ftCreationTime; <span class="comment">//文件创建时间</span></span><br><span class="line">    FILETIME ftLastAccessTime; <span class="comment">//最后访问时间</span></span><br><span class="line">    FILETIME ftLastWriteTime; <span class="comment">//最后修改时间</span></span><br><span class="line">    DWORD nFileSizeHigh; <span class="comment">//文件大小高32位</span></span><br><span class="line">    DWORD nFileSizeLow; <span class="comment">//文件大小低32位</span></span><br><span class="line">&#125; WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;</span><br></pre></td></tr></table></figure>

<h3 id="GetFileInformationByHandle-SetFileInformationByHandle"><a href="#GetFileInformationByHandle-SetFileInformationByHandle" class="headerlink" title="GetFileInformationByHandle&#x2F;SetFileInformationByHandle"></a>GetFileInformationByHandle&#x2F;SetFileInformationByHandle</h3><p>通过文件句柄后去文件属性信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetFileInformationByHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hFile, <span class="comment">//文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPBY_HANDLE_FILE_INFORMATION lpFileInformation <span class="comment">//返回文件信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>BY_HANDLE_FILE_INFORMATION比WIN32_FILE_ATTRIBUTE_DATA多了4个字段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_BY_HANDLE_FILE_INFORMATION</span> &#123;</span><br><span class="line">    DWORD dwFileAttributes;</span><br><span class="line">    FILETIME ftCreationTime;</span><br><span class="line">    FILETIME ftLastAccessTime;</span><br><span class="line">    FILETIME ftLastWriteTime;</span><br><span class="line">    DWORD dwVolumeSerialNumber; <span class="comment">//文件所属卷的序列号</span></span><br><span class="line">    DWORD nFileSizeHigh;</span><br><span class="line">    DWORD nFileSizeLow;</span><br><span class="line">    DWORD nNumberOfLinks; <span class="comment">//指向该文件的连接数</span></span><br><span class="line">    DWORD nFileIndexHigh; <span class="comment">//该文件ID高32位</span></span><br><span class="line">    DWORD nFileIndexLow; <span class="comment">//该文件ID低32位</span></span><br><span class="line">&#125; BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>当为了确定两个打开的文件句柄是否为同一个文件时，要同时比较卷序列号和文件ID，因为不同逻辑卷上可能有相同ID的文件。</p>
<p><code>SetFileInformationByHandle</code>略。</p>
<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><h3 id="CopyFile"><a href="#CopyFile" class="headerlink" title="CopyFile"></a>CopyFile</h3><p>将现有文件复制到新文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CopyFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpExistingFileName, <span class="comment">//源文件名</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpNewFileName, <span class="comment">//目标文件名</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ BOOL bFailIfExists</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>当lpExistingFileName不存在则调用失败，<code>GetLastError</code>返回ERROR_FILE_NOT_FOUND。当bFailIfExists为TRUE且lpNewFileName已经存在则调用失败，<code>GetLastError</code>返回ERROR_FILE_EXISTS。当bFailIfExists为FALSE且lpNewFileName已经存在则覆盖存在文件并成功执行，但如果目标文件有FILE_ATTRIBUTE_HIDDEN或FILE_ATTRIBUTE_READONLY属性则调用失败并<code>GetLastError</code>返回ERROR_ACCESS_DENIED。</p>
<p>已废弃用<code>CopyFileEx</code>。</p>
<h3 id="CopyFileEx"><a href="#CopyFileEx" class="headerlink" title="CopyFileEx"></a>CopyFileEx</h3><p>复制文件。每当一部分复制操作完成时可调用指定的回调函数，在复制期间可以取消正在进行的复制操作，用于复制较大文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CopyFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpExistingFileName, <span class="comment">//源文件名</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpNewFileName, <span class="comment">//目标文件名</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPPROGRESS_ROUTINE lpProgressRoutine, <span class="comment">//回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPVOID lpData, <span class="comment">//回调函数参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPBOOL pbCancel, <span class="comment">//复制操作时当该指针指向的变量为TRUE时取消复制操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwCopyFlags <span class="comment">//如何复制</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>在复制操作过程中如果将pbCancel指向的变量设置为TRUE，则复制操作取消并返回FALSE，<code>GetLastError</code>返回ERROR_REQUEST_ABORTED，并删除目标文件。</p>
<p>dwCopyFlags可以是以下组合：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>COPY_FILE_FAIL_IF_EXISTS</td>
<td>见下。</td>
</tr>
<tr>
<td>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</td>
<td>复制加密文件时，尝试用源文件密钥对目标文件加密，无法完成则用默认密钥对目标文件加密，都不能完成调用失败且<code>GetLastError</code>返回ERROR_ENCRYPTION_FAILED。即使无法加密也依然完成复制操作。</td>
</tr>
<tr>
<td>COPY_FILE_NO_BUFFERING</td>
<td>不使用系统I&#x2F;O缓存，用于传输非常大的文件。</td>
</tr>
</tbody></table>
<p>当lpExistingFileName不存在则调用失败，<code>GetLastError</code>返回ERROR_FILE_NOT_FOUND。当dwCopyFlags指定了COPY_FILE_FAIL_IF_EXISTS且lpNewFileName已经存在则调用失败，<code>GetLastError</code>返回ERROR_FILE_EXISTS。当dwCopyFlags未指定COPY_FILE_FAIL_IF_EXISTS且lpNewFileName已经存在则覆盖存在文件并成功执行，但如果目标文件有FILE_ATTRIBUTE_HIDDEN或FILE_ATTRIBUTE_READONLY属性则调用失败并<code>GetLastError</code>返回ERROR_ACCESS_DENIED。</p>
<p>回调函数格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">CopyProgressRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LARGE_INTEGER TotalFileSize, <span class="comment">//文件总大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LARGE_INTEGER TotalBytesTransferred, <span class="comment">//已传输的字节总数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LARGE_INTEGER StreamSize, <span class="comment">//当前文件流总大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LARGE_INTEGER StreamBytesTransferred, <span class="comment">//流中已传输的字节总数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwStreamNumber, <span class="comment">//流编号</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwCallbackReason, <span class="comment">//调用回调函数原因</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hSourceFile, <span class="comment">//源文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hDestinationFile, <span class="comment">//目标文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPVOID lpData <span class="comment">//传递过来的回调函数句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>当文件流已建立并即将开始复制，即首次调用回调函数时dwCallbackReason为CALLBACK_STREAM_SWITCH。完成一部分时dwCallbackReason为CALLBACK_CHUNK_FINISHED，一部分一般是1MB，也可能是64KB。</p>
<p>对于回调函数的返回值，一般返回PROGRESS_CONTINUE表示继续。返回PROGRESS_CANCEL或PROGRESS_STOP时取消复制。返回PROGRESS_QUIET时在以后的复制操作过程中停止调用回调函数。</p>
<h3 id="PathFileExists"><a href="#PathFileExists" class="headerlink" title="PathFileExists"></a>PathFileExists</h3><p>判断目录或文件是否存在：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PathFileExists</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR pszPath</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Shlwapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Shlwapi.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwndDlg;</span><br><span class="line">BOOL g_bCancel = FALSE;     <span class="comment">// 复制操作过程中，如果用户点击了“取消”按钮，设置该变量为TRUE</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 线程函数，创建一个新线程负责复制操作</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span>;</span><br><span class="line"><span class="comment">// CopyFileEx函数的回调函数</span></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">CopyProgressRoutine</span><span class="params">(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred,LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber,DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData)</span></span>;</span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            g_hwndDlg = hwndDlg;</span><br><span class="line">            <span class="comment">// 初始化源文件、目标文件编辑框</span></span><br><span class="line">            <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_SOURCE, <span class="built_in">TEXT</span>(<span class="string">&quot;F:\\Test.rar&quot;</span>));</span><br><span class="line">            <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_TARGET, <span class="built_in">TEXT</span>(<span class="string">&quot;F:\\Downloads\\Test.rar&quot;</span>));</span><br><span class="line">            <span class="comment">// 设置多行编辑控件的缓冲区大小为不限制</span></span><br><span class="line">            <span class="built_in">SendMessage</span>(<span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_PROCESS), EM_SETLIMITTEXT, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_COPY: &#123;</span><br><span class="line">                    <span class="comment">// 创建线程进行复制操作</span></span><br><span class="line">                    <span class="keyword">if</span> ((hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">                        <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_CANCEL: &#123;</span><br><span class="line">                    g_bCancel = TRUE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line">    TCHAR szSource[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR szTarget[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    <span class="built_in">GetDlgItemText</span>(g_hwndDlg, IDC_EDIT_SOURCE, szSource, _countof(szSource));</span><br><span class="line">    <span class="built_in">GetDlgItemText</span>(g_hwndDlg, IDC_EDIT_TARGET, szTarget, _countof(szTarget));</span><br><span class="line">    <span class="comment">// 指定的源文件是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PathFileExists</span>(szSource)) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;指定的源文件不存在！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 指定的目标文件是否已存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PathFileExists</span>(szTarget)) &#123;</span><br><span class="line">        INT nRet = <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;指定的新文件已经存在，是否覆盖目标文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);</span><br><span class="line">        <span class="keyword">switch</span> (nRet) &#123;</span><br><span class="line">            <span class="keyword">case</span> IDOK: &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    bRet = <span class="built_in">CopyFileEx</span>(szSource, szTarget, CopyProgressRoutine, <span class="literal">NULL</span>, &amp;g_bCancel, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bRet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_REQUEST_ABORTED)</span><br><span class="line">            <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;用户取消了复制操作，线程函数返回&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;已取消&quot;</span>), MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;已经成功复制了文件，线程函数返回&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;已成功&quot;</span>), MB_OK);</span><br><span class="line">    g_bCancel = FALSE;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">CopyProgressRoutine</span><span class="params">(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData)</span> </span>&#123;</span><br><span class="line">    HWND hwndEdit = <span class="built_in">GetDlgItem</span>(g_hwndDlg, IDC_EDIT_PROCESS);</span><br><span class="line">    TCHAR szBuf[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 实时显示复制进度</span></span><br><span class="line">    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;文件总大小：%I64X\t已传输：%I64X\t文件流总大小：%I64X\t已传输：%I64X\t流编号：%d\t\n&quot;</span>), TotalFileSize.QuadPart, TotalBytesTransferred.QuadPart, StreamSize.QuadPart, StreamBytesTransferred.QuadPart, dwStreamNumber);</span><br><span class="line">    <span class="built_in">SendMessage</span>(hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">SendMessage</span>(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">    <span class="comment">// 继续复制操作</span></span><br><span class="line">    <span class="keyword">return</span> PROGRESS_CONTINUE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="移动与删除"><a href="#移动与删除" class="headerlink" title="移动与删除"></a>移动与删除</h2><h3 id="MoveFile"><a href="#MoveFile" class="headerlink" title="MoveFile"></a>MoveFile</h3><p>移动一个文件或目录，已废弃用<code>MoveFileEx</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">MoveFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpExistingFileName, <span class="comment">//源文件/目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpNewFileName <span class="comment">//目标文件/目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>源文件&#x2F;目录不存在则调用失败，<code>GetLastError</code>返回ERROR_FILE_NOT_FOUND。目标文件&#x2F;目录已存在则调用失败，文件时<code>GetLastError</code>返回ERROR_FILE_EXISTS ，目录时返回ERROR_ALREADY_EXISTS。目标目录&#x2F;文件上一层目录不存在时调用失败，<code>GetLastError</code>返回ERROR_PATH_NOT_FOUND。移动目录时必须在同一个逻辑驱动器中，否则调用失败，<code>GetLastError</code>返回ERROR_ACCESS_DENIED。</p>
<h3 id="MoveFileEx"><a href="#MoveFileEx" class="headerlink" title="MoveFileEx"></a>MoveFileEx</h3><p>移动一个文件或目录：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">MoveFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpExistingFileName, <span class="comment">//源文件/目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpNewFileName <span class="comment">//目标文件/目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwFlags <span class="comment">//移动选项标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>源文件&#x2F;目录不存在则调用失败，<code>GetLastError</code>返回ERROR_FILE_NOT_FOUND。目标文件&#x2F;目录已存在则调用失败，文件时<code>GetLastError</code>返回ERROR_FILE_EXISTS ，目录时返回ERROR_ALREADY_EXISTS。目标目录&#x2F;文件上一层目录不存在时调用失败，<code>GetLastError</code>返回ERROR_PATH_NOT_FOUND。默认情况下移动目录&#x2F;文件时必须在同一个逻辑驱动器中，否则调用失败，<code>GetLastError</code>返回ERROR_NOT_SAME_DEVICE。</p>
<p>dwFlags选项：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>MOVEFILE_REPLACE_EXISTING</td>
<td>目标文件存在时覆盖。</td>
</tr>
<tr>
<td>MOVEFILE_COPY_ALLOWED</td>
<td>允许把一个文件移动到其他逻辑驱动器中。</td>
</tr>
<tr>
<td>MOVEFILE_DELAY_UNTIL_REBOOT</td>
<td>下次重启系统后移动文件&#x2F;目录，不能与MOVEFILE_COPY_ALLOWED同时使用。</td>
</tr>
</tbody></table>
<p>对于MOVEFILE_DELAY_UNTIL_REBOOT选项，<code>MoveFileEx</code>向注册表项HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessionManager\PendingFileRenameOperations中添加lpExistingFileName和lpNewFileName，并加上内核“&#x2F;??&#x2F;”前缀。当lpNewFileName指定为NULL时重启系统能够后删除lpExistingFileName。</p>
<h3 id="MoveFileWithProgress"><a href="#MoveFileWithProgress" class="headerlink" title="MoveFileWithProgress"></a>MoveFileWithProgress</h3><p>功能与<code>MoveFileEx</code>相同，指定一个接收进度通知的回调函数，具体同上且略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">MoveFileWithProgress</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpExistingFileName, <span class="comment">//源文件/目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPCTSTR lpNewFileName, <span class="comment">//目标文件/目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPPROGRESS_ROUTINE lpProgressRoutine, <span class="comment">//回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPVOID lpData, <span class="comment">//传递给回调函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwFlags <span class="comment">//移动选项标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="DeleteFile"><a href="#DeleteFile" class="headerlink" title="DeleteFile"></a>DeleteFile</h3><p>删除一个文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DeleteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>删除只读文件时需要用<code>SetFileAttributes</code>删除FILE_ATTRIBUTE_READONLY属性，否则调用失败且<code>GetLastError</code>返回ERROR_ACCESS_DENIED。删除一个处于打开状态的文件时需要先用<code>CloseHandle</code>关闭文件，否则调用失败且<code>GetLastError</code>返回ERROR_SHARING_VIOLATION，但如果<code>CreateFile</code>时指定FILE_SHARE_DELETE则无所谓。</p>
<h2 id="无缓冲I-O"><a href="#无缓冲I-O" class="headerlink" title="无缓冲I&#x2F;O"></a>无缓冲I&#x2F;O</h2><p>使用FILE_FLAG_NO_BUFFERING标志时，读写文件的偏移量必须为扇区大小整数倍，读写的字节数必须是扇区大小的整数倍，缓冲区地址必须是物理扇区大小的整数倍。</p>
<p>机械硬盘物理扇区大小为512字节，固态硬盘为4KB，所以引入逻辑扇区大小的概念。逻辑扇区大小是逻辑寻址单位，物理扇区大小是硬盘原子写入单位。即临时解决兼容性的方案是固态硬盘逻辑扇区为512字节。</p>
<p>一般页面大小大于扇区大小，所以页面对齐的内存也是扇区对齐的。为保证读写文件的缓冲区地址一定是物理扇区大小整数倍，用<code>VirtualAlloc</code>分配缓冲区，该函数保证内存区域起始地址是分配粒度64KB整数倍。</p>
<p>可用<code>GetDiskFreeSpace</code>获取逻辑扇区大小。也可用<code>DeviceIoControl</code>发送IOCTL_DISK_GET_DRIVE_GEOMETRY_EX控制代码获取逻辑扇区大小，发送IOCTL_STORAGE_QUERY_PROPERTY获取物理扇区大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)</span> </span>&#123;</span><br><span class="line">    HANDLE hDevice = INVALID_HANDLE_VALUE;</span><br><span class="line">    DISK_GEOMETRY_EX diskGeometryEx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    STORAGE_PROPERTY_QUERY storagePropertyQuery;</span><br><span class="line">    storagePropertyQuery.PropertyId = StorageAccessAlignmentProperty;</span><br><span class="line">    storagePropertyQuery.QueryType = PropertyStandardQuery;</span><br><span class="line">    STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR saad = &#123; <span class="built_in">sizeof</span>(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR) &#125;;</span><br><span class="line">    DWORD dwBytesReturned;</span><br><span class="line">    TCHAR szBuf[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR szTemp[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 驱动器0的逻辑扇区大小和物理扇区大小</span></span><br><span class="line">    hDevice = <span class="built_in">CreateFile</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;\\\\.\\PhysicalDrive0&quot;</span>), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;diskGeometryEx, <span class="built_in">sizeof</span>(diskGeometryEx), &amp;dwBytesReturned, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_STORAGE_QUERY_PROPERTY, &amp;storagePropertyQuery, <span class="built_in">sizeof</span>(storagePropertyQuery), &amp;saad, <span class="built_in">sizeof</span>(saad), &amp;dwBytesReturned, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">StringCchPrintf</span>(szBuf, _countof(szBuf), <span class="built_in">TEXT</span>(<span class="string">&quot;驱动器0：\r\n逻辑扇区大小：%d\r\n物理扇区大小：%d\r\n\r\n&quot;</span>), diskGeometryEx.Geometry.BytesPerSector, saad.BytesPerPhysicalSector);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 驱动器1的逻辑扇区大小和物理扇区大小</span></span><br><span class="line">    hDevice = INVALID_HANDLE_VALUE;</span><br><span class="line">    diskGeometryEx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    saad = &#123; <span class="built_in">sizeof</span>(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR) &#125;;</span><br><span class="line">    hDevice = <span class="built_in">CreateFile</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;\\\\.\\PhysicalDrive1&quot;</span>), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;diskGeometryEx, <span class="built_in">sizeof</span>(diskGeometryEx), &amp;dwBytesReturned, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_STORAGE_QUERY_PROPERTY, &amp;storagePropertyQuery, <span class="built_in">sizeof</span>(storagePropertyQuery), &amp;saad, <span class="built_in">sizeof</span>(saad), &amp;dwBytesReturned, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">StringCchPrintf</span>(szTemp, _countof(szTemp), <span class="built_in">TEXT</span>(<span class="string">&quot;驱动器1：\r\n逻辑扇区大小：%d\r\n物理扇区大小：%d\r\n\r\n&quot;</span>), diskGeometryEx.Geometry.BytesPerSector, saad.BytesPerPhysicalSector);</span><br><span class="line">        <span class="built_in">StringCchCat</span>(szBuf, _countof(szBuf), szTemp);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;驱动器扇区大小&quot;</span>), MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中各结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_DISK_GEOMETRY_EX</span> &#123;</span><br><span class="line">    DISK_GEOMETRY Geometry;     <span class="comment">// DISK_GEOMETRY结构</span></span><br><span class="line">    LARGE_INTEGER DiskSize;     <span class="comment">// 硬盘大小，以字节为单位</span></span><br><span class="line">    BYTE  Data[<span class="number">1</span>];              <span class="comment">// 附加数据</span></span><br><span class="line">&#125; DISK_GEOMETRY_EX, * PDISK_GEOMETRY_EX;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__WRAPPED__</span> _DISK_GEOMETRY &#123;</span><br><span class="line">    LARGE_INTEGER Cylinders;            <span class="comment">// 柱面数</span></span><br><span class="line">    MEDIA_TYPE MediaType;               <span class="comment">// 设备类型，枚举值，例如软盘、硬盘、U盘等</span></span><br><span class="line">    DWORD TracksPerCylinder;            <span class="comment">// 磁头数(盘面数)</span></span><br><span class="line">    DWORD SectorsPerTrack;              <span class="comment">// 每磁道扇区数</span></span><br><span class="line">    DWORD BytesPerSector;               <span class="comment">// 每扇区字节数</span></span><br><span class="line">&#125; DISK_GEOMETRY, * PDISK_GEOMETRY;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR</span> &#123;</span><br><span class="line">    DWORD Version;                      <span class="comment">// 该结构的大小</span></span><br><span class="line">    DWORD Size;                         <span class="comment">// 返回的数据大小</span></span><br><span class="line">    DWORD BytesPerCacheLine;            <span class="comment">// </span></span><br><span class="line">    DWORD BytesOffsetForCacheAlignment; <span class="comment">// </span></span><br><span class="line">    DWORD BytesPerLogicalSector;        <span class="comment">// 每逻辑扇区字节数</span></span><br><span class="line">    DWORD BytesPerPhysicalSector;       <span class="comment">// 每物理扇区字节数</span></span><br><span class="line">    DWORD BytesOffsetForSectorAlignment;<span class="comment">// </span></span><br><span class="line">&#125; STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR, * PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑驱动器和目录"><a href="#逻辑驱动器和目录" class="headerlink" title="逻辑驱动器和目录"></a>逻辑驱动器和目录</h2><h3 id="SetVolumeLabel"><a href="#SetVolumeLabel" class="headerlink" title="SetVolumeLabel"></a>SetVolumeLabel</h3><p>为一个卷（逻辑驱动器）设置卷标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">SetVolumeLabel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPCTSTR lpRootPathName, <span class="comment">//逻辑驱动器根目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPCTSTR lpVolumeName <span class="comment">//新卷标名称 最大32字符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetVolumeLabel</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;C:\\&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;系统&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="GetVolumeInformation"><a href="#GetVolumeInformation" class="headerlink" title="GetVolumeInformation"></a>GetVolumeInformation</h3><p>获取一个逻辑驱动器详细信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetVolumeInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPCTSTR lpRootPathName, <span class="comment">//逻辑驱动器根目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPTSTR lpVolumeNameBuffer, <span class="comment">//返回卷标名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD nVolumeNameSize, <span class="comment">//卷标名称缓冲区大小 单位字符</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPDWORD lpVolumeSerialNumber, <span class="comment">//卷序列号</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPDWORD lpMaximumComponentLength, <span class="comment">//文件系统支持的最大文件组名长度 通常255</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPDWORD lpFileSystemFlags, <span class="comment">//某些文件系统标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPTSTR lpFileSystemNameBuffer, <span class="comment">//文件系统名称缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD nFileSystemNameSize <span class="comment">//文件系统名称缓冲区大小 单位字符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>卷序列号是格式化硬盘时系统分配的一个序号，每次格式化后都可能变。不变的是硬盘制造商分配的硬盘序列号。</p>
<p>文件组名长度即完整路径文件名中以反斜杠分割的每一部分。</p>
<p>lpFileSystemFlags常用标志：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_CASE_SENSITIVE_SEARCH</td>
<td>支持区分大小写</td>
</tr>
<tr>
<td>FILE_CASE_PRESERVED_NAMES</td>
<td>保存文件&#x2F;目录时保留大小写</td>
</tr>
<tr>
<td>FILE_UNICODE_ON_DISK</td>
<td>文件名支持Unicode</td>
</tr>
<tr>
<td>FILE_FILE_COMPRESSION</td>
<td>支持文件压缩</td>
</tr>
<tr>
<td>FILE_SUPPORTS_ENCRYPTION</td>
<td>支持文件加密</td>
</tr>
<tr>
<td>FILE_READ_ONLY_VOLUME</td>
<td>只读</td>
</tr>
<tr>
<td>FILE_VOLUME_IS_COMPRESSED</td>
<td>压缩卷</td>
</tr>
</tbody></table>
<p>lpFileSystemNameBuffer可能返回FAT32、NTFS、ReFS等。</p>
<h3 id="GetLogicalDrives"><a href="#GetLogicalDrives" class="headerlink" title="GetLogicalDrives"></a>GetLogicalDrives</h3><p>获取系统中所有可用的逻辑驱动器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">GetLogicalDrives</span><span class="params">(VOID)</span></span>; <span class="comment">//返回可用逻辑驱动器位掩码 失败返回0</span></span><br></pre></td></tr></table></figure>

<p>位0为驱动器A，位1位驱动器B，以此类推。</p>
<h3 id="GetLogicalDriveStrings"><a href="#GetLogicalDriveStrings" class="headerlink" title="GetLogicalDriveStrings"></a>GetLogicalDriveStrings</h3><p>返回字符串类型逻辑驱动器列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">GetLogicalDriveStrings</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD nBufferLength, <span class="comment">//缓冲区大小 单位字符 不好阔终止空字符</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPTSTR lpBuffer <span class="comment">//缓冲区指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">//成功返回缓冲区字符个数</span></span></span><br></pre></td></tr></table></figure>

<p>一般第一次调用时nBufferLength位0，lpBuffer为NULL，返回所需缓冲区大小，包括终止空字符，分配合适大小后第二次调用。</p>
<h3 id="GetDriveType"><a href="#GetDriveType" class="headerlink" title="GetDriveType"></a>GetDriveType</h3><p>确定逻辑驱动器类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT WINAPI <span class="title">GetDriveType</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPCTSTR lpRootPathName <span class="comment">//根目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DRIVE_UNKNOW</td>
<td>无法确定</td>
</tr>
<tr>
<td>DRIVE_NO_ROOT_DIR</td>
<td>lpRootPathName无效</td>
</tr>
<tr>
<td>DRIVE_REMOVABLE</td>
<td>可移动介质如U盘</td>
</tr>
<tr>
<td>DRIVE_FIXED</td>
<td>固定介质如固态&#x2F;可移动硬盘</td>
</tr>
<tr>
<td>DRIVE_REMOTE</td>
<td>远程（网络）驱动器</td>
</tr>
<tr>
<td>DRIVE_CDROM</td>
<td>CD-ROM光盘驱动器</td>
</tr>
<tr>
<td>DRIVE_RAMDISK</td>
<td>RAM磁盘</td>
</tr>
</tbody></table>
<h3 id="GetDiskFreeSpace"><a href="#GetDiskFreeSpace" class="headerlink" title="GetDiskFreeSpace"></a>GetDiskFreeSpace</h3><p>获取一个逻辑驱动器总容量或空闲磁盘空间，已废弃用<code>GetDiskFreeSpaceEx</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetDiskFreeSpace</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpRootPathName, <span class="comment">//逻辑驱动器根目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPDWORD lpSectorsPerCluster, <span class="comment">//每簇扇区数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPDWORD lpBytesPerSector, <span class="comment">//每扇区字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPDWORD lpNumberOfFreeClusters, <span class="comment">//空闲簇总数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPDWORD lpTotalNumberOfClusters <span class="comment">//簇总数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"><span class="comment">//驱动器总容量为簇总数*每簇扇区数*每扇区字节数</span></span></span><br><span class="line"><span class="function"><span class="comment">//空闲磁盘空间为空闲簇总数*每簇扇区数*每扇区字节数</span></span></span><br></pre></td></tr></table></figure>

<h3 id="GetDiskFreeSpaceEx"><a href="#GetDiskFreeSpaceEx" class="headerlink" title="GetDiskFreeSpaceEx"></a>GetDiskFreeSpaceEx</h3><p>解决<code>GetDiskFreeSpace</code>计算麻烦的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetDiskFreeSpaceEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPCTSTR lpDirectoryName, <span class="comment">//驱动器根目录/子目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ PULARGE_INTEGER lpFreeBytesAvailable, <span class="comment">//空闲磁盘空间</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ PULARGE_INTEGER lpTotalNumberOfBytes, <span class="comment">//驱动器总容量</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ PULARGE_INTEGER lpTotalNumberOfFreeBytes <span class="comment">//空闲磁盘空间</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="CreateDirectory"><a href="#CreateDirectory" class="headerlink" title="CreateDirectory"></a>CreateDirectory</h3><p>创建一个目录：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CreateDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpPathName, <span class="comment">//要创建的目录名</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes <span class="comment">//安全属性结构</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>指定的目录已存在则调用失败，<code>GetLastError</code>返回ERROR_ALREADY_EXISTS。当将被创建的目录名与该目录下已有文件名重名时调用失败，<code>GetLastError</code>返回ERROR_ALREADY_EXISTS。上层目录中有不存在的调用失败，<code>GetLastError</code>返回ERROR_PATH_NOT_FOUND。</p>
<h3 id="RemoveDirectory"><a href="#RemoveDirectory" class="headerlink" title="RemoveDirectory"></a>RemoveDirectory</h3><p>删除一个目录：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">RemoveDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpPathName <span class="comment">//要删除的目录名</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>删除的不是空目录时调用失败，<code>GetLastError</code>返回ERROR_DIR_NOT_EMPTY。注意这是直接删除而不是移动到回收站。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>创建和删除目录，当上级目录不存在时自动创建，当删除的目录不为空时递归删除：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建目录</span></span><br><span class="line"><span class="function">BOOL <span class="title">MyCreateDirectory</span><span class="params">(LPTSTR lpPathName)</span> </span>&#123;</span><br><span class="line">    TCHAR szBuf[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LPTSTR lp;</span><br><span class="line">    <span class="comment">// 首先判断目录是否已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PathFileExists</span>(lpPathName))</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="comment">// 如果是这样F:\Downloads\Web\JavaWeb\末尾有一个\反斜杠，则去掉</span></span><br><span class="line">    <span class="keyword">if</span> (lpPathName[_tcslen(lpPathName) - <span class="number">1</span>] == <span class="built_in">TEXT</span>(<span class="string">&#x27;\\&#x27;</span>))</span><br><span class="line">        lpPathName[_tcslen(lpPathName) - <span class="number">1</span>] = <span class="built_in">TEXT</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="comment">// 递归创建上一级目录</span></span><br><span class="line">    lp = _tcsrchr(lpPathName, <span class="built_in">TEXT</span>(<span class="string">&#x27;\\&#x27;</span>));</span><br><span class="line">    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; lp - lpPathName; i++)</span><br><span class="line">        szBuf[i] = *(lpPathName + i);</span><br><span class="line">    <span class="built_in">MyCreateDirectory</span>(szBuf);</span><br><span class="line">    <span class="comment">// 创建相应的目录</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CreateDirectory</span>(lpPathName, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 删除目录</span></span><br><span class="line"><span class="function">BOOL <span class="title">MyRemoveDirectory</span><span class="params">(LPTSTR lpPathName)</span> </span>&#123;</span><br><span class="line">    TCHAR szDirectory[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR szSearch[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR szDirFile[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE hFindFile;</span><br><span class="line">    WIN32_FIND_DATA fd = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 如果路径结尾没有\则添加一个</span></span><br><span class="line">    <span class="built_in">StringCchCopy</span>(szDirectory, _countof(szDirectory), lpPathName);</span><br><span class="line">    <span class="keyword">if</span> (szDirectory[_tcslen(szDirectory) - <span class="number">1</span>] != <span class="built_in">TEXT</span>(<span class="string">&#x27;\\&#x27;</span>))</span><br><span class="line">        <span class="built_in">StringCchCat</span>(szDirectory, _countof(szDirectory), <span class="built_in">TEXT</span>(<span class="string">&quot;\\&quot;</span>));</span><br><span class="line">    <span class="comment">// 拼接搜索字符串</span></span><br><span class="line">    <span class="built_in">StringCchCopy</span>(szSearch, _countof(szSearch), szDirectory);</span><br><span class="line">    <span class="built_in">StringCchCat</span>(szSearch, _countof(szSearch), <span class="built_in">TEXT</span>(<span class="string">&quot;*.*&quot;</span>));</span><br><span class="line">    <span class="comment">// 递归遍历目录</span></span><br><span class="line">    hFindFile = <span class="built_in">FindFirstFile</span>(szSearch, &amp;fd);</span><br><span class="line">    <span class="keyword">if</span> (hFindFile != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是代表当前目录的.或者代表上一级目录的..则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (_tcscmp(fd.cFileName, <span class="built_in">TEXT</span>(<span class="string">&quot;.&quot;</span>)) == <span class="number">0</span> || _tcscmp(fd.cFileName, <span class="built_in">TEXT</span>(<span class="string">&quot;..&quot;</span>)) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 找到的文件或子目录名称</span></span><br><span class="line">            <span class="built_in">StringCchCopy</span>(szDirFile, _countof(szDirFile), szDirectory);</span><br><span class="line">            <span class="built_in">StringCchCat</span>(szDirFile, _countof(szDirFile), fd.cFileName);</span><br><span class="line">            <span class="comment">// 处理本次找到的文件或子目录</span></span><br><span class="line">            <span class="keyword">if</span> (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">                <span class="comment">// 如果是目录，递归调用</span></span><br><span class="line">                <span class="built_in">MyRemoveDirectory</span>(szDirFile);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 删除只读属性</span></span><br><span class="line">                <span class="keyword">if</span> (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY)</span><br><span class="line">                    <span class="built_in">SetFileAttributes</span>(szDirFile, fd.dwFileAttributes &amp; ~FILE_ATTRIBUTE_READONLY);</span><br><span class="line">                <span class="comment">// 删除文件</span></span><br><span class="line">                <span class="built_in">DeleteFile</span>(szDirFile);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">FindNextFile</span>(hFindFile, &amp;fd));</span><br><span class="line">        <span class="comment">// 关闭查找句柄</span></span><br><span class="line">        <span class="built_in">FindClose</span>(hFindFile);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 删除相应的目录</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RemoveDirectory</span>(lpPathName))</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="GetWindowsDirectory"><a href="#GetWindowsDirectory" class="headerlink" title="GetWindowsDirectory"></a>GetWindowsDirectory</h3><p>获取Windows操作系统安装目录，通常是C:\Windows，末尾没有“\”，已废弃用<code>SHGetKnownFolderPath</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">GetWindowsDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPTSTR lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ UINT uSize <span class="comment">//指定缓冲区大小 单位字符 通常MAX_PATH</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">//成功返回复制到缓冲区中字节数 不包含终止空字符 失败返回0</span></span></span><br></pre></td></tr></table></figure>

<h3 id="GetSystemDirectory"><a href="#GetSystemDirectory" class="headerlink" title="GetSystemDirectory"></a>GetSystemDirectory</h3><p>获取系统目录，通常是C:\Windows\system32，末尾没有“\”，已废弃用<code>SHGetKnownFolderPath</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">GetSystemDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPTSTR lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ UINT uSize</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="GetTempPath"><a href="#GetTempPath" class="headerlink" title="GetTempPath"></a>GetTempPath</h3><p>获取临时目录，临时目录在磁盘空间不足时自动删除，通常C:\Users\用户名\AppData\Local\Temp\，末尾有“\”，已废弃用<code>SHGetKnownFolderPath</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">GetTempPath</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ UINT uSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPTSTR lpBuffer</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>该函数按照这个顺序获取临时目录：TMP环境变量、TEMP环境变量、USERPROFILE环境变量、Windows目录。</p>
<h3 id="GetUserName"><a href="#GetUserName" class="headerlink" title="GetUserName"></a>GetUserName</h3><p>获取系统当前登录用户名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetUserName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPTSTR lpBuffer, <span class="comment">//返回用户名的缓冲区 最大字符个数UNLEN</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ LPDWORD lpnSize <span class="comment">//缓冲区大小 单位字符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">//返回复制到缓冲区中字符数 包括终止空字符</span></span></span><br></pre></td></tr></table></figure>

<p>UNLEN在Lmcons.h中定义。</p>
<h3 id="SHGetKnownFolderPath"><a href="#SHGetKnownFolderPath" class="headerlink" title="SHGetKnownFolderPath"></a>SHGetKnownFolderPath</h3><p>获取默写目录完整路径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Shlobj.h&gt;</span></span></span><br><span class="line"><span class="function">HRESULT <span class="title">SHGetKnownFolderPath</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ REFKNOWNFOLDERID rfid, <span class="comment">//通过该GUID指定一个目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwFlags, <span class="comment">//一些标志 一般0</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ HANDLE hToken, <span class="comment">//用户访问令牌 一般NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ PWSTR *ppszPath <span class="comment">//返回完整路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">//成功S_OK 失败E_FAIL或E_INVALIDARG 可用SUCCEEDED宏判断</span></span></span><br></pre></td></tr></table></figure>

<p>GUID指全局唯一标识符，是一个128位&#x2F;16字节的二进制数，格式XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX，它的生成使用网卡MAC、纳秒级时间、芯片ID码等，保证每次生成的GUID永远不会重复，即一个GUID在同一时空所有机器上都是唯一的。</p>
<p>其中REFKNOWNFOLDERID结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REFKNOWNFOLDERID const KNOWNFOLDERID &amp;</span></span><br><span class="line"><span class="keyword">typedef</span> GUID FOLDERTYPEID;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_GUID</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  Data1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> Data2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> Data3;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  Data4[ <span class="number">8</span> ];</span><br><span class="line">&#125; GUID;</span><br></pre></td></tr></table></figure>

<p>常用目录对应的GUID：</p>
<table>
<thead>
<tr>
<th>GUID</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>F38BF404-1D43-42F2-9305-67DE0B28FC23</td>
<td>Windows目录，如C:\Windows</td>
</tr>
<tr>
<td>1AC14E77-20E7-4E5D-B744-2EB1AE5198B7</td>
<td>系统目录，如C:\Windows\system32</td>
</tr>
<tr>
<td>0762D272-C50A-4BB0-A382-697DCD729B80</td>
<td>用户目录，如C:\Users</td>
</tr>
<tr>
<td>5E6C858F-0E22-4760-9AFE-EA3317B67173</td>
<td>当前用户目录，如C:\Users\用户名</td>
</tr>
<tr>
<td>B4BFCC3A-DB2C-424C-B029-7FE99A87C641</td>
<td>用户桌面文件，如C:\Users\用户名\Desktop</td>
</tr>
<tr>
<td>FDD39AD0-238F-46AF-ADB4-6C85480369C7</td>
<td>我的文档，如C:\Users\用户名\Documents</td>
</tr>
<tr>
<td>905E63B6-C1BF-494E-B29C-65B732D3D21A</td>
<td>应用程序安装目录，如C:\Program Files(x86)和C:\Program Files</td>
</tr>
<tr>
<td>62AB5D82-FDC1-4DC3-A9DD-070D1D495D97</td>
<td>所有用户应用程序数据目录，如C:\ProgramData</td>
</tr>
<tr>
<td>F1B32785-6FBA-4</td>
<td>当前用户应用程序数据目录（配置&#x2F;临时文件），如C:\Users\用户名\AppData\Local</td>
</tr>
<tr>
<td>3EB685DB-65F9-4CF6-A03A-E3EF65729F3D</td>
<td>当前用户应用程序数据目录（漫游用户配置文件），如C:\Users\用户名\AppData\Roaming</td>
</tr>
<tr>
<td>8983036C-27C0-404B-8F08-102D10DCFD74</td>
<td>鼠标右键发送到目录，如C:\Users\用户名\AppData\Roaming\Microsoft\Windows\SendTo</td>
</tr>
<tr>
<td>82A5EA35-D9CD-47C5-9629-E15D2F714E6E</td>
<td>所有用户开机自动启动程序目录，如C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</td>
</tr>
<tr>
<td>B97D20BB-F46A-4C97-BA10-5E3608430854</td>
<td>当前用户开机自动启动程序目录，如C:\Users\用户名\AppData\Roadming\Microsoft\Windows\Start Menu\Porgrams\Startup</td>
</tr>
<tr>
<td>374DE290-123F-4565-9164-39C4925E467B</td>
<td>用户下载文件夹，如C:\Users\ 用户名\Downloads</td>
</tr>
<tr>
<td>FD228CB7-AE11-4AE3-864C-16F3910AB8FE</td>
<td>字体文件夹，如C:\Windows\Fonts</td>
</tr>
</tbody></table>
<p>例如获取我的文档目录完整路径：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Rpcdce.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;Rpcrt4.lib&quot;</span>) <span class="comment">//UuidFromString要这俩</span></span></span><br><span class="line">GUID guid;</span><br><span class="line">PWSTR lpPath;</span><br><span class="line">HRESULT hResult;</span><br><span class="line"><span class="built_in">UuidFromString</span>((RPC_WSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;FDD39AD0-238F-46AF-ADB4-6C85480369C7&quot;</span>), &amp;guid); <span class="comment">//也可以直接对guid结构体赋值</span></span><br><span class="line">hResult = <span class="built_in">SHGetKnownFolderPath</span>(guid, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;lpPath);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hResult)) &#123;</span><br><span class="line">	<span class="built_in">MessageBox</span>(hwndDlg, lpPath, <span class="built_in">TEXT</span>(<span class="string">&quot;文档目录完整路径&quot;</span>), MB_OK);</span><br><span class="line">	<span class="built_in">CoTaskMemFree</span>(lpPath);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用<code>CoTaskMemFree</code>释放lpPath：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">CoTaskMemFree</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPVOID pv</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="GetEnvironmentStrings"><a href="#GetEnvironmentStrings" class="headerlink" title="GetEnvironmentStrings"></a>GetEnvironmentStrings</h3><p>获取指向调用进程的环境块的指针。默认情况下，子进程继承父进程环境变量，由命令行启动的程序继承cmd进程的环境变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPTSTR WINAPI <span class="title">GetEnvironmentStrings</span><span class="params">(VOID)</span> <span class="comment">//成功返回指针 失败返回NULL</span></span></span><br></pre></td></tr></table></figure>

<p>环境快中环境变量组个数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Var1=Value1\0</span><br><span class="line">Var2=Value2\0</span><br><span class="line">Var3=Value3\0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> HWND hwndEdit;</span><br><span class="line">    LPTSTR lpEnvironmentStrings;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            hwndEdit = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_ENV);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_LOOK: &#123;</span><br><span class="line">                    <span class="built_in">SetWindowText</span>(hwndEdit, <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">                    lpEnvironmentStrings = <span class="built_in">GetEnvironmentStrings</span>();</span><br><span class="line">                    <span class="keyword">while</span> (lpEnvironmentStrings[<span class="number">0</span>] != <span class="built_in">TEXT</span>(<span class="string">&#x27;\0&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)lpEnvironmentStrings);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">                        lpEnvironmentStrings += _tcslen(lpEnvironmentStrings) + <span class="number">1</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="GetEnvironmentVariable"><a href="#GetEnvironmentVariable" class="headerlink" title="GetEnvironmentVariable"></a>GetEnvironmentVariable</h3><p>获取当前进程指定环境变量的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">GetEnvironmentVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPCTSTR lpName, <span class="comment">//环境变量名</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPTSTR lpBuffer, <span class="comment">//接收环境变量值的缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD nSize <span class="comment">//缓冲区大小 最大32767字符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">//成功返回复制到缓冲区中字符数 不包括终止空字符 失败返回0</span></span></span><br></pre></td></tr></table></figure>

<p>可用两次调用法。</p>
<h3 id="SetEnvironmentVariable"><a href="#SetEnvironmentVariable" class="headerlink" title="SetEnvironmentVariable"></a>SetEnvironmentVariable</h3><p>设置当前进程中指定环境变量的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">SetEnvironmentVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpName, <span class="comment">//环境变量名</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPCTSTR lpValue <span class="comment">//环境变量的值 最大32767字符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>当lpName指定的不存在且lpValue不为NULL，则创建该环境变量。当lpName指定一个环境变量且lpValue为NULL，则删除该环境变量。注意这个函数只更改该进程环境变量，其他进程的不会改变，系统环境变量也不会改变。</p>
<p>系统环境变量与注册表HEKY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment下一一对应，修改系统环境变量可操作注册表，然后广播WM_SETTINGCHANGE消息（lParam为字符串“Environment”），其他应用程序收到该系统信息更改通知。</p>
<h3 id="FreeEnvironmentStrings"><a href="#FreeEnvironmentStrings" class="headerlink" title="FreeEnvironmentStrings"></a>FreeEnvironmentStrings</h3><p>释放环境块；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">FreeEnvironmentStrings</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPTSTR lpszEnvironmentBlock <span class="comment">//当前进程环境块</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ExpandEnvironmentStrings"><a href="#ExpandEnvironmentStrings" class="headerlink" title="ExpandEnvironmentStrings"></a>ExpandEnvironmentStrings</h3><p>展开环境变量字符串，如“%USERPROFILE%”等：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ExpandEnvironmentStrings</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR lpSrc, <span class="comment">//包含环境变量字符串的缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPTSTR lpDst, <span class="comment">//返回展开结果的缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD nSize <span class="comment">//lpDst大小 单位字符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> HWND hwndEdit;</span><br><span class="line">    LPCTSTR lpSrc[] = &#123; <span class="built_in">TEXT</span>(<span class="string">&quot;SystemDrive\t= %SystemDrive%&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;windir\t\t= %windir%&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;TEMP\t\t= %TEMP%&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;ProgramFiles\t= %ProgramFiles%&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;USERNAME\t= %USERNAME%&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;USERPROFILE\t= %USERPROFILE%&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;ALLUSERSPROFILE\t= %ALLUSERSPROFILE%&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;APPDATA\t\t= %APPDATA%&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;LOCALAPPDATA\t= %LOCALAPPDATA%&quot;</span>) &#125;;</span><br><span class="line">    TCHAR szDst[BUFFER_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            hwndEdit = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_ENV);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_LOOK: &#123;</span><br><span class="line">                    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; _countof(lpSrc); i++) &#123;</span><br><span class="line">                        <span class="built_in">ExpandEnvironmentStrings</span>(lpSrc[i], szDst, BUFFER_SIZE);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szDst);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="SHFileOperation"><a href="#SHFileOperation" class="headerlink" title="SHFileOperation"></a>SHFileOperation</h2><p>这函数还蛮重要的，单独拎出来一章记。</p>
<p>用于复制、移动、重命名或删除一个文件或目录。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">SHFileOperation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ LPSHFILEOPSTRUCT lpFileOp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">//成功0 失败非0</span></span></span><br></pre></td></tr></table></figure>

<p>其中SHFILEOPSTRUCT结构包含操作类型和所需信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SHFILEOPSTRUCT</span>&#123;</span><br><span class="line">    HWND            hwnd; <span class="comment">//窗口句柄</span></span><br><span class="line">    UINT            wFunc; <span class="comment">//指定执行哪个操作</span></span><br><span class="line">    PCZZSTR         pFrom; <span class="comment">//源文件/目录名</span></span><br><span class="line">    PCZZSTR         pTo; <span class="comment">//目标文件/目录名</span></span><br><span class="line">    FILEOP_FLAGS    fFlags; <span class="comment">//操作标志</span></span><br><span class="line">    BOOL            fAnyOperationsAborted; <span class="comment">//是否被用户取消</span></span><br><span class="line">    LPVOID          hNameMappings; <span class="comment">//通常NULL</span></span><br><span class="line">    PCTSTR          lpszProgressTitle; <span class="comment">//通常NULL</span></span><br><span class="line">&#125; SHFILEOPSTRUCT, *LPSHFILEOPSTRUCT;</span><br></pre></td></tr></table></figure>

<p>wFunc可以是：FO_COPY复制、FO_MOVE移动、FO_RENAME重命名、FO_DELETE删除。</p>
<p> pFrom和pTo都可以同时指定若干个完整路径名，但每个完整路径名后必须手动添加终止空字符，pTo在复制和移动时不存在时自动创建。</p>
<p>fFlags有些常用设置：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FOF_RENAMEONCOLLISION</td>
<td>目标未知存在同名文件&#x2F;目录时自动指定新文件&#x2F;目录名</td>
</tr>
<tr>
<td>FOF_ALLOWUNDO</td>
<td>删除文件&#x2F;目录时搁回收站</td>
</tr>
<tr>
<td>FOF_MULTIDESTFILES</td>
<td>指定多个源&#x2F;目标文件&#x2F;目录</td>
</tr>
<tr>
<td>FOF_NOCONFIRMMKDIR</td>
<td>需要创建新目录时不弹出对话框提示是否创建</td>
</tr>
<tr>
<td>FOF_SIMPLEPROGRESS</td>
<td>显示一个操作进度对话框，标题为lpszProgressTitle</td>
</tr>
<tr>
<td>FOF_SILENT</td>
<td>不显示操作进度对话框</td>
</tr>
<tr>
<td>FOF_NOERRORUI</td>
<td>发生错误时不弹出对话框</td>
</tr>
<tr>
<td>FOF_NOCONFIRMATION</td>
<td>弹出所有对话框全部答复确定</td>
</tr>
<tr>
<td>FOF_NO_UI</td>
<td>不显示任何对话框</td>
</tr>
</tbody></table>
<p>fAnyOperationsAborted为返回值，当操作在完成前被用户终止则为TRUE，否则FALSE。</p>
<h2 id="监视目录变化"><a href="#监视目录变化" class="headerlink" title="监视目录变化"></a>监视目录变化</h2><h3 id="ReadDirectoryChangesW"><a href="#ReadDirectoryChangesW" class="headerlink" title="ReadDirectoryChangesW"></a>ReadDirectoryChangesW</h3><p>监视一个目录中文件&#x2F;目录变化信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ReadDirectoryChagesW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hDirectory, <span class="comment">//要监视的目录句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPVOID lpBuffer, <span class="comment">//返回目录变化信息的缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD nBufferLength, <span class="comment">//lpBuffer缓冲区大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ BOOL bWatchSubtree, <span class="comment">//TRUE同时监控子目录 FALSE不监控</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwNotifyFilter, <span class="comment">//监视类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPDWORD lpBytesReturned, <span class="comment">//返回写入lpBuffer的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ LPOVERLAPPED lpOverlapped, <span class="comment">//异步操作用</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine <span class="comment">//完成例程指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>对于hDirectory需要获取该目录FILE_LIST_DIRECTORY访问权限。用<code>CreateFile</code>指定FILE_FLAG_BACKUP_SEMANTICS标志来获取一个目录句柄。</p>
<p>lpBuffer返回后被解析为FILE_NOTIFY_INFORMATION结构。</p>
<p>dwNotifyFilter由常用监视类型，对于同步操作，发生指定事件时函数才返回。</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_NOTIFY_CHANGE_FILE_NAME</td>
<td>文件名</td>
</tr>
<tr>
<td>FILE_NOTIFY_CHANGE_DIR_NAME</td>
<td>目录名</td>
</tr>
<tr>
<td>FILE_NOTIFY_CHANGE_ATTRIBTUES</td>
<td>属性</td>
</tr>
<tr>
<td>FILE_NOTIFY_CHANGE_SIZE</td>
<td>大小</td>
</tr>
<tr>
<td>FILE_NOTIFY_CHANGE_LAST_WRITE</td>
<td>最后写入时间</td>
</tr>
<tr>
<td>FILE_NOTIFY_CHANGE_LAST_ACCESS</td>
<td>最后访问时间</td>
</tr>
<tr>
<td>FILE_NOTIFY_CHANGE_CREATION</td>
<td>创建时间</td>
</tr>
<tr>
<td>FILE_NOTIFY_CHANGE_SECURITY</td>
<td>安全描述符</td>
</tr>
</tbody></table>
<p>同步操作时可将lpBuffer信息解析为FILE_NOTIFY_INFORMATION结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FILE_NOTIFY_INFORMATION</span> &#123;</span><br><span class="line">    DWORD NextEntryOffset; <span class="comment">//下一个FILE_NOTIFY_INFORMATION结构偏移地址 只重命名时用</span></span><br><span class="line">    DWORD Action; <span class="comment">//发生变化的类型</span></span><br><span class="line">    DWORD FileNameLength; <span class="comment">//FileName大小 单位字节</span></span><br><span class="line">    WCHAR FileName[<span class="number">1</span>]; <span class="comment">//可变长度文件/目录名 </span></span><br><span class="line">&#125; FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>对于Action字段表示发生变化的类型：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_ACTION_ADDED</td>
<td>新建</td>
</tr>
<tr>
<td>FILE_ACTION_REMOVED</td>
<td>删除</td>
</tr>
<tr>
<td>FILE_ACTION_MODIFIED</td>
<td>时间戳、大小、属性等修改或创建</td>
</tr>
<tr>
<td>FILE_ACTION_RENAMED_OLD_NAME</td>
<td></td>
</tr>
<tr>
<td>FILE_ACTION_RENAMED_NEW_NAME</td>
<td></td>
</tr>
</tbody></table>
<p>对于FILE_ACTION_RENAMED_OLD_NAME，第一个FILE_NOTIFY_INFORMATION的FileName为旧名称。NextEntryOffset指向的结构的FileName为新名称，Action为FILE_ACTION_RENAMED_NEW_NAME。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shlwapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;\&quot;/manifestdependency:type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;*&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Shlwapi.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 自定义消息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_DIRECTORYCHANGES (WM_APP + 1)</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND  g_hwndDlg;</span><br><span class="line">BOOL  g_bStarting;                  <span class="comment">// 工作线程开始、结束标志</span></span><br><span class="line">TCHAR g_szShowChanges[<span class="number">1024</span>];        <span class="comment">// 显示指定目录中文件、子目录变化结果所用的缓冲区</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span>;</span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> HWND hwndEditChanges;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            g_hwndDlg = hwndDlg;</span><br><span class="line">            <span class="comment">// 多行编辑控件窗口句柄</span></span><br><span class="line">            hwndEditChanges = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_CHANGES);</span><br><span class="line">            <span class="comment">// 初始化监视目录编辑框</span></span><br><span class="line">            <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_PATH, <span class="built_in">TEXT</span>(<span class="string">&quot;C:\\&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_START: &#123;</span><br><span class="line">                    <span class="comment">// 创建线程，开始监视目录变化</span></span><br><span class="line">                    g_bStarting = TRUE;</span><br><span class="line">                    hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (hThread)</span><br><span class="line">                        <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_STOP: &#123;</span><br><span class="line">                    g_bStarting = FALSE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_DIRECTORYCHANGES: &#123;</span><br><span class="line">            <span class="comment">// 处理自定义消息，显示g_szShowChanges中的目录变化结果</span></span><br><span class="line">            <span class="built_in">SendMessage</span>(hwndEditChanges, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">SendMessage</span>(hwndEditChanges, EM_REPLACESEL, TRUE, (LPARAM)g_szShowChanges);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line">    TCHAR   szPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;           <span class="comment">// 获取监视目录编辑控件中的路径</span></span><br><span class="line">    HANDLE  hDirectory = INVALID_HANDLE_VALUE;  <span class="comment">// 要监视的目录的句柄</span></span><br><span class="line">    TCHAR   szBuffer[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;             <span class="comment">// 返回目录变化信息的缓冲区</span></span><br><span class="line">    DWORD   dwBytesReturned;                    <span class="comment">// 实际写入到缓冲区的字节数</span></span><br><span class="line">    PFILE_NOTIFY_INFORMATION pFNI, pFNINext;</span><br><span class="line">    TCHAR szFileName[MAX_PATH], szFileNameNew[MAX_PATH];</span><br><span class="line">    <span class="comment">// 清空多行编辑控件</span></span><br><span class="line">    <span class="built_in">SetDlgItemText</span>(g_hwndDlg, IDC_EDIT_CHANGES, <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    <span class="built_in">GetDlgItemText</span>(g_hwndDlg, IDC_EDIT_PATH, szPath, _countof(szPath));</span><br><span class="line">    hDirectory = <span class="built_in">CreateFile</span>(szPath, <span class="comment">/*GENERIC_READ | GENERIC_WRITE | */</span>FILE_LIST_DIRECTORY, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDirectory == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFile函数调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (g_bStarting) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">PathFileExists</span>(szPath)) &#123;</span><br><span class="line">            <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;监视目录文件夹已被删除&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;Error&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 对于同步操作，直到指定目录中的文件、目录发生变化时，ReadDirectoryChangesW函数才返回 因此使用异步操作比较恰当一些</span></span><br><span class="line">        <span class="built_in">ZeroMemory</span>(szBuffer, <span class="built_in">sizeof</span>(szBuffer));</span><br><span class="line">        <span class="built_in">ReadDirectoryChangesW</span>(hDirectory, szBuffer, <span class="built_in">sizeof</span>(szBuffer), TRUE, FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_ATTRIBUTES | FILE_NOTIFY_CHANGE_SIZE | FILE_NOTIFY_CHANGE_LAST_WRITE | FILE_NOTIFY_CHANGE_LAST_ACCESS | FILE_NOTIFY_CHANGE_CREATION | FILE_NOTIFY_CHANGE_SECURITY, &amp;dwBytesReturned, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        pFNI = (PFILE_NOTIFY_INFORMATION)szBuffer;</span><br><span class="line">        <span class="built_in">ZeroMemory</span>(szFileName, <span class="built_in">sizeof</span>(szFileName));</span><br><span class="line">        <span class="built_in">ZeroMemory</span>(szFileNameNew, <span class="built_in">sizeof</span>(szFileNameNew));</span><br><span class="line">        <span class="built_in">memcpy_s</span>(szFileName, <span class="built_in">sizeof</span>(szFileName), pFNI-&gt;FileName, pFNI-&gt;FileNameLength);</span><br><span class="line">        <span class="keyword">if</span> (pFNI-&gt;NextEntryOffset) &#123;</span><br><span class="line">            pFNINext = (PFILE_NOTIFY_INFORMATION)((LPBYTE)pFNI + pFNI-&gt;NextEntryOffset);</span><br><span class="line">            <span class="built_in">memcpy_s</span>(szFileNameNew, <span class="built_in">sizeof</span>(szFileNameNew), pFNINext-&gt;FileName, pFNINext-&gt;FileNameLength);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 工作线程把目录变化结果写入g_szShowChanges中</span></span><br><span class="line">        <span class="built_in">ZeroMemory</span>(g_szShowChanges, <span class="built_in">sizeof</span>(g_szShowChanges));</span><br><span class="line">        <span class="keyword">switch</span> (pFNI-&gt;Action) &#123;</span><br><span class="line">            <span class="keyword">case</span> FILE_ACTION_ADDED: &#123;</span><br><span class="line">                <span class="built_in">wsprintf</span>(g_szShowChanges, <span class="built_in">TEXT</span>(<span class="string">&quot;新建文件、目录：%s\n&quot;</span>), szFileName);</span><br><span class="line">                <span class="built_in">PostMessage</span>(g_hwndDlg, WM_DIRECTORYCHANGES, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">case</span> FILE_ACTION_REMOVED: &#123;</span><br><span class="line">                <span class="built_in">wsprintf</span>(g_szShowChanges, <span class="built_in">TEXT</span>(<span class="string">&quot;删除文件、目录：%s\n&quot;</span>), szFileName);</span><br><span class="line">                <span class="built_in">PostMessage</span>(g_hwndDlg, WM_DIRECTORYCHANGES, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">case</span> FILE_ACTION_MODIFIED: &#123;</span><br><span class="line">                <span class="built_in">wsprintf</span>(g_szShowChanges, <span class="built_in">TEXT</span>(<span class="string">&quot;修改文件、目录：%s\n&quot;</span>), szFileName);</span><br><span class="line">                <span class="built_in">PostMessage</span>(g_hwndDlg, WM_DIRECTORYCHANGES, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">case</span> FILE_ACTION_RENAMED_OLD_NAME: &#123;</span><br><span class="line">                <span class="built_in">wsprintf</span>(g_szShowChanges, <span class="built_in">TEXT</span>(<span class="string">&quot;文件目录重命名：%s  --&gt;  %s\n&quot;</span>),</span><br><span class="line">                    szFileName, szFileNameNew);</span><br><span class="line">                <span class="built_in">PostMessage</span>(g_hwndDlg, WM_DIRECTORYCHANGES, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="获取硬盘序列号"><a href="#获取硬盘序列号" class="headerlink" title="获取硬盘序列号"></a>获取硬盘序列号</h2><h3 id="DeviceIoControl"><a href="#DeviceIoControl" class="headerlink" title="DeviceIoControl"></a>DeviceIoControl</h3><p>向指定设备驱动程序发送指定控制代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DeviceIoControl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hDevice, <span class="comment">//要执行操作的设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwIoControlCode, <span class="comment">//控制代码</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPVOID lpInBuffer, <span class="comment">//输入缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ DWORD nInBufferSize, <span class="comment">//输入缓冲区大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPVOID lpOutBuffer, <span class="comment">//输出缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ DWORD nOutBufferSize, <span class="comment">//输出缓冲区大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPDWORD lpBytesReturned, <span class="comment">//实际返回输出缓冲区字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ LPOVERLAPPED lpOverlapped <span class="comment">//异步操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>hDevice用<code>CreateFile</code>打开句柄，例如逻辑驱动器C为“\\.\C:”，物理驱动器0为“\\.\PhysicalDrive0”。</p>
<p>lpBytesReturned和lpOverlapped不能同时为NULL。</p>
<h4 id="IOCTL-STORAGE-QUERY-PROPERTY"><a href="#IOCTL-STORAGE-QUERY-PROPERTY" class="headerlink" title="IOCTL_STORAGE_QUERY_PROPERTY"></a>IOCTL_STORAGE_QUERY_PROPERTY</h4><p>查询存储设备或适配器属性。lpInBuffer指向STORAGE_PROPERTY_QUERY结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STORAGE_PROPERTY_QUERY</span> &#123;</span><br><span class="line">    STORAGE_PROPERTY_ID PropertyId; <span class="comment">//属性ID</span></span><br><span class="line">    STORAGE_QUERY_TYPE QueryType; <span class="comment">//查询类型</span></span><br><span class="line">    BYTE  AdditionalParameters[<span class="number">1</span>];</span><br><span class="line">&#125; STORAGE_PROPERTY_QUERY, *PSTORAGE_PROPERTY_QUERY;</span><br></pre></td></tr></table></figure>

<p>对于PropertyId有：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
<th>lpOutBuffer对应结构</th>
</tr>
</thead>
<tbody><tr>
<td>StorageDeviceProperty</td>
<td>设备描述符</td>
<td>STORAGE_DEVICE_DESCRIPTOR</td>
</tr>
<tr>
<td>StorageAdapterProperty</td>
<td>适配器描述符</td>
<td>STORAGE_ADAPTER_DESCRIPTOR</td>
</tr>
<tr>
<td>StorageDeviceIdProperty</td>
<td>SCSI重要产品数据页提供的设备ID</td>
<td>STORAGE_DEVICE_ID_DESCRIPTOR</td>
</tr>
<tr>
<td>StorageDeviceUniqueIdProperty</td>
<td>设备唯一ID</td>
<td>STORAGE_DEVICE_UNIQUE_IDENTIFIER</td>
</tr>
<tr>
<td>StorageDeviceWriteCacheProperty</td>
<td>写缓存属性</td>
<td>STORAGE_WRITE_CACHE_PROPERTY</td>
</tr>
<tr>
<td>StorageMiniportProperty</td>
<td>微型端口驱动程序描述符</td>
<td>STORAGE_MINIPORT_DESCRIPTOR</td>
</tr>
</tbody></table>
<p>对于QueryType有：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PropertyStandardQuery</td>
<td>查询相关描述符</td>
</tr>
<tr>
<td>PropertyExistsQuery</td>
<td>驱动程序是否支持指定描述符，lpOutBuffer和nOutBufferSize都为NULL，<code>DeviceIoControl</code>返回TRUE表示支持</td>
</tr>
</tbody></table>
<p>其中重点STORAGE_DEVICE_DESCRIPTOR结构如下，注意输出缓冲区中所有字符串都为ASCII格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _Struct_size_bytes_(Size) <span class="keyword">struct</span> <span class="title class_">_STORAGE_DEVICE_DESCRIPTOR</span> &#123;</span><br><span class="line">    DWORD Version; <span class="comment">//该结构大小 单位字节</span></span><br><span class="line">    DWORD Size; <span class="comment">//描述符总大小 单位字节</span></span><br><span class="line">    BYTE  DeviceType; <span class="comment">//设备类型</span></span><br><span class="line">    BYTE  DeviceTypeModifier; <span class="comment">//设备类型修饰符</span></span><br><span class="line">    BOOLEAN RemovableMedia; <span class="comment">//是否为可移动介质</span></span><br><span class="line">    BOOLEAN CommandQueueing; <span class="comment">//是否支持命令队列</span></span><br><span class="line">    DWORD VendorIdOffset; <span class="comment">//设备供应商ID字符串相对结构开始偏移</span></span><br><span class="line">    DWORD ProductIdOffset; <span class="comment">//设备产品ID字符串相对结构开始偏移</span></span><br><span class="line">    DWORD ProductRevisionOffset; <span class="comment">//设备产品修订版本字符串相对结构开始偏移</span></span><br><span class="line">    DWORD SerialNumberOffset; <span class="comment">//设备序列号字符串相对结构开始偏移</span></span><br><span class="line">    STORAGE_BUS_TYPE BusType; <span class="comment">//设备连接到总线的类型</span></span><br><span class="line">    DWORD RawPropertiesLength; <span class="comment">//总线特定属性数据字符数</span></span><br><span class="line">    BYTE  RawDeviceProperties[<span class="number">1</span>]; <span class="comment">//总线特定属性数据第一字节的占位符</span></span><br><span class="line">&#125; STORAGE_DEVICE_DESCRIPTOR, * PSTORAGE_DEVICE_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>其中STORAGE_BUS_TYPE结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_STORAGE_BUS_TYPE</span> &#123;</span><br><span class="line">    BusTypeUnknown = <span class="number">0x00</span>, <span class="comment">//未知</span></span><br><span class="line">    BusTypeScsi, <span class="comment">//SCSI</span></span><br><span class="line">    BusTypeAtapi, <span class="comment">//ATAPI</span></span><br><span class="line">    BusTypeAta, <span class="comment">//ATA</span></span><br><span class="line">    BusType1394, <span class="comment">//IEEE 1394</span></span><br><span class="line">    BusTypeSsa, <span class="comment">//SSA</span></span><br><span class="line">    BusTypeFibre, <span class="comment">//光纤通道</span></span><br><span class="line">    BusTypeUsb, <span class="comment">//USB</span></span><br><span class="line">    BusTypeRAID, <span class="comment">//RAID</span></span><br><span class="line">    BusTypeiScsi, <span class="comment">//iSCSI</span></span><br><span class="line">    BusTypeSas, <span class="comment">//串行链接的SCSI 即SAS</span></span><br><span class="line">    BusTypeSata, <span class="comment">//SATA</span></span><br><span class="line">    BusTypeSd, <span class="comment">//安全数字SD</span></span><br><span class="line">    BusTypeMmc, <span class="comment">//多媒体卡MMC</span></span><br><span class="line">    BusTypeVirtual, <span class="comment">//虚拟</span></span><br><span class="line">    BusTypeFileBackedVirtual, <span class="comment">//文件支持的虚拟</span></span><br><span class="line">    <span class="comment">//BusTypeSpaces,</span></span><br><span class="line">    <span class="comment">//BusTypeNvme,</span></span><br><span class="line">    <span class="comment">//BusTypeSCM,</span></span><br><span class="line">    <span class="comment">//BusTypeUfs,</span></span><br><span class="line">    BusTypeMax,</span><br><span class="line">    BusTypeMaxReserved = <span class="number">0x7F</span></span><br><span class="line">&#125; STORAGE_BUS_TYPE, * PSTORAGE_BUS_TYPE;</span><br></pre></td></tr></table></figure>

<h4 id="IOCTL-DISK-GET-DRIVE-GEOMETRY-EX"><a href="#IOCTL-DISK-GET-DRIVE-GEOMETRY-EX" class="headerlink" title="IOCTL_DISK_GET_DRIVE_GEOMETRY_EX"></a>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX</h4><p>获取一个物理驱动器大小、磁头数、柱面数等。</p>
<h4 id="SMART-GET-VERSION"><a href="#SMART-GET-VERSION" class="headerlink" title="SMART_GET_VERSION"></a>SMART_GET_VERSION</h4><p>获取磁盘设备是否支持SMART技术，即自我监控、分析和报告技术，可对硬盘温度、内部电路和盘片表面介质材料等进行检测。SMART信息为512字节，存放在硬盘控制内存中，前2字节为SMART版本信息，之后每12字节为一个SMART属性。</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>获取物理驱动器ProductIdOffset产品ID、SerialNumberOffset序列号、BusType设备接口类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)</span></span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> HWND hwndEditInfo;</span><br><span class="line">    TCHAR szDriverName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE hDriver;</span><br><span class="line">    STORAGE_PROPERTY_QUERY storagePropertyQuery;        <span class="comment">// 输入缓冲区</span></span><br><span class="line">    CHAR cOutBuffer[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;                      <span class="comment">// 输出缓冲区</span></span><br><span class="line">    PSTORAGE_DEVICE_DESCRIPTOR pStorageDeviceDesc;</span><br><span class="line">    DWORD dwBytesReturned;</span><br><span class="line">    CHAR szBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LPCSTR arrBusType[] = &#123; <span class="string">&quot;未知的总线类型&quot;</span>, <span class="string">&quot;SCSI总线类型&quot;</span>, <span class="string">&quot;ATAPI总线类型&quot;</span>,<span class="string">&quot;ATA总线类型&quot;</span>, <span class="string">&quot;IEEE 1394总线类型&quot;</span>, <span class="string">&quot;SSA总线类型&quot;</span>,<span class="string">&quot;光纤通道总线类型&quot;</span>, <span class="string">&quot;USB&quot;</span>, <span class="string">&quot;RAID总线类型&quot;</span>,<span class="string">&quot;iSCSI总线类型&quot;</span>, <span class="string">&quot;串行连接的SCSI总线类型&quot;</span>, <span class="string">&quot;SATA&quot;</span>,<span class="string">&quot;安全数字(SD)总线类型&quot;</span>, <span class="string">&quot;多媒体卡(MMC)总线类型&quot;</span>, <span class="string">&quot;虚拟总线类型&quot;</span>,<span class="string">&quot;文件支持的虚拟总线类型&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            hwndEditInfo = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_INFO);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_GETINFO: &#123;</span><br><span class="line">                    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                        <span class="comment">// 打开物理驱动器</span></span><br><span class="line">                        <span class="built_in">wsprintf</span>(szDriverName, <span class="built_in">TEXT</span>(<span class="string">&quot;\\\\.\\PhysicalDrive%d&quot;</span>), i);</span><br><span class="line">                        hDriver = <span class="built_in">CreateFile</span>(szDriverName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">                            <span class="built_in">wsprintfA</span>(szBuf, <span class="string">&quot;打开物理驱动器%d失败！\r\n\r\n&quot;</span>, i);</span><br><span class="line">                            <span class="built_in">SendMessage</span>(hwndEditInfo, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                            <span class="built_in">SendMessageA</span>(hwndEditInfo, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="comment">// 控制代码IOCTL_STORAGE_QUERY_PROPERTY</span></span><br><span class="line">                        <span class="built_in">ZeroMemory</span>(&amp;storagePropertyQuery, <span class="built_in">sizeof</span>(STORAGE_PROPERTY_QUERY));</span><br><span class="line">                        storagePropertyQuery.PropertyId = StorageDeviceProperty;</span><br><span class="line">                        storagePropertyQuery.QueryType = PropertyStandardQuery;</span><br><span class="line">                        <span class="built_in">DeviceIoControl</span>(hDriver, IOCTL_STORAGE_QUERY_PROPERTY, &amp;storagePropertyQuery, <span class="built_in">sizeof</span>(STORAGE_PROPERTY_QUERY), cOutBuffer, <span class="built_in">sizeof</span>(cOutBuffer), &amp;dwBytesReturned, <span class="literal">NULL</span>);</span><br><span class="line">                        pStorageDeviceDesc = (PSTORAGE_DEVICE_DESCRIPTOR)cOutBuffer;</span><br><span class="line">                        <span class="built_in">wsprintfA</span>(szBuf, <span class="string">&quot;物理驱动器%d\r\n产品 ID：\t%s\r\n序列号：\t%s\r\n接口类型：\t%s\r\n\r\n&quot;</span>, i, (LPBYTE)pStorageDeviceDesc + pStorageDeviceDesc-&gt;ProductIdOffset, (LPBYTE)pStorageDeviceDesc + pStorageDeviceDesc-&gt;SerialNumberOffset, arrBusType[pStorageDeviceDesc-&gt;BusType]);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEditInfo, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                        <span class="built_in">SendMessageA</span>(hwndEditInfo, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                        <span class="comment">// 关闭设备句柄</span></span><br><span class="line">                        <span class="built_in">CloseHandle</span>(hDriver);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="WMI管理技术"><a href="#WMI管理技术" class="headerlink" title="WMI管理技术"></a>WMI管理技术</h3><p>WMI可以访问、配置、管理并监视几乎所有Windows资源，所有WMI接口基于COM组件对象模型，这里不建议用WMI获取信息，因为速度慢。</p>
<p>创建WMI应用程序的步骤：</p>
<ol>
<li>初始化COM，因为WMI基于COM技术，所以必须执行对<code>CoInitializeEx</code>和<code>CoInitializeSecurity</code>函数的调用才能访问WMI。</li>
<li>创建到WMI指定命名空间的连接，要创建到WMI指定命名空间的连接，需要首先调用<code>CoCreateInstance</code>函数创建与指定CLSID关联的类的对象，该函数在最后一个参数中返回一个IWbemLocator类对象指针，然后可以通过<code>IWbemLocator::ConnectServer</code>方法连接到WMI指定命名空间，<code>IWbemLocator::ConnectServer</code>在最后一个参数中返回一个IWbemServices类对象指针（代理）。</li>
<li>设置WMI连接的安全级别，获取到IWbemServices代理的指针以后，必须在代理上设置安全性以通过代理访问WMI，如果没有设置适当的安全属性，则COM不允许一个进程访问另一进程，程序可以通过调用<code>CoSetProxyBlanket</code>函数来设置IWbemServices代理上的安全级别，在为IWbemServices代理设置安全级别以后，可以使用WMI提供的各种功能。</li>
<li>访问WMI，例如可以通过<code>IWbemServices::ExecQuery</code>方法执行WQL查询语句，<code>IWbemServices::ExecQuery</code>在最后一个参数中返回一个IEnumWbemClassObject类对象指针（枚举器），程序可以通过该枚举器访问查询结果。</li>
<li>清理工作。</li>
</ol>
<p>如果需要查询其他设备的信息，更改一下<code>IWbemServices::ExecQuery</code>方法的WQL查询语句即可，另外<code>IWbemClassObject::Get</code>方法的第一个参数应该设置为需要获取的字段，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Win32_BaseBoard <span class="keyword">where</span> SerialNumber <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> #获取主板序列号</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Win32_Processor <span class="keyword">where</span> ProcessorId <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> #获取处理器CPUID</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Win32_BIOS <span class="keyword">where</span> SerialNumber <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> #获取BIOS序列号</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Win32_NetworkAdapter <span class="keyword">where</span> MACAddress <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">and</span> <span class="keyword">not</span> (PNPDeviceID <span class="keyword">like</span> <span class="string">&#x27;ROOT%&#x27;</span>) #获取网卡Mac地址</span><br></pre></td></tr></table></figure>

<p>其他的自己查：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/cimwin32prov/computer-system-hardware-classes%E3%80%82">https://docs.microsoft.com/zh-cn/windows/win32/cimwin32prov/computer-system-hardware-classes。</a></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wbemidl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Propvarutil.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;comdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;wbemuuid.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Propsys.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> HWND hwndEditInfo;</span><br><span class="line">    HRESULT hr;</span><br><span class="line">    IWbemLocator* pIWbemLocator = <span class="literal">NULL</span>;</span><br><span class="line">    IWbemServices* pIWbemServices = <span class="literal">NULL</span>;</span><br><span class="line">    IEnumWbemClassObject* pIEnumWbemClassObject = <span class="literal">NULL</span>;</span><br><span class="line">    IWbemClassObject* pIWbemClassObject = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG uReturned = <span class="number">0</span>;</span><br><span class="line">    VARIANT variant;</span><br><span class="line">    TCHAR szBuf[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)&#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            hwndEditInfo = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_INFO);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_GETINFO: &#123;</span><br><span class="line">                    <span class="comment">// 初始化COM</span></span><br><span class="line">                    hr = <span class="built_in">CoInitializeEx</span>(<span class="number">0</span>, COINIT_MULTITHREADED);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr))</span><br><span class="line">                        <span class="keyword">return</span> FALSE;</span><br><span class="line">                    hr = <span class="built_in">CoInitializeSecurity</span>(<span class="literal">NULL</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, <span class="literal">NULL</span>, EOAC_NONE, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">                        <span class="built_in">CoUninitialize</span>();</span><br><span class="line">                        <span class="keyword">return</span> FALSE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 创建到WMI指定命名空间ROOT\CIMV2的连接</span></span><br><span class="line">                    hr = <span class="built_in">CoCreateInstance</span>(CLSID_WbemLocator, <span class="literal">NULL</span>, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&amp;pIWbemLocator);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">                        <span class="built_in">CoUninitialize</span>();</span><br><span class="line">                        <span class="keyword">return</span> FALSE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    hr = pIWbemLocator-&gt;<span class="built_in">ConnectServer</span>((BSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;ROOT\\CIMV2&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;pIWbemServices);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">                        pIWbemLocator-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        <span class="built_in">CoUninitialize</span>();</span><br><span class="line">                        <span class="keyword">return</span> FALSE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 设置WMI连接的安全级别</span></span><br><span class="line">                    hr = <span class="built_in">CoSetProxyBlanket</span>(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, <span class="literal">NULL</span>, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, <span class="literal">NULL</span>, EOAC_NONE);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">                        pIWbemServices-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        pIWbemLocator-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        <span class="built_in">CoUninitialize</span>();</span><br><span class="line">                        <span class="keyword">return</span> FALSE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 访问WMI</span></span><br><span class="line">                    <span class="comment">// 获取硬盘序列号</span></span><br><span class="line">                    hr = pIWbemServices-&gt;<span class="built_in">ExecQuery</span>((BSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;WQL&quot;</span>), (BSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;select * from Win32_DiskDrive where SerialNumber is not null&quot;</span>), WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, <span class="literal">NULL</span>, &amp;pIEnumWbemClassObject);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">                        pIWbemServices-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        pIWbemLocator-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        <span class="built_in">CoUninitialize</span>();</span><br><span class="line">                        <span class="keyword">return</span> FALSE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">while</span> (pIEnumWbemClassObject) &#123;</span><br><span class="line">                        hr = pIEnumWbemClassObject-&gt;<span class="built_in">Next</span>(WBEM_INFINITE, <span class="number">1</span>, &amp;pIWbemClassObject, &amp;uReturned);</span><br><span class="line">                        <span class="keyword">if</span> (uReturned == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        hr = pIWbemClassObject-&gt;<span class="built_in">Get</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;SerialNumber&quot;</span>), <span class="number">0</span>, &amp;variant, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hr)) &#123;</span><br><span class="line">                            <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;硬盘序列号：\t%s\n&quot;</span>), variant.bstrVal);</span><br><span class="line">                            <span class="built_in">SendMessage</span>(hwndEditInfo, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                            <span class="built_in">SendMessage</span>(hwndEditInfo, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                            <span class="built_in">VariantClear</span>(&amp;variant);</span><br><span class="line">                            pIWbemClassObject-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                            pIWbemClassObject = <span class="literal">NULL</span>;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 获取主板序列号</span></span><br><span class="line">                    hr = pIWbemServices-&gt;<span class="built_in">ExecQuery</span>((BSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;WQL&quot;</span>), (BSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;select * from Win32_BaseBoard where SerialNumber is not null&quot;</span>), WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, <span class="literal">NULL</span>, &amp;pIEnumWbemClassObject);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">                        pIWbemServices-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        pIWbemLocator-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        <span class="built_in">CoUninitialize</span>();</span><br><span class="line">                        <span class="keyword">return</span> FALSE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    hr = pIEnumWbemClassObject-&gt;<span class="built_in">Next</span>(WBEM_INFINITE, <span class="number">1</span>, &amp;pIWbemClassObject, &amp;uReturned);</span><br><span class="line">                    <span class="keyword">if</span> (uReturned == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    hr = pIWbemClassObject-&gt;<span class="built_in">Get</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;SerialNumber&quot;</span>), <span class="number">0</span>, &amp;variant, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hr)) &#123;</span><br><span class="line">                        <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;主板序列号：\t%s\n&quot;</span>), variant.bstrVal);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEditInfo, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEditInfo, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                        <span class="built_in">VariantClear</span>(&amp;variant);</span><br><span class="line">                        pIWbemClassObject-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        pIWbemClassObject = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 获取处理器CPUID</span></span><br><span class="line">                    hr = pIWbemServices-&gt;<span class="built_in">ExecQuery</span>((BSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;WQL&quot;</span>), (BSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;select * from Win32_Processor where ProcessorId is not null&quot;</span>), WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, <span class="literal">NULL</span>, &amp;pIEnumWbemClassObject);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">                        pIWbemServices-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        pIWbemLocator-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        <span class="built_in">CoUninitialize</span>();</span><br><span class="line">                        <span class="keyword">return</span> FALSE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    hr = pIEnumWbemClassObject-&gt;<span class="built_in">Next</span>(WBEM_INFINITE, <span class="number">1</span>, &amp;pIWbemClassObject, &amp;uReturned);</span><br><span class="line">                    <span class="keyword">if</span> (uReturned == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    hr = pIWbemClassObject-&gt;<span class="built_in">Get</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;ProcessorId&quot;</span>), <span class="number">0</span>, &amp;variant, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hr)) &#123;</span><br><span class="line">                        <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;CPUID：\t\t%s\n&quot;</span>), variant.bstrVal);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEditInfo, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEditInfo, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                        <span class="built_in">VariantClear</span>(&amp;variant);</span><br><span class="line">                        pIWbemClassObject-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        pIWbemClassObject = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 获取BIOS序列号</span></span><br><span class="line">                    hr = pIWbemServices-&gt;<span class="built_in">ExecQuery</span>((BSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;WQL&quot;</span>), (BSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;select * from Win32_BIOS where SerialNumber is not null&quot;</span>), WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, <span class="literal">NULL</span>, &amp;pIEnumWbemClassObject);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">                        pIWbemServices-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        pIWbemLocator-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        <span class="built_in">CoUninitialize</span>();</span><br><span class="line">                        <span class="keyword">return</span> FALSE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    hr = pIEnumWbemClassObject-&gt;<span class="built_in">Next</span>(WBEM_INFINITE, <span class="number">1</span>, &amp;pIWbemClassObject, &amp;uReturned);</span><br><span class="line">                    <span class="keyword">if</span> (uReturned == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    hr = pIWbemClassObject-&gt;<span class="built_in">Get</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;SerialNumber&quot;</span>), <span class="number">0</span>, &amp;variant, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hr)) &#123;</span><br><span class="line">                        <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;BIOS序列号：\t%s\n&quot;</span>), variant.bstrVal);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEditInfo, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                        <span class="built_in">SendMessage</span>(hwndEditInfo, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                        <span class="built_in">VariantClear</span>(&amp;variant);</span><br><span class="line">                        pIWbemClassObject-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        pIWbemClassObject = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 获取网卡Mac地址</span></span><br><span class="line">                    hr = pIWbemServices-&gt;<span class="built_in">ExecQuery</span>((BSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;WQL&quot;</span>), (BSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;select * from Win32_NetworkAdapter where MACAddress is not null and not (PNPDeviceID like &#x27;ROOT%&#x27;)&quot;</span>), WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, <span class="literal">NULL</span>, &amp;pIEnumWbemClassObject);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">                        pIWbemServices-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        pIWbemLocator-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                        <span class="built_in">CoUninitialize</span>();</span><br><span class="line">                        <span class="keyword">return</span> FALSE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">while</span> (pIEnumWbemClassObject) &#123;</span><br><span class="line">                        hr = pIEnumWbemClassObject-&gt;<span class="built_in">Next</span>(WBEM_INFINITE, <span class="number">1</span>, &amp;pIWbemClassObject, &amp;uReturned);</span><br><span class="line">                        <span class="keyword">if</span> (uReturned == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        hr = pIWbemClassObject-&gt;<span class="built_in">Get</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MACAddress&quot;</span>), <span class="number">0</span>, &amp;variant, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hr)) &#123;</span><br><span class="line">                            <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;MAC地址：\t%s\n&quot;</span>), variant.bstrVal);</span><br><span class="line">                            <span class="built_in">SendMessage</span>(hwndEditInfo, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                            <span class="built_in">SendMessage</span>(hwndEditInfo, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                            <span class="built_in">VariantClear</span>(&amp;variant);</span><br><span class="line">                            pIWbemClassObject-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                            pIWbemClassObject = <span class="literal">NULL</span>;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 清理工作</span></span><br><span class="line">                    pIEnumWbemClassObject-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                    pIWbemServices-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                    pIWbemLocator-&gt;<span class="built_in">Release</span>();</span><br><span class="line">                    <span class="built_in">CoUninitialize</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL:</span><br><span class="line">                <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="可移动硬盘和U盘监控"><a href="#可移动硬盘和U盘监控" class="headerlink" title="可移动硬盘和U盘监控"></a>可移动硬盘和U盘监控</h2><p>当计算机硬件设备或硬件配置发生变化时系统向窗口过程广播WM_DEVICECHANGE消息。其wParam参数常见值有：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DBT_DEVICEARRAIVAL</td>
<td>已插入设备或媒体并现在可用</td>
</tr>
<tr>
<td>DBT_DEVICEQUERYREMOVE</td>
<td>请求删除设备或媒体，任何应用程序可拒绝该请求并删除操作</td>
</tr>
<tr>
<td>DBT_EVICEQUERYREMOVEFAILED</td>
<td>删除设备或媒体的请求已被取消</td>
</tr>
<tr>
<td>DBT_DEVICEREMOVEPENDING</td>
<td>设备或介质将被删除，应用程序无法拒绝</td>
</tr>
<tr>
<td>DBT_DEVICEREMOVECOMPLETE</td>
<td>设备或媒体已被删除</td>
</tr>
<tr>
<td>DBT_DEVICETYPESPECIFIC</td>
<td>发生了特定于设备的事件</td>
</tr>
<tr>
<td>DBT_CUSTOMEVENT</td>
<td>发生了自定义事件</td>
</tr>
<tr>
<td>DBT_USERDEFINED</td>
<td>用户自定义事件</td>
</tr>
</tbody></table>
<p>处理完该消息后返回TRUE表示接收请求，返回BROADCAST_QUERY_DENY表示拒绝请求。这里只关注DBT_DEVICEARRAIVAL或DBT_DEVICEDEVICEMOVECOMPLETE，这时lParam为指向DEV_BROADCAST_HDR结构的指针，结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_DEV_BROADCAST_HDR</span> &#123;</span><br><span class="line">    DWORD dbch_size; <span class="comment">//该结构大小</span></span><br><span class="line">    DWORD dbch_devicetype; <span class="comment">//设备类型</span></span><br><span class="line">    DWORD dbch_reserved; <span class="comment">//保留字段</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">_DEV_BROADCAST_HDR</span> DEV_BROADCAST_HDR;</span><br></pre></td></tr></table></figure>

<p>其中dbch_devicetype表示设备类型：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
<th>lParam结构</th>
</tr>
</thead>
<tbody><tr>
<td>DBT_DEVTYP_DEVICEINTERFACE</td>
<td>设备类</td>
<td>DEV_BROADCAST_DEVICEINTERFACE</td>
</tr>
<tr>
<td>DBT_DEVTYP_HANDLE</td>
<td>文件系统句柄</td>
<td>DEV_BROADCAST_HANDLE</td>
</tr>
<tr>
<td>DBT_DEVTYP_OEM</td>
<td>OEM或IHV定义的设备类型</td>
<td>DEV_BROADCASE_OEM</td>
</tr>
<tr>
<td>DBT_DEVTYP_PORT</td>
<td>串&#x2F;并行端口设备</td>
<td>DEV_BROADCAST_PORT</td>
</tr>
<tr>
<td>DBT_DEVTYP_VOLUME</td>
<td>逻辑卷</td>
<td>DEV_BROADCAST_VOLUME</td>
</tr>
</tbody></table>
<p>这里只关注DBT_DEVTYP_VOLUME，其中DEV_BROADCAST_VOLUME结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_DEV_BROADCAST_VOLUME</span> &#123;</span><br><span class="line">    DWORD dbcv_size; <span class="comment">//该结构大小</span></span><br><span class="line">    DWORD dbcv_devicetype; <span class="comment">//DBT_DEVTYP_VOLUME</span></span><br><span class="line">    DWORD dbcv_reserved; <span class="comment">//保留</span></span><br><span class="line">    DWORD dbcv_unitmask; <span class="comment">//逻辑驱动器位掩码</span></span><br><span class="line">    WORD dbcv_flags; <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_DEV_BROADCAST_VOLUME</span> DEV_BROADCAST_VOLUME;</span><br></pre></td></tr></table></figure>

<p>dbcv_unitmask中，如位0是驱动器A、位1是驱动器B。</p>
<p>dbcv_flags是标志位：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DBTF_MEDIA</td>
<td>更改会影响驱动器中的媒体，否则影响物理设备或驱动器</td>
</tr>
<tr>
<td>DBTF_NET</td>
<td>逻辑卷是网络卷</td>
</tr>
</tbody></table>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Dbt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    PDEV_BROADCAST_HDR pDevBroadcastHdr = <span class="literal">NULL</span>;</span><br><span class="line">    PDEV_BROADCAST_VOLUME pDevBroadcastVolume = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwDriverMask, dwIndex;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_DEVICECHANGE: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (wParam) &#123;</span><br><span class="line">                <span class="keyword">case</span> DBT_DEVICEARRIVAL: &#123;</span><br><span class="line">                    pDevBroadcastHdr = (PDEV_BROADCAST_HDR)lParam;</span><br><span class="line">                    <span class="keyword">if</span> (pDevBroadcastHdr-&gt;dbch_devicetype == DBT_DEVTYP_VOLUME) &#123;</span><br><span class="line">                        pDevBroadcastVolume = (PDEV_BROADCAST_VOLUME)lParam;</span><br><span class="line">                        dwDriverMask = pDevBroadcastVolume-&gt;dbcv_unitmask;</span><br><span class="line">                        dwIndex = <span class="number">0x00000001</span>;</span><br><span class="line">                        TCHAR szDriverName[] = <span class="built_in">TEXT</span>(<span class="string">&quot;A:\\&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span> (szDriverName[<span class="number">0</span>] = <span class="built_in">TEXT</span>(<span class="string">&#x27;A&#x27;</span>); szDriverName[<span class="number">0</span>] &lt;= <span class="built_in">TEXT</span>(<span class="string">&#x27;Z&#x27;</span>); szDriverName[<span class="number">0</span>]++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> ((dwDriverMask &amp; dwIndex) &gt; <span class="number">0</span>)</span><br><span class="line">                                <span class="built_in">MessageBox</span>(hwndDlg, szDriverName, <span class="built_in">TEXT</span>(<span class="string">&quot;设备已插入&quot;</span>), MB_OK);</span><br><span class="line">                            <span class="comment">// 检测下一个辑驱动器位掩码</span></span><br><span class="line">                            dwIndex = dwIndex &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> DBT_DEVICEREMOVECOMPLETE: &#123;</span><br><span class="line">                    pDevBroadcastHdr = (PDEV_BROADCAST_HDR)lParam;</span><br><span class="line">                    <span class="keyword">if</span> (pDevBroadcastHdr-&gt;dbch_devicetype == DBT_DEVTYP_VOLUME) &#123;</span><br><span class="line">                        pDevBroadcastVolume = (PDEV_BROADCAST_VOLUME)lParam;</span><br><span class="line">                        dwDriverMask = pDevBroadcastVolume-&gt;dbcv_unitmask;</span><br><span class="line">                        dwIndex = <span class="number">0x00000001</span>;</span><br><span class="line">                        TCHAR szDriverName[] = <span class="built_in">TEXT</span>(<span class="string">&quot;A:\\&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span> (szDriverName[<span class="number">0</span>] = <span class="built_in">TEXT</span>(<span class="string">&#x27;A&#x27;</span>); szDriverName[<span class="number">0</span>] &lt;= <span class="built_in">TEXT</span>(<span class="string">&#x27;Z&#x27;</span>); szDriverName[<span class="number">0</span>]++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> ((dwDriverMask &amp; dwIndex) &gt; <span class="number">0</span>)</span><br><span class="line">                                <span class="built_in">MessageBox</span>(hwndDlg, szDriverName, <span class="built_in">TEXT</span>(<span class="string">&quot;设备已拔出&quot;</span>), MB_OK);</span><br><span class="line">                            <span class="comment">// 检测下一个辑驱动器位掩码</span></span><br><span class="line">                            dwIndex = dwIndex &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="获取主板和BIOS序列号"><a href="#获取主板和BIOS序列号" class="headerlink" title="获取主板和BIOS序列号"></a>获取主板和BIOS序列号</h2><h3 id="GetSystemFirmwareTable"><a href="#GetSystemFirmwareTable" class="headerlink" title="GetSystemFirmwareTable"></a>GetSystemFirmwareTable</h3><p>获取指定固件表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT WINAPI <span class="title">GetSystemFirmwareTable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD FirmwareTableProviderSignature, <span class="comment">//固件表提供程序的ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD FirmwareTableID, <span class="comment">//固件表ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PVOID pF1irmwareTableBuffer, <span class="comment">//返回请求的固件表的缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD BufferSize <span class="comment">//pFirmwareTableBuffer大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>其中FirmwareTableProviderSignature可以是：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&#39;ACPI&#39;</td>
<td>ACPI固件表提供程序</td>
</tr>
<tr>
<td>&#39;FIRM&#39;</td>
<td>原始固件表提供程序</td>
</tr>
<tr>
<td>&#39;RSMB&#39;</td>
<td>原始SMBIOS固件表提供程序</td>
</tr>
</tbody></table>
<p>对于FirmwareTableID获取SMBIOS固件表指定0就行。pFirmwareTableBuffer位NULL时函数返回所需缓冲区大小。</p>
<p>PFirmwareTableBuffer返回的缓冲区时RawSMBIOSTable（现更名为RawSMBIOSData？？？）结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RawSMBIOSData</span>&#123;</span><br><span class="line">    BYTE    Used20CallingMethod;</span><br><span class="line">    BYTE    SMBIOSMajorVersion;</span><br><span class="line">    BYTE    SMBIOSMinorVersion;</span><br><span class="line">    BYTE    DmiRevision;</span><br><span class="line">    DWORD   Length; <span class="comment">//原始SMBIOS固件数据长度 单位字节</span></span><br><span class="line">    BYTE    SMBIOSTableData[]; <span class="comment">//原始SMBIOS固件表数组 长度可变</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注册表HEKY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\mssmbios\Data子键下有个键名SMBiosData，键值是原始SMBIOS固件表，但<code>GetSystemFirmwareTable</code>不是读的这个。</p>
<p>后面太复杂了略。</p>
<h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;\&quot;/manifestdependency:type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;*&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __int64 QWORD;</span><br><span class="line"><span class="comment">// 原始SMBIOS固件表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RawSMBIOSTable</span>&#123;</span><br><span class="line">   BYTE    m_bUsed20CallingMethod;</span><br><span class="line">   BYTE    m_bSMBIOSMajorVersion;</span><br><span class="line">   BYTE    m_bSMBIOSMinorVersion;</span><br><span class="line">   BYTE    m_bDmiRevision;         <span class="comment">// 开头4个字段我们不关心</span></span><br><span class="line">   DWORD   m_dwLength;             <span class="comment">// 原始SMBIOS固件表数据的长度，以字节为单位</span></span><br><span class="line">   BYTE    m_bSMBIOSTableData[<span class="number">1</span>];  <span class="comment">// 偏移8字节，原始SMBIOS固件表数据，可变长度</span></span><br><span class="line">&#125;RawSMBIOSTable, * PRawSMBIOSTable;</span><br><span class="line"><span class="comment">// SMBIOS结构的格式化区域中的结构头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SMBIOSStructHeader</span>&#123;</span><br><span class="line">   BYTE    m_bType;    <span class="comment">// 结构类型</span></span><br><span class="line">   BYTE    m_bLength;  <span class="comment">// 该类型结构的格式化区域长度(请注意长度取决于主板或系统支持的版本)</span></span><br><span class="line">   WORD    m_wHandle;  <span class="comment">// 结构句柄(0～0xFEFF范围内的数字)</span></span><br><span class="line">&#125;SMBIOSStructHeader, * PSMBIOSStructHeader;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="comment">// 系统信息(Type 1)SMBIOS结构的格式化区域的完整定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Type1SystemInformation</span>&#123;</span><br><span class="line">   SMBIOSStructHeader m_sHeader; <span class="comment">// SMBIOS结构头SMBIOSStructHeader</span></span><br><span class="line">   BYTE    m_bManufacturer;      <span class="comment">// Manufacturer字符串的编号</span></span><br><span class="line">   BYTE    m_bProductName;       <span class="comment">// Product Name字符串的编号</span></span><br><span class="line">   BYTE    m_bVersion;           <span class="comment">// Version字符串的编号</span></span><br><span class="line">   BYTE    m_bSerialNumber;      <span class="comment">// BIOS Serial Number字符串的编号</span></span><br><span class="line">   UUID    m_uuid;               <span class="comment">// UUID</span></span><br><span class="line">   BYTE    m_bWakeupType;        <span class="comment">// 标识导致系统启动的事件(原因)</span></span><br><span class="line">   BYTE    m_bSKUNumber;         <span class="comment">// SKU Number字符串的编号</span></span><br><span class="line">   BYTE    m_bFamily;            <span class="comment">// Family字符串的编号</span></span><br><span class="line">&#125;Type1SystemInformation, * PType1SystemInformation;</span><br><span class="line"><span class="comment">// 基板信息(Type 2)SMBIOS结构的格式化区域的完整定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Type2BaseboardInformation</span>&#123;</span><br><span class="line">   SMBIOSStructHeader m_sHeader; <span class="comment">// SMBIOS结构头SMBIOSStructHeader</span></span><br><span class="line">   BYTE    m_bManufactur;        <span class="comment">// Manufactur字符串的编号</span></span><br><span class="line">   BYTE    m_bProduct;           <span class="comment">// Product字符串的编号</span></span><br><span class="line">   BYTE    m_bVersion;           <span class="comment">// Version字符串的编号</span></span><br><span class="line">   BYTE    m_bSerialNumber;      <span class="comment">// Baseboard Serial Number字符串的编号</span></span><br><span class="line">   BYTE    m_bAssetTag;          <span class="comment">// Asset Tag字符串的编号</span></span><br><span class="line">   BYTE    m_bFeatureFlags;      <span class="comment">// 基板特征标志</span></span><br><span class="line">   BYTE    m_bLocationInChassis; <span class="comment">// Location In Chassis字符串的编号</span></span><br><span class="line">   WORD    m_wChassisHandle;     <span class="comment">// Chassis Handle</span></span><br><span class="line">   BYTE    m_bBoardType;         <span class="comment">// 基板类型</span></span><br><span class="line">   <span class="comment">//BYTE  m_bNumberOfContainedObjectHandles;</span></span><br><span class="line">   <span class="comment">//WORD  m_wContainedObjectHandles[1];</span></span><br><span class="line">&#125;Type2BaseboardInformation, * PType2BaseboardInformation;</span><br><span class="line"><span class="comment">// 处理器信息(Type 4)SMBIOS结构的格式化区域的完整定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Type4ProcessorInformation</span>&#123;</span><br><span class="line">   SMBIOSStructHeader m_sHeader;       <span class="comment">// SMBIOS结构头SMBIOSStructHeader</span></span><br><span class="line">   BYTE    m_bSocketDesignation;       <span class="comment">// Socket Designation字符串的编号</span></span><br><span class="line">   BYTE    m_bProcessorType;           <span class="comment">// 处理器类型，ENUM值，例如03是中央处理器</span></span><br><span class="line">   BYTE    m_bProcessorFamily;         <span class="comment">// 处理器家族，ENUM值，例如0xC6是Intel® Core™ i7 processor</span></span><br><span class="line">   BYTE    m_bProcessorManufacturer;   <span class="comment">// Processor Manufacturer字符串的编号</span></span><br><span class="line">   QWORD   m_qProcessorID;             <span class="comment">// CPUID(本书结尾还会介绍)，包含描述处理器功能的特定信息</span></span><br><span class="line">   BYTE    m_bProcessorVersion;        <span class="comment">// Processor Version字符串的编号</span></span><br><span class="line">   BYTE    m_bVoltage;                 <span class="comment">// Voltage(电压)</span></span><br><span class="line">   WORD    m_wExternalClock;           <span class="comment">// 外部时钟频率，以MHz为单位</span></span><br><span class="line">   WORD    m_wMaxSpeed;                <span class="comment">// 适用于233MHz处理器</span></span><br><span class="line">   WORD    m_wCurrentSpeed;            <span class="comment">// 处理器在系统引导时的速度，处理器可以支持多种速度</span></span><br><span class="line">   BYTE    m_bStatus;                  <span class="comment">// CPU和CPU插槽的状态</span></span><br><span class="line">   BYTE    m_bProcessorUpgrade;        <span class="comment">// Processor Upgrade，ENUM值</span></span><br><span class="line">   WORD    m_wL1CacheHandle;           <span class="comment">// 一级缓存信息结构的句柄</span></span><br><span class="line">   WORD    m_wL2CacheHandle;           <span class="comment">// 二级缓存信息结构的句柄</span></span><br><span class="line">   WORD    m_wL3CacheHandle;           <span class="comment">// 三级缓存信息结构的句柄</span></span><br><span class="line">   BYTE    m_bSerialNumber;            <span class="comment">// 处理器序列号字符串的编号，由制造商设置，通常不可更改</span></span><br><span class="line">   BYTE    m_bAssetTag;                <span class="comment">// Asset Tag字符串的编号</span></span><br><span class="line">   BYTE    m_bPartNumber;              <span class="comment">// 处理器部件号字符串的编号，由制造商设置，通常不可更改</span></span><br><span class="line">   BYTE    m_bCoreCount;               <span class="comment">// 处理器的核心数</span></span><br><span class="line">   BYTE    m_bCoreEnabled;             <span class="comment">// 由BIOS启用并可供系统使用的核心数</span></span><br><span class="line">   BYTE    m_bThreadCount;             <span class="comment">// 处理器的线程数</span></span><br><span class="line">   WORD    m_wProcessorCharacteristics;<span class="comment">// 处理器特性，例如0x0004表示64位处理器</span></span><br><span class="line">   <span class="comment">// 最后4个字段2.6及以上版本才支持</span></span><br><span class="line">   <span class="comment">//WORD    m_wProcessorFamily2;      // 处理器家族2</span></span><br><span class="line">   <span class="comment">//WORD    m_wCoreCount2;            // 处理器的核心数，用于个数大于255时</span></span><br><span class="line">   <span class="comment">//WORD    m_wCoreEnabled2;          // 由BIOS启用并可供系统使用的核心数，用于个数大于255时</span></span><br><span class="line">   <span class="comment">//WORD    m_wThreadCount2;          // 处理器的线程数，用于个数大于255时</span></span><br><span class="line">&#125;Type4ProcessorInformation, * PType4ProcessorInformation;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HINSTANCE g_hInstance;</span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 从SMBIOS结构的未格式化区域中查找指定编号的字符串</span></span><br><span class="line"><span class="function">LPSTR <span class="title">FingStrFromStruct</span><span class="params">(PSMBIOSStructHeader pStructHeader, BYTE bNum)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    g_hInstance = hInstance;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    HWND hwndEdit = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwBufferSize = <span class="number">0</span>;</span><br><span class="line">    LPBYTE lpBuf = <span class="literal">NULL</span>;</span><br><span class="line">    PRawSMBIOSTable pRawSMBIOSTable = <span class="literal">NULL</span>;   <span class="comment">// 原始SMBIOS固件表</span></span><br><span class="line">    LPBYTE lpData = <span class="literal">NULL</span>;                     <span class="comment">// 原始SMBIOS固件表数据</span></span><br><span class="line">    PSMBIOSStructHeader pStructHeader = <span class="literal">NULL</span>; <span class="comment">// SMBIOS结构的格式化区域中的结构头</span></span><br><span class="line">    CHAR szBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            hwndEdit = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_INFO);</span><br><span class="line">            <span class="comment">// 第1次调用获取所需的缓冲区大小</span></span><br><span class="line">            dwBufferSize = <span class="built_in">GetSystemFirmwareTable</span>(<span class="string">&#x27;RSMB&#x27;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (dwBufferSize == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            <span class="comment">// 第2次调用获取原始SMBIOS固件表</span></span><br><span class="line">            lpBuf = <span class="keyword">new</span> BYTE[dwBufferSize];</span><br><span class="line">            <span class="built_in">ZeroMemory</span>(lpBuf, dwBufferSize);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetSystemFirmwareTable</span>(<span class="string">&#x27;RSMB&#x27;</span>, <span class="number">0</span>, lpBuf, dwBufferSize) != dwBufferSize)</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            <span class="comment">// 解析获取到的原始SMBIOS固件表数据</span></span><br><span class="line">            pRawSMBIOSTable = (PRawSMBIOSTable)lpBuf;</span><br><span class="line">            lpData = pRawSMBIOSTable-&gt;m_bSMBIOSTableData;</span><br><span class="line">            <span class="keyword">while</span> ((lpData - pRawSMBIOSTable-&gt;m_bSMBIOSTableData) &lt; pRawSMBIOSTable-&gt;m_dwLength) &#123;</span><br><span class="line">                <span class="comment">// 根据SMBIOS结构的格式化区域中的结构头的m_bType字段确定结构类型</span></span><br><span class="line">                <span class="comment">// 确定结构类型以后再把pStructHeader转换为指向对应的格式化区域完整定义的指针</span></span><br><span class="line">                pStructHeader = (PSMBIOSStructHeader)lpData;</span><br><span class="line">                <span class="keyword">if</span> (pStructHeader-&gt;m_bType == <span class="number">1</span>) &#123;</span><br><span class="line">                    PType1SystemInformation pType1 = (PType1SystemInformation)pStructHeader;</span><br><span class="line">                    CHAR szUUID[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="built_in">wsprintfA</span>(szUUID, <span class="string">&quot;%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X&quot;</span>, pType1-&gt;m_uuid.Data1, pType1-&gt;m_uuid.Data2, pType1-&gt;m_uuid.Data3, pType1-&gt;m_uuid.Data4[<span class="number">0</span>], pType1-&gt;m_uuid.Data4[<span class="number">1</span>], pType1-&gt;m_uuid.Data4[<span class="number">2</span>], pType1-&gt;m_uuid.Data4[<span class="number">3</span>], pType1-&gt;m_uuid.Data4[<span class="number">4</span>], pType1-&gt;m_uuid.Data4[<span class="number">5</span>], pType1-&gt;m_uuid.Data4[<span class="number">6</span>], pType1-&gt;m_uuid.Data4[<span class="number">7</span>]);</span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(szBuf, <span class="built_in">sizeof</span>(szBuf));</span><br><span class="line">                    <span class="built_in">StringCchPrintfA</span>(szBuf, _countof(szBuf), <span class="string">&quot;系统信息(类型1)：\r\nType\t\t%d\r\nLength\t\t0x%X\r\nHandle\t\t%d\r\nManufacturer\t%s\r\nProduct Name\t%s\r\nVersion\t\t%s\r\nSerial Number\t%s\r\nUUID\t\t%s\r\nWake-up Type\t%d\r\nSKU Number\t%s\r\nFamily\t\t%s\r\n\r\n&quot;</span>, pType1-&gt;m_sHeader.m_bType, pType1-&gt;m_sHeader.m_bLength, pType1-&gt;m_sHeader.m_wHandle, <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType1-&gt;m_bManufacturer), <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType1-&gt;m_bProductName), <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType1-&gt;m_bVersion), <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType1-&gt;m_bSerialNumber), szUUID, pType1-&gt;m_bWakeupType, <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType1-&gt;m_bSKUNumber), <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType1-&gt;m_bFamily));</span><br><span class="line">                    <span class="built_in">SendMessageA</span>(hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">SendMessageA</span>(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pStructHeader-&gt;m_bType == <span class="number">2</span>) &#123;</span><br><span class="line">                    PType2BaseboardInformation pType2 = (PType2BaseboardInformation)pStructHeader;</span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(szBuf, <span class="built_in">sizeof</span>(szBuf));</span><br><span class="line">                    <span class="built_in">StringCchPrintfA</span>(szBuf, _countof(szBuf), <span class="string">&quot;基板信息(类型2)：\r\nType\t\t%d\r\nLength\t\t0x%X\r\nHandle\t\t%d\r\nManufactur\t%s\r\nProduct\t\t%s\r\nVersion\t\t%s\r\nSerial Number\t%s\r\nAsset Tag\t%s\r\nFeature Flags\t%d\r\nLocation In Chassis\t%s\r\nChassis Handle\t%d\r\nBoard Type\t%d\r\n\r\n&quot;</span>, pType2-&gt;m_sHeader.m_bType, pType2-&gt;m_sHeader.m_bLength, pType2-&gt;m_sHeader.m_wHandle, <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType2-&gt;m_bManufactur), <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType2-&gt;m_bProduct), <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType2-&gt;m_bVersion), <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType2-&gt;m_bSerialNumber), <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType2-&gt;m_bAssetTag), pType2-&gt;m_bFeatureFlags, <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType2-&gt;m_bLocationInChassis), pType2-&gt;m_wChassisHandle, pType2-&gt;m_bBoardType);</span><br><span class="line">                    <span class="built_in">SendMessageA</span>(hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">SendMessageA</span>(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pStructHeader-&gt;m_bType == <span class="number">4</span>) &#123;</span><br><span class="line">                    PType4ProcessorInformation pType4 = (PType4ProcessorInformation)pStructHeader;</span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(szBuf, <span class="built_in">sizeof</span>(szBuf));</span><br><span class="line">                    <span class="built_in">StringCchPrintfA</span>(szBuf, _countof(szBuf), <span class="string">&quot;处理器信息(类型4)：\r\nType\t\t\t%d\r\nLength\t\t\t0x%X\r\nHandle\t\t\t%d\r\nSocket Designation\t\t%s\r\nProcessor Type\t\t%d\r\nProcessor Family\t\t%d\r\nProcessor Manufacturer\t%s\r\nProcessor ID\t\t%I64X\r\nProcessor Version\t\t%s\r\nVoltage\t\t\t%d\r\nExternal Clock\t\t%d\r\nMax Speed\t\t%d\r\nCurrent Speed\t\t%d\r\nStatus\t\t\t%d\r\nProcessor Upgrade\t\t%d\r\nL1 Cache Handle\t\t%d\r\nL2 Cache Handle\t\t%d\r\nL3 Cache Handle\t\t%d\r\nSerial Number\t\t%s\r\nAsset Tag\t\t%s\r\nPart Number\t\t%s\r\nCore Count\t\t%d\r\nCore Enabled\t\t%d\r\nThread Count\t\t%d\r\nProcessor Characteristics\t%d\r\n\r\n&quot;</span>, pType4-&gt;m_sHeader.m_bType, pType4-&gt;m_sHeader.m_bLength, pType4-&gt;m_sHeader.m_wHandle, <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType4-&gt;m_bSocketDesignation), pType4-&gt;m_bProcessorType, pType4-&gt;m_bProcessorFamily, <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType4-&gt;m_bProcessorManufacturer), pType4-&gt;m_qProcessorID, <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType4-&gt;m_bProcessorVersion), pType4-&gt;m_bVoltage, pType4-&gt;m_wExternalClock, pType4-&gt;m_wMaxSpeed, pType4-&gt;m_wCurrentSpeed, pType4-&gt;m_bStatus, pType4-&gt;m_bProcessorUpgrade, pType4-&gt;m_wL1CacheHandle, pType4-&gt;m_wL2CacheHandle, pType4-&gt;m_wL3CacheHandle, <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType4-&gt;m_bSerialNumber), <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType4-&gt;m_bAssetTag), <span class="built_in">FingStrFromStruct</span>(pStructHeader, pType4-&gt;m_bPartNumber), pType4-&gt;m_bCoreCount, pType4-&gt;m_bCoreEnabled, pType4-&gt;m_bThreadCount, pType4-&gt;m_wProcessorCharacteristics);</span><br><span class="line">                    <span class="built_in">SendMessageA</span>(hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">SendMessageA</span>(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 遍历完本SMBIOS结构的未格式化区域，以指向下一个SMBIOS结构</span></span><br><span class="line">                lpData += pStructHeader-&gt;m_bLength;</span><br><span class="line">                <span class="keyword">while</span> ((*(LPWORD)lpData) != <span class="number">0</span>) lpData++;</span><br><span class="line">                lpData += <span class="number">2</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">delete</span>[]lpBuf;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_OPEN: &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_CLOSE: &#123;</span><br><span class="line">            <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">LPSTR <span class="title">FingStrFromStruct</span><span class="params">(PSMBIOSStructHeader pStructHeader, BYTE bNum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向SMBIOS结构的未格式化区域(字符串数组)</span></span><br><span class="line">    LPBYTE lpByte = (LPBYTE)pStructHeader + pStructHeader-&gt;m_bLength;</span><br><span class="line">    <span class="comment">// 字符串编号从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (BYTE i = <span class="number">1</span>; i &lt; bNum; i++)</span><br><span class="line">        lpByte += <span class="built_in">strlen</span>((LPSTR)lpByte) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (LPSTR)lpByte;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><h3 id="CreateFileMapping"><a href="#CreateFileMapping" class="headerlink" title="CreateFileMapping"></a>CreateFileMapping</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateFileMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hFile, <span class="comment">//文件对象句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpAttributes, <span class="comment">//安全属性结构</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD flProtect, <span class="comment">//页面保护属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwMaximumSizeHigh, <span class="comment">//文件映射大小高32位 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwMaximumSizeLow, <span class="comment">//文件映射大小低32位</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCTSTR lpName <span class="comment">//文件映射对象名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>fProtect可以以下选一个：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_READONLY&#x2F;PAGE_WRITECOPY</td>
<td>可读、写时复制</td>
</tr>
<tr>
<td>PAGE_READWRITE</td>
<td>可读可写、写时复制</td>
</tr>
<tr>
<td>PAGE_EXECUTE_READ&#x2F;PAGE_EXECUTE_WRITECOPY</td>
<td>可读可执行、写时复制</td>
</tr>
<tr>
<td>PAGE_EXECUTE_READWRITE</td>
<td>可读可写可执行、写时复制</td>
</tr>
</tbody></table>
<p>hFile还可以指定位INVALID_HANDLE_VALUE，系统使用页面交换文件创建或打开一个文件映射对象，通常用于进程间共享数据，此时fProtect还可以同时使用：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SEC_COMMIT</td>
<td>默认属性，提交所有页面</td>
</tr>
<tr>
<td>SEC_RESERVE</td>
<td>页面处于预定&#x2F;保留状态，需要时用<code>VirtualAlloc</code>提交</td>
</tr>
<tr>
<td>SEC_IMAGE</td>
<td>是可执行文件</td>
</tr>
</tbody></table>
<p>对于dwMaximumSizeHigh和dwMaximumSizeLow：若文件映像基于hFile指定的文件，这俩都可以为0，文件映射对象大小等于hFile指定文件大小；当hFile指定的文件为0，这俩参数也为0则调用失败返回NULL，<code>GetLastError</code>返回ERROR_FILE_INVALID；若这俩参数指定的大小大于hFile指定的文件大小则扩展文件到指定大小，扩展失败则调用失败返回HULL，<code>GetLastError</code>返回ERROR_DISK_FULL；若是基于页面交换文件映射对象，这俩参数必须指定明确大小。</p>
<p>lpName为NULL则创建一个匿名文件映射对象，已存在则打开并返回该文件映射对象句柄。</p>
<h3 id="MapViewOfFile"><a href="#MapViewOfFile" class="headerlink" title="MapViewOfFile"></a>MapViewOfFile</h3><p>把文件映射对象的部分或全部映射到进程的虚拟地址空间中，返回内存指针lpMemory，通过该指针读写文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID WINAPI <span class="title">MapViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hFileMappingObject, <span class="comment">//文件映射对象句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwDesiredAccess, <span class="comment">//访问类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwFileOffsetHigh, <span class="comment">//文件映射对象偏移量高32位</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwFileOffsetLow, <span class="comment">//文件映射对象偏移量低32位</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T dwNumberOfBytesToMap <span class="comment">//视图大小（要映射的字节数）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>对于dwDesiredAccess有：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_MAP_READ</td>
<td>可读</td>
</tr>
<tr>
<td>FILE_MAP_WRITE&#x2F;FILE_MAP_ALL_ACCESS</td>
<td>可读可写</td>
</tr>
<tr>
<td>FILE_MAP_COPY</td>
<td>写时复制</td>
</tr>
<tr>
<td>FILE_MAP_EXECUTE</td>
<td>可执行</td>
</tr>
</tbody></table>
<p>该函数从dwFileOffsetHigh和dwFileOffsetLow偏移量开始映射dwNumberOfBytesToMap字节。当dwNumberOfBytesToMap位0则映射到文件映射对象末尾。偏移量必须是分配粒度整数倍。</p>
<h3 id="MapViewOfFileEx"><a href="#MapViewOfFileEx" class="headerlink" title="MapViewOfFileEx"></a>MapViewOfFileEx</h3><p>同上，可指定映射基地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID WINAPI <span class="title">MapViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hFileMappingObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwFileOffsetHigh,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwFileOffsetLow,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T dwNumberOfBytesToMap,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPVOID lpBaseAddress <span class="comment">//映射基地址 内存分配粒度整数倍</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="OverFileMapping"><a href="#OverFileMapping" class="headerlink" title="OverFileMapping"></a>OverFileMapping</h3><p>打开一个名命名文件映射对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">OpenFileMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwDesiredAccess, <span class="comment">//访问类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ BOOL bInheritHandle, <span class="comment">//返回是否可被子进程继承</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPCTSTR lpName <span class="comment">//文件映射对象名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="FlushViewOfFile"><a href="#FlushViewOfFile" class="headerlink" title="FlushViewOfFile"></a>FlushViewOfFile</h3><p>系统对文件视图的页面做缓存处理，吸入文件视图时不一定随时更新磁盘上文件，用该函数强制系统把部分或全部已修改的数据（脏页）写回到磁盘中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">FlushViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPCVOID lpBaseAddress, <span class="comment">//视图起始地址 自动向下取整到页面大小整数倍</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T dwNumberOfBytesToFlush <span class="comment">//要刷新的字节数 自动向上取整到页面大小整数倍 为0从基地址刷新到视图末尾</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="UnmapViewOfFile"><a href="#UnmapViewOfFile" class="headerlink" title="UnmapViewOfFile"></a>UnmapViewOfFile</h3><p>撤销对视图的映射：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">UnmapViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPCVOID lpBaseAddress <span class="comment">//内存映射文件的视图的起始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    TCHAR szPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 文件路径</span></span><br><span class="line">    TCHAR szBuf[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;       <span class="comment">// 追加数据</span></span><br><span class="line">    LARGE_INTEGER liFileSize;</span><br><span class="line">    HANDLE hFile, hFileMap;</span><br><span class="line">    LPVOID lpMemory;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_PATH, <span class="built_in">TEXT</span>(<span class="string">&quot;D:\\Test.txt&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_OPEN: &#123;</span><br><span class="line">                    <span class="comment">// 打开一个文件</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_PATH, szPath, _countof(szPath));</span><br><span class="line">                    hFile = <span class="built_in">CreateFile</span>(szPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFile函数调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">GetFileSizeEx</span>(hFile, &amp;liFileSize);</span><br><span class="line">                        <span class="keyword">if</span> (liFileSize.QuadPart == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;文件大小为0&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                            <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">                            <span class="keyword">return</span> TRUE;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 为hFile文件对象创建一个文件映射内核对象</span></span><br><span class="line">                    hFileMap = <span class="built_in">CreateFileMapping</span>(hFile, <span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!hFileMap) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFileMapping调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 把文件映射对象hFileMap的全部映射到进程的虚拟地址空间中</span></span><br><span class="line">                    lpMemory = <span class="built_in">MapViewOfFile</span>(hFileMap, FILE_MAP_READ | FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!lpMemory) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;MapViewOfFile调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 把文件内容显示到编辑控件中</span></span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_TEXT, (LPTSTR)lpMemory);</span><br><span class="line">                    <span class="comment">// 清理工作</span></span><br><span class="line">                    <span class="built_in">UnmapViewOfFile</span>(lpMemory);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFileMap);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_APPEND: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_APPEND, szBuf, _countof(szBuf))) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;请输入追加内容&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 打开一个文件</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_PATH, szPath, _countof(szPath));</span><br><span class="line">                    hFile = <span class="built_in">CreateFile</span>(szPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFile函数调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 为hFile文件对象创建一个文件映射内核对象</span></span><br><span class="line">                    <span class="comment">// 扩展文件到指定的大小</span></span><br><span class="line">                    <span class="built_in">GetFileSizeEx</span>(hFile, &amp;liFileSize);</span><br><span class="line">                    hFileMap = <span class="built_in">CreateFileMapping</span>(hFile, <span class="literal">NULL</span>, PAGE_READWRITE, liFileSize.HighPart, liFileSize.LowPart + _tcslen(szBuf) * <span class="built_in">sizeof</span>(TCHAR), <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!hFileMap) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFileMapping调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 把文件映射对象hFileMap的全部映射到进程的虚拟地址空间中</span></span><br><span class="line">                    lpMemory = <span class="built_in">MapViewOfFile</span>(hFileMap, FILE_MAP_READ | FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!lpMemory) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;MapViewOfFile调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 写入追加数据</span></span><br><span class="line">                    <span class="built_in">memcpy_s</span>((LPBYTE)lpMemory + liFileSize.QuadPart, _tcslen(szBuf) * <span class="built_in">sizeof</span>(TCHAR), szBuf, _tcslen(szBuf) * <span class="built_in">sizeof</span>(TCHAR));</span><br><span class="line">                    <span class="built_in">FlushViewOfFile</span>(lpMemory, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">// 把新文件内容显示到编辑控件中</span></span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_TEXT, (LPTSTR)lpMemory);</span><br><span class="line">                    <span class="comment">// 清理工作</span></span><br><span class="line">                    <span class="built_in">UnmapViewOfFile</span>(lpMemory);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFileMap);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="多进程间数据共享"><a href="#多进程间数据共享" class="headerlink" title="多进程间数据共享"></a>多进程间数据共享</h3><p>启动多个同一个.exe时，可执行代码的页面为两个进程所共享。但当一个程序实例修改并写入一个内存页，则将导致混乱，这时引进写时复制。系统统计多少页面可写，从页面交换文件中分配空间来容纳，当线程视图写入一个共享页面时，系统从分配的页面交换文件中找一个空闲页面，并把要修改的页面复制到空闲页面，更新进程页面表，这个进程即可访问它自己的副本。</p>
<h3 id="CoCreateGuid"><a href="#CoCreateGuid" class="headerlink" title="CoCreateGuid"></a>CoCreateGuid</h3><p>动态生成一个GUID：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GUID guid;</span><br><span class="line">TCHAR szGUID[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 生成一个GUID</span></span><br><span class="line"><span class="built_in">CoCreateGuid</span>(&amp;guid);</span><br><span class="line"><span class="comment">// 转换为字符串</span></span><br><span class="line"><span class="built_in">wsprintf</span>(szGUID, <span class="built_in">TEXT</span>(<span class="string">&quot;%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X&quot;</span>),guid.Data1, guid.Data2, guid.Data3,guid.Data4[<span class="number">0</span>], guid.Data4[<span class="number">1</span>], guid.Data4[<span class="number">2</span>], guid.Data4[<span class="number">3</span>],guid.Data4[<span class="number">4</span>], guid.Data4[<span class="number">5</span>], guid.Data4[<span class="number">6</span>], guid.Data4[<span class="number">7</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> HANDLE hFileMap;</span><br><span class="line">    <span class="type">static</span> LPVOID lpMemory;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="comment">// 创建或打开一个 命名文件映射内核对象，BUF_SIZE字节</span></span><br><span class="line">            hFileMap = <span class="built_in">CreateFileMapping</span>(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, BUF_SIZE, <span class="built_in">TEXT</span>(<span class="string">&quot;2F4368E6-09A1-4D5E-ACC9-C1BDBB041BF7&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (!hFileMap) &#123;</span><br><span class="line">                <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFileMapping调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 把文件映射对象hFileMap的全部映射到进程的虚拟地址空间中</span></span><br><span class="line">            lpMemory = <span class="built_in">MapViewOfFile</span>(hFileMap, FILE_MAP_READ | FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!lpMemory) &#123;</span><br><span class="line">                <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;MapViewOfFile调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 创建一个计时器，每一秒钟在静态控件中刷新显示一次共享数据</span></span><br><span class="line">            <span class="built_in">SetTimer</span>(hwndDlg, <span class="number">1</span>, <span class="number">1000</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_EDIT_SHARE: &#123;</span><br><span class="line">                    <span class="comment">// 编辑控件中的内容改变</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">HIWORD</span>(wParam) == EN_UPDATE)</span><br><span class="line">                        <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_SHARE, (LPTSTR)lpMemory, BUF_SIZE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="comment">// 清理工作</span></span><br><span class="line">                    <span class="built_in">KillTimer</span>(hwndDlg, <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">UnmapViewOfFile</span>(lpMemory);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFileMap);</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_TIMER: &#123;</span><br><span class="line">            <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_STATIC_SHARE, (LPTSTR)lpMemory);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="大型文件处理"><a href="#大型文件处理" class="headerlink" title="大型文件处理"></a>大型文件处理</h3><p>复制大型文件，注意<code>MapViewOfFile</code>的文件映射对象偏移量参数必须指定为内存分配粒度整数倍：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CopyLargeFile</span><span class="params">(LPCTSTR lpFileName1, LPCTSTR lpFileName2)</span> </span>&#123;</span><br><span class="line">    HANDLE hFile1, hFile2, hFileMap;</span><br><span class="line">    LPVOID lpMemory;</span><br><span class="line">    <span class="comment">//打开文件1</span></span><br><span class="line">    hFile1 = <span class="built_in">CreateFile</span>(lpFileName1, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFile1 == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">//创建文件2</span></span><br><span class="line">    hFile2 = <span class="built_in">CreateFile</span>(lpFileName2, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFile2 == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">   	<span class="comment">//为hFile1文件对象创建一个文件映射内核对象</span></span><br><span class="line">    hFileMap = <span class="built_in">CreateFileMapping</span>(hFile1, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hFileMap)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">//获取文件大小 内存分配粒度</span></span><br><span class="line">    __int64 qwFileSize;</span><br><span class="line">    DWORD dwFileSizeHigh;</span><br><span class="line">    SYSTEM_INFO si;</span><br><span class="line">    qwFileSize = <span class="built_in">GetFileSize</span>(hFile1, &amp;dwFileSizeHigh);</span><br><span class="line">    qwFileSize += (((__int64)dwFileSizeHigh) &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">GetSystemInfo</span>(&amp;si);</span><br><span class="line">    <span class="comment">//把文件映射对象hFileMap不断映射到进程的虚拟地址空间中</span></span><br><span class="line">    __int64 qwFileOffset = <span class="number">0</span>; <span class="comment">//文件映射对象偏移量</span></span><br><span class="line">    DWORD dwBytesInBlock; <span class="comment">//本次映射大小</span></span><br><span class="line">    <span class="keyword">while</span> (qwFileSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dwBytesInBlock = si.dwAllocationGranularity;</span><br><span class="line">        lpMemory = <span class="built_in">MapViewOfFile</span>(hFileMap, FILE_MAP_READ, (DWORD)(qwFileOffset &gt;&gt; <span class="number">32</span>), (DWORD)(qwFileOffset &amp; <span class="number">0xFFFFFFFF</span>), dwBytesInBlock);</span><br><span class="line">        <span class="keyword">if</span> (!lpMemory)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        <span class="comment">//对已映射部分进程操作</span></span><br><span class="line">        <span class="built_in">WriteFile</span>(hFile2, lpMemory, dwBytesInBlock, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//取消本次映射 进行下一轮映射</span></span><br><span class="line">        <span class="built_in">UnmapViewOfFile</span>(lpMemory);</span><br><span class="line">        qwFileOffset += dwBytesInBlock;</span><br><span class="line">        qwFileSize -= dwBytesInBlock;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//清理工作</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFileMap);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile1);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile2);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="APC异步过程调用"><a href="#APC异步过程调用" class="headerlink" title="APC异步过程调用"></a>APC异步过程调用</h2><h3 id="ReadFileEx-WriteFileEx"><a href="#ReadFileEx-WriteFileEx" class="headerlink" title="ReadFileEx&#x2F;WriteFileEx"></a>ReadFileEx&#x2F;WriteFileEx</h3><p>在指定文件或其他I&#x2F;O设备中读&#x2F;写数据，系统异步报告完成状态，并在操作完成&#x2F;取消时且调用线程处于可通知&#x2F;提醒的等待状态时调用指定的例程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ReadFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hFile, <span class="comment">//文件或其他I/O设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ LPVOID lpBuffer, <span class="comment">//接收为你教案或其他I/O设备数据的缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD nNumberOfBytesToRead, <span class="comment">//要读取的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_ LPOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine <span class="comment">//完成例程</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功TRUE 失败FALSE</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">WriteFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPCVOID lpBuffer, <span class="comment">//要写入文件或其他I/O设备的数据的缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD nNumberOfBytesToWrite, <span class="comment">//要写入的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_ LPOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于hFile，在<code>CreateFile</code>时dwFlagsAndAttributes需要FILE_FLAG_OVERLAPPED标志。</p>
<p>OVERLAPPED结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OVERLAPPED</span> &#123;</span><br><span class="line">    ULONG_PTR Internal; <span class="comment">//I/O请求的状态代码</span></span><br><span class="line">    ULONG_PTR InternalHigh; <span class="comment">//已传输的字节数</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD Offset; <span class="comment">//从文件开始读取/写入的字节偏移的低32位</span></span><br><span class="line">            DWORD OffsetHigh; <span class="comment">//从文件开始读取/写入的字节偏移的高32位</span></span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">        PVOID Pointer;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    HANDLE  hEvent;</span><br><span class="line">&#125; OVERLAPPED, * LPOVERLAPPED;</span><br></pre></td></tr></table></figure>

<p>要写入文件末尾时，Offset和OffsetHigh都指定为0xFFFFFFFF。</p>
<p>完成例程lpCompletionRoutine定义形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">OverlappedCompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwErrorCode, <span class="comment">//I/O请求的状态代码</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwNumberOfBytesTransfered, <span class="comment">//已传输字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_ LPOVERLAPPED lpOverlapped <span class="comment">//调用I/O时指定的</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>这里的dwErrorCode和dwNumberOfBytesTransfered与OVERLAPPED结构的Internal和InternalHigh效果一样。异步I&#x2F;O操作成功完成并执行完成例程，则dwErrorCode值为ERROR_SUCCESS。</p>
<p>使调用线程处于可通知的等待状态的方法有<code>SleepEx</code>、<code>MsgWaitForMultipleObjectsEx</code>、<code>WaitForSingleObjectEx</code>、<code>WaitForMultipleObjectsEx</code>等，当函数执行成功，异步I&#x2F;O完成后并等待调用线程进入可通知的等待状态后，系统调用完成例程并执行结束后，等待函数返回值为WAIT_IO_COMPLETION。</p>
<p>系统创建一个线程时，同时创建一个相关联的APC异步过程调用队列。调用<code>ReadFileEx</code>&#x2F;<code>WriteFileEx</code>函数后，系统将完成例程地址传递给设备驱动程序，设备驱动程序在发出I&#x2F;O请求的线程APC队列中添加一项，该项包括完成例程的地址和发出I&#x2F;O请求时所使用的OVERLAPPED结构的地址。调用等待函数时，若APC队列中没有项目则一直等待直到超时。出现一项时系统取出并删除，调用完成例程。</p>
<h3 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Winmm.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;\&quot;/manifestdependency:type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;*&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="comment">// 传递给完成例程的自定义数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IOData</span>&#123;</span><br><span class="line">    HANDLE m_hFileSource; <span class="comment">// 源文件句柄</span></span><br><span class="line">    HANDLE m_hFileDest;   <span class="comment">// 目标文件句柄</span></span><br><span class="line">    HANDLE m_hFileMap;    <span class="comment">// 源文件映射对象</span></span><br><span class="line">    LPVOID m_lpMemory;    <span class="comment">// 映射的虚拟地址</span></span><br><span class="line">&#125;IOData, * PIOData;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HINSTANCE g_hInstance;</span><br><span class="line">HWND g_hwndDlg;</span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 完成例程</span></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">OverlappedCompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwErrorCode,              <span class="comment">// I/O请求的状态代码</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwNumberOfBytesTransfered,<span class="comment">// 已传输的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED lpOverlapped       <span class="comment">// 当初调用I/O函数时指定的那个OVERLAPPED结构的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)</span> </span>&#123;</span><br><span class="line">    g_hInstance = hInstance;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>&#123;</span><br><span class="line">    TCHAR  szFileNameSource[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR  szFileNameDest[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OPENFILENAME ofnSource = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ofnSource.lStructSize = <span class="built_in">sizeof</span>(ofnSource);</span><br><span class="line">    ofnSource.hwndOwner = hwndDlg;</span><br><span class="line">    ofnSource.lpstrFilter = <span class="built_in">TEXT</span>(<span class="string">&quot;All(*.*)\0*.*\0&quot;</span>);</span><br><span class="line">    ofnSource.nFilterIndex = <span class="number">1</span>;                          <span class="comment">// 默认选择第1个过滤器</span></span><br><span class="line">    ofnSource.lpstrFile = szFileNameSource;              <span class="comment">// 返回用户选择的文件名的缓冲区</span></span><br><span class="line">    ofnSource.lpstrFile[<span class="number">0</span>] = <span class="literal">NULL</span>;                       <span class="comment">// 不需要初始化文件名编辑控件</span></span><br><span class="line">    ofnSource.nMaxFile = _countof(szFileNameSource);</span><br><span class="line">    ofnSource.lpstrTitle = <span class="built_in">TEXT</span>(<span class="string">&quot;请选择要打开的文件&quot;</span>);   <span class="comment">// 对话框标题栏中显示的字符串</span></span><br><span class="line">    ofnSource.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_CREATEPROMPT;</span><br><span class="line">    OPENFILENAME ofnDest = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ofnDest.lStructSize = <span class="built_in">sizeof</span>(ofnDest);</span><br><span class="line">    ofnDest.hwndOwner = hwndDlg;</span><br><span class="line">    ofnDest.lpstrFilter = <span class="built_in">TEXT</span>(<span class="string">&quot;All(*.*)\0*.*\0&quot;</span>);</span><br><span class="line">    ofnDest.nFilterIndex = <span class="number">1</span>;                           <span class="comment">// 默认选择第1个过滤器</span></span><br><span class="line">    ofnDest.lpstrFile = szFileNameDest;                 <span class="comment">// 返回用户选择的文件名的缓冲区</span></span><br><span class="line">    ofnDest.lpstrFile[<span class="number">0</span>] = <span class="literal">NULL</span>;                        <span class="comment">// 不需要初始化文件名编辑控件</span></span><br><span class="line">    ofnDest.nMaxFile = _countof(szFileNameDest);</span><br><span class="line">    ofnDest.lpstrTitle = <span class="built_in">TEXT</span>(<span class="string">&quot;请选择要保存的文件名&quot;</span>);  <span class="comment">// 对话框标题栏中显示的字符串</span></span><br><span class="line">    ofnDest.Flags = OFN_EXPLORER | OFN_OVERWRITEPROMPT;</span><br><span class="line">    HANDLE hFileSource = INVALID_HANDLE_VALUE, hFileDest = INVALID_HANDLE_VALUE;</span><br><span class="line">    HANDLE hFileMap = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID lpMemory = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD  dwFileSizeLow = <span class="number">0</span>;</span><br><span class="line">    DWORD  dwFileSizeHigh = <span class="number">0</span>;</span><br><span class="line">    BOOL   bRet = FALSE;</span><br><span class="line">    DWORD  dwRet = <span class="number">0</span>;</span><br><span class="line">    PIOData pIOData = <span class="literal">NULL</span>;</span><br><span class="line">    LPOVERLAPPED lpOverlapped = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            g_hwndDlg = hwndDlg;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SOURCE: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetOpenFileName</span>(&amp;ofnSource))</span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_SOURCE, szFileNameSource);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_DEST: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetSaveFileName</span>(&amp;ofnDest))</span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_DEST, szFileNameDest);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_COPY: &#123;</span><br><span class="line">                    <span class="comment">// 打开源文件</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_SOURCE, szFileNameSource, _countof(szFileNameSource));</span><br><span class="line">                    hFileSource = <span class="built_in">CreateFile</span>(szFileNameSource, GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">                        FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (hFileSource == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;打开源文件失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 获取源文件大小</span></span><br><span class="line">                    dwFileSizeLow = <span class="built_in">GetFileSize</span>(hFileSource, &amp;dwFileSizeHigh);</span><br><span class="line">                    <span class="comment">// 为hFile文件对象创建一个文件映射内核对象</span></span><br><span class="line">                    hFileMap = <span class="built_in">CreateFileMapping</span>(hFileSource, <span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!hFileMap) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFileMapping调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 把文件映射对象hFileMap的全部映射到进程的虚拟地址空间中</span></span><br><span class="line">                    lpMemory = <span class="built_in">MapViewOfFile</span>(hFileMap, FILE_MAP_READ | FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!lpMemory) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;MapViewOfFile调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 创建目标文件</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_DEST, szFileNameDest, _countof(szFileNameDest));</span><br><span class="line">                    hFileDest = <span class="built_in">CreateFile</span>(szFileNameDest, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (hFileDest == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;创建目标文件失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 分配一个IOData结构，把相关句柄传递过去以释放</span></span><br><span class="line">                    pIOData = <span class="keyword">new</span> IOData;</span><br><span class="line">                    pIOData-&gt;m_hFileSource = hFileSource;</span><br><span class="line">                    pIOData-&gt;m_hFileDest = hFileDest;</span><br><span class="line">                    pIOData-&gt;m_hFileMap = hFileMap;</span><br><span class="line">                    pIOData-&gt;m_lpMemory = lpMemory;</span><br><span class="line">                    <span class="comment">// 异步写入目标文件</span></span><br><span class="line">                    lpOverlapped = <span class="keyword">new</span> OVERLAPPED;</span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(lpOverlapped, <span class="built_in">sizeof</span>(OVERLAPPED));</span><br><span class="line">                    lpOverlapped-&gt;Offset = <span class="number">0</span>;</span><br><span class="line">                    lpOverlapped-&gt;OffsetHigh = <span class="number">0</span>;</span><br><span class="line">                    lpOverlapped-&gt;hEvent = pIOData; <span class="comment">// 通过hEvent字段传递给完成例程一个自定义数据结构</span></span><br><span class="line">                    bRet = <span class="built_in">WriteFileEx</span>(hFileDest, lpMemory, dwFileSizeLow, lpOverlapped, OverlappedCompletionRoutine);</span><br><span class="line">                    <span class="comment">// 可以接着去做一些其他事情，这里播放一首音乐</span></span><br><span class="line">                    <span class="built_in">PlaySound</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;爱是一缕寂寞的愁.wav&quot;</span>), <span class="literal">NULL</span>, SND_FILENAME | SND_ASYNC<span class="comment">/* | SND_LOOP*/</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_QUERY: &#123;</span><br><span class="line">                    dwRet = <span class="built_in">SleepEx</span>(INFINITE, TRUE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_CLOSE: &#123;</span><br><span class="line">            <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID WINAPI <span class="title">OverlappedCompletionRoutine</span><span class="params">(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped)</span> </span>&#123;</span><br><span class="line">    PIOData pIOData = (PIOData)(lpOverlapped-&gt;hEvent);</span><br><span class="line">    <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;写入目标文件完成&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">    <span class="comment">// 清理工作</span></span><br><span class="line">    <span class="built_in">UnmapViewOfFile</span>(pIOData-&gt;m_lpMemory);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pIOData-&gt;m_hFileMap);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pIOData-&gt;m_hFileSource);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pIOData-&gt;m_hFileDest);</span><br><span class="line">    <span class="keyword">delete</span> pIOData;</span><br><span class="line">    <span class="keyword">delete</span> lpOverlapped;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="CancelIo"><a href="#CancelIo" class="headerlink" title="CancelIo"></a>CancelIo</h3><p>取消调用线程为指定文件或其他I&#x2F;O设备发出的所有未完成的异步I&#x2F;O操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CancelIo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hFile</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="CancelIoEx"><a href="#CancelIoEx" class="headerlink" title="CancelIoEx"></a>CancelIoEx</h3><p>同上，取消当前进程的另一个线程中异步I&#x2F;O操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CancelIoEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="CancelSynchronousIo"><a href="#CancelSynchronousIo" class="headerlink" title="CancelSynchronousIo"></a>CancelSynchronousIo</h3><p>取消指定线程中未完成的同步I&#x2F;O操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CancelSynchronousIo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hThread</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>线程句柄需要THREAD_TERMINATE访问权限。</p>
<h3 id="QueueUserAPC"><a href="#QueueUserAPC" class="headerlink" title="QueueUserAPC"></a>QueueUserAPC</h3><p>将一个用户模式APC对象添加到指定线程APC队列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">QueueUserAPC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PAPCFUNC pfnAPC, <span class="comment">//APC回调函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hThread, <span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG_PTR dwData <span class="comment">//传递给APC函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">//成功非0 失败0</span></span></span><br></pre></td></tr></table></figure>

<p>APC回调函数定义格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">APCProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG_PTR Parameter <span class="comment">//传递来的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://Monoceros.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://monoceros.github.io/2024/06/12/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E6%96%87%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9B%AE%E5%BD%95/">http://monoceros.github.io/2024/06/12/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E6%96%87%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9B%AE%E5%BD%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Monoceros.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/">逆向工程</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/08/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E8%BF%9B%E7%A8%8B/" title="WindowsAPI查缺补漏-进程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">WindowsAPI查缺补漏-进程</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/12/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="WindowsAPI查缺补漏-内存管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">WindowsAPI查缺补漏-内存管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/16/Angr%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/" title="Angr做题笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-16</div><div class="title">Angr做题笔记</div></div></a></div><div><a href="/2023/10/29/Angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%AC%94%E8%AE%B0/" title="Angr符号执行笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">Angr符号执行笔记</div></div></a></div><div><a href="/2023/11/09/C-%E7%97%85%E6%AF%92%E6%8A%80%E6%9C%AF/" title="C++病毒技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-09</div><div class="title">C++病毒技术</div></div></a></div><div><a href="/2023/11/15/CvxPy%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/" title="CvxPy整数规划笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">CvxPy整数规划笔记</div></div></a></div><div><a href="/2023/10/21/IDA%E5%9C%A8Kali-Linux%E4%B8%8B%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/" title="IDA在Kali Linux下的远程动态调试笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-21</div><div class="title">IDA在Kali Linux下的远程动态调试笔记</div></div></a></div><div><a href="/2023/10/29/IDA%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/" title="IDA脚本编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">IDA脚本编程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">智邮普创工作室安全组/Nepnep联合战队</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">248</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂无公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E6%96%87%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">WindowsAPI查缺补漏-文件驱动器目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%8E%E7%A2%8E%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">碎碎念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.</span> <span class="toc-text">目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SetCurrentDirectory"><span class="toc-number">1.2.1.</span> <span class="toc-text">SetCurrentDirectory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetCurrentDirectory"><span class="toc-number">1.2.2.</span> <span class="toc-text">GetCurrentDirectory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetFullPathName"><span class="toc-number">1.2.3.</span> <span class="toc-text">GetFullPathName</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateFile"><span class="toc-number">1.3.1.</span> <span class="toc-text">CreateFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadFile"><span class="toc-number">1.3.2.</span> <span class="toc-text">ReadFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WriteFile"><span class="toc-number">1.3.3.</span> <span class="toc-text">WriteFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FlushFileBuffers"><span class="toc-number">1.3.4.</span> <span class="toc-text">FlushFileBuffers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetFilePointerEx"><span class="toc-number">1.3.5.</span> <span class="toc-text">SetFilePointerEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetEndOfFile"><span class="toc-number">1.3.6.</span> <span class="toc-text">SetEndOfFile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">文件属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetFileSizeEx"><span class="toc-number">1.4.1.</span> <span class="toc-text">GetFileSizeEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetFileType"><span class="toc-number">1.4.2.</span> <span class="toc-text">GetFileType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetFileTime"><span class="toc-number">1.4.3.</span> <span class="toc-text">GetFileTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetFileTime"><span class="toc-number">1.4.4.</span> <span class="toc-text">SetFileTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetFileAttributes-SetFileAttributes"><span class="toc-number">1.4.5.</span> <span class="toc-text">GetFileAttributes&#x2F;SetFileAttributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetFileAttributesEx"><span class="toc-number">1.4.6.</span> <span class="toc-text">GetFileAttributesEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetFileInformationByHandle-SetFileInformationByHandle"><span class="toc-number">1.4.7.</span> <span class="toc-text">GetFileInformationByHandle&#x2F;SetFileInformationByHandle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">复制文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyFile"><span class="toc-number">1.5.1.</span> <span class="toc-text">CopyFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyFileEx"><span class="toc-number">1.5.2.</span> <span class="toc-text">CopyFileEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PathFileExists"><span class="toc-number">1.5.3.</span> <span class="toc-text">PathFileExists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.5.4.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">1.6.</span> <span class="toc-text">移动与删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MoveFile"><span class="toc-number">1.6.1.</span> <span class="toc-text">MoveFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MoveFileEx"><span class="toc-number">1.6.2.</span> <span class="toc-text">MoveFileEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MoveFileWithProgress"><span class="toc-number">1.6.3.</span> <span class="toc-text">MoveFileWithProgress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeleteFile"><span class="toc-number">1.6.4.</span> <span class="toc-text">DeleteFile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2I-O"><span class="toc-number">1.7.</span> <span class="toc-text">无缓冲I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%A9%B1%E5%8A%A8%E5%99%A8%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">1.8.</span> <span class="toc-text">逻辑驱动器和目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SetVolumeLabel"><span class="toc-number">1.8.1.</span> <span class="toc-text">SetVolumeLabel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetVolumeInformation"><span class="toc-number">1.8.2.</span> <span class="toc-text">GetVolumeInformation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetLogicalDrives"><span class="toc-number">1.8.3.</span> <span class="toc-text">GetLogicalDrives</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetLogicalDriveStrings"><span class="toc-number">1.8.4.</span> <span class="toc-text">GetLogicalDriveStrings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetDriveType"><span class="toc-number">1.8.5.</span> <span class="toc-text">GetDriveType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetDiskFreeSpace"><span class="toc-number">1.8.6.</span> <span class="toc-text">GetDiskFreeSpace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetDiskFreeSpaceEx"><span class="toc-number">1.8.7.</span> <span class="toc-text">GetDiskFreeSpaceEx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.</span> <span class="toc-text">目录操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateDirectory"><span class="toc-number">1.9.1.</span> <span class="toc-text">CreateDirectory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RemoveDirectory"><span class="toc-number">1.9.2.</span> <span class="toc-text">RemoveDirectory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">1.9.3.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetWindowsDirectory"><span class="toc-number">1.9.4.</span> <span class="toc-text">GetWindowsDirectory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetSystemDirectory"><span class="toc-number">1.9.5.</span> <span class="toc-text">GetSystemDirectory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetTempPath"><span class="toc-number">1.9.6.</span> <span class="toc-text">GetTempPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetUserName"><span class="toc-number">1.9.7.</span> <span class="toc-text">GetUserName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHGetKnownFolderPath"><span class="toc-number">1.9.8.</span> <span class="toc-text">SHGetKnownFolderPath</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.10.</span> <span class="toc-text">环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetEnvironmentStrings"><span class="toc-number">1.10.1.</span> <span class="toc-text">GetEnvironmentStrings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetEnvironmentVariable"><span class="toc-number">1.10.2.</span> <span class="toc-text">GetEnvironmentVariable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetEnvironmentVariable"><span class="toc-number">1.10.3.</span> <span class="toc-text">SetEnvironmentVariable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FreeEnvironmentStrings"><span class="toc-number">1.10.4.</span> <span class="toc-text">FreeEnvironmentStrings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExpandEnvironmentStrings"><span class="toc-number">1.10.5.</span> <span class="toc-text">ExpandEnvironmentStrings</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SHFileOperation"><span class="toc-number">1.11.</span> <span class="toc-text">SHFileOperation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E7%9B%AE%E5%BD%95%E5%8F%98%E5%8C%96"><span class="toc-number">1.12.</span> <span class="toc-text">监视目录变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadDirectoryChangesW"><span class="toc-number">1.12.1.</span> <span class="toc-text">ReadDirectoryChangesW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-number">1.12.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%A1%AC%E7%9B%98%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">1.13.</span> <span class="toc-text">获取硬盘序列号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DeviceIoControl"><span class="toc-number">1.13.1.</span> <span class="toc-text">DeviceIoControl</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IOCTL-STORAGE-QUERY-PROPERTY"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">IOCTL_STORAGE_QUERY_PROPERTY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IOCTL-DISK-GET-DRIVE-GEOMETRY-EX"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">IOCTL_DISK_GET_DRIVE_GEOMETRY_EX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SMART-GET-VERSION"><span class="toc-number">1.13.1.3.</span> <span class="toc-text">SMART_GET_VERSION</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-3"><span class="toc-number">1.13.2.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WMI%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF"><span class="toc-number">1.13.3.</span> <span class="toc-text">WMI管理技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E5%92%8CU%E7%9B%98%E7%9B%91%E6%8E%A7"><span class="toc-number">1.14.</span> <span class="toc-text">可移动硬盘和U盘监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-4"><span class="toc-number">1.14.1.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%BB%E6%9D%BF%E5%92%8CBIOS%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">1.15.</span> <span class="toc-text">获取主板和BIOS序列号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetSystemFirmwareTable"><span class="toc-number">1.15.1.</span> <span class="toc-text">GetSystemFirmwareTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-5"><span class="toc-number">1.15.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">1.16.</span> <span class="toc-text">内存映射文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateFileMapping"><span class="toc-number">1.16.1.</span> <span class="toc-text">CreateFileMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MapViewOfFile"><span class="toc-number">1.16.2.</span> <span class="toc-text">MapViewOfFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MapViewOfFileEx"><span class="toc-number">1.16.3.</span> <span class="toc-text">MapViewOfFileEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OverFileMapping"><span class="toc-number">1.16.4.</span> <span class="toc-text">OverFileMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FlushViewOfFile"><span class="toc-number">1.16.5.</span> <span class="toc-text">FlushViewOfFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UnmapViewOfFile"><span class="toc-number">1.16.6.</span> <span class="toc-text">UnmapViewOfFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-6"><span class="toc-number">1.16.7.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">1.16.8.</span> <span class="toc-text">多进程间数据共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CoCreateGuid"><span class="toc-number">1.16.9.</span> <span class="toc-text">CoCreateGuid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-7"><span class="toc-number">1.16.10.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%9E%8B%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">1.16.11.</span> <span class="toc-text">大型文件处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APC%E5%BC%82%E6%AD%A5%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">1.17.</span> <span class="toc-text">APC异步过程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadFileEx-WriteFileEx"><span class="toc-number">1.17.1.</span> <span class="toc-text">ReadFileEx&#x2F;WriteFileEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-8"><span class="toc-number">1.17.2.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CancelIo"><span class="toc-number">1.17.3.</span> <span class="toc-text">CancelIo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CancelIoEx"><span class="toc-number">1.17.4.</span> <span class="toc-text">CancelIoEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CancelSynchronousIo"><span class="toc-number">1.17.5.</span> <span class="toc-text">CancelSynchronousIo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QueueUserAPC"><span class="toc-number">1.17.6.</span> <span class="toc-text">QueueUserAPC</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/14/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" title="WindowsAPI查缺补漏-动态链接库">WindowsAPI查缺补漏-动态链接库</a><time datetime="2024-07-14T07:41:58.000Z" title="发表于 2024-07-14 15:41:58">2024-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/13/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%89%AA%E8%B4%B4%E6%9D%BF/" title="WindowsAPI查缺补漏-剪贴板">WindowsAPI查缺补漏-剪贴板</a><time datetime="2024-07-13T08:21:18.000Z" title="发表于 2024-07-13 16:21:18">2024-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/08/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E8%BF%9B%E7%A8%8B/" title="WindowsAPI查缺补漏-进程">WindowsAPI查缺补漏-进程</a><time datetime="2024-07-08T10:28:14.000Z" title="发表于 2024-07-08 18:28:14">2024-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/12/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E6%96%87%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9B%AE%E5%BD%95/" title="WindowsAPI查缺补漏-文件驱动器目录">WindowsAPI查缺补漏-文件驱动器目录</a><time datetime="2024-06-12T13:04:28.000Z" title="发表于 2024-06-12 21:04:28">2024-06-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/12/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="WindowsAPI查缺补漏-内存管理">WindowsAPI查缺补漏-内存管理</a><time datetime="2024-06-12T06:43:32.000Z" title="发表于 2024-06-12 14:43:32">2024-06-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>