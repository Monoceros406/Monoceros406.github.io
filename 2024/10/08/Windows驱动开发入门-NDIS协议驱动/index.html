<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Windows驱动开发入门-NDIS协议驱动 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Windows驱动开发入门-NDIS协议驱动碎碎念本节代码需要最低警告、关警告按错误处理、关符合模式、关SDL检查、导入ndis.lib和wdmsec.lib。可直接参考Github上微软官方的驱动代码示例库的ndisprot工程。本节代码用传统型驱动编码方式，后面NDIS小端口驱动将用WDF驱动编码方式。 最常用的Ethernet V2(ARPA)以太网包如下，若类型2字节为0x80、0x00则">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows驱动开发入门-NDIS协议驱动">
<meta property="og:url" content="https://monoceros406.github.io/2024/10/08/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-NDIS%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="Windows驱动开发入门-NDIS协议驱动碎碎念本节代码需要最低警告、关警告按错误处理、关符合模式、关SDL检查、导入ndis.lib和wdmsec.lib。可直接参考Github上微软官方的驱动代码示例库的ndisprot工程。本节代码用传统型驱动编码方式，后面NDIS小端口驱动将用WDF驱动编码方式。 最常用的Ethernet V2(ARPA)以太网包如下，若类型2字节为0x80、0x00则">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://monoceros406.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-10-08T11:20:42.000Z">
<meta property="article:modified_time" content="2025-05-11T02:15:52.929Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="Win驱动开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://monoceros406.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://monoceros406.github.io/2024/10/08/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-NDIS%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Windows驱动开发入门-NDIS协议驱动',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-11 10:15:52'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="The Blog of Monoceros406" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">324</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/ycy')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Windows驱动开发入门-NDIS协议驱动</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-08T11:20:42.000Z" title="发表于 2024-10-08 19:20:42">2024-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-11T02:15:52.929Z" title="更新于 2025-05-11 10:15:52">2025-05-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Windows驱动开发入门-NDIS协议驱动"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Windows驱动开发入门-NDIS协议驱动"><a href="#Windows驱动开发入门-NDIS协议驱动" class="headerlink" title="Windows驱动开发入门-NDIS协议驱动"></a>Windows驱动开发入门-NDIS协议驱动</h1><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>本节代码需要最低警告、关警告按错误处理、关符合模式、关SDL检查、导入ndis.lib和wdmsec.lib。可直接参考Github上微软官方的驱动代码示例库的ndisprot工程。本节代码用传统型驱动编码方式，后面NDIS小端口驱动将用WDF驱动编码方式。</p>
<p>最常用的Ethernet V2(ARPA)以太网包如下，若类型2字节为0x80、0x00则表示为IP包。</p>
<table>
<thead>
<tr>
<th>低地址</th>
<th></th>
<th></th>
<th>高地址</th>
</tr>
</thead>
<tbody><tr>
<td>源网卡MAC地址</td>
<td>目标网卡MAC地址</td>
<td>类型</td>
<td>数据</td>
</tr>
<tr>
<td>6字节</td>
<td>6字节</td>
<td>2字节</td>
<td>其他</td>
</tr>
</tbody></table>
<p>协议驱动接收上层用户的Socket请求，把这些数据封装为IP包，再把IP包封装成以太网包发送出去；接收到以太网包时，分析这时给哪个用户程序的，把用户数据解析出来，提交给上层应用程序。协议驱动较多用于嗅探，如Wincap，一般不用于防火墙，应为这玩意儿不好干预应用程序发送或接收包。</p>
<p>网卡驱动接口标准NDIS是一组定义好的函数接口的集合。NDIS网络驱动有三种：协议驱动、小端口驱动、中间层驱动（包含过滤驱动），开发者可提供这三种不同的内核模块给NDIS使用。协议驱动上层提供直接供应用层Socket使用的数据传输接口，下层绑定小端口，用于发送与接收以太网包。小端口驱动针对网卡，给协议层提供接收和发送数据包的能力。传统中间层驱动即将被过滤驱动淘汰，在协议驱动和小端口驱动之间。</p>
<p>开发历程为：填写协议特征（协议回调函数列表）；把自己注册为协议驱动；系统对每个实际存在的网卡实例调用本协议驱动在协议特征集中提供的一个回调函数，在该回调函数中决定是否要绑定一个网卡，一旦绑定，该网卡接收到的包将提交给该协议驱动，后者也可用该网卡发送包；发生各种事件时，如网卡接收到一个新数据包，特征集中某个函数被调用，后者决定如何处理接收到的数据包；当应用层试图发送一个以太网包时，可打开该协议并发出请求。</p>
<h2 id="协议驱动入口"><a href="#协议驱动入口" class="headerlink" title="协议驱动入口"></a>协议驱动入口</h2><p>要做的有：生成一个控制设备和一个符号链接，指定分发函数；注册一个协议，提供协议特征。入口在ntdisp.c中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT   pDriverObject, IN PUNICODE_STRING  pRegistryPath)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*++</span></span></span><br><span class="line"><span class="comment"><span class="function">Routine Description:</span></span></span><br><span class="line"><span class="comment"><span class="function">    Called on loading. We create a device object to handle user-mode requests on, and register ourselves as a protocol with NDIS.</span></span></span><br><span class="line"><span class="comment"><span class="function">Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function">    pDriverObject - Pointer to driver object created by system.</span></span></span><br><span class="line"><span class="comment"><span class="function">    pRegistryPath - Pointer to the Unicode name of the registry path for this driver.</span></span></span><br><span class="line"><span class="comment"><span class="function">Return Value:</span></span></span><br><span class="line"><span class="comment"><span class="function">    NT Status code</span></span></span><br><span class="line"><span class="comment"><span class="function">--*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NDIS_PROTOCOL_CHARACTERISTICS   protocolChar; <span class="comment">//协议特征</span></span><br><span class="line">    NTSTATUS                        status = STATUS_SUCCESS; <span class="comment">//状态变量 返回值</span></span><br><span class="line">    NDIS_STRING                     protoName = <span class="built_in">NDIS_STRING_CONST</span>(<span class="string">&quot;NdisProt&quot;</span>);</span><br><span class="line">    UNICODE_STRING                  ntDeviceName;</span><br><span class="line">    UNICODE_STRING                  win32DeviceName;</span><br><span class="line">    BOOLEAN                         fSymbolicLink = FALSE;</span><br><span class="line">    PDEVICE_OBJECT                  deviceObject = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pRegistryPath);</span><br><span class="line">    <span class="built_in">DEBUGP</span>(DL_LOUD, (<span class="string">&quot;DriverEntry\n&quot;</span>));</span><br><span class="line">    Globals.pDriverObject = pDriverObject;</span><br><span class="line">    <span class="built_in">NPROT_INIT_EVENT</span>(&amp;Globals.BindsComplete);</span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">//这里do-while当作try来用 出错用break快速退出</span></span><br><span class="line">        <span class="comment">// Create our device object using which an application can access NDIS devices.</span></span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;ntDeviceName, NT_DEVICE_NAME); <span class="comment">//初始化控制设备名</span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifndef</span> WIN9X</span></span><br><span class="line">        status = <span class="built_in">IoCreateDeviceSecure</span>(pDriverObject, <span class="number">0</span>, &amp;ntDeviceName, FILE_DEVICE_NETWORK, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;SDDL_DEVOBJ_SYS_ALL_ADM_ALL, <span class="literal">NULL</span>, &amp;deviceObject); <span class="comment">//生成设备</span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        status = <span class="built_in">IoCreateDevice</span>(pDriverObject, <span class="number">0</span>, &amp;ntDeviceName, FILE_DEVICE_NETWORK, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;deviceObject);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="comment">// Either not enough memory to create a deviceobject or another deviceobject with the same name exits. This could happen if you install another instance of this device.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;win32DeviceName, DOS_DEVICE_NAME);</span><br><span class="line">        status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;win32DeviceName, &amp;ntDeviceName); <span class="comment">//生成符号链接</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        fSymbolicLink = TRUE;</span><br><span class="line">        deviceObject-&gt;Flags |= DO_DIRECT_IO; <span class="comment">//直接IO方式</span></span><br><span class="line">        Globals.ControlDeviceObject = deviceObject; <span class="comment">//控制设备指针</span></span><br><span class="line">        <span class="built_in">NPROT_INIT_LIST_HEAD</span>(&amp;Globals.OpenList); <span class="comment">//初始化链表</span></span><br><span class="line">        <span class="built_in">NPROT_INIT_LOCK</span>(&amp;Globals.GlobalLock); <span class="comment">//初始化一个锁</span></span><br><span class="line">        <span class="comment">// Initialize the protocol characterstic structure</span></span><br><span class="line">        <span class="built_in">NdisZeroMemory</span>(&amp;protocolChar, <span class="built_in">sizeof</span>(NDIS_PROTOCOL_CHARACTERISTICS)); <span class="comment">//填写协议特征</span></span><br><span class="line">        protocolChar.MajorNdisVersion = <span class="number">5</span>;</span><br><span class="line">        protocolChar.MinorNdisVersion = <span class="number">0</span>;</span><br><span class="line">        protocolChar.Name = protoName;</span><br><span class="line">        protocolChar.OpenAdapterCompleteHandler = NdisProtOpenAdapterComplete;</span><br><span class="line">        protocolChar.CloseAdapterCompleteHandler = NdisProtCloseAdapterComplete; <span class="comment">//关闭完成回调</span></span><br><span class="line">        protocolChar.SendCompleteHandler = NdisProtSendComplete;</span><br><span class="line">        protocolChar.TransferDataCompleteHandler = NdisProtTransferDataComplete;</span><br><span class="line">        protocolChar.ResetCompleteHandler = NdisProtResetComplete;</span><br><span class="line">        protocolChar.RequestCompleteHandler = NdisProtRequestComplete; <span class="comment">//请求发送后未决 完成时调用该完成函数</span></span><br><span class="line">        protocolChar.ReceiveHandler = NdisProtReceive;</span><br><span class="line">        protocolChar.ReceiveCompleteHandler = NdisProtReceiveComplete;</span><br><span class="line">        protocolChar.StatusHandler = NdisProtStatus;</span><br><span class="line">        protocolChar.StatusCompleteHandler = NdisProtStatusComplete;</span><br><span class="line">        protocolChar.BindAdapterHandler = NdisProtBindAdapter; <span class="comment">//内核检测到网卡存在时 调用每个注册过的协议的该回调函数</span></span><br><span class="line">        protocolChar.UnbindAdapterHandler = NdisProtUnbindAdapter; <span class="comment">//解绑回调</span></span><br><span class="line">        protocolChar.UnloadHandler = <span class="literal">NULL</span>;</span><br><span class="line">        protocolChar.ReceivePacketHandler = NdisProtReceivePacket;</span><br><span class="line">        protocolChar.PnPEventHandler = NdisProtPnPEventHandler;</span><br><span class="line">        <span class="comment">// Register as a protocol driver</span></span><br><span class="line">        <span class="built_in">NdisRegisterProtocol</span>((PNDIS_STATUS)&amp;status, &amp;Globals.NdisProtocolHandle, &amp;protocolChar, <span class="built_in">sizeof</span>(NDIS_PROTOCOL_CHARACTERISTICS)); <span class="comment">//注册协议</span></span><br><span class="line">        <span class="keyword">if</span> (status != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;Failed to register protocol with NDIS\n&quot;</span>));</span><br><span class="line">            status = STATUS_UNSUCCESSFUL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> NDIS51</span></span><br><span class="line">        Globals.PartialCancelId = <span class="built_in">NdisGeneratePartialCancelId</span>();</span><br><span class="line">        Globals.PartialCancelId &lt;&lt;= ((<span class="built_in">sizeof</span>(PVOID) - <span class="number">1</span>) * <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">DEBUGP</span>(DL_LOUD, (<span class="string">&quot;DriverEntry: CancelId %lx\n&quot;</span>, Globals.PartialCancelId));</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// Now set only the dispatch points we would like to handle.</span></span><br><span class="line">        pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = NdisProtOpen; <span class="comment">//填写分发函数</span></span><br><span class="line">        pDriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = NdisProtClose;</span><br><span class="line">        pDriverObject-&gt;MajorFunction[IRP_MJ_READ] = NdisProtRead;</span><br><span class="line">        pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = NdisProtWrite;</span><br><span class="line">        pDriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = NdisProtCleanup;</span><br><span class="line">        pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = NdisProtIoControl;</span><br><span class="line">        pDriverObject-&gt;DriverUnload = NdisProtUnload;</span><br><span class="line">        status = STATUS_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123; <span class="comment">//失败则释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (deviceObject) &#123;</span><br><span class="line">            <span class="built_in">IoDeleteDevice</span>(deviceObject);</span><br><span class="line">            Globals.ControlDeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (fSymbolicLink)</span><br><span class="line">            <span class="built_in">IoDeleteSymbolicLink</span>(&amp;win32DeviceName);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="协议与网卡绑定"><a href="#协议与网卡绑定" class="headerlink" title="协议与网卡绑定"></a>协议与网卡绑定</h2><p>当一个协议驱动绑定了一个网卡时，网卡收到的数据包会提交给该协议，协议可用该网卡发送数据包。网卡也可以是虚拟网卡。本小节详细讲<code>NdisProtBindAdapter</code>内部工作原理，想直接开发的就跳过本小节。</p>
<p>协议驱动的打开上下文：打开指的是打开网卡，也就是绑定网卡，NDIS中用<code>NdisOpenAdapter</code>。该驱动中每当有一个网卡被绑定，就分配一个内存空间来保存和这次绑定相关的信息，以及本次绑定所需要用到的资源，如锁和队列等。</p>
<p><code>NdisProtBindAdapter</code>工作有：打开上下文的分配和初始化；将打开的上下文保存到全局链表中，完成绑定。代码在ndisbind.c中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">NdisProtBindAdapter</span><span class="params">(OUT PNDIS_STATUS pStatus, IN NDIS_HANDLE BindContext, IN PNDIS_STRING pDeviceName, IN PVOID SystemSpecific1, IN PVOID SystemSpecific2)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*++</span></span></span><br><span class="line"><span class="comment"><span class="function">Routine Description:</span></span></span><br><span class="line"><span class="comment"><span class="function">    Protocol Bind Handler entry point called when NDIS wants us to bind to an adapter. We go ahead and set up a binding. An OPEN_CONTEXT structure is allocated to keep state about this binding.</span></span></span><br><span class="line"><span class="comment"><span class="function">Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function">    pStatus - place to return bind status</span></span></span><br><span class="line"><span class="comment"><span class="function">    BindContext - handle to use with NdisCompleteBindAdapter</span></span></span><br><span class="line"><span class="comment"><span class="function">    DeviceName - adapter to bind to</span></span></span><br><span class="line"><span class="comment"><span class="function">    SystemSpecific1 - used to access protocol-specific registry key for this binding</span></span></span><br><span class="line"><span class="comment"><span class="function">    SystemSpecific2 - unused</span></span></span><br><span class="line"><span class="comment"><span class="function">Return Value:</span></span></span><br><span class="line"><span class="comment"><span class="function">    None</span></span></span><br><span class="line"><span class="comment"><span class="function">--*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT           pOpenContext;</span><br><span class="line">    NDIS_STATUS                     Status, ConfigStatus;</span><br><span class="line">    NDIS_HANDLE                     ConfigHandle;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(BindContext);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(SystemSpecific2);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//  Allocate our context for this open.</span></span><br><span class="line">        <span class="comment">// 分配空间给每个打开上下文。所谓打开上下文就是每次绑定，用户分配的一片空间，用来保存这次绑定相关的信息。这里用宏NPROT_ALLOC_MEM分配内存是为了调试的方便。实际上本质是用NdisAllocateMemoryWithTag分配空间。读者如果用ExAllocatePoolWithTag代替也是可行的。只是要注意必须是Nonpaged空间。</span></span><br><span class="line">        <span class="built_in">NPROT_ALLOC_MEM</span>(pOpenContext, <span class="built_in">sizeof</span>(NDISPROT_OPEN_CONTEXT));</span><br><span class="line">        <span class="keyword">if</span> (pOpenContext == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Status = NDIS_STATUS_RESOURCES;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 内存清0。同样用宏。实际上用的NdisZeroMemory。</span></span><br><span class="line">        <span class="built_in">NPROT_ZERO_MEM</span>(pOpenContext, <span class="built_in">sizeof</span>(NDISPROT_OPEN_CONTEXT));</span><br><span class="line">        <span class="comment">// 给这个空间写一个特征数据便于识别判错。</span></span><br><span class="line">        <span class="built_in">NPROT_SET_SIGNATURE</span>(pOpenContext, oc);</span><br><span class="line">        <span class="comment">// 初始化几个用到的数据成员。锁、读队列、写对队列、包队列</span></span><br><span class="line">        <span class="comment">// 电源打开事件</span></span><br><span class="line">        <span class="built_in">NPROT_INIT_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="built_in">NPROT_INIT_LIST_HEAD</span>(&amp;pOpenContext-&gt;PendedReads);</span><br><span class="line">        <span class="built_in">NPROT_INIT_LIST_HEAD</span>(&amp;pOpenContext-&gt;PendedWrites);</span><br><span class="line">        <span class="built_in">NPROT_INIT_LIST_HEAD</span>(&amp;pOpenContext-&gt;RecvPktQueue);</span><br><span class="line">        <span class="built_in">NPROT_INIT_EVENT</span>(&amp;pOpenContext-&gt;PoweredUpEvent);</span><br><span class="line">        <span class="comment">//  Start off by assuming that the device below is powered up.</span></span><br><span class="line">        <span class="comment">// 认为开始的时候电源是打开的。</span></span><br><span class="line">        <span class="built_in">NPROT_SIGNAL_EVENT</span>(&amp;pOpenContext-&gt;PoweredUpEvent);</span><br><span class="line">        <span class="comment">//  Determine the platform we are running on.</span></span><br><span class="line">        <span class="comment">// 下面开始检测我们运行在什么平台。首先假定是Win9x.但是为了去掉多余的部分，实际上我已经去掉了对Win9x的支持。所以下面这一段已经没有意义了。但是下面的代码依然有参考价值。实际上是在读取注册表的配置。</span></span><br><span class="line">        <span class="comment">//pOpenContext-&gt;bRunningOnWin9x = TRUE;</span></span><br><span class="line">        <span class="comment">//NdisOpenProtocolConfiguration(&amp;ConfigStatus,&amp;ConfigHandle,(PNDIS_STRING)SystemSpecific1);</span></span><br><span class="line">        <span class="comment">//if (ConfigStatus == NDIS_STATUS_SUCCESS)&#123;</span></span><br><span class="line">        <span class="comment">//    PNDIS_CONFIGURATION_PARAMETER   pParameter;</span></span><br><span class="line">        <span class="comment">//    NDIS_STRING                     VersionKey = NDIS_STRING_CONST(&quot;Environment&quot;);</span></span><br><span class="line">        <span class="comment">//    NdisReadConfiguration(&amp;ConfigStatus,&amp;pParameter,ConfigHandle,&amp;VersionKey,NdisParameterInteger);</span></span><br><span class="line">        <span class="comment">//    if ((ConfigStatus == NDIS_STATUS_SUCCESS) &amp;&amp; ((pParameter-&gt;ParameterType == NdisParameterInteger) || (pParameter-&gt;ParameterType == NdisParameterHexInteger)))</span></span><br><span class="line">        <span class="comment">//        pOpenContext-&gt;bRunningOnWin9x = (pParameter-&gt;ParameterData.IntegerData == NdisEnvironmentWindows);</span></span><br><span class="line">        <span class="comment">//    NdisCloseConfiguration(ConfigHandle);</span></span><br><span class="line">        <span class="comment">//&#125;;</span></span><br><span class="line">        <span class="built_in">NPROT_REF_OPEN</span>(pOpenContext);</span><br><span class="line">        <span class="comment">//  Add it to the global list.</span></span><br><span class="line">        <span class="comment">// 因为打开上下文已经被分配好。所以这里将这个打开上下文保存到全局链表里以便日后检索。注意这个操作要加锁。实际上这里用的就是读者前面学过的自旋锁。</span></span><br><span class="line">        <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;Globals.GlobalLock);</span><br><span class="line">        <span class="built_in">NPROT_INSERT_TAIL_LIST</span>(&amp;Globals.OpenList, &amp;pOpenContext-&gt;Link);</span><br><span class="line">        <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;Globals.GlobalLock);</span><br><span class="line">        <span class="comment">// 正式的绑定过程。</span></span><br><span class="line">        Status = <span class="built_in">ndisprotCreateBinding</span>(pOpenContext, (PUCHAR)pDeviceName-&gt;Buffer, pDeviceName-&gt;Length);</span><br><span class="line">        <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    *pStatus = Status;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>协议绑定网卡用<code>NdisOpenAdapter</code>，原型如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">NdisOpenAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PNDIS_STATUS Status, <span class="comment">//状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PNDIS_STATUS OpenErrorStatus, <span class="comment">//错误码</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PNDIS_HANDLE NdisBindingHandle, <span class="comment">//绑定句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PUINT SelectedMediumIndex, <span class="comment">//最终选择的媒质类型数组下标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PNDIS_MEDIUM MediumArrary, <span class="comment">//该协议支持的所有媒质类型 本章内容只有NdisMedium802_3</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT MediumArraySize, <span class="comment">//媒质数组大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ NDIS_HANDLE NdisProtocolHandle, <span class="comment">//协议句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ NDIS_HANDLE ProtocolBindingContext, <span class="comment">//上下文指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PNDIS_STRING AdapterName, <span class="comment">//要绑定的网卡名</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT OpenOptions, <span class="comment">//0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PSTRING AddressingInformation <span class="comment">//用来编码网卡的地址 一般NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>ndisprotCreateBinding</code>工作有：防止多线程竞争；分配和初始化本次绑定的相关资源；获得网卡参数，代码如下。</p>
<p>自旋锁会提高中断级别，在此之后很多事情就不能做了。自旋锁非常消耗资源，在锁住时会不断重试，此时不宜做耗时长、复杂的操作。</p>
<p>需要分配的资源有输入和输出缓冲区的包池和缓冲池。包池是一组预先分配好的包描述符，缓冲池是一组已分配好的包缓冲区描述符。每个以太网包都用一个NDIS_PACKET包描述符来描述，实际内容包含在NDIS_BUFFER包缓冲区描述符。网卡接收到包后要保存到报池中等待上层应用程序取走，上层应用程序要求发送的包先保存在包池中再发送出去。这样在具体有以太网包需要存入时，不用再次分配包描述符和包缓冲区描述符，以此减少动态分配内存的消耗。</p>
<p>NDIS对象描述符OID是一组系统定义的常熟，每个OID为一个请求的类型号。NDIS上层驱动可以给下层驱动发送OID请求，下层驱动必需返回约定的结果。如可以获取网卡MAC地址、最大帧长等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NDIS_STATUS <span class="title">ndisprotCreateBinding</span><span class="params">(IN PNDISPROT_OPEN_CONTEXT pOpenContext,__in_bcount(BindingInfoLength) IN PUCHAR pBindingInfo,IN ULONG BindingInfoLength)</span> </span>&#123;</span><br><span class="line">    NDIS_STATUS Status;</span><br><span class="line">    NDIS_STATUS  OpenErrorCode;</span><br><span class="line">    NDIS_MEDIUM  MediumArray[<span class="number">1</span>] = &#123; NdisMedium802_3 &#125;;</span><br><span class="line">    UINT  SelectedMediumIndex;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT  pTmpOpenContext;</span><br><span class="line">    BOOLEAN  fDoNotDisturb = FALSE;</span><br><span class="line">    BOOLEAN  fOpenComplete = FALSE;</span><br><span class="line">    ULONG  BytesProcessed;</span><br><span class="line">    ULONG GenericUlong = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输出一句调试信息。</span></span><br><span class="line">    <span class="built_in">DEBUGP</span>(DL_LOUD, (<span class="string">&quot;CreateBinding: open %p/%x, device [%ws]\n&quot;</span>,pOpenContext, pOpenContext-&gt;Flags, pBindingInfo));</span><br><span class="line">    Status = NDIS_STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 检查看看是否已经绑定了这个网卡。如果已经绑定的话，就没有必要再次绑定了，直接返回成功即可。请注意，ndisprotLookupDevice会给这个打开上下文增加一个引用。</span></span><br><span class="line">        pTmpOpenContext = <span class="built_in">ndisprotLookupDevice</span>(pBindingInfo, BindingInfoLength);</span><br><span class="line">        <span class="comment">// 如果没有找到的话，就返回NULL了。</span></span><br><span class="line">        <span class="keyword">if</span> (pTmpOpenContext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;CreateBinding: Binding to device %ws already exists on open %p\n&quot;</span>, pTmpOpenContext-&gt;DeviceName.Buffer, pTmpOpenContext));</span><br><span class="line">            <span class="comment">// 减少这个打开上下文的一个引用。</span></span><br><span class="line">            <span class="built_in">NPROT_DEREF_OPEN</span>(pTmpOpenContext);</span><br><span class="line">            Status = NDIS_STATUS_FAILURE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 获得锁。为什么这里要用锁？这是因为只有对空闲的打开上下文</span></span><br><span class="line">        <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="comment">// 通过标记来检查...如果绑定标志不是空闲状态，或者解除绑定信息收到了解除绑定的要求，那就直接返回失败。 NUIOO_BIND_IDLE当pOpenContext有绑定已完成、或正进行绑定、或有其他操作时不为0</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NPROT_TEST_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_IDLE) || <span class="built_in">NPROT_TEST_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_UNBIND_FLAGS, NUIOO_UNBIND_RECEIVED)) &#123;</span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock); <span class="comment">//释放锁</span></span><br><span class="line">            Status = NDIS_STATUS_NOT_ACCEPTED;</span><br><span class="line">            <span class="comment">// 设置了标记，表示</span></span><br><span class="line">            fDoNotDisturb = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 设置标记，表示我们已经开始绑定了。别人勿操作它。</span></span><br><span class="line">        <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_OPENING);</span><br><span class="line">        <span class="comment">// 释放锁。</span></span><br><span class="line">        <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="comment">// 以下开始绑定 不用担心其他线程进入这里</span></span><br><span class="line">        <span class="comment">// 分配名字。到这里开始绑定了。先分配设备名字符串。</span></span><br><span class="line">        <span class="built_in">NPROT_ALLOC_MEM</span>(pOpenContext-&gt;DeviceName.Buffer, BindingInfoLength + <span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line">        <span class="keyword">if</span> (pOpenContext-&gt;DeviceName.Buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;CreateBinding: failed to alloc device name buf (%d bytes)\n&quot;</span>, BindingInfoLength + <span class="built_in">sizeof</span>(WCHAR)));</span><br><span class="line">            Status = NDIS_STATUS_RESOURCES;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 从pBindingInfo中把字符串拷贝出来。</span></span><br><span class="line">        <span class="built_in">NPROT_COPY_MEM</span>(pOpenContext-&gt;DeviceName.Buffer, pBindingInfo, BindingInfoLength);</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> prefast(suppress: 12009, <span class="string">&quot;DeviceName length will not cause overflow&quot;</span>)</span></span><br><span class="line">        * (PWCHAR)((PUCHAR)pOpenContext-&gt;DeviceName.Buffer + BindingInfoLength) = <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">NdisInitUnicodeString</span>(&amp;pOpenContext-&gt;DeviceName, pOpenContext-&gt;DeviceName.Buffer);</span><br><span class="line">        <span class="comment">// 分配包池。用来做发送缓冲区，容纳将要发送出去的包。</span></span><br><span class="line">        <span class="built_in">NdisAllocatePacketPoolEx</span>(&amp;Status,&amp;pOpenContext-&gt;SendPacketPool,MIN_SEND_PACKET_POOL_SIZE,MAX_SEND_PACKET_POOL_SIZE - MIN_SEND_PACKET_POOL_SIZE,<span class="built_in">sizeof</span>(NPROT_SEND_PACKET_RSVD)); <span class="comment">//pOpenContext-&gt;SendPacketPool为发送缓冲区包池</span></span><br><span class="line">        <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;CreateBinding: failed to alloc send packet pool: %x\n&quot;</span>, Status));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 分配包池，用来容纳</span></span><br><span class="line">        <span class="built_in">NdisAllocatePacketPoolEx</span>(&amp;Status,&amp;pOpenContext-&gt;RecvPacketPool,MIN_RECV_PACKET_POOL_SIZE,MAX_RECV_PACKET_POOL_SIZE - MIN_RECV_PACKET_POOL_SIZE,<span class="built_in">sizeof</span>(NPROT_RECV_PACKET_RSVD));</span><br><span class="line">        <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;CreateBinding: failed to alloc recv packet pool: %x\n&quot;</span>, Status));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 包池。用来做接收缓冲区。</span></span><br><span class="line">        <span class="built_in">NdisAllocateBufferPool</span>(&amp;Status,&amp;pOpenContext-&gt;RecvBufferPool,MAX_RECV_PACKET_POOL_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;CreateBinding: failed to alloc recv buffer pool: %x\n&quot;</span>, Status));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 电源状态是打开着的。</span></span><br><span class="line">        pOpenContext-&gt;PowerState = NetDeviceStateD0;</span><br><span class="line">        <span class="comment">// 初始化一个打开事件。（打开就是绑定！）</span></span><br><span class="line">        <span class="built_in">NPROT_INIT_EVENT</span>(&amp;pOpenContext-&gt;BindEvent);</span><br><span class="line">        <span class="built_in">NdisOpenAdapter</span>(&amp;Status,&amp;OpenErrorCode,&amp;pOpenContext-&gt;BindingHandle,&amp;SelectedMediumIndex,&amp;MediumArray[<span class="number">0</span>],<span class="built_in">sizeof</span>(MediumArray) / <span class="built_in">sizeof</span>(NDIS_MEDIUM),Globals.NdisProtocolHandle,(NDIS_HANDLE)pOpenContext,&amp;pOpenContext-&gt;DeviceName,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 等待请求完成。</span></span><br><span class="line">        <span class="keyword">if</span> (Status == NDIS_STATUS_PENDING) &#123;</span><br><span class="line">            <span class="built_in">NPROT_WAIT_EVENT</span>(&amp;pOpenContext-&gt;BindEvent, <span class="number">0</span>);</span><br><span class="line">            Status = pOpenContext-&gt;BindStatus;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 如果不成功</span></span><br><span class="line">        <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;CreateBinding: NdisOpenAdapter (%ws) failed: %x\n&quot;</span>, pOpenContext-&gt;DeviceName.Buffer, Status));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 记住我们已经成功的绑定了。但是我们还没有更新打开状态。这是为了避免别的线程开始关闭这个绑定。</span></span><br><span class="line">        fOpenComplete = TRUE;</span><br><span class="line">        <span class="comment">// 发请求，获得一个可阅读的名字。不过这并不是非成功不可的。所以不检查返回值。</span></span><br><span class="line">        (VOID)<span class="built_in">NdisQueryAdapterInstanceName</span>(&amp;pOpenContext-&gt;DeviceDescr,pOpenContext-&gt;BindingHandle);</span><br><span class="line">        <span class="comment">// 获得下面网卡的Mac地址</span></span><br><span class="line">        Status = <span class="built_in">ndisprotDoRequest</span>(pOpenContext,NdisRequestQueryInformation,OID_802_3_CURRENT_ADDRESS,&amp;pOpenContext-&gt;CurrentAddress[<span class="number">0</span>],NPROT_MAC_ADDR_LEN,&amp;BytesProcessed);</span><br><span class="line">        <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;CreateBinding: qry current address failed: %x\n&quot;</span>, Status));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 获得网卡选项</span></span><br><span class="line">        Status = <span class="built_in">ndisprotDoRequest</span>(pOpenContext,NdisRequestQueryInformation,OID_GEN_MAC_OPTIONS,&amp;pOpenContext-&gt;MacOptions,<span class="built_in">sizeof</span>(pOpenContext-&gt;MacOptions),&amp;BytesProcessed);</span><br><span class="line">        <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;CreateBinding: qry MAC options failed: %x\n&quot;</span>, Status));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 获得最大帧长</span></span><br><span class="line">        Status = <span class="built_in">ndisprotDoRequest</span>(pOpenContext,NdisRequestQueryInformation,OID_GEN_MAXIMUM_FRAME_SIZE,&amp;pOpenContext-&gt;MaxFrameSize,<span class="built_in">sizeof</span>(pOpenContext-&gt;MaxFrameSize),&amp;BytesProcessed);</span><br><span class="line">        <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;CreateBinding: qry max frame failed: %x\n&quot;</span>, Status));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 获得下层连接状态。</span></span><br><span class="line">        Status = <span class="built_in">ndisprotDoRequest</span>(pOpenContext,NdisRequestQueryInformation,OID_GEN_MEDIA_CONNECT_STATUS,&amp;GenericUlong,<span class="built_in">sizeof</span>(GenericUlong),&amp;BytesProcessed);</span><br><span class="line">        <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;CreateBinding: qry media connect status failed: %x\n&quot;</span>, Status));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (GenericUlong == NdisMediaStateConnected)</span><br><span class="line">            <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_MEDIA_FLAGS, NUIOO_MEDIA_CONNECTED);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_MEDIA_FLAGS, NUIOO_MEDIA_DISCONNECTED);</span><br><span class="line">        <span class="comment">// 设置标记</span></span><br><span class="line">        <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE);</span><br><span class="line">        <span class="comment">// 检测是否这时候出现了一个解除绑定请求</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NPROT_TEST_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_UNBIND_FLAGS, NUIOO_UNBIND_RECEIVED))</span><br><span class="line">            <span class="comment">// 出现了则这次绑定失败</span></span><br><span class="line">            Status = NDIS_STATUS_FAILURE;</span><br><span class="line">        <span class="comment">// 标记测试完之后就可以解锁了。</span></span><br><span class="line">        <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    <span class="comment">// 如果没有成功，而且fDoNotDisturb为FALSE</span></span><br><span class="line">    <span class="keyword">if</span> ((Status != NDIS_STATUS_SUCCESS) &amp;&amp; !fDoNotDisturb) &#123;</span><br><span class="line">        <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="comment">// 如果是已经成功的绑定了</span></span><br><span class="line">        <span class="keyword">if</span> (fOpenComplete)</span><br><span class="line">            <span class="comment">// 如果已经绑定结束了，设置已经绑定标记。</span></span><br><span class="line">            <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">NPROT_TEST_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_OPENING))</span><br><span class="line">            <span class="comment">// 如果是正在绑定过程中，设置绑定失败了。</span></span><br><span class="line">            <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_FAILED);</span><br><span class="line">        <span class="comment">// 释放锁。</span></span><br><span class="line">        <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="comment">// 调用停止绑定函数。这里会释放所有资源。</span></span><br><span class="line">        <span class="built_in">ndisprotShutdownBinding</span>(pOpenContext);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">DEBUGP</span>(DL_INFO, (<span class="string">&quot;CreateBinding: OpenContext %p, Status %x\n&quot;</span>,pOpenContext, Status));</span><br><span class="line">    <span class="keyword">return</span> (Status);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述<code>ndisprotDoRequest</code>函数封装了<code>NdisRequest</code>，所有OID都用它发送，原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">NdisRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PNDIS_STATUS Status, <span class="comment">//返回结果</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ NDIS_HANDLE NdisBindingHandle, <span class="comment">//绑定句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PNDIS_REQUEST NdisRequest <span class="comment">//请求句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>至于请求句柄咋填：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NDIS_STATUS <span class="title">ndisprotDoRequest</span><span class="params">(IN PNDISPROT_OPEN_CONTEXT pOpenContext, IN NDIS_REQUEST_TYPE RequestType, IN NDIS_OID Oid, IN PVOID InformationBuffer, IN ULONG InformationBufferLength, OUT PULONG pBytesProcessed)</span> </span>&#123;</span><br><span class="line">    NDISPROT_REQUEST ReqContext;</span><br><span class="line">    PNDIS_REQUEST pNdisRequest = &amp;ReqContext.Request;</span><br><span class="line">    NDIS_STATUS Status;</span><br><span class="line">    <span class="comment">// 初始化一个事件。这个事件会在请求完成函数中被设置，以便通知请求完成了。</span></span><br><span class="line">    <span class="built_in">NPROT_INIT_EVENT</span>(&amp;ReqContext.ReqEvent);</span><br><span class="line">    <span class="comment">// 请求的类型。如果只是查询信息，只要用NdisRequestQueryInformation就可以了。</span></span><br><span class="line">    pNdisRequest-&gt;RequestType = RequestType;</span><br><span class="line">    <span class="comment">// 根据不同的请求类型，填写OID和输入输出缓冲区。</span></span><br><span class="line">    <span class="keyword">switch</span> (RequestType) &#123;</span><br><span class="line">        <span class="keyword">case</span> NdisRequestQueryInformation:</span><br><span class="line">        &#123;</span><br><span class="line">            pNdisRequest-&gt;DATA.QUERY_INFORMATION.Oid = Oid;</span><br><span class="line">            pNdisRequest-&gt;DATA.QUERY_INFORMATION.InformationBuffer = InformationBuffer;</span><br><span class="line">            pNdisRequest-&gt;DATA.QUERY_INFORMATION.InformationBufferLength = InformationBufferLength;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> NdisRequestSetInformation:</span><br><span class="line">        &#123;</span><br><span class="line">            pNdisRequest-&gt;DATA.SET_INFORMATION.Oid = Oid;</span><br><span class="line">            pNdisRequest-&gt;DATA.SET_INFORMATION.InformationBuffer = InformationBuffer;</span><br><span class="line">            pNdisRequest-&gt;DATA.SET_INFORMATION.InformationBufferLength = InformationBufferLength;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>(FALSE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="built_in">NdisRequest</span>(&amp;Status, pOpenContext-&gt;BindingHandle, pNdisRequest);</span><br><span class="line">    <span class="comment">// 如果是未决，则等待事件。这个事件会在完成函数中设置。</span></span><br><span class="line">    <span class="keyword">if</span> (Status == NDIS_STATUS_PENDING) &#123;</span><br><span class="line">        <span class="built_in">NPROT_WAIT_EVENT</span>(&amp;ReqContext.ReqEvent, <span class="number">0</span>);</span><br><span class="line">        Status = ReqContext.Status;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 如果成功了的话...</span></span><br><span class="line">    <span class="keyword">if</span> (Status == NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">// 获得结果的长度。这个结果的长度是实际需要的长度。可能比我们实际提供的长度要长。</span></span><br><span class="line">        *pBytesProcessed = (RequestType == NdisRequestQueryInformation) ? pNdisRequest-&gt;DATA.QUERY_INFORMATION.BytesWritten : pNdisRequest-&gt;DATA.SET_INFORMATION.BytesRead;</span><br><span class="line">        <span class="comment">// 如果结果长度比实际上我们提供的缓冲区要长，那么就简单的设置为输入参数中缓冲区的最大长度。</span></span><br><span class="line">        <span class="keyword">if</span> (*pBytesProcessed &gt; InformationBufferLength)</span><br><span class="line">            *pBytesProcessed = InformationBufferLength;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完成函数的编写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">NdisProtRequestComplete</span><span class="params">(IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_REQUEST pNdisRequest, IN NDIS_STATUS Status)</span> </span>&#123;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT       pOpenContext;</span><br><span class="line">    PNDISPROT_REQUEST            pReqContext;</span><br><span class="line">    <span class="comment">// 这两句话起验证的作用，确保输入参数ProtocolBindingContext是合法的。但是对后面的处理没影响。</span></span><br><span class="line">    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;</span><br><span class="line">    <span class="built_in">NPROT_STRUCT_ASSERT</span>(pOpenContext, oc);</span><br><span class="line">    <span class="comment">// 从pNdisRequest中得到请求上下文</span></span><br><span class="line">    pReqContext = <span class="built_in">CONTAINING_RECORD</span>(pNdisRequest, NDISPROT_REQUEST, Request);</span><br><span class="line">    <span class="comment">// 保存结果状态</span></span><br><span class="line">    pReqContext-&gt;Status = Status;</span><br><span class="line">    <span class="comment">// 设置事件</span></span><br><span class="line">    <span class="built_in">NPROT_SIGNAL_EVENT</span>(&amp;pReqContext-&gt;ReqEvent);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解除绑定"><a href="#解除绑定" class="headerlink" title="解除绑定"></a>解除绑定</h2><p>当一个网卡被拔出时，内核调用协议特征集中的解除绑定回调函数来解除一个协议驱动和一个网卡的绑定。解除绑定用<code>NdisCloseAdapter</code>，原型如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">NdisCloseAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PNDIS_STATUS Status,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ NDIS_HANDLE NdisBindingHandle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>NdisProtUnbindAdapter</code>实现：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">NdisProtUnbindAdapter</span><span class="params">(OUT PNDIS_STATUS pStatus, IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_HANDLE UnbindContext)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*++</span></span></span><br><span class="line"><span class="comment"><span class="function">Routine Description:</span></span></span><br><span class="line"><span class="comment"><span class="function">    NDIS calls this when it wants us to close the binding to an adapter.</span></span></span><br><span class="line"><span class="comment"><span class="function">Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function">    pStatus - place to return status of Unbind</span></span></span><br><span class="line"><span class="comment"><span class="function">    ProtocolBindingContext - pointer to open context structure</span></span></span><br><span class="line"><span class="comment"><span class="function">    UnbindContext - to use in NdisCompleteUnbindAdapter if we return pending</span></span></span><br><span class="line"><span class="comment"><span class="function">Return Value:</span></span></span><br><span class="line"><span class="comment"><span class="function">    None</span></span></span><br><span class="line"><span class="comment"><span class="function">--*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT           pOpenContext;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(UnbindContext);</span><br><span class="line">    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;</span><br><span class="line">    <span class="built_in">NPROT_STRUCT_ASSERT</span>(pOpenContext, oc);</span><br><span class="line">    <span class="comment">//  Mark this open as having seen an Unbind.</span></span><br><span class="line">    <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">    <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_UNBIND_FLAGS, NUIOO_UNBIND_RECEIVED); <span class="comment">//无条件设置接收到解绑的标记</span></span><br><span class="line">    <span class="comment">//  In case we had threads blocked for the device below to be powered up, wake them up.</span></span><br><span class="line">    <span class="built_in">NPROT_SIGNAL_EVENT</span>(&amp;pOpenContext-&gt;PoweredUpEvent); <span class="comment">//设置事件 通知所有在等待电源启动的线程 避免一些请求无法完成</span></span><br><span class="line">    <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">    <span class="built_in">ndisprotShutdownBinding</span>(pOpenContext); <span class="comment">//解绑</span></span><br><span class="line">    *pStatus = NDIS_STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>ndisprotShutdownBinding</code>的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ndisprotShutdownBinding</span><span class="params">(IN PNDISPROT_OPEN_CONTEXT pOpenContext)</span> </span>&#123;</span><br><span class="line">    NDIS_STATUS Status;</span><br><span class="line">    BOOLEAN DoCloseBinding = FALSE;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="comment">// 检查标记是否有NUIOO_BIND_OPENING，如果是正在打开的话，立刻退出。放弃解除绑定操作。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NPROT_TEST_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_OPENING)) &#123;</span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 如果是绑定已经完成的情况，则设置为开始解除绑定，标记NUI_BIND_ACTIVE。其他的情况则根本不用做下面的操作。因为绑定既然没有完成，也当然不用解除绑定。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NPROT_TEST_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE)) &#123;</span><br><span class="line">            <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_CLOSING); <span class="comment">//NUIOO_BIND_CLOSING已进入解绑过程</span></span><br><span class="line">            DoCloseBinding = TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="keyword">if</span> (DoCloseBinding) &#123;</span><br><span class="line">            <span class="comment">// 从这里开始解除绑定。</span></span><br><span class="line">            ULONG    PacketFilter = <span class="number">0</span>;</span><br><span class="line">            ULONG    BytesRead = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 把绑定了的网卡的包过滤器设置为0，换句话说，就是从现在开始停止收包。这是为了便于清理资源。</span></span><br><span class="line">            Status = <span class="built_in">ndisprotDoRequest</span>(pOpenContext, NdisRequestSetInformation, OID_GEN_CURRENT_PACKET_FILTER, &amp;PacketFilter, <span class="built_in">sizeof</span>(PacketFilter), &amp;BytesRead);</span><br><span class="line">            <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS)</span><br><span class="line">                <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;ShutDownBinding: set packet filter failed: %x\n&quot;</span>, Status));</span><br><span class="line">            <span class="comment">// 把这个网卡的广播列表设置为NULL.</span></span><br><span class="line">            Status = <span class="built_in">ndisprotDoRequest</span>(pOpenContext, NdisRequestSetInformation, OID_802_3_MULTICAST_LIST, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;BytesRead);</span><br><span class="line">            <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS)</span><br><span class="line">                <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;ShutDownBinding: set multicast list failed: %x\n&quot;</span>, Status));</span><br><span class="line">            <span class="comment">// 取消所有的提交状态IRP。</span></span><br><span class="line">            <span class="built_in">ndisServiceIndicateStatusIrp</span>(pOpenContext, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, TRUE);</span><br><span class="line">            <span class="comment">// 等待所有未决IRP完成。</span></span><br><span class="line">            <span class="built_in">ndisprotWaitForPendingIO</span>(pOpenContext, TRUE);</span><br><span class="line">            <span class="comment">// 清理掉接收队列中所有的包。</span></span><br><span class="line">            <span class="built_in">ndisprotFlushReceiveQueue</span>(pOpenContext);</span><br><span class="line">            <span class="comment">// 初始化绑定事件，这个时间将用来等待解除绑定完成。</span></span><br><span class="line">            <span class="built_in">NPROT_INIT_EVENT</span>(&amp;pOpenContext-&gt;BindEvent);</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_INFO, (<span class="string">&quot;ShutdownBinding: Closing OpenContext %p, BindingHandle %p\n&quot;</span>, pOpenContext, pOpenContext-&gt;BindingHandle));</span><br><span class="line">            <span class="comment">// 正式调用解除绑定。</span></span><br><span class="line">            <span class="built_in">NdisCloseAdapter</span>(&amp;Status, pOpenContext-&gt;BindingHandle);</span><br><span class="line">            <span class="keyword">if</span> (Status == NDIS_STATUS_PENDING) &#123;</span><br><span class="line">                <span class="built_in">NPROT_WAIT_EVENT</span>(&amp;pOpenContext-&gt;BindEvent, <span class="number">0</span>);</span><br><span class="line">                Status = pOpenContext-&gt;BindStatus;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>(Status == NDIS_STATUS_SUCCESS);</span><br><span class="line">            pOpenContext-&gt;BindingHandle = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (DoCloseBinding) &#123;</span><br><span class="line">            <span class="comment">// 设置上已经解除绑定的标记。</span></span><br><span class="line">            <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">            <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_IDLE);</span><br><span class="line">            <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_UNBIND_FLAGS, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 下面的操作主要是释放资源。</span></span><br><span class="line">        <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;Globals.GlobalLock);</span><br><span class="line">        <span class="built_in">NPROT_REMOVE_ENTRY_LIST</span>(&amp;pOpenContext-&gt;Link);</span><br><span class="line">        <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;Globals.GlobalLock);</span><br><span class="line">        <span class="built_in">ndisprotFreeBindResources</span>(pOpenContext);</span><br><span class="line">        <span class="built_in">NPROT_DEREF_OPEN</span>(pOpenContext);  <span class="comment">// Shutdown binding</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="用户态操作协议驱动"><a href="#用户态操作协议驱动" class="headerlink" title="用户态操作协议驱动"></a>用户态操作协议驱动</h2><p>本小节为应用层程序代码。</p>
<p>标准的协议驱动可在用户层用Socket打开进行收发包的，但本例中抛弃了上层接口，简单地用<code>ReadFile</code>和<code>WriteFile</code>进行收发包。<code>ReadFile</code>从应用层发出一个控制请求到某个设备，主功能号IRP_MJ_READ，<code>WriteFile</code>同理。<code>DeviceIoControl</code>调用时，设备收到一个控制请求，IRP主功能号IRP_MJ_DEVICE_CONTROL。</p>
<p>应用层基本步骤为：用<code>CreateFile</code>打开协议控制设备对象CDO，得到其句柄；用<code>DeviceIoControl</code>来等待绑定结束；用<code>WriteFile</code>发送数据包，用<code>ReadFile</code>接收数据包；用<code>CloseHandle</code>关闭句柄。本例驱动中设置的符号链接为“\\.\NdisProt”。</p>
<p>打开设备并发送控制请求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in__nullterminated PCHAR pDeviceName <span class="comment">//符号链接名 以NULL结尾</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    DWORD DesiredAccess;</span><br><span class="line">    DWORD ShareMode;</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpSecurityAttributes = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD CreationDistribution;</span><br><span class="line">    DWORD FlagsAndAttributes;</span><br><span class="line">    HANDLE TemplateFile;</span><br><span class="line">    HANDLE Handle;</span><br><span class="line">    DWORD BytesReturned;</span><br><span class="line">    DesiredAccess = GENERIC_READ | GENERIC_WRITE;</span><br><span class="line">    ShareMode = <span class="number">0</span>;</span><br><span class="line">    CreationDistribution = OPEN_EXISTING;</span><br><span class="line">    FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;</span><br><span class="line">    TemplateFile = (HANDLE)INAVLID_HANDLE_VALUE;</span><br><span class="line">    Handle = <span class="built_in">CreateFile</span>(pDeviceName, DesiredAccess, ShareMode, lpSecurityAttributes, CreationDistribution, FlagsAndAttributes, TemplateFile);</span><br><span class="line">    <span class="keyword">if</span> (Handle == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span> Handle;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">DeviceIoControl</span>(Handle, IOCTL_NDISPROT_BIND_WAIT, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;BytesReturned, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(Handle);</span><br><span class="line">        Handle = INVALID_HANDLE_VALUE;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>DeviceIoControl</code>原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeviceIoControl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE handle, <span class="comment">//打开的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD control_code, <span class="comment">//控制码 驱动中定义</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID input_buf, <span class="comment">//输入缓冲区 可NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD input_length, <span class="comment">//输入缓冲区长度 可0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID output_buf, <span class="comment">//输出缓冲区 可NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD output_length <span class="comment">//输出缓冲区长度 可0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功TRUE 失败FALSE</span></span><br></pre></td></tr></table></figure>

<p>但此时仅用<code>CreateFile</code>打开了一个句柄，并输入了协议驱动的符号链接，还需要用<code>DeviceIoControl</code>传入设备名，控制码IOCTL_NDISPROT_OPEN_DEVICE。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WCHAR wNdisDeviceName[MAX_NDIS_DEVICE_NAME_LEN];</span><br><span class="line">INT wNameLength;</span><br><span class="line">INT NameLength = <span class="built_in">strlen</span>(pDeviceName);</span><br><span class="line">DWORD BytesReturned;</span><br><span class="line">INT i;</span><br><span class="line">wNameLength = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NameLength &amp;&amp; i &lt; MAX_NDIS_DEVICE_NAME_LEN - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    wNdisDeviceName[i] = (WCHAR)pDeviceName[i];</span><br><span class="line">    wNameLength++;</span><br><span class="line">&#125;;</span><br><span class="line">wNdisDeviceName[i] = <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(Handle, IOCTL_NDISPROT_OPEN_DEVICE, (LPVOID)&amp;wndisDevicename[<span class="number">0</span>], wnameLength * <span class="built_in">sizeof</span>(WCHAR), <span class="literal">NULL</span>, <span class="number">0</span>, &amp;BytesReturned, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>接下来用<code>WriteFile</code>发送数据包，需要填写数据区和以太网包头。以太网包头有一个来源地址、一个目的地址、一个协议号。来源地址可以冒名顶替。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pWriteBuf = <span class="built_in">malloc</span>(PacketLength);</span><br><span class="line">pEthHeader-&gt;EthType = EthType;</span><br><span class="line"><span class="keyword">if</span> (bUseFakeAddress)</span><br><span class="line">    <span class="built_in">memcpy</span>(pEthHeader-&gt;SrcAddr, FakeSrcMacAddr, MAC_ADDR_LEN);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pEthHeader-&gt;SrcAddr, SrcMacAddr, MAC_ADDR_LEN);</span><br><span class="line"><span class="built_in">memcpy</span>(pEthHeader-&gt;DstAddr, DstMacAddr, MAC_ADDR_LEN);</span><br><span class="line">pData = (PUCHAR)(pEthHeader + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PacketLength - <span class="built_in">sizeof</span>(ETH_HEADER); i++)</span><br><span class="line">    *pData++ = (UCHAR)i;</span><br><span class="line">bSuccess = (BOOLEAN)<span class="built_in">WriteFile</span>(Handle, pWriteBuf, PacketLength, &amp;BytesWritten, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!bSuccess)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (pWriteBuf)</span><br><span class="line">    <span class="built_in">free</span>(pWriteBuf);</span><br></pre></td></tr></table></figure>

<p><code>WriteFile</code>和<code>ReadFile</code>原型为：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE file_handle, <span class="comment">//打开的设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID packet_buf, <span class="comment">//要写入内容缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD packet_length, <span class="comment">//缓冲区长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PDWORD written_length, <span class="comment">//返回实际成功发出的长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER offset <span class="comment">//写文件的偏移 这里发送包用不上 填NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">ReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE file_handle,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID packet_buf,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD packet_length,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDWORD written_length,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER offset</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>读取数据包方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUCHAR pReadBuf = <span class="literal">NULL</span>;</span><br><span class="line">INT ReadCount = <span class="number">0</span>;</span><br><span class="line">BOOLEAN bSuccess;</span><br><span class="line">ULONG BytesRead;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    pReadBuf = <span class="built_in">malloc</span>(PacketLength);</span><br><span class="line">    <span class="keyword">if</span> (pReadBuf == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ReadCount = <span class="number">0</span>; <span class="comment">//读出包的个数</span></span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        bSuccess = (BOOLEAN)<span class="built_in">ReadFile</span>(Handle, (LPVOID)pReadBuf, PacketLength, &amp;BytesRead, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!bSuccess)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ReadCount++;</span><br><span class="line">        <span class="keyword">if</span> ((NumberOfPackets != <span class="number">-1</span>) &amp;&amp; (ReadCount == NumberOfPackets))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line"><span class="keyword">if</span> (pReadBuf)</span><br><span class="line">    <span class="built_in">free</span>(pReadBuf);</span><br></pre></td></tr></table></figure>

<h2 id="内核态功能实现"><a href="#内核态功能实现" class="headerlink" title="内核态功能实现"></a>内核态功能实现</h2><p>在驱动入口函数有设置各类分发函数。分发函数<code>NdisProtIoControl</code>处理所有主功能号为IRP_MJ_DEVICE_CONTROL的IRP。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NdisProtIoControl</span><span class="params">(IN PDEVICE_OBJECT pDeviceObject,IN PIRP pIrp)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*++</span></span></span><br><span class="line"><span class="comment"><span class="function">Routine Description:</span></span></span><br><span class="line"><span class="comment"><span class="function">    This is the dispatch routine for handling device ioctl requests.</span></span></span><br><span class="line"><span class="comment"><span class="function">Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function">    pDeviceObject - Pointer to the device object.</span></span></span><br><span class="line"><span class="comment"><span class="function">    pIrp - Pointer to the request packet.</span></span></span><br><span class="line"><span class="comment"><span class="function">Return Value:</span></span></span><br><span class="line"><span class="comment"><span class="function">    Status is returned.</span></span></span><br><span class="line"><span class="comment"><span class="function">--*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION      pIrpSp;</span><br><span class="line">    ULONG                   FunctionCode;</span><br><span class="line">    NTSTATUS                NtStatus;</span><br><span class="line">    NDIS_STATUS             Status;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT   pOpenContext;</span><br><span class="line">    ULONG                   BytesReturned;</span><br><span class="line">    USHORT                  EthType;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> !DBG</span></span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pDeviceObject);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">DEBUGP</span>(DL_LOUD, (<span class="string">&quot;IoControl: DevObj %p, Irp %p\n&quot;</span>, pDeviceObject, pIrp));</span><br><span class="line">    pIrpSp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    FunctionCode = pIrpSp-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line">    pOpenContext = (PNDISPROT_OPEN_CONTEXT)pIrpSp-&gt;FileObject-&gt;FsContext;</span><br><span class="line">    BytesReturned = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (FunctionCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_NDISPROT_BIND_WAIT:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 所有的DeviceIoControl请求的都应该是用的缓冲方式。这里只是确认一下。</span></span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>((FunctionCode &amp; <span class="number">0x3</span>) == METHOD_BUFFERED);</span><br><span class="line">            <span class="comment">// 非常简单。等待一个全局事件。这个全局变量会在绑定完成的时候被设置。如果等待到了或者超时了（5秒）则返回。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">NPROT_WAIT_EVENT</span>(&amp;Globals.BindsComplete, <span class="number">5000</span>))</span><br><span class="line">                NtStatus = STATUS_SUCCESS;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                NtStatus = STATUS_TIMEOUT;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_INFO, (<span class="string">&quot;IoControl: BindWait returning %x\n&quot;</span>, NtStatus));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_NDISPROT_QUERY_BINDING:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>((FunctionCode &amp; <span class="number">0x3</span>) == METHOD_BUFFERED);</span><br><span class="line">            Status = <span class="built_in">ndisprotQueryBinding</span>(pIrp-&gt;AssociatedIrp.SystemBuffer, pIrpSp-&gt;Parameters.DeviceIoControl.InputBufferLength, pIrpSp-&gt;Parameters.DeviceIoControl.OutputBufferLength, &amp;BytesReturned);</span><br><span class="line">            <span class="built_in">NDIS_STATUS_TO_NT_STATUS</span>(Status, &amp;NtStatus);</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_LOUD, (<span class="string">&quot;IoControl: QueryBinding returning %x\n&quot;</span>, NtStatus));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_NDISPROT_OPEN_DEVICE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>((FunctionCode &amp; <span class="number">0x3</span>) == METHOD_BUFFERED);</span><br><span class="line">            <span class="keyword">if</span> (pOpenContext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">NPROT_STRUCT_ASSERT</span>(pOpenContext, oc);</span><br><span class="line">                <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;IoControl: OPEN_DEVICE: FileObj %p alreadyassociated with open %p\n&quot;</span>, pIrpSp-&gt;FileObject, pOpenContext));</span><br><span class="line">                NtStatus = STATUS_DEVICE_BUSY;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            NtStatus = <span class="built_in">ndisprotOpenDevice</span>(pIrp-&gt;AssociatedIrp.SystemBuffer, pIrpSp-&gt;Parameters.DeviceIoControl.InputBufferLength, pIrpSp-&gt;FileObject, &amp;pOpenContext);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(NtStatus))</span><br><span class="line">                <span class="built_in">DEBUGP</span>(DL_VERY_LOUD, (<span class="string">&quot;IoControl OPEN_DEVICE: Open %p &lt;-&gt; FileObject %p\n&quot;</span>, pOpenContext, pIrpSp-&gt;FileObject));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_NDISPROT_QUERY_OID_VALUE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>((FunctionCode &amp; <span class="number">0x3</span>) == METHOD_BUFFERED);</span><br><span class="line">            <span class="keyword">if</span> (pOpenContext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Status = <span class="built_in">ndisprotQueryOidValue</span>(pOpenContext, pIrp-&gt;AssociatedIrp.SystemBuffer, pIrpSp-&gt;Parameters.DeviceIoControl.OutputBufferLength, &amp;BytesReturned);</span><br><span class="line">                <span class="built_in">NDIS_STATUS_TO_NT_STATUS</span>(Status, &amp;NtStatus);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                NtStatus = STATUS_DEVICE_NOT_CONNECTED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_NDISPROT_SET_OID_VALUE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>((FunctionCode &amp; <span class="number">0x3</span>) == METHOD_BUFFERED);</span><br><span class="line">            <span class="keyword">if</span> (pOpenContext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Status = <span class="built_in">ndisprotSetOidValue</span>(pOpenContext, pIrp-&gt;AssociatedIrp.SystemBuffer, pIrpSp-&gt;Parameters.DeviceIoControl.InputBufferLength);</span><br><span class="line">                BytesReturned = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">NDIS_STATUS_TO_NT_STATUS</span>(Status, &amp;NtStatus);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                NtStatus = STATUS_DEVICE_NOT_CONNECTED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_NDISPROT_INDICATE_STATUS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>((FunctionCode &amp; <span class="number">0x3</span>) == METHOD_BUFFERED);</span><br><span class="line">            <span class="keyword">if</span> (pOpenContext != <span class="literal">NULL</span>)</span><br><span class="line">                NtStatus = <span class="built_in">ndisprotQueueStatusIndicationIrp</span>(pOpenContext, pIrp, &amp;BytesReturned);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                NtStatus = STATUS_DEVICE_NOT_CONNECTED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            NtStatus = STATUS_NOT_SUPPORTED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (NtStatus != STATUS_PENDING) &#123;</span><br><span class="line">        pIrp-&gt;IoStatus.Information = BytesReturned;</span><br><span class="line">        pIrp-&gt;IoStatus.Status = NtStatus;</span><br><span class="line">        <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> NtStatus;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ndisprotOpenDevice</code>实现步骤有：从输入缓冲区拿到设备名、通过设备名去找对应的打开上下文、找到后保存在<code>pIrpSp-&gt;FileObject-&gt;FsContext</code>。在文件系统中FsContext保存FCB，但其他驱动中可以提供“文件”对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ndisprotOpenDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in_bcount(DeviceNameLength) IN PUCHAR pDeviceName,<span class="comment">// pDeviceName 设备对象名</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG DeviceNameLength,<span class="comment">// DeviceNameLength 设备对象的长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PFILE_OBJECT pFileObject,<span class="comment">// pFileObject 文件对象指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PNDISPROT_OPEN_CONTEXT* ppOpenContext</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT   pOpenContext;</span><br><span class="line">    NTSTATUS                NtStatus;</span><br><span class="line">    ULONG                   PacketFilter;</span><br><span class="line">    NDIS_STATUS             NdisStatus;</span><br><span class="line">    ULONG                   BytesProcessed;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT   pCurrentOpenContext = <span class="literal">NULL</span>;</span><br><span class="line">    pOpenContext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 根据设备名找到打开上下文。请注意这个中间会调用增加打开上下文引用计数，所以后面要解引用。</span></span><br><span class="line">        pOpenContext = <span class="built_in">ndisprotLookupDevice</span>(pDeviceName, DeviceNameLength);</span><br><span class="line">        <span class="comment">// 如果找不到打开上下文，说明没绑定过...</span></span><br><span class="line">        <span class="keyword">if</span> (pOpenContext == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;ndisprotOpenDevice: couldn&#x27;t find device\n&quot;</span>));</span><br><span class="line">            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="comment">// 如果找到了，但是不是打开空闲状态，则返回设备忙。</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NPROT_TEST_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_OPEN_FLAGS, NUIOO_OPEN_IDLE)) &#123;</span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>(pOpenContext-&gt;pFileObject != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;ndisprotOpenDevice: Open %p/%x already associated with another FileObject %p\n&quot;</span>, pOpenContext, pOpenContext-&gt;Flags, pOpenContext-&gt;pFileObject));</span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">            <span class="comment">// 注意解引用。</span></span><br><span class="line">            <span class="built_in">NPROT_DEREF_OPEN</span>(pOpenContext); <span class="comment">// ndisprotOpenDevice failure</span></span><br><span class="line">            NtStatus = STATUS_DEVICE_BUSY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 比较交换。首先比较pFileObject-&gt;FsContext和NULL.如果是NULL,则用pFileObject-&gt;FsContext设置为pOpenContext，然后返回NULL。如果不是NULL，则不交换，并返回pFileObject-&gt;FsContext</span></span><br><span class="line">        <span class="keyword">if</span> ((pCurrentOpenContext = <span class="built_in">InterlockedCompareExchangePointer</span>(&amp;(pFileObject-&gt;FsContext), pOpenContext, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 到了这里，说明另一个打开已经使用了这个文件对象。这个设备不支持两次打开。到这里直接返回失败即可。</span></span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;ndisprotOpenDevice: FileObject %p already associated with another Open %p/%x\n&quot;</span>, pFileObject, pCurrentOpenContext, pCurrentOpenContext-&gt;Flags));  <span class="comment">//BUG</span></span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">            <span class="built_in">NPROT_DEREF_OPEN</span>(pOpenContext); <span class="comment">// ndisprotOpenDevice failure</span></span><br><span class="line">            NtStatus = STATUS_INVALID_DEVICE_REQUEST;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 这个打开上下文被打开了，保存在这个文件对象的FsContext中。这里也保存</span></span><br><span class="line">        pOpenContext-&gt;pFileObject = pFileObject;</span><br><span class="line">        <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_OPEN_FLAGS, NUIOO_OPEN_ACTIVE);</span><br><span class="line">        <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="comment">// 设置PacketFilter，使之能收到包。</span></span><br><span class="line">        PacketFilter = NUIOO_PACKET_FILTER;</span><br><span class="line">        NdisStatus = <span class="built_in">ndisprotValidateOpenAndDoRequest</span>(pOpenContext, NdisRequestSetInformation, OID_GEN_CURRENT_PACKET_FILTER, &amp;PacketFilter, <span class="built_in">sizeof</span>(PacketFilter), &amp;BytesProcessed, TRUE); <span class="comment">// TRUE:Do wait for power on</span></span><br><span class="line">        <span class="comment">// 不成功的话</span></span><br><span class="line">        <span class="keyword">if</span> (NdisStatus != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;openDevice: Open %p: set packet filter (%x) failed: %x\n&quot;</span>, pOpenContext, PacketFilter, NdisStatus));</span><br><span class="line">            <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">            <span class="comment">// 不成功的话，去掉FileObject-&gt;FsContext设置，如果pFileObject-&gt;FsContext是pOpenContext，则去掉。</span></span><br><span class="line">            pCurrentOpenContext = <span class="built_in">InterlockedCompareExchangePointer</span>(&amp;(pFileObject-&gt;FsContext), <span class="literal">NULL</span>, pOpenContext);</span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>(pCurrentOpenContext == pOpenContext);</span><br><span class="line">            <span class="built_in">NPROT_SET_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_OPEN_FLAGS, NUIOO_OPEN_IDLE);</span><br><span class="line">            pOpenContext-&gt;pFileObject = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">            <span class="built_in">NPROT_DEREF_OPEN</span>(pOpenContext); <span class="comment">// ndisprotOpenDevice failure</span></span><br><span class="line">            <span class="built_in">NDIS_STATUS_TO_NT_STATUS</span>(NdisStatus, &amp;NtStatus);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 返回打开上下文。</span></span><br><span class="line">        *ppOpenContext = pOpenContext;</span><br><span class="line">        NtStatus = STATUS_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    <span class="keyword">return</span> (NtStatus);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>读请求就是从应用层获取网卡收到的包，这些包被本协议驱动放入缓冲队列中。处理读请求就是检测队列中有无数据包，有则把包内容拷贝到读请求输出缓冲区中。若存在多个网卡，则把打开上下文取出，就能知道调用者需要收包的是哪个网卡。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分发函数之一，处理读请求。</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">NdisProtRead</span><span class="params">(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION      pIrpSp;</span><br><span class="line">    NTSTATUS                NtStatus;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT   pOpenContext;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pDeviceObject);</span><br><span class="line">    pIrpSp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    pOpenContext = pIrpSp-&gt;FileObject-&gt;FsContext;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 检测打开上下文的可靠性</span></span><br><span class="line">        <span class="keyword">if</span> (pOpenContext == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_FATAL, (<span class="string">&quot;Read: NULL FsContext on FileObject %p\n&quot;</span>, pIrpSp-&gt;FileObject));</span><br><span class="line">            NtStatus = STATUS_INVALID_HANDLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">NPROT_STRUCT_ASSERT</span>(pOpenContext, oc);</span><br><span class="line">        <span class="comment">// Read和Write都是使用的直接IO操作，所以应该使用MdlAddress来传递缓冲。如果不是，返回非法参数错误。</span></span><br><span class="line">        <span class="keyword">if</span> (pIrp-&gt;MdlAddress == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_FATAL, (<span class="string">&quot;Read: NULL MDL address on IRP %p\n&quot;</span>, pIrp));</span><br><span class="line">            NtStatus = STATUS_INVALID_PARAMETER;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 得到缓冲的虚拟地址。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">MmGetSystemAddressForMdlSafe</span>(pIrp-&gt;MdlAddress, NormalPagePriority) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_FATAL, (<span class="string">&quot;Read: MmGetSystemAddr failed for IRP %p, MDL %p\n&quot;</span>, pIrp, pIrp-&gt;MdlAddress));</span><br><span class="line">            NtStatus = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NPROT_TEST_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE)) &#123;</span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">            NtStatus = STATUS_INVALID_HANDLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 将这个请求插入处理队列里。并把打开上下文引用计数增加就1.把未处理读请求数目增加1.</span></span><br><span class="line">        <span class="built_in">NPROT_INSERT_TAIL_LIST</span>(&amp;pOpenContext-&gt;PendedReads, &amp;pIrp-&gt;Tail.Overlay.ListEntry);</span><br><span class="line">        <span class="built_in">NPROT_REF_OPEN</span>(pOpenContext);  <span class="comment">// pended read IRP</span></span><br><span class="line">        pOpenContext-&gt;PendedReadCount++;</span><br><span class="line">        <span class="comment">// 标记IRP未决。给IRP设置一个取消函数，使之变得可取消。</span></span><br><span class="line">        pIrp-&gt;Tail.Overlay.DriverContext[<span class="number">0</span>] = (PVOID)pOpenContext;</span><br><span class="line">        <span class="built_in">IoMarkIrpPending</span>(pIrp);</span><br><span class="line">        <span class="built_in">IoSetCancelRoutine</span>(pIrp, NdisProtCancelRead);</span><br><span class="line">        <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        NtStatus = STATUS_PENDING;</span><br><span class="line">        <span class="comment">// 调用一个处理例程来处理所有未决的读请求。</span></span><br><span class="line">        <span class="built_in">ndisprotServiceReads</span>(pOpenContext);</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    <span class="comment">// 读请求只返回STATUS_PENDING.如果不是，则说明出错，按错误返回。</span></span><br><span class="line">    <span class="keyword">if</span> (NtStatus != STATUS_PENDING) &#123;</span><br><span class="line">        <span class="built_in">NPROT_ASSERT</span>(NtStatus != STATUS_SUCCESS);</span><br><span class="line">        pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">        pIrp-&gt;IoStatus.Status = NtStatus;</span><br><span class="line">        <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (NtStatus);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>写请求就是发包请求，处理代码在<code>NdisProtWrite</code>中，主请求号IRP_MJ_WRITE。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分发函数，处理写请求（也就是发包请求）。</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">NdisProtWrite</span><span class="params">(IN PDEVICE_OBJECT pDeviceObject,IN PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION      pIrpSp;</span><br><span class="line">    ULONG                   DataLength;</span><br><span class="line">    NTSTATUS                NtStatus;</span><br><span class="line">    NDIS_STATUS             Status;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT   pOpenContext;</span><br><span class="line">    PNDIS_PACKET            pNdisPacket;</span><br><span class="line">    PNDIS_BUFFER            pNdisBuffer;</span><br><span class="line">    NDISPROT_ETH_HEADER UNALIGNED* pEthHeader;</span><br><span class="line">    <span class="comment">// NDIS51支持写请求取消。但是本书不讨论请求取消的话题。</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> NDIS51</span></span><br><span class="line">    PVOID                   CancelId;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pDeviceObject);</span><br><span class="line">    <span class="comment">// 首先得到打开上下文。以确认是用哪个网卡发包。</span></span><br><span class="line">    pIrpSp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    pOpenContext = pIrpSp-&gt;FileObject-&gt;FsContext;</span><br><span class="line">    pNdisPacket = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 检查打开上下文的可靠性。</span></span><br><span class="line">        <span class="keyword">if</span> (pOpenContext == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;Write: FileObject %p not yet associated with a device\n&quot;</span>, pIrpSp-&gt;FileObject));</span><br><span class="line">            NtStatus = STATUS_INVALID_HANDLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">NPROT_STRUCT_ASSERT</span>(pOpenContext, oc);</span><br><span class="line">        <span class="comment">// 确认输入缓冲的可靠性。</span></span><br><span class="line">        <span class="keyword">if</span> (pIrp-&gt;MdlAddress == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_FATAL, (<span class="string">&quot;Write: NULL MDL address on IRP %p\n&quot;</span>, pIrp));</span><br><span class="line">            NtStatus = STATUS_INVALID_PARAMETER;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 得到输入缓冲的虚拟地址。之后进行一系列的检查。第一，输入缓冲虚拟地址不能为NULL，第二，缓冲的长度，至少必须比一个以太网包头要长。否则无法填写以太网包头。第三，发包的长度不能超过这个网卡的最大帧长。第四，</span></span><br><span class="line">        pEthHeader = <span class="built_in">MmGetSystemAddressForMdlSafe</span>(pIrp-&gt;MdlAddress, NormalPagePriority);</span><br><span class="line">        <span class="keyword">if</span> (pEthHeader == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_FATAL, (<span class="string">&quot;Write: MmGetSystemAddr failed for IRP %p, MDL %p\n&quot;</span>, pIrp, pIrp-&gt;MdlAddress));</span><br><span class="line">            NtStatus = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        DataLength = <span class="built_in">MmGetMdlByteCount</span>(pIrp-&gt;MdlAddress);</span><br><span class="line">        <span class="keyword">if</span> (DataLength &lt; <span class="built_in">sizeof</span>(NDISPROT_ETH_HEADER)) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;Write: too small to be a valid packet (%d bytes)\n&quot;</span>, DataLength));</span><br><span class="line">            NtStatus = STATUS_BUFFER_TOO_SMALL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (DataLength &gt; (pOpenContext-&gt;MaxFrameSize + <span class="built_in">sizeof</span>(NDISPROT_ETH_HEADER))) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;Write: Open %p: data length (%d) larger than max frame size (%d)\n&quot;</span>, pOpenContext, DataLength, pOpenContext-&gt;MaxFrameSize));</span><br><span class="line">            NtStatus = STATUS_INVALID_BUFFER_SIZE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 下面开始检查，缓冲中是否已经填写了伪造的MAC地址。方法很简单，取得已填写的地址和网卡的MAC地址比较。如果不符合则返回失败。很多情况，网络攻击工具是不会拷贝这段代码的。</span></span><br><span class="line">        <span class="keyword">if</span> ((pIrp-&gt;RequestorMode == UserMode) &amp;&amp; !<span class="built_in">NPROT_MEM_CMP</span>(pEthHeader-&gt;SrcAddr, pOpenContext-&gt;CurrentAddress, NPROT_MAC_ADDR_LEN)) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;Write: Failing with invalid Source address&quot;</span>));</span><br><span class="line">            NtStatus = STATUS_INVALID_PARAMETER;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 确认包可以发送了。下面开始真实的准备发送一个包，首先获得锁，并判断当前网卡是否处于可以发包的状态。</span></span><br><span class="line">        <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NPROT_TEST_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE)) &#123;</span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_FATAL, (<span class="string">&quot;Write: Open %p is not bound or in low power state\n&quot;</span>, pOpenContext));</span><br><span class="line">            NtStatus = STATUS_INVALID_HANDLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 从前面绑定时分配的发送包池中分配一个包描述符。</span></span><br><span class="line">        <span class="built_in">NPROT_ASSERT</span>(pOpenContext-&gt;SendPacketPool != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">NdisAllocatePacket</span>(&amp;Status,&amp;pNdisPacket,pOpenContext-&gt;SendPacketPool);</span><br><span class="line">        <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_FATAL, (<span class="string">&quot;Write: open %p, failed to alloc send pkt\n&quot;</span>, pOpenContext));</span><br><span class="line">            NtStatus = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 下面的代码为Win9x编写，本书不讨论。</span></span><br><span class="line">        <span class="keyword">if</span> (pOpenContext-&gt;bRunningOnWin9x) &#123;</span><br><span class="line">            <span class="built_in">NdisAllocateBuffer</span>(&amp;Status,&amp;pNdisBuffer,pOpenContext-&gt;SendBufferPool,pEthHeader,DataLength);</span><br><span class="line">            <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">                <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">                <span class="built_in">NdisFreePacket</span>(pNdisPacket);</span><br><span class="line">                <span class="built_in">DEBUGP</span>(DL_FATAL, (<span class="string">&quot;Write: open %p, failed to alloc send buf\n&quot;</span>, pOpenContext));</span><br><span class="line">                NtStatus = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pNdisBuffer = pIrp-&gt;MdlAddress;</span><br><span class="line">        <span class="comment">// 记录发送包又增加了一个。</span></span><br><span class="line">        <span class="built_in">NdisInterlockedIncrement</span>((PLONG)&amp;pOpenContext-&gt;PendedSendCount);</span><br><span class="line">        <span class="comment">// 打开上下文引用计数加1，这是为了防止发包过程中这个绑定被解除。</span></span><br><span class="line">        <span class="built_in">NPROT_REF_OPEN</span>(pOpenContext);  <span class="comment">// pended send</span></span><br><span class="line">        <span class="built_in">IoMarkIrpPending</span>(pIrp);</span><br><span class="line">        <span class="comment">// 初始化包引用计数。这个包会在计数为0的时候释放掉。</span></span><br><span class="line">        <span class="built_in">NPROT_SEND_PKT_RSVD</span>(pNdisPacket)-&gt;RefCount = <span class="number">1</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> NDIS51</span></span><br><span class="line">        <span class="comment">// NDIS5.1支持取消发送。我们给每个包设置一个取消ID。每个包和一个写IRP关联，把包的指针保存在IRP中。如果IRP获得取消通知，则使用NdisCancelSendPackets去取消包。</span></span><br><span class="line">        CancelId = <span class="built_in">NPROT_GET_NEXT_CANCEL_ID</span>();</span><br><span class="line">        <span class="built_in">NDIS_SET_PACKET_CANCEL_ID</span>(pNdisPacket, CancelId);</span><br><span class="line">        pIrp-&gt;Tail.Overlay.DriverContext[<span class="number">0</span>] = (PVOID)pOpenContext;</span><br><span class="line">        pIrp-&gt;Tail.Overlay.DriverContext[<span class="number">1</span>] = (PVOID)pNdisPacket;</span><br><span class="line">        <span class="built_in">NPROT_INSERT_TAIL_LIST</span>(&amp;pOpenContext-&gt;PendedWrites, &amp;pIrp-&gt;Tail.Overlay.ListEntry);</span><br><span class="line">        <span class="built_in">IoSetCancelRoutine</span>(pIrp, NdisProtCancelWrite);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">// NDIS51</span></span></span><br><span class="line">        <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="comment">// 记下irp的指针放在包描述符里，以备后用。</span></span><br><span class="line">        <span class="built_in">NPROT_IRP_FROM_SEND_PKT</span>(pNdisPacket) = pIrp;</span><br><span class="line">        <span class="comment">// 把缓冲和包联系起来。状态设置为pending。</span></span><br><span class="line">        NtStatus = STATUS_PENDING;</span><br><span class="line">        pNdisBuffer-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">NdisChainBufferAtFront</span>(pNdisPacket, pNdisBuffer);</span><br><span class="line">        <span class="comment">// 下面的代码仅供调试使用。</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> SEND_DBG&#123;</span></span><br><span class="line">            PUCHAR      pData;</span><br><span class="line">            pData = <span class="built_in">MmGetSystemAddressForMdlSafe</span>(pNdisBuffer, NormalPagePriority);</span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>(pEthHeader == pData);</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_VERY_LOUD,(<span class="string">&quot;Write: MDL %p, MdlFlags %x, SystemAddr %p, %d bytes\n&quot;</span>,pIrp-&gt;MdlAddress, pIrp-&gt;MdlAddress-&gt;MdlFlags, pData, DataLength));</span><br><span class="line">            <span class="built_in">DEBUGPDUMP</span>(DL_VERY_LOUD, pData, <span class="built_in">MIN</span>(DataLength, <span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">// SEND_DBG</span></span></span><br><span class="line">        <span class="comment">// 发送包。非常简单。包发送完之后会自动调用协议特征中的一个回调函数NdisProtSendComplete。在其中再完成IRP即可。</span></span><br><span class="line">        <span class="built_in">NdisSendPackets</span>(pOpenContext-&gt;BindingHandle, &amp;pNdisPacket, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    <span class="comment">// 如果正常发送包是STATUS_PENDING。否则是有错的，可以在这里直接完成。</span></span><br><span class="line">    <span class="keyword">if</span> (NtStatus != STATUS_PENDING) &#123;</span><br><span class="line">        pIrp-&gt;IoStatus.Status = NtStatus;</span><br><span class="line">        <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> NtStatus;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>包发送<code>NdisProtSendComplete</code>的实现：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是协议特征集中的一个回调函数。如果调用了NdisSendPacket,那么在发送结束之后，这个函数会被调用。</span></span><br><span class="line"><span class="function">VOID <span class="title">NdisProtSendComplete</span><span class="params">(IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_PACKET pNdisPacket, IN NDIS_STATUS Status)</span> </span>&#123;</span><br><span class="line">    PIRP                        pIrp;</span><br><span class="line">    PIO_STACK_LOCATION          pIrpSp;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT       pOpenContext;</span><br><span class="line">    <span class="comment">// 取得打开上下文。</span></span><br><span class="line">    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;</span><br><span class="line">    <span class="built_in">NPROT_STRUCT_ASSERT</span>(pOpenContext, oc);</span><br><span class="line">    <span class="comment">// 从包描述符中取得IRP的指针。</span></span><br><span class="line">    pIrp = <span class="built_in">NPROT_IRP_FROM_SEND_PKT</span>(pNdisPacket);</span><br><span class="line">    <span class="comment">// 下面的代码只和Win9x有关。本书不讨论。</span></span><br><span class="line">    <span class="keyword">if</span> (pOpenContext-&gt;bRunningOnWin9x) &#123;</span><br><span class="line">        <span class="comment">//  We would have attached our own NDIS_BUFFER. Take it out and free it.</span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifndef</span> NDIS51</span></span><br><span class="line">        PNDIS_BUFFER                pNdisBuffer;</span><br><span class="line">        PVOID                       VirtualAddr;</span><br><span class="line">        UINT                        BufferLength;</span><br><span class="line">        UINT                        TotalLength;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> NDIS51</span></span><br><span class="line">        <span class="built_in">NPROT_ASSERT</span>(FALSE); <span class="comment">// NDIS 5.1 not on Win9X!</span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">NdisGetFirstBufferFromPacket</span>(pNdisPacket, &amp;pNdisBuffer, &amp;VirtualAddr, &amp;BufferLength, &amp;TotalLength);</span><br><span class="line">        <span class="built_in">NPROT_ASSERT</span>(pNdisBuffer != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">NdisFreeBuffer</span>(pNdisBuffer);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 去掉未决取消函数。同时从未决链中删除。</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> NDIS51</span></span><br><span class="line">    <span class="built_in">IoSetCancelRoutine</span>(pIrp, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">    <span class="built_in">NPROT_REMOVE_ENTRY_LIST</span>(&amp;pIrp-&gt;Tail.Overlay.ListEntry);</span><br><span class="line">    <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 数据包解引用。</span></span><br><span class="line">    <span class="built_in">NPROT_DEREF_SEND_PKT</span>(pNdisPacket);</span><br><span class="line">    <span class="comment">// 把请求完成掉。</span></span><br><span class="line">    pIrpSp = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    <span class="keyword">if</span> (Status == NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">        pIrp-&gt;IoStatus.Information = pIrpSp-&gt;Parameters.Write.Length;</span><br><span class="line">        pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">        pIrp-&gt;IoStatus.Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">DEBUGP</span>(DL_INFO, (<span class="string">&quot;SendComplete: packet %p/IRP %p/Length %d completed with status %x\n&quot;</span>, pNdisPacket, pIrp, pIrp-&gt;IoStatus.Information, pIrp-&gt;IoStatus.Status));</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="comment">// 未决发送包减少一个。</span></span><br><span class="line">    <span class="built_in">NdisInterlockedDecrement</span>((PLONG)&amp;pOpenContext-&gt;PendedSendCount);</span><br><span class="line">    <span class="built_in">NPROT_DEREF_OPEN</span>(pOpenContext);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="协议驱动接收回调"><a href="#协议驱动接收回调" class="headerlink" title="协议驱动接收回调"></a>协议驱动接收回调</h2><p>当被绑定的网卡收到数据包时，内核调用<code>ReceiveHandler</code>和<code>ReceivePacketHandler</code>，至于啥时候调用哪个尚不明朗。<code>ReceiveCompleteHandler</code>回调函数在<code>ReceiveHandler</code>调用完后。若只需要包的数据内容的前几字节就可决定该包是否是本协议需要处理的，那么下层驱动就没必要提交整个包，只提供包开始的几个字节给协议驱动，这称为前视区。若决定获取完整数据，应用<code>NdisTransferData</code>，传输完成后回调函数<code>TransferDataCompleteHandler</code>将被调用。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NDIS_STATUS <span class="title">NdisProtReceive</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN NDIS_HANDLE ProtocolBindingContext, <span class="comment">//绑定句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN NDIS_HANDLE MacReceiveContext, </span></span></span><br><span class="line"><span class="params"><span class="function">    __in_bcount(HeaderBufferSize) IN PVOID pHeaderBuffer, <span class="comment">//以太网包头</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN UINT HeaderBufferSize, <span class="comment">//包头长度 一般14</span></span></span></span><br><span class="line"><span class="params"><span class="function">    __in_bcount(LookaheadBufferSize) IN PVOID pLookaheadBuffer, <span class="comment">//前视区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN UINT LookaheadBufferSize, <span class="comment">//前视区长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN UINT PacketSize <span class="comment">//完整包长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*++</span></span></span><br><span class="line"><span class="comment"><span class="function">Routine Description:</span></span></span><br><span class="line"><span class="comment"><span class="function">    Our protocol receive handler called by NDIS, typically if we have a miniport below that doesn&#x27;t indicate packets.</span></span></span><br><span class="line"><span class="comment"><span class="function">    We make a local packet/buffer copy of this data, queue it up, and kick off the read service routine.</span></span></span><br><span class="line"><span class="comment"><span class="function">Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function">    ProtocolBindingContext - pointer to open context</span></span></span><br><span class="line"><span class="comment"><span class="function">    MacReceiveContext - for use in NdisTransferData</span></span></span><br><span class="line"><span class="comment"><span class="function">    pHeaderBuffer - pointer to data header</span></span></span><br><span class="line"><span class="comment"><span class="function">    HeaderBufferSize - size of the above</span></span></span><br><span class="line"><span class="comment"><span class="function">    pLookaheadBuffer - pointer to buffer containing lookahead data</span></span></span><br><span class="line"><span class="comment"><span class="function">    LookaheadBufferSize - size of the above</span></span></span><br><span class="line"><span class="comment"><span class="function">    PacketSize - size of the entire packet, minus header size.</span></span></span><br><span class="line"><span class="comment"><span class="function">Return Value:</span></span></span><br><span class="line"><span class="comment"><span class="function">    NDIS_STATUS_NOT_ACCEPTED - if this packet is uninteresting</span></span></span><br><span class="line"><span class="comment"><span class="function">    NDIS_STATUS_SUCCESS - if we processed this successfully</span></span></span><br><span class="line"><span class="comment"><span class="function">--*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT   pOpenContext;</span><br><span class="line">    NDIS_STATUS             Status;</span><br><span class="line">    PNDIS_PACKET            pRcvPacket;</span><br><span class="line">    PUCHAR                  pRcvData;</span><br><span class="line">    UINT                    BytesTransferred;</span><br><span class="line">    PNDIS_BUFFER            pOriginalNdisBuffer, pPartialNdisBuffer;</span><br><span class="line">    <span class="comment">// 获得绑定句柄。</span></span><br><span class="line">    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;</span><br><span class="line">    <span class="built_in">NPROT_STRUCT_ASSERT</span>(pOpenContext, oc);</span><br><span class="line">    pRcvPacket = <span class="literal">NULL</span>;</span><br><span class="line">    pRcvData = <span class="literal">NULL</span>;</span><br><span class="line">    Status = NDIS_STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果头长度不是以太网包头的长度，则不接收这个包。本协议只接收以太网包。</span></span><br><span class="line">        <span class="keyword">if</span> (HeaderBufferSize != <span class="built_in">sizeof</span>(NDISPROT_ETH_HEADER)) &#123;</span><br><span class="line">            Status = NDIS_STATUS_NOT_ACCEPTED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 这个比较比较奇怪。难道头长度是负数?</span></span><br><span class="line">        <span class="keyword">if</span> ((PacketSize + HeaderBufferSize) &lt; PacketSize) &#123;</span><br><span class="line">            Status = NDIS_STATUS_NOT_ACCEPTED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 分配一个包。包括包描述符和缓冲描述符，以及内存空间，一次性分配好。</span></span><br><span class="line">        pRcvPacket = <span class="built_in">ndisprotAllocateReceivePacket</span>(pOpenContext, PacketSize + HeaderBufferSize, &amp;pRcvData);</span><br><span class="line">        <span class="comment">// 如果分配失败了，就不再接收这个包了。</span></span><br><span class="line">        <span class="keyword">if</span> ((pRcvPacket == <span class="literal">NULL</span>) || (pRcvData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            Status = NDIS_STATUS_NOT_ACCEPTED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 内存拷贝。先拷贝以太网包头。</span></span><br><span class="line">        <span class="built_in">NdisMoveMappedMemory</span>(pRcvData, pHeaderBuffer, HeaderBufferSize);</span><br><span class="line">        <span class="comment">// 检查前视区里是否包含了完整包的数据。</span></span><br><span class="line">        <span class="keyword">if</span> (PacketSize == LookaheadBufferSize) &#123;</span><br><span class="line">            <span class="comment">// 如果前视区已经包括了整个数据包，那么调用NdisCopyLookaheadData就得到了完整的包，然后调用ndisprotQueueReceivePacket将这个包插入队列即可。</span></span><br><span class="line">            <span class="built_in">NdisCopyLookaheadData</span>(pRcvData + HeaderBufferSize, pLookaheadBuffer, LookaheadBufferSize, pOpenContext-&gt;MacOptions);</span><br><span class="line">            <span class="built_in">ndisprotQueueReceivePacket</span>(pOpenContext, pRcvPacket);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则的话，需要分配一个新的缓冲描述符。请注意这个描述符号对应的是从包缓冲区开始之后HeaderBufferSize个字节之后处开始的空间（pRcvData + HeaderBufferSize）。</span></span><br><span class="line">            <span class="built_in">NdisAllocateBuffer</span>(&amp;Status, &amp;pPartialNdisBuffer, pOpenContext-&gt;RecvBufferPool, pRcvData + HeaderBufferSize, PacketSize);</span><br><span class="line">            <span class="keyword">if</span> (Status == NDIS_STATUS_SUCCESS) &#123;</span><br><span class="line">                <span class="comment">// 如果成功了，就把包上原有的缓冲解链。使原来的缓冲描述符脱离包描述符。</span></span><br><span class="line">                <span class="built_in">NdisUnchainBufferAtFront</span>(pRcvPacket, &amp;pOriginalNdisBuffer);</span><br><span class="line">                <span class="comment">// 现在把原来的包描述符保存在包描述符中（保留以备后用）</span></span><br><span class="line">                <span class="built_in">NPROT_RCV_PKT_TO_ORIGINAL_BUFFER</span>(pRcvPacket) = pOriginalNdisBuffer;</span><br><span class="line">                <span class="comment">// 然后把新的缓冲描述符连接到包上。</span></span><br><span class="line">                <span class="built_in">NdisChainBufferAtBack</span>(pRcvPacket, pPartialNdisBuffer);</span><br><span class="line">                <span class="built_in">DEBUGP</span>(DL_LOUD, (<span class="string">&quot;Receive: setting up for TransferData: Pkt %p, OriginalBuf %p, PartialBuf %p\n&quot;</span>, pRcvPacket, pOriginalNdisBuffer, pPartialNdisBuffer));</span><br><span class="line">                <span class="comment">// 然后调用NdisTransferData来传输数据包剩余的部分。这个调用完成之后，协议特征中的NdisProtTransferDataComplete会被调用。</span></span><br><span class="line">                <span class="built_in">NdisTransferData</span>(&amp;Status, pOpenContext-&gt;BindingHandle, MacReceiveContext, <span class="number">0</span>, PacketSize, pRcvPacket, &amp;BytesTransferred);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果失败了，就不会调用NdisTransferData。但是我们还是要在NdisProtTransferDataComplete中做最后的处理。所以自己填写BytesTransferred。</span></span><br><span class="line">                BytesTransferred = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (Status != NDIS_STATUS_PENDING)</span><br><span class="line">                <span class="comment">// 如果前面就失败了，我们自己调用NdisProtTransferDataComplete。</span></span><br><span class="line">                <span class="built_in">NdisProtTransferDataComplete</span>((NDIS_HANDLE)pOpenContext, pRcvPacket, Status, BytesTransferred);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    <span class="built_in">DEBUGP</span>(DL_LOUD, (<span class="string">&quot;Receive: Open %p, Pkt %p, Size %d\n&quot;</span>, pOpenContext, pRcvPacket, PacketSize));</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种类型的接收回调函数指针<code>ReceivePacketHandler</code>的原型为：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">NdisProtReceivePacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ NDIS_HANDLE ProtocolBindingContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PNDIS_PACKET pNdisPacket</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上述<code>TransferDataCompleteHandler</code>实现如下：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">NdisProtTransferDataComplete</span><span class="params">(IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_PACKET pNdisPacket, IN NDIS_STATUS TransferStatus, IN UINT BytesTransferred)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*++</span></span></span><br><span class="line"><span class="comment"><span class="function">Routine Description:</span></span></span><br><span class="line"><span class="comment"><span class="function">    NDIS entry point called to signal completion of a call to NdisTransferData that had pended.</span></span></span><br><span class="line"><span class="comment"><span class="function">Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function">    ProtocolBindingContext - pointer to open context</span></span></span><br><span class="line"><span class="comment"><span class="function">    pNdisPacket - our receive packet into which data is transferred</span></span></span><br><span class="line"><span class="comment"><span class="function">    TransferStatus - status of the transfer</span></span></span><br><span class="line"><span class="comment"><span class="function">    BytesTransferred - bytes copied into the packet.</span></span></span><br><span class="line"><span class="comment"><span class="function">Return Value:</span></span></span><br><span class="line"><span class="comment"><span class="function">    None</span></span></span><br><span class="line"><span class="comment"><span class="function">--*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT   pOpenContext;</span><br><span class="line">    PNDIS_BUFFER            pOriginalBuffer, pPartialBuffer;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(BytesTransferred);</span><br><span class="line">    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;</span><br><span class="line">    <span class="built_in">NPROT_STRUCT_ASSERT</span>(pOpenContext, oc);</span><br><span class="line">    <span class="comment">// 得到保存过的旧的缓冲描述符。要记得在传输之前，为了让传输的内容正确的写到以太网包头后，我们分配了一个新的缓冲描述符替换了旧的缓冲描述符。现在要恢复它了。</span></span><br><span class="line">    pOriginalBuffer = <span class="built_in">NPROT_RCV_PKT_TO_ORIGINAL_BUFFER</span>(pNdisPacket);</span><br><span class="line">    <span class="keyword">if</span> (pOriginalBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 和前面的替换时的操作一样，先Unchain，然后再调用Chain。调用之后已经恢复了使用旧的包描述符。</span></span><br><span class="line">        <span class="built_in">NdisUnchainBufferAtFront</span>(pNdisPacket, &amp;pPartialBuffer);</span><br><span class="line">        <span class="built_in">NdisChainBufferAtBack</span>(pNdisPacket, pOriginalBuffer);</span><br><span class="line">        <span class="built_in">DEBUGP</span>(DL_LOUD, (<span class="string">&quot;TransferComp: Pkt %p, OrigBuf %p, PartialBuf %p\n&quot;</span>, pNdisPacket, pOriginalBuffer, pPartialBuffer));</span><br><span class="line">        <span class="built_in">ASSERT</span>(pPartialBuffer != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 那么那个新的包描述符已经没用了，调用NdisFreeBuffer释放它。</span></span><br><span class="line">        <span class="keyword">if</span> (pPartialBuffer != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">NdisFreeBuffer</span>(pPartialBuffer);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (TransferStatus == NDIS_STATUS_SUCCESS)</span><br><span class="line">        <span class="comment">// 如果传输是成功的，将包保存到接收队列中。</span></span><br><span class="line">        <span class="built_in">ndisprotQueueReceivePacket</span>(pOpenContext, pNdisPacket);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果传输失败了，直接释放这个包。</span></span><br><span class="line">        <span class="built_in">ndisprotFreeReceivePacket</span>(pOpenContext, pNdisPacket);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里<code>ReveicePacketHandler</code>返回值为引用计数，即接收到的包描述符被本协议驱动使用的次数。若包被本驱动使用，则下层网卡不能释放这个包。引用计数为0才能释放。若要重用该网络包，就要返回一个引用计数，一般1就行。下层驱动资源紧张时，必需释放该包并重新分配，拷贝到新的包描述符中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">NdisProtReceivePacket</span><span class="params">(IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_PACKET pNdisPacket)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*++</span></span></span><br><span class="line"><span class="comment"><span class="function">Routine Description:</span></span></span><br><span class="line"><span class="comment"><span class="function">    Protocol entry point called by NDIS if the driver below uses NDIS 4 style receive packet indications.</span></span></span><br><span class="line"><span class="comment"><span class="function">    If the miniport allows us to hold on to this packet, we use it as is, otherwise we make a copy.</span></span></span><br><span class="line"><span class="comment"><span class="function">Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function">    ProtocolBindingContext - pointer to open context</span></span></span><br><span class="line"><span class="comment"><span class="function">    pNdisPacket - the packet being indicated up.</span></span></span><br><span class="line"><span class="comment"><span class="function">Return Value:</span></span></span><br><span class="line"><span class="comment"><span class="function">    None</span></span></span><br><span class="line"><span class="comment"><span class="function">--*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNDISPROT_OPEN_CONTEXT   pOpenContext;</span><br><span class="line">    PNDIS_BUFFER            pNdisBuffer;</span><br><span class="line">    UINT                    BufferLength;</span><br><span class="line">    PNDISPROT_ETH_HEADER     pEthHeader;</span><br><span class="line">    PNDIS_PACKET            pCopyPacket;</span><br><span class="line">    PUCHAR                  pCopyBuf;</span><br><span class="line">    UINT                    TotalPacketLength;</span><br><span class="line">    UINT                    BytesCopied;</span><br><span class="line">    INT                     RefCount = <span class="number">0</span>;</span><br><span class="line">    NDIS_STATUS             Status;</span><br><span class="line">    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;</span><br><span class="line">    <span class="built_in">NPROT_STRUCT_ASSERT</span>(pOpenContext, oc);</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> NDIS51</span></span><br><span class="line">    <span class="built_in">NdisGetFirstBufferFromPacketSafe</span>(pNdisPacket, &amp;pNdisBuffer, &amp;pEthHeader, &amp;BufferLength, &amp;TotalPacketLength, NormalPagePriority);</span><br><span class="line">    <span class="keyword">if</span> (pEthHeader == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//  The system is low on resources. Set up to handle failure below.</span></span><br><span class="line">        BufferLength = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 从包描述符中得到第一个缓冲描述符。</span></span><br><span class="line">    <span class="built_in">NdisGetFirstBufferFromPacket</span>(pNdisPacket, &amp;pNdisBuffer, &amp;pEthHeader, &amp;BufferLength, &amp;TotalPacketLength);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这个包的长度比以太网包头还要小，丢弃之。</span></span><br><span class="line">        <span class="keyword">if</span> (BufferLength &lt; <span class="built_in">sizeof</span>(NDISPROT_ETH_HEADER)) &#123;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_WARN, (<span class="string">&quot;ReceivePacket: Open %p, runt pkt %p, first buffer length %d\n&quot;</span>, pOpenContext, pNdisPacket, BufferLength));</span><br><span class="line">            Status = NDIS_STATUS_NOT_ACCEPTED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">DEBUGP</span>(DL_LOUD, (<span class="string">&quot;ReceivePacket: Open %p, interesting pkt %p\n&quot;</span>, pOpenContext, pNdisPacket));</span><br><span class="line">        <span class="comment">// 如果这个包有NDIS_STATUS_RESOURCES状态，则必须拷贝而不能重用该包。当然这样就比较消耗时间和资源了。</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">NDIS_GET_PACKET_STATUS</span>(pNdisPacket) == NDIS_STATUS_RESOURCES) || pOpenContext-&gt;bRunningOnWin9x) &#123;</span><br><span class="line">            <span class="comment">// 下面是分配一个包并拷贝其内容。读者可以参考前面讲过的内容来理解。</span></span><br><span class="line">            pCopyPacket = <span class="built_in">ndisprotAllocateReceivePacket</span>(pOpenContext, TotalPacketLength, &amp;pCopyBuf);</span><br><span class="line">            <span class="keyword">if</span> (pCopyPacket == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">DEBUGP</span>(DL_FATAL, (<span class="string">&quot;ReceivePacket: Open %p, failed to alloc copy, %d bytes\n&quot;</span>, pOpenContext, TotalPacketLength));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 调用NdisCopyFromPacketToPacket来拷贝包。当然在拷贝之前调用者必须确保目标包的缓冲区长度是足够的。</span></span><br><span class="line">            <span class="built_in">NdisCopyFromPacketToPacket</span>(pCopyPacket, <span class="number">0</span>, TotalPacketLength, pNdisPacket, <span class="number">0</span>, &amp;BytesCopied);</span><br><span class="line">            <span class="built_in">NPROT_ASSERT</span>(BytesCopied == TotalPacketLength);</span><br><span class="line">            <span class="comment">// 那么现在开始就用新的包了。</span></span><br><span class="line">            pNdisPacket = pCopyPacket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 返回值。返回值表示的是我们已经一次引用了这个包。当处理完结的时候，我们就可以调用NdisReturnPackets来要求下层驱动释放这个包了。本函数把RefCount当做返回值。如果返回了0，那么下层驱动会认为我们不再需要这个数据包。</span></span><br><span class="line">            RefCount = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将数据包放入队列里。</span></span><br><span class="line">        <span class="built_in">ndisprotQueueReceivePacket</span>(pOpenContext, pNdisPacket);</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    <span class="keyword">return</span> RefCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这俩接收包的回调函数最终都是收到一个数据包并把它放入队列中。该队列用LIST_ENTRY实现，还有一些常用宏：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NPROT_INSERT_TAIL_LIST(_pList, _pEnt)    InsertTailList(_pList, _pEnt) <span class="comment">//插入链表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPROT_REMOVE_ENTRY_LIST(_pEnt)           RemoveEntryList(_pEnt)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPROT_LIST_ENTRY_TO_RCV_PKT(_pEnt) CONTAINING_RECORD(CONTAINING_RECORD(_pEnt, NPROT_RECV_PACKET_RSVD, Link), NDIS_PACKET, ProtocolReserved) <span class="comment">//从链表节点指针得到包指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPROT_RCV_PKT_TO_LIST_ENTRY(_pPkt) (&amp;((PNPROT_RECV_PACKET_RSVD)&amp;((_pPkt)-&gt;ProtocolReserved[0]))-&gt;Link)</span></span><br></pre></td></tr></table></figure>

<p><code>ndisprotQueueReceivePacket</code>代码实现如下。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ndisprotQueueReceivePacket</span><span class="params">(IN PNDISPROT_OPEN_CONTEXT pOpenContext, IN PNDIS_PACKET pRcvPacket)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*++</span></span></span><br><span class="line"><span class="comment"><span class="function">Routine Description:</span></span></span><br><span class="line"><span class="comment"><span class="function">    Queue up a received packet on the open context structure. If the queue size goes beyond a water mark, discard a packet at the head of the queue.</span></span></span><br><span class="line"><span class="comment"><span class="function">    Finally, run the queue service routine.</span></span></span><br><span class="line"><span class="comment"><span class="function">Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function">    pOpenContext - pointer to open context</span></span></span><br><span class="line"><span class="comment"><span class="function">    pRcvPacket - the received packet</span></span></span><br><span class="line"><span class="comment"><span class="function">Return Value:</span></span></span><br><span class="line"><span class="comment"><span class="function">    None</span></span></span><br><span class="line"><span class="comment"><span class="function">--*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PLIST_ENTRY     pEnt;</span><br><span class="line">    PLIST_ENTRY     pDiscardEnt;</span><br><span class="line">    PNDIS_PACKET    pDiscardPkt;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pEnt = <span class="built_in">NPROT_RCV_PKT_TO_LIST_ENTRY</span>(pRcvPacket);</span><br><span class="line">        <span class="built_in">NPROT_REF_OPEN</span>(pOpenContext);    <span class="comment">// queued rcv packet</span></span><br><span class="line">        <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="comment">// 如果处于活动的状态，并且正确的电源状态，那么就把这个包插入接收缓冲链表中。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NPROT_TEST_FLAGS</span>(pOpenContext-&gt;Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE) &amp;&amp;</span><br><span class="line">            (pOpenContext-&gt;PowerState == NetDeviceStateD0)) &#123;</span><br><span class="line">            <span class="built_in">NPROT_INSERT_TAIL_LIST</span>(&amp;pOpenContext-&gt;RecvPktQueue, pEnt);</span><br><span class="line">            pOpenContext-&gt;RecvPktCount++;</span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_VERY_LOUD, (<span class="string">&quot;QueueReceivePacket: open %p, queued pkt %p, queue size %d\n&quot;</span>, pOpenContext, pRcvPacket, pOpenContext-&gt;RecvPktCount));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则的话，就直接释放掉这个包即可。</span></span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">            <span class="built_in">ndisprotFreeReceivePacket</span>(pOpenContext, pRcvPacket);</span><br><span class="line">            <span class="built_in">NPROT_DEREF_OPEN</span>(pOpenContext);  <span class="comment">// dropped rcv packet - bad state</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 如果输入缓冲区里包太多了，就要删除一个。</span></span><br><span class="line">        <span class="keyword">if</span> (pOpenContext-&gt;RecvPktCount &gt; MAX_RECV_QUEUE_SIZE) &#123;</span><br><span class="line">            <span class="comment">// 要删除的包的链节点指针</span></span><br><span class="line">            pDiscardEnt = pOpenContext-&gt;RecvPktQueue.Flink;</span><br><span class="line">            <span class="built_in">NPROT_REMOVE_ENTRY_LIST</span>(pDiscardEnt);</span><br><span class="line">            <span class="comment">// 接收包数量减去1</span></span><br><span class="line">            pOpenContext-&gt;RecvPktCount--;</span><br><span class="line">            <span class="comment">// 可以释放锁了。</span></span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">            <span class="comment">// 从链节点转换为包的指针</span></span><br><span class="line">            pDiscardPkt = <span class="built_in">NPROT_LIST_ENTRY_TO_RCV_PKT</span>(pDiscardEnt);</span><br><span class="line">            <span class="comment">// 把包释放掉。</span></span><br><span class="line">            <span class="built_in">ndisprotFreeReceivePacket</span>(pOpenContext, pDiscardPkt);</span><br><span class="line">            <span class="comment">// 打开上下文解引用。这是因为每入队一个都要增加一次引用计数。</span></span><br><span class="line">            <span class="built_in">NPROT_DEREF_OPEN</span>(pOpenContext);  <span class="comment">// dropped rcv packet - queue too long</span></span><br><span class="line">            <span class="built_in">DEBUGP</span>(DL_INFO, (<span class="string">&quot;QueueReceivePacket: open %p queue too long, discarded pkt %p\n&quot;</span>, pOpenContext, pDiscardPkt));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="comment">// 服务函数。这个函数看是否有未决的读请求。如果有，就取包来完成这个请求。</span></span><br><span class="line">        <span class="built_in">ndisprotServiceReads</span>(pOpenContext);</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述<code>ndisprotServiceReads</code>负责接收数据包的出队和读请求的完成。该函数当读请求队列和接收包队列都不为空时，从包中取得数据，拷贝到IRP里，完成该IRP。<code>pOpenContext-&gt;PendedReads</code>为未决读请求队列，<code>pOpenContext-&gt;RecvPktQueue</code>为接收包缓冲队列，这俩实际是链表。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ndisprotServiceReads</span><span class="params">(IN PNDISPROT_OPEN_CONTEXT pOpenContext)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*++</span></span></span><br><span class="line"><span class="comment"><span class="function">Routine Description:</span></span></span><br><span class="line"><span class="comment"><span class="function">    Utility routine to copy received data into user buffers and complete READ IRPs.</span></span></span><br><span class="line"><span class="comment"><span class="function">Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function">    pOpenContext - pointer to open context</span></span></span><br><span class="line"><span class="comment"><span class="function">Return Value:</span></span></span><br><span class="line"><span class="comment"><span class="function">    None</span></span></span><br><span class="line"><span class="comment"><span class="function">--*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIRP                pIrp = <span class="literal">NULL</span>;</span><br><span class="line">    PLIST_ENTRY         pIrpEntry;</span><br><span class="line">    PNDIS_PACKET        pRcvPacket;</span><br><span class="line">    PLIST_ENTRY         pRcvPacketEntry;</span><br><span class="line">    PUCHAR              pSrc, pDst;</span><br><span class="line">    ULONG               BytesRemaining; <span class="comment">// at pDst</span></span><br><span class="line">    PNDIS_BUFFER        pNdisBuffer;</span><br><span class="line">    ULONG               BytesAvailable;</span><br><span class="line">    BOOLEAN             FoundPendingIrp;</span><br><span class="line">    <span class="built_in">DEBUGP</span>(DL_VERY_LOUD, (<span class="string">&quot;ServiceReads: open %p/%x\n&quot;</span>, pOpenContext, pOpenContext-&gt;Flags));</span><br><span class="line">    <span class="built_in">NPROT_REF_OPEN</span>(pOpenContext);  <span class="comment">// temp ref - service reads</span></span><br><span class="line">    <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">    <span class="comment">// 只要读请求队列和接收包队列同时不为空，则可以做...</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">NPROT_IS_LIST_EMPTY</span>(&amp;pOpenContext-&gt;PendedReads) &amp;&amp; !<span class="built_in">NPROT_IS_LIST_EMPTY</span>(&amp;pOpenContext-&gt;RecvPktQueue)) &#123;</span><br><span class="line">        FoundPendingIrp = FALSE;</span><br><span class="line">        <span class="comment">// 获得第一个未决读请求</span></span><br><span class="line">        pIrpEntry = pOpenContext-&gt;PendedReads.Flink;</span><br><span class="line">        <span class="keyword">while</span> (pIrpEntry != &amp;pOpenContext-&gt;PendedReads) &#123;</span><br><span class="line">            <span class="comment">// 从链表节点得到IRP</span></span><br><span class="line">            pIrp = <span class="built_in">CONTAINING_RECORD</span>(pIrpEntry, IRP, Tail.Overlay.ListEntry);</span><br><span class="line">            <span class="comment">// 检查这个请求是否正在被取消。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IoSetCancelRoutine</span>(pIrp, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="comment">// 把这个IRP出列。</span></span><br><span class="line">                <span class="built_in">NPROT_REMOVE_ENTRY_LIST</span>(pIrpEntry);</span><br><span class="line">                FoundPendingIrp = TRUE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是在去掉，则跳过这个IRP即可。使用下一个。</span></span><br><span class="line">                <span class="built_in">DEBUGP</span>(DL_INFO, (<span class="string">&quot;ServiceReads: open %p, skipping cancelled IRP %p\n&quot;</span>, pOpenContext, pIrp));</span><br><span class="line">                pIrpEntry = pIrpEntry-&gt;Flink;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 如果没有IRP,直接跳出结束。</span></span><br><span class="line">        <span class="keyword">if</span> (FoundPendingIrp == FALSE)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 得到第一个包（最旧的），出队列。</span></span><br><span class="line">        pRcvPacketEntry = pOpenContext-&gt;RecvPktQueue.Flink;</span><br><span class="line">        <span class="built_in">NPROT_REMOVE_ENTRY_LIST</span>(pRcvPacketEntry);</span><br><span class="line">        pOpenContext-&gt;RecvPktCount--;</span><br><span class="line">        <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        <span class="built_in">NPROT_DEREF_OPEN</span>(pOpenContext);</span><br><span class="line">        <span class="comment">// 从节点获得包。</span></span><br><span class="line">        pRcvPacket = <span class="built_in">NPROT_LIST_ENTRY_TO_RCV_PKT</span>(pRcvPacketEntry);</span><br><span class="line">        <span class="comment">//  Copy as much data as possible from the receive packet to the IRP MDL.</span></span><br><span class="line">        <span class="comment">// 得到IRP的输出缓冲地址。然后尽量拷贝更多的数据。</span></span><br><span class="line">        pDst = <span class="built_in">MmGetSystemAddressForMdlSafe</span>(pIrp-&gt;MdlAddress, NormalPagePriority);</span><br><span class="line">        <span class="built_in">NPROT_ASSERT</span>(pDst != <span class="literal">NULL</span>);  <span class="comment">// since it was already mapped</span></span><br><span class="line">        BytesRemaining = <span class="built_in">MmGetMdlByteCount</span>(pIrp-&gt;MdlAddress);</span><br><span class="line">        pNdisBuffer = <span class="built_in">NDIS_PACKET_FIRST_NDIS_BUFFER</span>(pRcvPacket);</span><br><span class="line">        <span class="comment">// 请注意，每个PNDIS_BUFFER都是一个PMDL，同时PNDIS_BUFFER本身都是链表。用NdisGetNextBuffer可以从一个得到它的下面一个。包的数据实际上是保存在一个缓冲描述符链表里的。</span></span><br><span class="line">        <span class="keyword">while</span> (BytesRemaining &amp;&amp; (pNdisBuffer != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">ifndef</span> WIN9X</span></span><br><span class="line">            <span class="built_in">NdisQueryBufferSafe</span>(pNdisBuffer, &amp;pSrc, &amp;BytesAvailable, NormalPagePriority);</span><br><span class="line">            <span class="keyword">if</span> (pSrc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">DEBUGP</span>(DL_FATAL, (<span class="string">&quot;ServiceReads: Open %p, QueryBuffer failed for buffer %p\n&quot;</span>, pOpenContext, pNdisBuffer));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="built_in">NdisQueryBuffer</span>(pNdisBuffer, &amp;pSrc, &amp;BytesAvailable);</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">// 如果还可以继续拷贝，就继续拷贝。</span></span><br><span class="line">            <span class="keyword">if</span> (BytesAvailable) &#123;</span><br><span class="line">                ULONG       BytesToCopy = <span class="built_in">MIN</span>(BytesAvailable, BytesRemaining);</span><br><span class="line">                <span class="built_in">NPROT_COPY_MEM</span>(pDst, pSrc, BytesToCopy);</span><br><span class="line">                BytesRemaining -= BytesToCopy;</span><br><span class="line">                pDst += BytesToCopy;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">NdisGetNextBuffer</span>(pNdisBuffer, &amp;pNdisBuffer); <span class="comment">//得到下一个NDIS_BUFFER节点</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 拷贝好数据之后，结束IRP即可。</span></span><br><span class="line">        pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">        pIrp-&gt;IoStatus.Information = <span class="built_in">MmGetMdlByteCount</span>(pIrp-&gt;MdlAddress) - BytesRemaining;</span><br><span class="line">        <span class="built_in">DEBUGP</span>(DL_INFO, (<span class="string">&quot;ServiceReads: Open %p, IRP %p completed with %d bytes\n&quot;</span>, pOpenContext, pIrp, pIrp-&gt;IoStatus.Information));</span><br><span class="line">        <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">        <span class="comment">// 如果这个包描述符不是从接收包池里分配的，那么就是从网卡驱动里重用的。如果是重用的，调用NdisReturnPackets归还给网卡驱动，让它释放。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NdisGetPoolFromPacket</span>(pRcvPacket) != pOpenContext-&gt;RecvPacketPool)</span><br><span class="line">            <span class="built_in">NdisReturnPackets</span>(&amp;pRcvPacket, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则的话自己释放。</span></span><br><span class="line">            <span class="built_in">ndisprotFreeReceivePacket</span>(pOpenContext, pRcvPacket);</span><br><span class="line">        <span class="built_in">NPROT_DEREF_OPEN</span>(pOpenContext);    <span class="comment">// took out pended Read</span></span><br><span class="line">        <span class="built_in">NPROT_ACQUIRE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">        pOpenContext-&gt;PendedReadCount--;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">NPROT_RELEASE_LOCK</span>(&amp;pOpenContext-&gt;Lock);</span><br><span class="line">    <span class="built_in">NPROT_DEREF_OPEN</span>(pOpenContext);    <span class="comment">// temp ref - service reads</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io/2024/10/08/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-NDIS%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8/">https://monoceros406.github.io/2024/10/08/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-NDIS%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://monoceros406.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Win%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">Win驱动开发</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/08/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-NDIS%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8%E6%BA%90%E7%A0%81/" title="Windows驱动开发入门-NDIS协议驱动源码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Windows驱动开发入门-NDIS协议驱动源码</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/08/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-WFP%E8%BF%87%E6%BB%A4%E5%B9%B3%E5%8F%B0/" title="Windows驱动开发入门-WFP过滤平台"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Windows驱动开发入门-WFP过滤平台</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/28/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-Minifilter%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/" title="Windows驱动开发入门-Minifilter示例代码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-28</div><div class="title">Windows驱动开发入门-Minifilter示例代码</div></div></a></div><div><a href="/2024/10/08/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-NDIS%E5%B0%8F%E7%AB%AF%E5%8F%A3%E9%A9%B1%E5%8A%A8/" title="Windows驱动开发入门-NDIS小端口驱动"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-08</div><div class="title">Windows驱动开发入门-NDIS小端口驱动</div></div></a></div><div><a href="/2024/05/14/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E4%B8%B2%E5%8F%A3%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8/" title="Windows驱动开发入门-串口过滤驱动"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-14</div><div class="title">Windows驱动开发入门-串口过滤驱动</div></div></a></div><div><a href="/2024/10/08/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-WFP%E8%BF%87%E6%BB%A4%E5%B9%B3%E5%8F%B0/" title="Windows驱动开发入门-WFP过滤平台"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-08</div><div class="title">Windows驱动开发入门-WFP过滤平台</div></div></a></div><div><a href="/2024/05/14/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E5%BA%94%E7%94%A8%E4%B8%8E%E5%86%85%E6%A0%B8%E9%80%9A%E4%BF%A1/" title="Windows驱动开发入门-应用与内核通信"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-14</div><div class="title">Windows驱动开发入门-应用与内核通信</div></div></a></div><div><a href="/2024/05/28/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BE%AE%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8/" title="Windows驱动开发入门-文件系统微过滤驱动"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-28</div><div class="title">Windows驱动开发入门-文件系统微过滤驱动</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">Windows系统安全爱好者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">324</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://monoceros406.github.io/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哪里排版出锅了请告诉我QwQ  QQ:1295625063</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-NDIS%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">Windows驱动开发入门-NDIS协议驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%8E%E7%A2%8E%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">碎碎念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8%E5%85%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">协议驱动入口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%BD%91%E5%8D%A1%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.</span> <span class="toc-text">协议与网卡绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%99%A4%E7%BB%91%E5%AE%9A"><span class="toc-number">1.4.</span> <span class="toc-text">解除绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E6%93%8D%E4%BD%9C%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.5.</span> <span class="toc-text">用户态操作协议驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.</span> <span class="toc-text">内核态功能实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8%E6%8E%A5%E6%94%B6%E5%9B%9E%E8%B0%83"><span class="toc-number">1.7.</span> <span class="toc-text">协议驱动接收回调</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/01/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8ELibevent%E5%88%9D%E6%8E%A2/" title="C++后端开发入门-FTP服务器与Libevent初探">C++后端开发入门-FTP服务器与Libevent初探</a><time datetime="2025-06-01T02:37:07.000Z" title="发表于 2025-06-01 10:37:07">2025-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/31/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="C++后端开发入门-HTTP服务器编程">C++后端开发入门-HTTP服务器编程</a><time datetime="2025-05-31T12:36:58.000Z" title="发表于 2025-05-31 20:36:58">2025-05-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/31/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="C++后端开发入门-服务器模型编程">C++后端开发入门-服务器模型编程</a><time datetime="2025-05-31T02:14:48.000Z" title="发表于 2025-05-31 10:14:48">2025-05-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/25/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-UDP%E4%B8%8E%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/" title="C++后端开发入门-UDP与原始套接字编程">C++后端开发入门-UDP与原始套接字编程</a><time datetime="2025-05-25T13:27:37.000Z" title="发表于 2025-05-25 21:27:37">2025-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/19/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="C++后端开发入门-TCP服务器编程">C++后端开发入门-TCP服务器编程</a><time datetime="2025-05-19T06:13:56.000Z" title="发表于 2025-05-19 14:13:56">2025-05-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>