<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>恶意代码分析-Rootkit初探 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="恶意代码分析-Rootkit初探TDL3TDL3可将其代码加载到Windows内核中，因此微软在64位Windows系统上引入核完整性度量来使其无效。目前TDL3已经被TDL4取代，后者有大量逃逸和反取证功能，还用Bootkit突破64位系统的内核模式代码签名机制。 TDL3 Rootkit于2010年被首次发现，是当时开发的最复杂的恶意软件之一。该恶意软件家族被称为TDSS、Olmarik、Al">
<meta property="og:type" content="article">
<meta property="og:title" content="恶意代码分析-Rootkit初探">
<meta property="og:url" content="http://monoceros.github.io/2024/09/17/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-Rootkit%E5%88%9D%E6%8E%A2/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="恶意代码分析-Rootkit初探TDL3TDL3可将其代码加载到Windows内核中，因此微软在64位Windows系统上引入核完整性度量来使其无效。目前TDL3已经被TDL4取代，后者有大量逃逸和反取证功能，还用Bootkit突破64位系统的内核模式代码签名机制。 TDL3 Rootkit于2010年被首次发现，是当时开发的最复杂的恶意软件之一。该恶意软件家族被称为TDSS、Olmarik、Al">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://monoceros.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-09-17T13:01:48.000Z">
<meta property="article:modified_time" content="2024-09-26T07:25:00.000Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="逆向工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://monoceros.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://monoceros.github.io/2024/09/17/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-Rootkit%E5%88%9D%E6%8E%A2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '恶意代码分析-Rootkit初探',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-26 15:25:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">281</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/ycy')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">恶意代码分析-Rootkit初探</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-17T13:01:48.000Z" title="发表于 2024-09-17 21:01:48">2024-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-26T07:25:00.000Z" title="更新于 2024-09-26 15:25:00">2024-09-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="恶意代码分析-Rootkit初探"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="恶意代码分析-Rootkit初探"><a href="#恶意代码分析-Rootkit初探" class="headerlink" title="恶意代码分析-Rootkit初探"></a>恶意代码分析-Rootkit初探</h1><h2 id="TDL3"><a href="#TDL3" class="headerlink" title="TDL3"></a>TDL3</h2><p>TDL3可将其代码加载到Windows内核中，因此微软在64位Windows系统上引入核完整性度量来使其无效。目前TDL3已经被TDL4取代，后者有大量逃逸和反取证功能，还用Bootkit突破64位系统的内核模式代码签名机制。</p>
<p>TDL3 Rootkit于2010年被首次发现，是当时开发的最复杂的恶意软件之一。该恶意软件家族被称为TDSS、Olmarik、Alureon等。TDL3通过子公司DogmaMillions和GangstaBucks以按安装付费PPI商业模式进行分发。</p>
<p>TDL3通过在驱动程序的二进制文件中注入恶意代码来感染加载操作系统所必需的一个引导启动驱动程序。在操作系统初始化过程早期阶段，这些引导启动驱动程序与内核映像一起加载，恶意代码控制启动过程。感染例程搜索支持核心操作系统组件的引导启动驱动程序列表，并随机选择一个作为感染目标。列表中每个条目用一个KLDR_DATA_TABLE_ENTRY结构描述，该结构由DRIVER_OBJECT结构中DriverSection字段引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_KLDR_DATA_TABLE_ENTRY</span> &#123;</span><br><span class="line">	LIST_ENTRY InLoadOrderLinks;<span class="comment">//这个成员把系统所有加载(可能是停止没被卸载)已经读取到内存中 我们关心第一个  我们要遍历链表 双链表 不管中间哪个节点都可以遍历整个链表 本驱动的驱动对象就是一个节点</span></span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;<span class="comment">//系统已经启动 没有被初始化 没有调用DriverEntry这个历程的时候 通过这个链表进程串接起来</span></span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks;<span class="comment">//已经调用DriverEntry这个函数的所有驱动程序</span></span><br><span class="line">	PVOID DllBase;</span><br><span class="line">	PVOID EntryPoint;<span class="comment">//驱动的进入点 DriverEntry</span></span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;<span class="comment">//驱动的满路径</span></span><br><span class="line">	UNICODE_STRING BaseDllName;<span class="comment">//不带路径的驱动名字</span></span><br><span class="line">	ULONG Flags;</span><br><span class="line">	USHORT LoadCount;</span><br><span class="line">	USHORT TlsIndex;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		LIST_ENTRY HashLinks;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			PVOID SectionPointer;</span><br><span class="line">			ULONG CheckSum;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			ULONG TimeDateStamp;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			PVOID LoadedImports;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>
<p>一旦选择一个目标驱动程序，则用一个恶意加载程序覆盖他的资源节区.rsrc的前几百字节，修改驱动程序在内存中的映像，该加载程序在启动时从硬盘上加载它需要的其余恶意代码。资源节区内容仍是驱动程序正确运行所需要的， TDL3将其先存储在rsrc.dat文件中，该文件位于由恶意软件维护的隐藏文件系统中。修改资源节区后，将PE头的入口点函数改为指向资源节区。</p>
<p>TDL3拦截了读写I/O请求发送到硬盘的存储/微型端口驱动程序，即为硬件存储媒体驱动发新的最底层存储驱动程序栈。例如在文件系统驱动程序ntfs.sys、fastfat.sys下，有存储类驱动程序disk.sys，其下又有存储端口驱动程序scsiport.sys、storport.sys等。存储端口驱动包含SCSI微型端口、Storport微型端口、ATA微型端口、IDE微型端口等，这些是TDL3的内核钩子的目标。</p>
<p>为了实现上述挂接技术，TDL3先获得一个指向对应设备对象的微型端口驱动对象指针。特别地，钩子代码尝试打开“\\??\\PhysicalDriveXX”的句柄时（XX表示硬盘驱动编码），该字符串实际指向设备对象“\\Device\\HardDisk0\\DR0”的符号链接，该对象由存储类驱动程序创建。从设备对象向下移动设备展，可在最底部找到微型端口存储设备对象，之后即可跟踪记录的DEVICE_OBJECT结构中DriverObject字段，获取指向驱动对象的指针。此时恶意软件有了挂接存储驱动程序栈所需的所有信息。</p>
<p>接下来TDL3创建一个新的恶意驱动对象，并用指向新创建字段的指针覆盖微型端口驱动对象的DriverObject字段，这将允许恶意软件拦截对底层硬盘驱动器的读写请求，因为所有处理程序的地址都在相关驱动程序对象结构中指定DRIVER_OBJECT结构的MajorFunction数组。恶意主处理器拦截了IOCTL_ATA_PASS_THROUGH_DIRECT和IOCTL_ATA_PASS_THROUGH来监控和修改硬盘的读写请求。</p>
<p>TDL3为止包含受保护数据的硬盘驱动器扇区被Windows工具读取或被Windows文件系统意外覆盖，当遇到读操作时，TDL3在I/O操作完成时返回缓冲区的零输出，在写数据请求时跳过整个读请求。TDL3的修改不涉及任何经常受保护和监视的区域，包括系统模块、SSDT、GDT和IDT等。</p>
<p>TDL3是第一个将配置文件和有效负载存储再目标系统隐藏的加密存储区域的恶意软件系统，不依赖于操作系统提供的文件系统服务，已被Rovnix Bootkit、ZeroAccess、Avatar、Gapz等威胁所采用和适应。但恶意软件能使用传统Windows API接口如<code>CreateFile</code>、<code>ReadFile</code>、<code>WriteFile</code>、<code>CloseHandle</code>访问隐藏文件系统内容，简化恶意软件有效负载的开发。TDL3在操作系统文件系统未占用的扇区中分配硬盘隐藏文件系统的映像，从末端向起始段增长，这意味着足够大会覆盖用户的文件系统数据。映像分为1024字节的块，在硬盘驱动器末尾的第一个块包含一个文件表，其条目描述文件系统中包含的文件，信息有：文件名（限制16字符，包括末尾空字符）、文件大小、实际文件偏移量、文件系统创建时间。</p>
<p>文件系统内容按照每个块使用自定义加密算法加密，如RC4等，使用与每个块对应的第一个扇区的逻辑块地址LBA作为密钥。</p>
<p>用户模式下，有效负载打开“\\Device\\XXXXXXXX\\YYYYYYYY”设备对象的句柄来访问隐藏存储，其中XXXXXXXX和YYYYYYYY是随机生成的十六进制数字。</p>
<h2 id="Festi"><a href="#Festi" class="headerlink" title="Festi"></a>Festi</h2><p>Win32/Festi僵尸网络是发现的最先进的垃圾邮件和分布式拒绝服务DDoS僵尸网络。Festi拥有强大的垃圾邮件发送、DDoS和Rootkit功能，使得它可连接到文件系统和系统注册表而不被发现。Festi Rookit通过PPI方案分发。Dropper是一种特殊的感染类型，它携带有效负载到受害者系统内部，负载经常被压缩、加密和混淆。一旦执行，Dropper从它的映像中提取有效负载，并安装到受害系统上。与Downloader不同，后者自身不携带有效负载，而是从远程服务器下载。</p>
<p>Festi僵尸网络只针对Windows x86平台，其内核模式驱动程序有俩主要职责：从命令控制C&amp;C服务器请求配置信息，以插件形式下载和执行恶意模块。每个插件用于特定任务，如对执行网络资源执行DDoS攻击，或向C&amp;C服务器提供电子邮件列表发送垃圾邮件。插件不存储在系统硬盘驱动器上，而是易失性内存中，当受感染计算机关闭或重启时，插件从系统内存中消失。唯一存储在硬盘上的是主内核模式驱动程序，它不包含有效负载和攻击目标。</p>
<p>为使Festi能够与C&amp;C服务器通信，Festi提供三种预定义的配置信息：C&amp;C服务器域名、加密bot僵尸主机和C&amp;C之间传输数据的密钥、bot版本信息，这些被硬编码在驱动程序的.cdata可写节，用一个4字节密钥进行异或加密。部分Festi配置数据的加密字符串：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符串</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>\\Device\\Tcp、\\Device\\Udp</td>
<td>用于通过网络发送和接收数据的设备对象名</td>
</tr>
<tr>
<td>\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile\\GloballyOpenPorts\\List</td>
<td>带有Windows防火墙参数的注册表项的路径，被恶意软件用于禁用本地防火墙</td>
</tr>
<tr>
<td>ZwDeleteFile、ZwQueryInformationFIle、ZwLoadDriver、KdDebuggerEnabled、ZwDeleteValueKey、ZwLoadDriver</td>
<td>恶意软件使用的系统服务名</td>
</tr>
</tbody>
</table>
</div>
<p>Festi具有面向对象的架构，主要组件包括：内存管理器负责分配和释放内存缓冲区、网络套接字通过网络发送和接收数据、C&amp;C协议解析器解析C&amp;C消息并执行接收到的命令、插件管理器管理下载插件。其中内存管理器是其他组件的中心组件，网络套接字和插件管理器都与C&amp;C协议解析器交互。</p>
<p>为了有效地管理下载的插件，Festi维护了一个指针数组，该指针指向一个结构，每个结构对应内存中一个插件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PLUGIN_INTERFACE</span> &#123;</span><br><span class="line">    PVOID Initialize; <span class="comment">//初始化插件</span></span><br><span class="line">    PVOID Release; <span class="comment">//释放插件执行清除操作</span></span><br><span class="line">    PVOID GetVersionInfo_1; <span class="comment">//获取插件版本信息</span></span><br><span class="line">    PVOID GetVersionInfo_2;</span><br><span class="line">    PVOID WriteIntoTcpStream; <span class="comment">//向TCP流中写入具体插件信息</span></span><br><span class="line">    PVOID ReadFromTcpStream; <span class="comment">//从TCP流读取特定于插件的信息并解析数据</span></span><br><span class="line">    PVOID Reserved_1;</span><br><span class="line">    PVOID Reserved_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>安装时主恶意内核模式驱动程序实现两个内置插件：配置信息管理器和僵尸主机插件管理器。配置信息管理器插件请求配置信息并定期连接到C&amp;C服务器以下载插件，两个连续请求之间的延迟由C&amp;C服务器决定，以规避杀软用来检测感染的静态模式。僵尸主机插件管理器维护下载的插件数组，从C&amp;C服务器接收远程命令，加载和卸载以压缩形式交付到系统特定插件。</p>
<p>每个插件都有默认入口点<code>DriverEntry</code>，并导出例程<code>CreateModule</code>和<code>DeleteModule</code>。<code>CreateModule</code>例程在插件初始化时执行，返回一个指向PLUGIN_INTERFACE结构的指针。<code>DeleteModule</code>例程在卸载插件并释放分配的所有资源时执行。</p>
<p>恶意软件先将插件解压到内存缓冲区中，再将其映射到内核模式地址空间中，作为一个PE映像。插件管理器初始化导入地址表IAT并将其重定位到映射的映像，在该算法中Festi仿真了一个典型操作系统的运行时加载器和操作系统模块的动态链接器。根据插件被加载还是被卸载，插件管理器执行<code>CreateModule</code>或<code>DeleteModule</code>例程。若插件被加载，则插件管理器获取插件ID和版本信息，将其注册到PLUGIN_INTERFACE结构。若插件被卸载，则释放之前分配给插件映像的所有内存。</p>
<p>Festi检测它是否在VMware虚拟机中运行，以规避沙箱和自动恶意软件分析环境，用以下代码获取现有VMware软件版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, &#x27;VMXh&#x27;</span><br><span class="line">mov ebx, 0</span><br><span class="line">mov ecx, 0Ah</span><br><span class="line">mov edx, &#x27;VX&#x27;</span><br><span class="line">in eax, dx</span><br></pre></td></tr></table></figure>
<p>当Festi检测到虚拟环境存在时，仍像在物理机上一样继续执行。当其从C&amp;C服务器请求插件时会提交信息以指示是否在虚拟环境中执行。如果是，C&amp;C服务器可能不会返回任何插件。Festi还检查系统上是否存在网络流量监控软件，如寻找内核模式驱动程序npf.sys网络包过滤器，该驱动属于WIndows包捕获库WinPcap。</p>
<p>Festi检查从操作系统内核映像导出的<code>KdDebuggerEnable</code>变量来检查系统中是否存在内核调试器，若系统附加了系统调试器，则该变量为TRUE，否则FALSE。Festi定期将调试寄存器DR0~DR3调零来抵消系统调试器，这些寄存器用于存储断点地址，删除硬件断点会妨碍调试过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> _thiscall <span class="title">ProtoHandler_1</span><span class="params">(STRUCT_4_4 *<span class="keyword">this</span>, PKEVENT a1)</span> </span>&#123;</span><br><span class="line">    __writedr(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    __writedr(<span class="number">1u</span>,<span class="number">0</span>);</span><br><span class="line">    __writedr(<span class="number">2u</span>,<span class="number">0</span>);</span><br><span class="line">    __writedr(<span class="number">3u</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> _ProtoHandler(&amp;<span class="keyword">this</span>-&gt;struct43,a1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了保护和隐藏存储在硬盘上的恶意内核模式驱动程序的映像，Festi挂在文件系统驱动程序，拦截和修改发送到文件系统驱动程序的所有请求，以排除它存在的证据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS __stdcall <span class="title">SetHookOnSystemRoot</span><span class="params">(PDRIVER_OBJECT DriverObject,<span class="type">int</span>** HookParams)</span></span>&#123;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;DestinationString,<span class="string">L&quot;\\SystemRoot&quot;</span>);</span><br><span class="line">    ObjectAttributes.Length=<span class="number">24</span>;</span><br><span class="line">    ObjectAttributes.RootDirectory=<span class="number">0</span>;</span><br><span class="line">    ObjectAttributes.Attributes=<span class="number">64</span>;</span><br><span class="line">    ObjectAttributes.ObjectName=&amp;DestinationString;</span><br><span class="line">    ObjectAttributes.SecurityDescriptor=<span class="number">0</span>;</span><br><span class="line">    ObjectAttributes.SecurityQualityOfService=<span class="number">0</span>;</span><br><span class="line">    NTSTATUS Status=<span class="built_in">IoCreateFile</span>(&amp;hSystemRoot,<span class="number">0x80000000</span>,&amp;ObjectAttributes,&amp;IoStatusBlock,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3u</span>,<span class="number">1u</span>,<span class="number">1u</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x100</span>u);</span><br><span class="line">    <span class="keyword">if</span>(Status&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">   	Status=<span class="built_in">ObReferenceObjectByHandle</span>(hSystemRoot,<span class="number">1u</span>,<span class="number">0</span>,<span class="number">0</span>,&amp;SystemRootFileObject,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(Status&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    PDEVICE_OBJECT TargetDevice=<span class="built_in">IoGetRelatedDeviceObject</span>(SystemRootFileObject);</span><br><span class="line">    <span class="keyword">if</span>(!_TargetDevice)</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="built_in">ObReferenceObject</span>(TargetDevice);</span><br><span class="line">    Status=<span class="built_in">IoCreateDevice</span>(DriverObject,<span class="number">0xC</span>u,<span class="number">0</span>,TargetDev-&gt;DeviceType,TargetDevice-&gt;Characteristics,<span class="number">0</span>,&amp;SourceDevice);</span><br><span class="line">    <span class="keyword">if</span>(Status&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    PDEVICE_OBJECT DeviceAttachedTo=<span class="built_in">IoAttachDeviceToDeviceStack</span>(SourceDevice,TargetDevice);</span><br><span class="line">    <span class="keyword">if</span>(!DeviceAttachedTo)&#123;</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(SourceDevice);</span><br><span class="line">        <span class="keyword">return</span> STATUS_uNSUCCESSFUL;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第9行恶意软件尝试获取一个特定系统文件SystemRoot的句柄，该文件对应Windows安装目录。第12行获得一个指向FILE_OBJECT的指针，对应SystemRoot的句柄。FILE_OBJECT是操作系统用来管理设备对象访问的特殊数据结构，包含一个指向相关设备对象的指针。第15行获得指向DEVICE_OBJECT的指针，创建一个新设备对象。第22行将其附加到获得的设备对象指针，这意味着对文件系统的IRP被重新路由到恶意软件，允许Festi改变请求和向文件系统驱动返回数据来隐藏自己。</p>
<p>Festi用IRP_MJ_DIRECTORY_CONTROL请求代码来监视IRP，该请求代码用于查询目录内容，监视与恶意软件驱动程序所在位置相关的查询。</p>
<p>位于HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services中注册表项包含Festi驱动程序类型和文件系统上驱动程序映像路径。为隐藏它，Festi挂在<code>ZwEnumerateKey</code>系统服务，修改SSDT处该地址替换为钩子地址。钩子监视发送到上述注册表项的请求，修改自建列表以排除与其驱动程序相对应的条目。Festi还先执行系统例程<code>IoRegisterShutdownNotification</code>，以便在系统关机时接收关闭通知。当注册表被杀软发现并在关机期间删除，Festi检查关闭通知处理程序，查看系统中相应注册表项是否还存在，不存在则回复，保证它在重启过程中一直存在。</p>
<p>Festi与C&amp;C服务器通信，有些服务器用于发送垃圾邮件，有些执行DDoS攻击。Festi通信协议由两个阶段组成：初始化阶段和工作阶段。</p>
<p>在初始化阶段，恶意软件获得C&amp;C服务器IP地址，服务器域名存储在僵尸主机的二进制文件中。恶意软件手动构造DNS请求包来解析C&amp;C服务器域名，并发送到8.8.8.8\:53或8.8.4.4\:53，这两台主机都是谷歌DNS服务器。作为回应，Festi接收一个IP地址。若不手动解析域名，Festi不得不依赖当地ISP的DNS服务器来解析，这使得ISP可能修改DNS信息来阻止对&amp;C服务器的访问。手动解析域名绕过了ISP的DNS基础设施，当执法机构发布组织这些域名的搜查令时，这删除更加困难。</p>
<p>在工作阶段，  Festi向C&amp;C服务器请求信息，通信通过TCP执行，发送的网络包请求布局如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>消息头</th>
<th></th>
<th></th>
<th></th>
<th>消息尾</th>
</tr>
</thead>
<tbody>
<tr>
<td>消息头</td>
<td>插件1数据</td>
<td>插件2数据</td>
<td>…</td>
<td>后面字节</td>
</tr>
</tbody>
</table>
</div>
<p>消息头由配置管理器插件生成，包含：Festi版本信息、是否有系统调试器、是否有虚拟化软件VMware、是否有网络流量监控软件WinPcap、操作系统版本信息。插件数据由结构数组组成：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>标记Tag</td>
<td>一个16位整数，指定标记后面值的类型</td>
</tr>
<tr>
<td>值Value</td>
<td>数据，可能是字节、字、双字、以空字符结尾的字符串、二进制数组等形式</td>
</tr>
<tr>
<td>项Term</td>
<td>条目结束字0xABCD</td>
</tr>
</tbody>
</table>
</div>
<p>数据发送前通过一种加密算法进行模糊处理，伪代码为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key=(<span class="number">0x17</span>,<span class="number">0xFB</span>,<span class="number">0x71</span>,<span class="number">0x5C</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decr_data</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">for</span> ix <span class="keyword">in</span> xrange(<span class="built_in">len</span>(data)):</span><br><span class="line">        data[ix]^=key[ix%<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>安全软件监控设备对象访问的常见方式是连接<code>ZwCreateFile</code>系统服务处理程序，拦截所有打开设备的尝试，并附加到\\Device\\Tcp或\\Device\\Udp以拦截发送所有IRP请求。Festi规避了这两种技术。</p>
<p>一方面，Festi没有使用<code>ZwCreateFile</code>而是实现了自己的系统服务，其功能几乎与原初系统服务相同。首先用<code>ObCreateObject</code>创建文件对象，初始化所创建文件对象的安全属性，用<code>ObInsertObject</code>将创建的文件对象插入FILE_OBJECT类型列表中，创建IRP请求且主函数代码设为IRP_MJ_CREATE，将创建的IRP请求直接发送到tcpip.sys系统驱动程序，不经过过滤驱动程序栈。</p>
<p>另一方面，Festi直接获取\\Device\\Tcp或\\Device\\Udp设备对象指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DriverName,<span class="string">L&quot;\\Driver\\Tcpip&quot;</span>);</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;tcp_name,<span class="string">L&quot;\\Device\\Tcp&quot;</span>);</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;udp_name,<span class="string">L&quot;\\Device\\Udp&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">ObReferenceObjectByName</span>(&amp;DriverName,<span class="number">64</span>,<span class="number">0</span>,<span class="number">0x1F01FF</span>,IoDriverObjectType,<span class="number">0</span>,<span class="number">0</span>,&amp;TcpipDriver))&#123;</span><br><span class="line">    DevObj=TcpipDriver-&gt;DeviceObject;</span><br><span class="line">    <span class="keyword">while</span>(DevObj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">ObQueryNameString</span>(DevObj,&amp;Objname,<span class="number">256</span>,&amp;v8))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">RtlCompareUnicodeString</span>(&amp;tcp_name,&amp;Objname,<span class="number">1u</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">RtlCompareUnicodeString</span>(&amp;udp_name,&amp;Objname,<span class="number">1u</span>))&#123;</span><br><span class="line">                    <span class="built_in">ObfReferenceObject</span>(DevObj);</span><br><span class="line">                    <span class="keyword">this</span>-&gt;DeviceUdp=DevObj;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">ObfReferenceObject</span>(DevObj);</span><br><span class="line">                <span class="keyword">this</span>-&gt;DeviceTcp=Devobj;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        DevObj=DevObj-&gt;NextDevice;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">ObfDereferenceObject</span>(TcpipDriver);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当Festi的主C&amp;C服务器被注销后，它用域名生成算法DGA作为一种备用机制，所有生成的域名都是伪随机的。僵尸网络控制者仍可通过回滚到DGA上重新获得对僵尸网络的控制。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>日期</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>07/11/2012</td>
<td>fzcbihskf.com</td>
</tr>
<tr>
<td>08/11/2012</td>
<td>pzcaihszf.com</td>
</tr>
<tr>
<td>09/11/2012</td>
<td>dzcxifsff.com</td>
</tr>
<tr>
<td>10/11/2012</td>
<td>azcgnfsmf.com</td>
</tr>
<tr>
<td>11/11/2012</td>
<td>bzcfnfsif.com</td>
</tr>
</tbody>
</table>
</div>
<p>Festi有三种插件的类型：BotSpam.sys滥发电子邮件、BotDos.sys执行DDoS攻击、BotSocks.sys提供代理服务，不同C&amp;C服务器提供不同类型的插件。</p>
<p>对于BotSpam.sys的工作流为：首先BotSpam.sys向C&amp;C服务器发起一个加密连接，C&amp;C服务器先返回发送器参数和电子邮件地址列表，再返回SMTP服务器列表和垃圾邮件消息模板。然后把垃圾信件分发给收件人，同时向C&amp;C服务器报告状态，并请求更新电子邮件列表和垃圾邮件模板。之后，该插件扫描来自SMTP服务器的响应来检查发送的电子邮件的状态字符串，若找到没有指定地址收件人、没有收到电子邮件、收到的邮件被归为垃圾邮件等，则终止与当前SMTP服务器的会话，并获取列表中下一个地址。该措施避免被SMTP服务器列入垃圾邮件发送者黑名单，阻止恶意软件发送更多垃圾邮件。</p>
<p>对于BotDos.sys插件，它支持针对远程主机的TCP Flood、UDP Fload、DNS Flood、HTTP Flood等DDoS攻击类型，具体类型取决于从C&amp;C接收到的配置数据。</p>
<p>对于BotSocks.sys插件，它通过TCP和UDP实现SOCKS服务器，为供给制提供远程代理服务，允许攻击者通过受感染的机器连接到远程服务器以实现匿名。该插件不适用任何反代机制来绕过NAT，使得多台计算机共享一个公网IP。端口号是随机的，范围4000~65536。该插件还尝试绕过Winodws防火墙，要不被阻止打开端口。其向注册表项SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\Domain-Profile\\GloballyOpenPorts\\List下添加两个子密钥，以便启用来自任何目的地的CP和UDP连接。</p>
<h2 id="Rootkit感染"><a href="#Rootkit感染" class="headerlink" title="Rootkit感染"></a>Rootkit感染</h2><p>Rootkit必需在操作系统的特定位置拦截控制，以防止反Rootkit工具启动或初始化，可拦截的操作系统机制主要有3种。</p>
<p>第一种方法是通过事件通知回调来拦截系统事件。例如用<code>CmRegisterCallbackEx</code>例程注册一个回调函数后，当有人在系统注册表项上执行操作时，该例程将执行。每个内核模式驱动程序在系统注册表中的HEKY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services键下都有一个专用条目，指定驱动程序的名称、类型、映像在磁盘上的位置以及加载时间（按需加载、引导时加载、系统初始化时加载等），若该条目被删除则操作系统无法加载内核模式驱动程序。另外Rootkit还经常滥用<code>PsSetLoadImageNotifyRoutine</code>例程，向目标进程的用户模式地址注入恶意负载。</p>
<p>第二种方法时拦截系统调用 。文件子系统与I/O子系统紧密集成，驱动程序分为三类，在存储设备驱动栈上从下到上分别为：存储设备驱动、存储卷驱动和文件系统驱动。存储设备驱动是与特定设备（端口、总线和驱动器）的控制器交互的底层驱动程序，大多数存储设备驱动是即插即用PnP的，由PnP管理器加载和控制。存储卷驱动时控制存储设备分区上的卷抽象的中层驱动程序，为了与磁盘子系统较低层交互，这些驱动创建一个物理设备对象PDO来表示每个分区。当一个文件系统挂载在一个分区上时，文件系统驱动创建一个卷设备对象VDO。文件系统驱动实现特定文件系统（FAT32、NTFS、CDFS等），还创建一对对象VDO和控制设备对象CDO，他们表示给定的文件系统，这些CDO设备名称为\\Device\\Ntfs。</p>
<p>在存储设备驱动程序层，有SCSI适配器（上层）和磁盘设备对象（下层），他们由三个不同的驱动程序创建和管理：PCI总线驱动，枚举和发现PCI总线上可用的存储适配器；SCSI端口/微型端口驱动，初始化和控制枚举的SCSI存储适配器；磁盘类驱动，控制附加到SCSI存储适配器的磁盘设备。</p>
<p>在存储卷驱动层，磁盘分区1设备对象PDO（上层）和磁盘分区0设备对象（下层），他们都由磁盘类驱动创建和管理的。其中分区0为整个原始磁盘并始终存在，无论磁盘是否分区。分区1为磁盘设备上第一个分区，还有可能更多。分区1必需公开给用户，以便他们能存储和访问存储在磁盘设备上的文件。要公开分区1则需要文件系统驱动在存储卷驱动层顶部创建一个卷设备对象VDO，操作系统用文件系统控制设备对象CDO来控制文件系统驱动，进而控制该创建的卷设备对象VDO。</p>
<p>Rootkit一般在顶层文件系统驱动层拦截文件操作，这样可看到应用程序的所有操作，而不必查找和解析程序员看不见的文件系统结构。Rootkit有三种拦截方法：将过滤驱动附加到目标设备的驱动程序栈；替换驱动程序描述符结构中指向IRP或FastIO处理函数的指针；替换这些IRP或FastIO驱动程序函数的代码。Festi采用第一种方法，TDL4、Olmasco、Rovnix Bootkit采用第二种方法，Gapz Bootkit采用第三种方法。</p>
<p>为了执行I/O操作，IRP要遍历整个存储设备栈，从最顶层设备对象一直到底层。这时若用FastIO方法，数据直接在用户模式缓冲区和系统缓存之间传输，绕过文件系统和存储驱动程序栈，使得对缓存文件I/O操作更快。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://Monoceros.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://monoceros.github.io/2024/09/17/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-Rootkit%E5%88%9D%E6%8E%A2/">http://monoceros.github.io/2024/09/17/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-Rootkit%E5%88%9D%E6%8E%A2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Monoceros.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/">逆向工程</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/20/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%9D%E6%8E%A2/" title="硬件安全初探"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">硬件安全初探</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/05/Windows%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2-%E6%A0%88%E5%92%8C%E5%A0%86/" title="Windows软件调试初探-栈和堆"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Windows软件调试初探-栈和堆</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/16/Angr%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/" title="Angr做题笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-16</div><div class="title">Angr做题笔记</div></div></a></div><div><a href="/2023/10/29/Angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%AC%94%E8%AE%B0/" title="Angr符号执行笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">Angr符号执行笔记</div></div></a></div><div><a href="/2023/11/09/C-%E7%97%85%E6%AF%92%E6%8A%80%E6%9C%AF/" title="C++病毒技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-09</div><div class="title">C++病毒技术</div></div></a></div><div><a href="/2023/11/15/CvxPy%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/" title="CvxPy整数规划笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">CvxPy整数规划笔记</div></div></a></div><div><a href="/2023/10/21/IDA%E5%9C%A8Kali-Linux%E4%B8%8B%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/" title="IDA在Kali Linux下的远程动态调试笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-21</div><div class="title">IDA在Kali Linux下的远程动态调试笔记</div></div></a></div><div><a href="/2023/10/29/IDA%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/" title="IDA脚本编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">IDA脚本编程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">智邮普创工作室安全组/Nepnep联合战队</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">281</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">QQ:1295625063（不找对象）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-Rootkit%E5%88%9D%E6%8E%A2"><span class="toc-number">1.</span> <span class="toc-text">恶意代码分析-Rootkit初探</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TDL3"><span class="toc-number">1.1.</span> <span class="toc-text">TDL3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Festi"><span class="toc-number">1.2.</span> <span class="toc-text">Festi</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rootkit%E6%84%9F%E6%9F%93"><span class="toc-number">1.3.</span> <span class="toc-text">Rootkit感染</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/16/Windows%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2-WinDBG%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/" title="Windows软件调试初探-WinDBG命令入门">Windows软件调试初探-WinDBG命令入门</a><time datetime="2024-10-16T11:00:06.000Z" title="发表于 2024-10-16 19:00:06">2024-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/16/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BC%8F%E5%89%8D%E7%BA%BF%E6%88%98%E6%9C%AF%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2024-10-16T09:08:04.570Z" title="发表于 2024-10-16 17:08:04">2024-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/08/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-NDIS%E5%B0%8F%E7%AB%AF%E5%8F%A3%E9%A9%B1%E5%8A%A8/" title="Windows驱动开发入门-NDIS小端口驱动">Windows驱动开发入门-NDIS小端口驱动</a><time datetime="2024-10-08T11:21:54.000Z" title="发表于 2024-10-08 19:21:54">2024-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/08/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-NDIS%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8%E6%BA%90%E7%A0%81/" title="Windows驱动开发入门-NDIS协议驱动源码">Windows驱动开发入门-NDIS协议驱动源码</a><time datetime="2024-10-08T11:21:15.000Z" title="发表于 2024-10-08 19:21:15">2024-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/08/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-NDIS%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8/" title="Windows驱动开发入门-NDIS协议驱动">Windows驱动开发入门-NDIS协议驱动</a><time datetime="2024-10-08T11:20:42.000Z" title="发表于 2024-10-08 19:20:42">2024-10-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>