<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WindowsAPI编程核心技术-内核枚举 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="WindowsAPI编程核心技术-内核枚举枚举用户进程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;ntifs.h&gt;#include &lt;windef.h&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="WindowsAPI编程核心技术-内核枚举">
<meta property="og:url" content="https://monoceros406.github.io/2024/12/05/WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%86%85%E6%A0%B8%E6%9E%9A%E4%B8%BE/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="WindowsAPI编程核心技术-内核枚举枚举用户进程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;ntifs.h&gt;#include &lt;windef.h&amp;gt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://monoceros406.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-12-05T01:34:52.000Z">
<meta property="article:modified_time" content="2025-05-11T02:17:23.334Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="Win内核安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://monoceros406.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://monoceros406.github.io/2024/12/05/WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%86%85%E6%A0%B8%E6%9E%9A%E4%B8%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WindowsAPI编程核心技术-内核枚举',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-11 10:17:23'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="The Blog of Monoceros406" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">331</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/ycy')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">WindowsAPI编程核心技术-内核枚举</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-05T01:34:52.000Z" title="发表于 2024-12-05 09:34:52">2024-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-11T02:17:23.334Z" title="更新于 2025-05-11 10:17:23">2025-05-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="WindowsAPI编程核心技术-内核枚举"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="WindowsAPI编程核心技术-内核枚举"><a href="#WindowsAPI编程核心技术-内核枚举" class="headerlink" title="WindowsAPI编程核心技术-内核枚举"></a>WindowsAPI编程核心技术-内核枚举</h1><h2 id="枚举用户进程"><a href="#枚举用户进程" class="headerlink" title="枚举用户进程"></a>枚举用户进程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windef.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> PVOID <span class="title">PsGetProcessPeb</span><span class="params">(_In_ PEPROCESS Process)</span></span>;</span><br><span class="line"><span class="function">NTKERNELAPI NTSTATUS <span class="title">PsLookupProcessByProcessId</span><span class="params">(HANDLE ProcessId, PEPROCESS* Process)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> NTKERNELAPI PVOID <span class="title">PsGetProcessWow64Process</span><span class="params">(_In_ PEPROCESS Process)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> NTKERNELAPI UCHAR* <span class="title">PsGetProcessImageFileName</span><span class="params">(IN PEPROCESS Process)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> NTKERNELAPI HANDLE <span class="title">PsGetProcessInheritedFromUniqueProcessId</span><span class="params">(IN PEPROCESS Process)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    DWORD Pid;</span><br><span class="line">    UCHAR ProcessName[<span class="number">2048</span>];</span><br><span class="line">    DWORD Handle;</span><br><span class="line">    LIST_ENTRY ListEntry;</span><br><span class="line">&#125;ProcessList;</span><br><span class="line"><span class="comment">// 根据进程ID返回进程EPROCESS结构体失败返回NULL</span></span><br><span class="line"><span class="function">PEPROCESS <span class="title">LookupProcess</span><span class="params">(HANDLE Pid)</span> </span>&#123;</span><br><span class="line">    PEPROCESS eprocess = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    Status = <span class="built_in">PsLookupProcessByProcessId</span>(Pid, &amp;eprocess);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        <span class="keyword">return</span> eprocess;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 内核链表操作</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">GetAllProcess</span><span class="params">(VOID)</span> </span>&#123;</span><br><span class="line">    PEPROCESS eproc = <span class="literal">NULL</span>;</span><br><span class="line">    LIST_ENTRY linkListHead;</span><br><span class="line">    <span class="comment">// 初始化链表头部</span></span><br><span class="line">    <span class="built_in">InitializeListHead</span>(&amp;linkListHead);</span><br><span class="line">    ProcessList* pData = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> temp = <span class="number">0</span>; temp &lt; <span class="number">100000</span>; temp += <span class="number">4</span>) &#123;</span><br><span class="line">        eproc = <span class="built_in">LookupProcess</span>((HANDLE)temp);</span><br><span class="line">        <span class="keyword">if</span> (eproc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            STRING nowProcessnameString = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="built_in">RtlInitString</span>(&amp;nowProcessnameString, <span class="built_in">PsGetProcessImageFileName</span>(eproc));</span><br><span class="line">            <span class="comment">// DbgPrint(&quot;进程名: %s --&gt; 进程PID = %d --&gt; 父进程PPID = %d\r\n&quot;,PsGetProcessImageFileName(eproc), PsGetProcessId(eproc),PsGetProcessInheritedFromUniqueProcessId(eproc));</span></span><br><span class="line">            <span class="comment">// 分配内核堆空间</span></span><br><span class="line">            pData = (ProcessList*)<span class="built_in">ExAllocatePool</span>(PagedPool, <span class="built_in">sizeof</span>(ProcessList));</span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>(pData, <span class="built_in">sizeof</span>(ProcessList));</span><br><span class="line">            <span class="comment">// 设置变量</span></span><br><span class="line">            pData-&gt;Pid = (DWORD)<span class="built_in">PsGetProcessId</span>(eproc);</span><br><span class="line">            <span class="built_in">RtlCopyMemory</span>(pData-&gt;ProcessName, <span class="built_in">PsGetProcessImageFileName</span>(eproc), <span class="built_in">strlen</span>(<span class="built_in">PsGetProcessImageFileName</span>(eproc)) * <span class="number">2</span>);</span><br><span class="line">            pData-&gt;Handle = (DWORD)<span class="built_in">PsGetProcessInheritedFromUniqueProcessId</span>(eproc);</span><br><span class="line">            <span class="comment">// 插入元素到</span></span><br><span class="line">            <span class="built_in">InsertTailList</span>(&amp;linkListHead, &amp;pData-&gt;ListEntry);</span><br><span class="line">            <span class="built_in">ObDereferenceObject</span>(eproc);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 输出链表内的数据</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsListEmpty</span>(&amp;linkListHead)) &#123;</span><br><span class="line">        LIST_ENTRY* pEntry = <span class="built_in">RemoveHeadList</span>(&amp;linkListHead);</span><br><span class="line">        pData = <span class="built_in">CONTAINING_RECORD</span>(pEntry, ProcessList, ListEntry);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;%d \n&quot;</span>, pData-&gt;Pid);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;%s \n&quot;</span>, pData-&gt;ProcessName);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;%d \n&quot;</span>, pData-&gt;Handle);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(pData);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">UnDriver</span><span class="params">(PDRIVER_OBJECT driver)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>((<span class="string">&quot;Uninstall Driver Is OK \n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">GetAllProcess</span>();</span><br><span class="line">    Driver-&gt;DriverUnload = UnDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="枚举IoTimer定时器"><a href="#枚举IoTimer定时器" class="headerlink" title="枚举IoTimer定时器"></a>枚举IoTimer定时器</h2><p>在<code>IoInitializeTimer</code>中可找到IopTimerQueueHead地址，存储定时器链表头部。枚举方法如下：</p>
<ol>
<li>找到<code>IoInitializeTimer</code>函数，该函数可以通过<code>MmGetSystemRoutineAddress</code>得到。</li>
<li>找到地址以后，我们向下增加0xFF偏移量，并搜索特征定位到IopTimerQueueHead链表头。</li>
<li>将链表头转换为IO_TIMER结构体，并循环链表头输出。</li>
</ol>
<p><code>IoInitializeTimer</code>定义为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoInitializeTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PDEVICE_OBJECT  DeviceObject,   <span class="comment">// 设备对象指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PIO_TIMER_ROUTINE  TimerRoutine,  <span class="comment">// 定时器例程</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PVOID  Context           <span class="comment">// 传给定时器例程的函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>DEVICE_OBJECT对象指针中存在一个Timer成员，后者是个IO_TIMER结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">3: kd&gt; dt nt!_DEVICE_OBJECT</span><br><span class="line">   +0x000 Type             : Int2B</span><br><span class="line">   +0x002 Size             : Uint2B</span><br><span class="line">   +0x004 ReferenceCount   : Int4B</span><br><span class="line">   +0x008 DriverObject     : Ptr64 _DRIVER_OBJECT</span><br><span class="line">   +0x010 NextDevice       : Ptr64 _DEVICE_OBJECT</span><br><span class="line">   +0x018 AttachedDevice   : Ptr64 _DEVICE_OBJECT</span><br><span class="line">   +0x020 CurrentIrp       : Ptr64 _IRP</span><br><span class="line">   +0x028 Timer            : Ptr64 _IO_TIMER</span><br><span class="line">   +0x030 Flags            : Uint4B</span><br><span class="line">   +0x034 Characteristics  : Uint4B</span><br><span class="line">   +0x038 Vpb              : Ptr64 _VPB</span><br><span class="line">   +0x040 DeviceExtension  : Ptr64 Void</span><br><span class="line">   +0x048 DeviceType       : Uint4B</span><br><span class="line">   +0x04c StackSize        : Char</span><br><span class="line">   +0x050 Queue            : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x098 AlignmentRequirement : Uint4B</span><br><span class="line">   +0x0a0 DeviceQueue      : _KDEVICE_QUEUE</span><br><span class="line">   +0x0c8 Dpc              : _KDPC</span><br><span class="line">   +0x108 ActiveThreadCount : Uint4B</span><br><span class="line">   +0x110 SecurityDescriptor : Ptr64 Void</span><br><span class="line">   +0x118 DeviceLock       : _KEVENT</span><br><span class="line">   +0x130 SectorSize       : Uint2B</span><br><span class="line">   +0x132 Spare1           : Uint2B</span><br><span class="line">   +0x138 DeviceObjectExtension : Ptr64 _DEVOBJ_EXTENSION</span><br><span class="line">   +0x140 Reserved         : Ptr64 Void</span><br><span class="line">3: kd&gt; dt nt!_IO_TIMER</span><br><span class="line">   +0x000 Type             : Int2B</span><br><span class="line">   +0x002 TimerFlag        : Int2B</span><br><span class="line">   +0x008 TimerList        : _LIST_ENTRY</span><br><span class="line">   +0x018 TimerRoutine     : Ptr64     void </span><br><span class="line">   +0x020 Context          : Ptr64 Void</span><br><span class="line">   +0x028 DeviceObject     : Ptr64 _DEVICE_OBJECT</span><br><span class="line">2: kd&gt; uf nt!IoInitializeTimer</span><br><span class="line">...</span><br><span class="line">nt!IoInitializeTimer+0x5d:</span><br><span class="line">fffff800`559b5c1d 488d5008        lea     rdx,[rax+8]</span><br><span class="line">fffff800`559b5c21 48897018        mov     qword ptr [rax+18h],rsi</span><br><span class="line">fffff800`559b5c25 4c8d0514d55600  lea     r8,[nt!IopTimerLock (fffff800`55f23140)]</span><br><span class="line">fffff800`559b5c2c 48897820        mov     qword ptr [rax+20h],rdi</span><br><span class="line">fffff800`559b5c30 488d0d89004900  lea     rcx,[nt!IopTimerQueueHead (fffff800`55e45cc0)]</span><br><span class="line">fffff800`559b5c37 e84495acff      call    nt!ExInterlockedInsertTailList (fffff800`5547f180)</span><br><span class="line">fffff800`559b5c3c 33c0            xor     eax,eax</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>实现为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IO_TIMER</span> &#123;</span><br><span class="line">    INT16     Type;</span><br><span class="line">    INT16     TimerFlag;</span><br><span class="line">    LONG32    Unknown;</span><br><span class="line">    LIST_ENTRY  TimerList;</span><br><span class="line">    PVOID     TimerRoutine;</span><br><span class="line">    PVOID     Context;</span><br><span class="line">    PVOID     DeviceObject;</span><br><span class="line">&#125;IO_TIMER, * PIO_TIMER;</span><br><span class="line"><span class="comment">// 得到IoInitializeTimer基址</span></span><br><span class="line"><span class="function">PVOID <span class="title">GetIoInitializeTimerAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PVOID VariableAddress = <span class="number">0</span>;</span><br><span class="line">    UNICODE_STRING uioiTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;uioiTime, <span class="string">L&quot;IoInitializeTimer&quot;</span>);</span><br><span class="line">    VariableAddress = (PVOID)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;uioiTime);</span><br><span class="line">    <span class="keyword">if</span> (VariableAddress != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> VariableAddress;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">UnDriver</span><span class="params">(PDRIVER_OBJECT driver)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到基址</span></span><br><span class="line">    PUCHAR IoInitializeTimer = <span class="built_in">GetIoInitializeTimerAddress</span>();</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;IoInitializeTimer Address = %p \n&quot;</span>, IoInitializeTimer);</span><br><span class="line">    <span class="comment">// 搜索IoTimerQueueHead地址</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     nt!IoInitializeTimer+0x5d:</span></span><br><span class="line"><span class="comment">     fffff806`349963cd 488d5008    lea   rdx,[rax+8]</span></span><br><span class="line"><span class="comment">     fffff806`349963d1 48897018    mov   qword ptr [rax+18h],rsi</span></span><br><span class="line"><span class="comment">     fffff806`349963d5 4c8d05648de0ff lea   r8,[nt!IopTimerLock(fffff806`3479f140)]</span></span><br><span class="line"><span class="comment">     fffff806`349963dc 48897820    mov   qword ptr [rax+20h],rdi</span></span><br><span class="line"><span class="comment">     fffff806`349963e0 488d0d99f6cdff lea   rcx,[nt!IopTimerQueueHead(fffff806`34675a80)]</span></span><br><span class="line"><span class="comment">     fffff806`349963e7 e8c43598ff   call  nt!ExInterlockedInsertTailList(fffff806`343199b0)</span></span><br><span class="line"><span class="comment">     fffff806`349963ec 33c0      xor   eax,eax</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    INT32 iOffset = <span class="number">0</span>;</span><br><span class="line">    PLIST_ENTRY IoTimerQueueHead = <span class="literal">NULL</span>;</span><br><span class="line">    PUCHAR StartSearchAddress = IoInitializeTimer;</span><br><span class="line">    PUCHAR EndSearchAddress = IoInitializeTimer + <span class="number">0xFF</span>;</span><br><span class="line">    UCHAR v1 = <span class="number">0</span>, v2 = <span class="number">0</span>, v3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (PUCHAR i = StartSearchAddress; i &lt; EndSearchAddress; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">MmIsAddressValid</span>(i) &amp;&amp; <span class="built_in">MmIsAddressValid</span>(i + <span class="number">1</span>) &amp;&amp; <span class="built_in">MmIsAddressValid</span>(i + <span class="number">2</span>)) &#123;</span><br><span class="line">            v1 = *i;</span><br><span class="line">            v2 = *(i + <span class="number">1</span>);</span><br><span class="line">            v3 = *(i + <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// fffff806`349963e0 48 8d 0d 99 f6 cd ff lea rcx,[nt!IopTimerQueueHead(fffff806`34675a80)]</span></span><br><span class="line">            <span class="keyword">if</span> (v1 == <span class="number">0x48</span> &amp;&amp; v2 == <span class="number">0x8d</span> &amp;&amp; v3 == <span class="number">0x0d</span>) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;iOffset, i + <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">                IoTimerQueueHead = (PLIST_ENTRY)(iOffset + (ULONG64)i + <span class="number">7</span>);</span><br><span class="line">                <span class="built_in">DbgPrint</span>(<span class="string">&quot;IoTimerQueueHead = %p \n&quot;</span>, IoTimerQueueHead);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 枚举列表</span></span><br><span class="line">    KIRQL OldIrql;</span><br><span class="line">    <span class="comment">// 获得特权级</span></span><br><span class="line">    OldIrql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line">    <span class="keyword">if</span> (IoTimerQueueHead &amp;&amp; <span class="built_in">MmIsAddressValid</span>((PVOID)IoTimerQueueHead)) &#123;</span><br><span class="line">        PLIST_ENTRY NextEntry = IoTimerQueueHead-&gt;Flink;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">MmIsAddressValid</span>(NextEntry) &amp;&amp; NextEntry != (PLIST_ENTRY)IoTimerQueueHead) &#123;</span><br><span class="line">            PIO_TIMER Timer = <span class="built_in">CONTAINING_RECORD</span>(NextEntry, IO_TIMER, TimerList);</span><br><span class="line">            <span class="keyword">if</span> (Timer &amp;&amp; <span class="built_in">MmIsAddressValid</span>(Timer))</span><br><span class="line">                <span class="built_in">DbgPrint</span>(<span class="string">&quot;IO对象地址: %p \n&quot;</span>, Timer);</span><br><span class="line">            NextEntry = NextEntry-&gt;Flink;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复特权级</span></span><br><span class="line">    <span class="built_in">KeLowerIrql</span>(OldIrql);</span><br><span class="line">    Driver-&gt;DriverUnload = UnDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举DpcTimer定时器"><a href="#枚举DpcTimer定时器" class="headerlink" title="枚举DpcTimer定时器"></a>枚举DpcTimer定时器</h2><p>DPC在系统中是被异或加密的，得到DPC定时器步骤为：</p>
<ol>
<li>找到KiProcessorBlock地址并解析成_KPRCB结构。</li>
<li>在_KPRCB 结构中得到_KTIMER_TABLE偏移。</li>
<li>解析_KTIMER_TABLE_ENTRY得到加密后的双向链表。</li>
</ol>
<p>KiProcessorBlock中记录每个CPU的_KPRCB结构，有几个CPU就有几个项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dq nt!KiProcessorBlock</span><br><span class="line">fffff800`55efdc80  fffff800`50ef3180 ffffd501`a3267180</span><br><span class="line">fffff800`55efdc90  ffffd501`a332a180 ffffd501`a33ad180</span><br><span class="line">fffff800`55efdca0  00000000`00000000 00000000`00000000</span><br><span class="line">0: kd&gt; dt nt!_KPRCB fffff800`50ef3180</span><br><span class="line">...</span><br><span class="line">   +0x3940 TimerTable       : _KTIMER_TABLE</span><br><span class="line">...</span><br><span class="line">   +0x7b80 DpcGate          : _KGATE</span><br><span class="line">...</span><br><span class="line">0: kd&gt; dt nt!_KTIMER_TABLE fffff800`50ef3180+0x3940</span><br><span class="line">   +0x000 TimerExpiry      : [64] (null) </span><br><span class="line">   +0x200 TimerEntries     : [2] [256] _KTIMER_TABLE_ENTRY</span><br><span class="line">   +0x4200 TableState       : _KTIMER_TABLE_STATE</span><br><span class="line">0: kd&gt; dt nt!_KTIMER_TABLE_ENTRY fffff800`50ef3180+0x3940+0x200</span><br><span class="line">   +0x000 Lock             : 0</span><br><span class="line">   +0x008 Entry            : _LIST_ENTRY [ 0xfffff800`50ef6cc8 - 0xfffff800`50ef6cc8 ]</span><br><span class="line">   +0x018 Time             : _ULARGE_INTEGER 0xffffffff`0c0340d1</span><br></pre></td></tr></table></figure>

<p>至于如何解密，需要逆一下<code>KeSetTimer</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; u nt!KiSetTimerEx l50</span><br><span class="line">nt!KiSetTimerEx:</span><br><span class="line">fffff800`554bbbf0 48895c2408      mov     qword ptr [rsp+8],rbx</span><br><span class="line">fffff800`554bbbf5 48896c2410      mov     qword ptr [rsp+10h],rbp</span><br><span class="line">fffff800`554bbbfa 4889742420      mov     qword ptr [rsp+20h],rsi</span><br><span class="line">fffff800`554bbbff 57              push    rdi</span><br><span class="line">fffff800`554bbc00 4154            push    r12</span><br><span class="line">fffff800`554bbc02 4155            push    r13</span><br><span class="line">fffff800`554bbc04 4156            push    r14</span><br><span class="line">fffff800`554bbc06 4157            push    r15</span><br><span class="line">fffff800`554bbc08 4883ec30        sub     rsp,30h</span><br><span class="line">fffff800`554bbc0c 488b05e50ba400  mov     rax,qword ptr [nt!KiWaitNever (fffff800`55efc7f8)]</span><br><span class="line">fffff800`554bbc13 488bf9          mov     rdi,rcx</span><br><span class="line">fffff800`554bbc16 488b35db0da400  mov     rsi,qword ptr [nt!KiWaitAlways (fffff800`55efc9f8)]</span><br><span class="line">fffff800`554bbc1d 450fb6e1        movzx   r12d,r9b</span><br><span class="line">fffff800`554bbc21 4c8bb42480000000 mov     r14,qword ptr [rsp+80h]</span><br><span class="line">fffff800`554bbc29 458be8          mov     r13d,r8d</span><br><span class="line">fffff800`554bbc2c 4933f6          xor     rsi,r14</span><br><span class="line">fffff800`554bbc2f c744247000000000 mov     dword ptr [rsp+70h],0</span><br><span class="line">fffff800`554bbc37 480fce          bswap   rsi</span><br><span class="line">fffff800`554bbc3a 4833f1          xor     rsi,rcx</span><br><span class="line">fffff800`554bbc3d 488bda          mov     rbx,rdx</span><br><span class="line">fffff800`554bbc40 8bc8            mov     ecx,eax</span><br><span class="line">fffff800`554bbc42 48d3ce          ror     rsi,cl</span><br><span class="line">fffff800`554bbc45 4833f0          xor     rsi,rax</span><br><span class="line">fffff800`554bbc48 440f20c1        mov     rcx,tmm</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>具体解密方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"><span class="comment">// 解密DPC</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DPC_Print</span><span class="params">(PKTIMER ptrTimer)</span> </span>&#123;</span><br><span class="line">    ULONG_PTR ptrDpc = (ULONG_PTR)ptrTimer-&gt;Dpc;</span><br><span class="line">    KDPC* DecDpc = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD nShift = (<span class="built_in">p2dq</span>(ptrKiWaitNever) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="comment">// _RSI-&gt;Dpc = (_KDPC *)v19;</span></span><br><span class="line">    <span class="comment">// _RSI = Timer;</span></span><br><span class="line">    ptrDpc ^= <span class="built_in">p2dq</span>(ptrKiWaitNever);     <span class="comment">// v19 = KiWaitNever ^ v18;</span></span><br><span class="line">    ptrDpc = _rotl64(ptrDpc, nShift);    <span class="comment">// v18 = __ROR8__((unsigned __int64)Timer^ _RBX, KiWaitNever);</span></span><br><span class="line">    ptrDpc ^= (ULONG_PTR)ptrTimer;</span><br><span class="line">    ptrDpc = _byteswap_uint64(ptrDpc);   <span class="comment">// __asm &#123; bswap  rbx &#125;</span></span><br><span class="line">    ptrDpc ^= <span class="built_in">p2dq</span>(ptrKiWaitAlways);    <span class="comment">// _RBX = (unsigned __int64)DPC ^ KiWaitAlways;</span></span><br><span class="line">    <span class="comment">// real DPC</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MmIsAddressValid</span>((PVOID)ptrDpc)) &#123;</span><br><span class="line">        DecDpc = (KDPC*)ptrDpc;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;DPC = %p | routine = %p \n&quot;</span>, DecDpc, DecDpc-&gt;DeferredRoutine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">UnDriver</span><span class="params">(PDRIVER_OBJECT driver)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span> </span>&#123;</span><br><span class="line">    PKTIMER ptrTimer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">DPC_Print</span>(ptrTimer);</span><br><span class="line">    Driver-&gt;DriverUnload = UnDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到KiProcessorBlock方法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"><span class="comment">// 得到KiProcessorBlock地址</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">GetKiProcessorBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ULONG64 PrcbAddress = <span class="number">0</span>;</span><br><span class="line">    PrcbAddress = (ULONG64)__readmsr(<span class="number">0xC0000101</span>) + <span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrcbAddress != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// PrcbAddress 是一个地址 这个地址存放了某个 CPU 的 _KPRCB 的地址</span></span><br><span class="line">        <span class="keyword">return</span> *(ULONG_PTR*)PrcbAddress;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">UnDriver</span><span class="params">(PDRIVER_OBJECT driver)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span> </span>&#123;</span><br><span class="line">    ULONG64 address = <span class="built_in">GetKiProcessorBlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (address != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;KiProcessorBlock = %p \n&quot;</span>, address);</span><br><span class="line">    Driver-&gt;DriverUnload = UnDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在<code>KeSetTimer</code>中找<code>KeSetTimerEx</code>地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"><span class="comment">// 得到KiProcessorBlock地址</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">GetKeSetTimerEx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 KeSetTimer 地址</span></span><br><span class="line">    ULONG64 ul_KeSetTimer = <span class="number">0</span>;</span><br><span class="line">    UNICODE_STRING  uc_KeSetTimer = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;uc_KeSetTimer, <span class="string">L&quot;KeSetTimer&quot;</span>);</span><br><span class="line">    ul_KeSetTimer = (ULONG64)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;uc_KeSetTimer);</span><br><span class="line">    <span class="keyword">if</span> (ul_KeSetTimer == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 前 30 字节找 call 指令</span></span><br><span class="line">    BOOLEAN b_e8 = FALSE;</span><br><span class="line">    ULONG64 ul_e8Addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 验证地址是否可读写</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)ul_KeSetTimer))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// e8 0c 00 00 00 call nt!KiSetTimerEx (fffff807`70520a50)</span></span><br><span class="line">        <span class="keyword">if</span> (*(PUCHAR)(ul_KeSetTimer + i) == <span class="number">0xe8</span>) &#123;</span><br><span class="line">            b_e8 = TRUE;</span><br><span class="line">            ul_e8Addr = ul_KeSetTimer + i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到 call 则解析目的地址</span></span><br><span class="line">    <span class="keyword">if</span> (b_e8 == TRUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)ul_e8Addr))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        INT ul_callCode = *(INT*)(ul_e8Addr + <span class="number">1</span>);</span><br><span class="line">        ULONG64 ul_KiSetTimerEx = ul_e8Addr + ul_callCode + <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> ul_KiSetTimerEx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">UnDriver</span><span class="params">(PDRIVER_OBJECT driver)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span> </span>&#123;</span><br><span class="line">    ULONG64 address = <span class="built_in">GetKeSetTimerEx</span>();</span><br><span class="line">    <span class="keyword">if</span> (address != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;KeSetTimerEx = %p \n&quot;</span>, address);</span><br><span class="line">    Driver-&gt;DriverUnload = UnDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着要在<code>KiSetTimerEx</code>中搜索<code>KiWaitNever</code>和<code>KiWaitAlways</code>两个函数地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"><span class="comment">// 得到KiProcessorBlock地址</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">GetKeSetTimerEx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 KeSetTimer 地址</span></span><br><span class="line">    ULONG64 ul_KeSetTimer = <span class="number">0</span>;</span><br><span class="line">    UNICODE_STRING  uc_KeSetTimer = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;uc_KeSetTimer, <span class="string">L&quot;KeSetTimer&quot;</span>);</span><br><span class="line">    ul_KeSetTimer = (ULONG64)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;uc_KeSetTimer);</span><br><span class="line">    <span class="keyword">if</span> (ul_KeSetTimer == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 前 30 字节找 call 指令</span></span><br><span class="line">    BOOLEAN b_e8 = FALSE;</span><br><span class="line">    ULONG64 ul_e8Addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 验证地址是否可读写</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)ul_KeSetTimer))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// e8 0c 00 00 00 call nt!KiSetTimerEx (fffff807`70520a50)</span></span><br><span class="line">        <span class="keyword">if</span> (*(PUCHAR)(ul_KeSetTimer + i) == <span class="number">0xe8</span>) &#123;</span><br><span class="line">            b_e8 = TRUE;</span><br><span class="line">            ul_e8Addr = ul_KeSetTimer + i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到 call 则解析目的地址</span></span><br><span class="line">    <span class="keyword">if</span> (b_e8 == TRUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)ul_e8Addr))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        INT ul_callCode = *(INT*)(ul_e8Addr + <span class="number">1</span>);</span><br><span class="line">        ULONG64 ul_KiSetTimerEx = ul_e8Addr + ul_callCode + <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> ul_KiSetTimerEx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到KiWaitNever地址</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">GetKiWaitNever</span><span class="params">(ULONG64 address)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 验证地址是否可读写</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)address))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 前 100 字节找 找 KiWaitNever</span></span><br><span class="line">    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="comment">// 48 8b 05 85 0c 51 00 | mov rax, qword ptr[nt!KiWaitNever(fffff807`70a316f8)]</span></span><br><span class="line">        <span class="keyword">if</span> (*(PUCHAR)(address + i) == <span class="number">0x48</span> &amp;&amp; *(PUCHAR)(address + i + <span class="number">1</span>) == <span class="number">0x8b</span> &amp;&amp; *(PUCHAR)(address + i + <span class="number">2</span>) == <span class="number">0x05</span>) &#123;</span><br><span class="line">            ULONG64 ul_movCode = *(UINT32*)(address + i + <span class="number">3</span>);</span><br><span class="line">            ULONG64 ul_movAddr = address + i + ul_movCode + <span class="number">7</span>;</span><br><span class="line">            <span class="comment">// DbgPrint(&quot;找到KiWaitNever地址: %p \n&quot;, ul_movAddr);</span></span><br><span class="line">            <span class="keyword">return</span> ul_movAddr;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到KiWaitAlways地址</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">GetKiWaitAlways</span><span class="params">(ULONG64 address)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 验证地址是否可读写</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)address))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 前 100 字节找 找 KiWaitNever</span></span><br><span class="line">    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="comment">// 48 8b 35 6b 0e 51 00 | mov rsi,qword ptr [nt!KiWaitAlways(fffff807`70a318e8)]</span></span><br><span class="line">        <span class="keyword">if</span> (*(PUCHAR)(address + i) == <span class="number">0x48</span> &amp;&amp; *(PUCHAR)(address + i + <span class="number">1</span>) == <span class="number">0x8b</span> &amp;&amp; *(PUCHAR)(address + i + <span class="number">2</span>) == <span class="number">0x35</span>) &#123;</span><br><span class="line">            ULONG64 ul_movCode = *(UINT32*)(address + i + <span class="number">3</span>);</span><br><span class="line">            ULONG64 ul_movAddr = address + i + ul_movCode + <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">return</span> ul_movAddr;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">UnDriver</span><span class="params">(PDRIVER_OBJECT driver)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span> </span>&#123;</span><br><span class="line">    ULONG64 address = <span class="built_in">GetKeSetTimerEx</span>();</span><br><span class="line">    <span class="keyword">if</span> (address != <span class="number">0</span>) &#123;</span><br><span class="line">        ULONG64 KiWaitNeverAddress = <span class="built_in">GetKiWaitNever</span>(address);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;KiWaitNeverAddress = %p \n&quot;</span>, KiWaitNeverAddress);</span><br><span class="line">        ULONG64 KiWaitAlwaysAddress = <span class="built_in">GetKiWaitAlways</span>(address);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;KiWaitAlwaysAddress = %p \n&quot;</span>, KiWaitAlwaysAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    Driver-&gt;DriverUnload = UnDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结实现方法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Fltkernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_TEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED,</span></span><br><span class="line">FILE_ANY_ACCESS)</span><br><span class="line">UNICODE_STRING name_device; <span class="comment">// 设备名</span></span><br><span class="line">UNICODE_STRING name_symbol; <span class="comment">// 符号链接</span></span><br><span class="line">PDEVICE_OBJECT deviceObj; <span class="comment">// 设备对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_KTIMER_TABLE_ENTRY</span> &#123;</span><br><span class="line">    ULONG_PTR  Lock;</span><br><span class="line">    LIST_ENTRY  Entry;</span><br><span class="line">    ULONG_PTR  Time;</span><br><span class="line">&#125;KTIMER_TABLE_ENTRY, * PKTIMER_TABLE_ENTRY;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_KTIMER_TABLE</span> &#123;</span><br><span class="line">    ULONG_PTR      TimerExpiry[<span class="number">64</span>];</span><br><span class="line">    KTIMER_TABLE_ENTRY  TimerEntries[<span class="number">256</span>];</span><br><span class="line">&#125;KTIMER_TABLE, * PKTIMER_TABLE;</span><br><span class="line"><span class="function">BOOLEAN <span class="title">get_KiWait</span><span class="params">(PULONG64 never, PULONG64 always)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 KeSetTimer 地址</span></span><br><span class="line">    ULONG64 ul_KeSetTimer = <span class="number">0</span>;</span><br><span class="line">    UNICODE_STRING uc_KeSetTimer = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;uc_KeSetTimer, <span class="string">L&quot;KeSetTimer&quot;</span>);</span><br><span class="line">    ul_KeSetTimer = (ULONG64)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;uc_KeSetTimer);</span><br><span class="line">    <span class="keyword">if</span> (ul_KeSetTimer == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 前 30 字节找 call 指令</span></span><br><span class="line">    BOOLEAN b_e8 = FALSE;</span><br><span class="line">    ULONG64 ul_e8Addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)ul_KeSetTimer))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0: kd&gt; u nt!KeSetTimer</span></span><br><span class="line"><span class="comment">        nt!KeSetTimer:</span></span><br><span class="line"><span class="comment">        fffff803`0fc63a40 4883ec38    sub   rsp,38h</span></span><br><span class="line"><span class="comment">        fffff803`0fc63a44 4c89442420   mov   qword ptr [rsp+20h],r8</span></span><br><span class="line"><span class="comment">        fffff803`0fc63a49 4533c9     xor   r9d,r9d</span></span><br><span class="line"><span class="comment">        fffff803`0fc63a4c 4533c0     xor   r8d,r8d</span></span><br><span class="line"><span class="comment">        fffff803`0fc63a4f e80c000000   call  nt!KiSetTimerEx</span></span><br><span class="line"><span class="comment">        (fffff803`0fc63a60)</span></span><br><span class="line"><span class="comment">        fffff803`0fc63a54 4883c438    add   rsp,38h</span></span><br><span class="line"><span class="comment">        fffff803`0fc63a58 c3       ret</span></span><br><span class="line"><span class="comment">        fffff803`0fc63a59 cc       int   3</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// fffff803`0fc63a4f e8 0c 00 00 00   call  nt!KiSetTimerEx(fffff803`0fc63a60)</span></span><br><span class="line">        <span class="keyword">if</span> (*(PUCHAR)(ul_KeSetTimer + i) == <span class="number">0xe8</span>) &#123;</span><br><span class="line">            b_e8 = TRUE;</span><br><span class="line">            ul_e8Addr = ul_KeSetTimer + i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到 call 则解析目的地址</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0: kd&gt; u nt!KiSetTimerEx l20</span></span><br><span class="line"><span class="comment">    nt!KiSetTimerEx:</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a60 48895c2408   mov   qword ptr [rsp+8],rbx</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a65 48896c2410   mov   qword ptr [rsp+10h],rbp</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a6a 4889742418   mov   qword ptr [rsp+18h],rsi</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a6f 57       push  rdi</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a70 4154      push  r12</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a72 4155      push  r13</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a74 4156      push  r14</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a76 4157      push  r15</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a78 4883ec50    sub   rsp,50h</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a7c 488b057d0c5100 mov   rax,qword ptr [nt!KiWaitNever</span></span><br><span class="line"><span class="comment">    (fffff803`10174700)]</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a83 488bf9     mov   rdi,rcx</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ULONG64 ul_KiSetTimerEx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b_e8 == TRUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)ul_e8Addr))</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        INT ul_callCode = *(INT*)(ul_e8Addr + <span class="number">1</span>);</span><br><span class="line">        ULONG64 ul_callAddr = ul_e8Addr + ul_callCode + <span class="number">5</span>;</span><br><span class="line">        ul_KiSetTimerEx = ul_callAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有 call 则直接在当前函数找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ul_KiSetTimerEx = ul_KeSetTimer;</span><br><span class="line">    <span class="comment">// 前 50 字节找 找 KiWaitNever 和 KiWaitAlways</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0: kd&gt; u nt!KiSetTimerEx l20</span></span><br><span class="line"><span class="comment">    nt!KiSetTimerEx:</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a60 48895c2408   mov   qword ptr [rsp+8],rbx</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a65 48896c2410   mov   qword ptr [rsp+10h],rbp</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a6a 4889742418   mov   qword ptr [rsp+18h],rsi</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a6f 57       push  rdi</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a70 4154      push  r12</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a72 4155      push  r13</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a74 4156      push  r14</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a76 4157      push  r15</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a78 4883ec50    sub   rsp,50h</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a7c 488b057d0c5100 mov   rax,qword ptr [nt!KiWaitNever</span></span><br><span class="line"><span class="comment">    (fffff803`10174700)]</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a83 488bf9     mov   rdi,rcx</span></span><br><span class="line"><span class="comment">    fffff803`0fc63a86 488b35630e5100 mov   rsi,qword ptr [nt!KiWaitAlways</span></span><br><span class="line"><span class="comment">    (fffff803`101748f0)]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)ul_KiSetTimerEx))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    ULONG64 ul_arr_ret[<span class="number">2</span>]; <span class="comment">// 存放 KiWaitNever 和 KiWaitAlways 的地址</span></span><br><span class="line">    INT i_sub = <span class="number">0</span>; <span class="comment">// 对应 ul_arr_ret 的下标</span></span><br><span class="line">    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">        <span class="comment">// fffff803`0fc63a7c 488b057d0c5100 mov   rax,qword ptr[nt!KiWaitNever(fffff803`10174700)]</span></span><br><span class="line">        <span class="keyword">if</span> (*(PUCHAR)(ul_KiSetTimerEx + i) == <span class="number">0x48</span> &amp;&amp; *(PUCHAR)(ul_KiSetTimerEx + i + <span class="number">1</span>) == <span class="number">0x8b</span> &amp;&amp; *(PUCHAR)(ul_KiSetTimerEx + i + <span class="number">6</span>) == <span class="number">0x00</span>) &#123;</span><br><span class="line">            ULONG64 ul_movCode = *(UINT32*)(ul_KiSetTimerEx + i + <span class="number">3</span>);</span><br><span class="line">            ULONG64 ul_movAddr = ul_KiSetTimerEx + i + ul_movCode + <span class="number">7</span>;</span><br><span class="line">            <span class="comment">// 只拿符合条件的前两个值</span></span><br><span class="line">            <span class="keyword">if</span> (i_sub &lt; <span class="number">2</span>)</span><br><span class="line">                ul_arr_ret[i_sub++] = ul_movAddr;</span><br><span class="line">        &#125;</span><br><span class="line">    *never = ul_arr_ret[<span class="number">0</span>];</span><br><span class="line">    *always = ul_arr_ret[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOLEAN <span class="title">EnumDpc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 CPU 核心数</span></span><br><span class="line">    INT i_cpuNum = KeNumberProcessors;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;CPU核心数: %d \n&quot;</span>, i_cpuNum);</span><br><span class="line">    <span class="keyword">for</span> (KAFFINITY i = <span class="number">0</span>; i &lt; i_cpuNum; i++) &#123;</span><br><span class="line">        <span class="comment">// 线程绑定特定 CPU</span></span><br><span class="line">        <span class="built_in">KeSetSystemAffinityThread</span>(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获得 KPRCB 的地址</span></span><br><span class="line">        ULONG64 p_PRCB = (ULONG64)__readmsr(<span class="number">0xC0000101</span>) + <span class="number">0x20</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)p_PRCB))</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        <span class="comment">// 取消绑定 CPU</span></span><br><span class="line">        <span class="built_in">KeRevertToUserAffinityThread</span>();</span><br><span class="line">        <span class="comment">// 计算 TimerTable 在 _KPRCB 结构中的偏移</span></span><br><span class="line">        PKTIMER_TABLE p_TimeTable = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// Windows 10 得到_KPRCB + 0x3680</span></span><br><span class="line">        p_TimeTable = (PKTIMER_TABLE)(*(PULONG64)p_PRCB + <span class="number">0x3680</span>);</span><br><span class="line">        <span class="comment">// 遍历 TimerEntries[] 数组（大小 256）</span></span><br><span class="line">        <span class="keyword">for</span> (INT j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 获取 Entry 双向链表地址</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)p_TimeTable))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            PLIST_ENTRY p_ListEntryHead = &amp;(p_TimeTable-&gt;TimerEntries[j].Entry);</span><br><span class="line">            <span class="comment">// 遍历 Entry 双向链表</span></span><br><span class="line">            <span class="keyword">for</span> (PLIST_ENTRY p_ListEntry = p_ListEntryHead-&gt;Flink; p_ListEntry != p_ListEntryHead; p_ListEntry = p_ListEntry-&gt;Flink) &#123;</span><br><span class="line">                <span class="comment">// 根据 Entry 取 _KTIMER 对象地址</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)p_ListEntry))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                PKTIMER p_Timer = <span class="built_in">CONTAINING_RECORD</span>(p_ListEntry, KTIMER, TimerListEntry);</span><br><span class="line">                <span class="comment">// 硬编码取 KiWaitNever 和 KiWaitAlways</span></span><br><span class="line">                ULONG64 never = <span class="number">0</span>, always = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get_KiWait</span>(&amp;never, &amp;always) == FALSE)</span><br><span class="line">                    <span class="keyword">return</span> FALSE;</span><br><span class="line">                <span class="comment">// 获取解密前的 Dpc 对象</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)p_Timer))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                ULONG64 ul_Dpc = (ULONG64)p_Timer-&gt;Dpc;</span><br><span class="line">                INT i_Shift = (*((PULONG64)never) &amp; <span class="number">0xFF</span>);</span><br><span class="line">                <span class="comment">// 解密 Dpc 对象</span></span><br><span class="line">                ul_Dpc ^= *((ULONG_PTR*)never); <span class="comment">// 异或</span></span><br><span class="line">                ul_Dpc = _rotl64(ul_Dpc, i_Shift); <span class="comment">// 循环左移</span></span><br><span class="line">                ul_Dpc ^= (ULONG_PTR)p_Timer; <span class="comment">// 异或</span></span><br><span class="line">                ul_Dpc = _byteswap_uint64(ul_Dpc); <span class="comment">// 颠倒顺序</span></span><br><span class="line">                ul_Dpc ^= *((ULONG_PTR*)always); <span class="comment">// 异或</span></span><br><span class="line">                <span class="comment">// 对象类型转换</span></span><br><span class="line">                PKDPC p_Dpc = (PKDPC)ul_Dpc;</span><br><span class="line">                <span class="comment">// 打印验证</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)p_Dpc))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">DbgPrint</span>(<span class="string">&quot;定时器对象：0x%p | 函数入口：0x%p | 触发周期: %d \n &quot;</span>, p_Timer, p_Dpc-&gt;DeferredRoutine, p_Timer-&gt;Period);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应 IRP_MJ_DEVICE_CONTROL</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">myIrpControl</span><span class="params">(IN PDEVICE_OBJECT pDevObj, IN PIRP pIRP)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 IRP 对应的 I/O 堆栈指针</span></span><br><span class="line">    PIO_STACK_LOCATION stack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIRP);</span><br><span class="line">    <span class="comment">// 得到输入缓冲区大小</span></span><br><span class="line">    ULONG cbin = stack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">    <span class="comment">// 得到输出缓冲区大小</span></span><br><span class="line">    ULONG cbout = stack-&gt;Parameters.DeviceIoControl.OutputBufferLength;</span><br><span class="line">    <span class="comment">// 得到 IOCTL 码</span></span><br><span class="line">    ULONG code = stack-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line">    <span class="comment">// 捕获 I/O 操作类型（MajorFunction）</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> IRP_TEST:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成 IO 请求</span></span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIRP, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应 IRP_MJ_CREATE 、 IRP_MJ_CLOSE</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">dpc_CAC</span><span class="params">(IN PDEVICE_OBJECT pDevObj, IN PIRP pIRP)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 IRP 返回给 I/O 管理器</span></span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIRP, IO_NO_INCREMENT);</span><br><span class="line">    <span class="comment">// 设置 I/O 请求状态</span></span><br><span class="line">    pIRP-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="comment">// 设置 I/O 请求传输的字节数</span></span><br><span class="line">    pIRP-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">CreateDevice</span><span class="params">(IN PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义返回值</span></span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    <span class="comment">// 初始化设备名</span></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;name_device, <span class="string">L&quot;\\Device\\MyDriver&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建设备</span></span><br><span class="line">    status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="number">0</span>, &amp;name_device, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, TRUE, &amp;deviceObj);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    <span class="comment">// 初始化符号链接名</span></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;name_symbol, <span class="string">L&quot;\\??\\MyDriver&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建符号链接</span></span><br><span class="line">    status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;name_symbol, &amp;name_device);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义返回值</span></span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    <span class="comment">// 删除符号链接</span></span><br><span class="line">    status = <span class="built_in">IoDeleteSymbolicLink</span>(&amp;name_symbol);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    <span class="comment">// 删除设备</span></span><br><span class="line">    <span class="built_in">IoDeleteDevice</span>(deviceObj);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRINGRegistryPath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义返回值</span></span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    <span class="comment">// 指定驱动卸载函数</span></span><br><span class="line">    DriverObject-&gt;DriverUnload = (PDRIVER_UNLOAD)DriverUnload;</span><br><span class="line">    <span class="comment">// 指定派遣函数</span></span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = dpc_CAC;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = dpc_CAC;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = myIrpControl;</span><br><span class="line">    <span class="comment">// 创建设备</span></span><br><span class="line">    status = <span class="built_in">CreateDevice</span>(DriverObject);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    <span class="comment">// 执行枚举</span></span><br><span class="line">    <span class="built_in">EnumDpc</span>();</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举PspCidTable句柄表"><a href="#枚举PspCidTable句柄表" class="headerlink" title="枚举PspCidTable句柄表"></a>枚举PspCidTable句柄表</h2><p>PspCidTable为一种内核句柄表，内部存放系统所有EPROCESS和ETHREAD的内核对象，通过PID和TID索引，ID号以4自增，访问对象时要掩掉低3位。</p>
<p>PspCidTable与每个进程的私有句柄表结构不同，后者每个表项为OBJECT_HEADER对象头。且PspCidTable是个独立的句柄表，进程私有句柄表是以双链连接的。</p>
<p>枚举句柄表方法为：</p>
<ol>
<li>找到<code>PsLookupProcessByProcessId</code>函数地址，该函数是被导出的可以动态拿到。</li>
<li>在<code>PsLookupProcessByProcessId</code>地址中搜索<code>PspReferenceCidTableEntry</code>。</li>
<li>在<code>PspReferenceCidTableEntry</code>地址中找到<code>PspCidTable</code>函数。</li>
</ol>
<p>首先获取PspCidTable地址，程序中用<code>MmGetSystemRoutineAddress</code>得到。PspCidTable是个HANDLE_TABLE结构，新建进程时会在其内存入一个该进线程对应的HANDLE_TABLE_ENTRY项。其采用动态扩展方法，句柄数少则采用下层表，多时才采用中层表或上层表。</p>
<p>内核句柄表三层如下：</p>
<ul>
<li>下层表是个HANDLE_TABLE_ENTRY项索引，整个表有256个元素，每个元素是个8字节长的HANDLE_TABLE_ENTRY项及索引，每个项中保存指向对象的指针。下层表可看作是进程和线程的稠密索引。内容是加密的。</li>
<li>中层表共有256个元素，每个元素是个4字节长指向下层表的入口指针及索引。中层表可看作是进程和线程的稀疏索引。</li>
<li>上层表共有256个元素，每个元素是个4字节长指向中层表的入口指针及索引。上层表可看作是中层表的稀疏索引。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dq nt!PspCidTable</span><br><span class="line">fffff800`55efc5c0  ffffc18d`63834d40 ffff9786`796fd370</span><br><span class="line">fffff800`55efc5d0  ffff9786`797cf2a0 00000000`00000002</span><br><span class="line">fffff800`55efc5e0  00000000`00000000 00001000`00010000</span><br><span class="line">fffff800`55efc5f0  00000000`00000000 00000000`0000b701</span><br><span class="line">fffff800`55efc600  00000000`00000000 00000000`00000000</span><br><span class="line">fffff800`55efc610  00000000`00000000 00000000`00000000</span><br><span class="line">fffff800`55efc620  00000000`00000000 00000000`00000000</span><br><span class="line">fffff800`55efc630  ffff9786`797fc2a0 fffff800`56246000</span><br><span class="line">1: kd&gt; dt nt!_HANDLE_TABLE ffffc18d`63834d40</span><br><span class="line">   +0x000 NextHandleNeedingPool : 0x1400</span><br><span class="line">   +0x004 ExtraInfoPages   : 0n0</span><br><span class="line">   +0x008 TableCode        : 0xffffc18d`671fd001 //抹掉低2位</span><br><span class="line">   +0x010 QuotaProcess     : (null) </span><br><span class="line">   +0x018 HandleTableList  : _LIST_ENTRY [ 0xffffc18d`63834d58 - 0xffffc18d`63834d58 ]</span><br><span class="line">   +0x028 UniqueProcessId  : 0</span><br><span class="line">   +0x02c Flags            : 1</span><br><span class="line">   +0x02c StrictFIFO       : 0y1</span><br><span class="line">   +0x02c EnableHandleExceptions : 0y0</span><br><span class="line">   +0x02c Rundown          : 0y0</span><br><span class="line">   +0x02c Duplicated       : 0y0</span><br><span class="line">   +0x02c RaiseUMExceptionOnInvalidHandleClose : 0y0</span><br><span class="line">   +0x030 HandleContentionEvent : _EX_PUSH_LOCK</span><br><span class="line">   +0x038 HandleTableLock  : _EX_PUSH_LOCK</span><br><span class="line">   +0x040 FreeLists        : [1] _HANDLE_TABLE_FREE_LIST</span><br><span class="line">   +0x040 ActualEntry      : [32]  &quot;&quot;</span><br><span class="line">   +0x060 DebugInfo        : (null) </span><br><span class="line">1: kd&gt; dq 0xffffc18d`671fd000</span><br><span class="line">ffffc18d`671fd000  ffffc18d`638a0000 ffffc18d`671fe000</span><br><span class="line">ffffc18d`671fd010  ffffc18d`678ff000 ffffc18d`68963000</span><br><span class="line">ffffc18d`671fd020  ffffc18d`6917f000 00000000`00000000</span><br><span class="line">ffffc18d`671fd030  00000000`00000000 00000000`00000000</span><br><span class="line">ffffc18d`671fd040  00000000`00000000 00000000`00000000</span><br><span class="line">ffffc18d`671fd050  00000000`00000000 00000000`00000000</span><br><span class="line">ffffc18d`671fd060  00000000`00000000 00000000`00000000</span><br><span class="line">ffffc18d`671fd070  00000000`00000000 00000000`00000000</span><br><span class="line">1: kd&gt; dq ffffc18d`638a0000</span><br><span class="line">ffffc18d`638a0000  00000000`00000000 00000000`00000000</span><br><span class="line">ffffc18d`638a0010  97867967`6040ff59 00000000`00000000 //System的EPROCESS结构地址 需解密</span><br><span class="line">ffffc18d`638a0020  97867e58`e0800001 00000000`00000000</span><br><span class="line">ffffc18d`638a0030  97867967`80800001 00000000`00000000</span><br><span class="line">ffffc18d`638a0040  9786796d`a0800001 00000000`00000000</span><br><span class="line">ffffc18d`638a0050  97867970`20800001 00000000`00000000</span><br><span class="line">ffffc18d`638a0060  97867973`50800001 00000000`00000000</span><br><span class="line">ffffc18d`638a0070  9786797b`a1400001 00000000`00000000</span><br></pre></td></tr></table></figure>

<p>上面TableCode成员是指向句柄表的指针，二进制低2位表示句柄表等级。0b00为下层表，0b01为中层表，0b10为上层表，这里0xffffc18d`671fd001就是个中层表。</p>
<p>EPROCESS地址解密方法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">    ULONG64 ul_recode = <span class="number">0xb281de283300ffa7</span>;</span><br><span class="line">    ULONG64 ul_decode = (LONG64)ul_recode &gt;&gt; <span class="number">0x10</span>;</span><br><span class="line">    ul_decode &amp;= <span class="number">0xfffffffffffffff0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;解密后地址: &quot;</span> &lt;&lt; std::hex &lt;&lt; ul_decode &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来获取PspCidTable地址，并对各级表解析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windef.h&gt;</span></span></span><br><span class="line"><span class="comment">// 获取 PspCidTable</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">get_PspCidTable</span><span class="params">(ULONG64* tableAddr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 PsLookupProcessByProcessId 地址</span></span><br><span class="line">    UNICODE_STRING uc_funcName;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;uc_funcName, <span class="string">L&quot;PsLookupProcessByProcessId&quot;</span>);</span><br><span class="line">    ULONG64 ul_funcAddr = <span class="built_in">MmGetSystemRoutineAddress</span>(&amp;uc_funcName);</span><br><span class="line">    <span class="keyword">if</span> (ul_funcAddr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;PsLookupProcessByProcessId addr = %p \n&quot;</span>, ul_funcAddr);</span><br><span class="line">    <span class="comment">// 前 40 字节有 call（PspReferenceCidTableEntry）</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0: kd&gt; uf PsLookupProcessByProcessId</span></span><br><span class="line"><span class="comment">    nt!PsLookupProcessByProcessId:</span></span><br><span class="line"><span class="comment">    fffff802`0841cfe0 48895c2418   mov   qword ptr [rsp+18h],rbx</span></span><br><span class="line"><span class="comment">    fffff802`0841cfe5 56       push  rsi</span></span><br><span class="line"><span class="comment">    fffff802`0841cfe6 4883ec20    sub   rsp,20h</span></span><br><span class="line"><span class="comment">    fffff802`0841cfea 48897c2438   mov   qword ptr [rsp+38h],rdi</span></span><br><span class="line"><span class="comment">    fffff802`0841cfef 488bf2     mov   rsi,rdx</span></span><br><span class="line"><span class="comment">    fffff802`0841cff2 65488b3c2588010000 mov  rdi,qword ptr gs:[188h]</span></span><br><span class="line"><span class="comment">    fffff802`0841cffb 66ff8fe6010000 dec   word ptr [rdi+1E6h]</span></span><br><span class="line"><span class="comment">    fffff802`0841d002 b203      mov   dl,3</span></span><br><span class="line"><span class="comment">    fffff802`0841d004 e887000000   call  nt!PspReferenceCidTableEntry(fffff802`0841d090)</span></span><br><span class="line"><span class="comment">    fffff802`0841d009 488bd8     mov   rbx,rax</span></span><br><span class="line"><span class="comment">    fffff802`0841d00c 4885c0     test  rax,rax</span></span><br><span class="line"><span class="comment">    fffff802`0841d00f 7435      je  nt!PsLookupProcessByProcessId+0x66 (fffff802`0841d046) Branch</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ULONG64 ul_entry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="comment">// fffff802`0841d004 e8 87 00 00 00   call nt!PspReferenceCidTableEntry(fffff802`0841d090)</span></span><br><span class="line">        <span class="keyword">if</span> (*(PUCHAR)(ul_funcAddr + i) == <span class="number">0xe8</span>) &#123;</span><br><span class="line">            ul_entry = ul_funcAddr + i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (ul_entry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析 call 地址</span></span><br><span class="line">        INT i_callCode = *(INT*)(ul_entry + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;i_callCode = %p \n&quot;</span>, i_callCode);</span><br><span class="line">        ULONG64 ul_callJmp = ul_entry + i_callCode + <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;ul_callJmp = %p \n&quot;</span>, ul_callJmp);</span><br><span class="line">        <span class="comment">// 来到 call（PspReferenceCidTableEntry） 内找 PspCidTable</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0: kd&gt; uf PspReferenceCidTableEntry</span></span><br><span class="line"><span class="comment">        nt!PspReferenceCidTableEntry+0x115:</span></span><br><span class="line"><span class="comment">        fffff802`0841d1a5 488b0d8473f5ff mov   rcx,qword ptr [nt!PspCidTable (fffff802`08374530)]</span></span><br><span class="line"><span class="comment">        fffff802`0841d1ac b801000000   mov   eax,1</span></span><br><span class="line"><span class="comment">        fffff802`0841d1b1 f0480fc107   lock xadd qword ptr [rdi],rax</span></span><br><span class="line"><span class="comment">        fffff802`0841d1b6 4883c130    add   rcx,30h</span></span><br><span class="line"><span class="comment">        fffff802`0841d1ba f0830c2400   lock or dword ptr [rsp],0</span></span><br><span class="line"><span class="comment">        fffff802`0841d1bf 48833900    cmp   qword ptr [rcx],0</span></span><br><span class="line"><span class="comment">        fffff802`0841d1c3 0f843fffffff  je   nt!PspReferenceCidTableEntry+0x78 (fffff802`0841d108) Branch</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">0x120</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// fffff802`0841d1a5 48 8b 0d 84 73 f5 ff mov   rcx,qword ptr[nt!PspCidTable(fffff802`08374530)]</span></span><br><span class="line">            <span class="keyword">if</span> (*(PUCHAR)(ul_callJmp + i) == <span class="number">0x48</span> &amp;&amp; *(PUCHAR)(ul_callJmp + i + <span class="number">1</span>) == <span class="number">0x8b</span> &amp;&amp; *(PUCHAR)(ul_callJmp + i + <span class="number">2</span>) == <span class="number">0x0d</span>) &#123;</span><br><span class="line">                <span class="comment">// 解析 mov 地址</span></span><br><span class="line">                INT i_movCode = *(INT*)(ul_callJmp + i + <span class="number">3</span>);</span><br><span class="line">                <span class="built_in">DbgPrint</span>(<span class="string">&quot;i_movCode = %p \n&quot;</span>, i_movCode);</span><br><span class="line">                ULONG64 ul_movJmp = ul_callJmp + i + i_movCode + <span class="number">7</span>;</span><br><span class="line">                <span class="built_in">DbgPrint</span>(<span class="string">&quot;ul_movJmp = %p \n&quot;</span>, ul_movJmp);</span><br><span class="line">                <span class="comment">// 得到 PspCidTable</span></span><br><span class="line">                *tableAddr = ul_movJmp;</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 解析一级表</span></span><br><span class="line"><span class="comment">BaseAddr：一级表的基地址</span></span><br><span class="line"><span class="comment">index1：第几个一级表</span></span><br><span class="line"><span class="comment">index2：第几个二级表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">VOID <span class="title">parse_table_1</span><span class="params">(ULONG64 BaseAddr, INT index1, INT index2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历一级表（每个表项大小 16 ），表大小 4k，所以遍历 4096/16 = 526 次</span></span><br><span class="line">    PEPROCESS p_eprocess = <span class="literal">NULL</span>;</span><br><span class="line">    PETHREAD p_ethread = <span class="literal">NULL</span>;</span><br><span class="line">    INT i_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)(BaseAddr + i * <span class="number">16</span>))) &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;非法地址= %p \n&quot;</span>, BaseAddr + i * <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ULONG64 ul_recode = *(PULONG64)(BaseAddr + i * <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        ULONG64 ul_decode = (LONG64)ul_recode &gt;&gt; <span class="number">0x10</span>;</span><br><span class="line">        ul_decode &amp;= <span class="number">0xfffffffffffffff0</span>;</span><br><span class="line">        <span class="comment">// 判断是进程还是线程</span></span><br><span class="line">        i_id = i * <span class="number">4</span> + <span class="number">1024</span> * index1 + <span class="number">512</span> * index2 * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">PsLookupProcessByProcessId</span>(i_id, &amp;p_eprocess) == STATUS_SUCCESS)</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;进程PID: %d | ID: %d | 内存地址: %p | 对象: %p \n&quot;</span>, i_id, i, BaseAddr + i * <span class="number">0x10</span>, ul_decode);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">PsLookupThreadByThreadId</span>(i_id, &amp;p_ethread) == STATUS_SUCCESS)</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;线程TID: %d | ID: %d | 内存地址: %p | 对象: %p \n&quot;</span>, i_id, i, BaseAddr + i * <span class="number">0x10</span>, ul_decode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 解析二级表</span></span><br><span class="line"><span class="comment">BaseAddr：二级表基地址</span></span><br><span class="line"><span class="comment">index2：第几个二级表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">VOID <span class="title">parse_table_2</span><span class="params">(ULONG64 BaseAddr, INT index2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历二级表（每个表项大小 8）,表大小 4k，所以遍历 4096/8 = 512 次</span></span><br><span class="line">    ULONG64 ul_baseAddr_1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)(BaseAddr + i * <span class="number">8</span>))) &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;非法二级表指针（1）:%p \n&quot;</span>, BaseAddr + i * <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64) * (PULONG64)(BaseAddr + i * <span class="number">8</span>))) &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;非法二级表指针（2）:%p \n&quot;</span>, BaseAddr + i * <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ul_baseAddr_1 = *(PULONG64)(BaseAddr + i * <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">parse_table_1</span>(ul_baseAddr_1, i, index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 解析三级表</span></span><br><span class="line"><span class="comment">BaseAddr：三级表基地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">VOID <span class="title">parse_table_3</span><span class="params">(ULONG64 BaseAddr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历三级表（每个表项大小 8）,表大小 4k，所以遍历 4096/8 = 512 次</span></span><br><span class="line">    ULONG64 ul_baseAddr_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64)(BaseAddr + i * <span class="number">8</span>)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID64) * (PULONG64)(BaseAddr + i * <span class="number">8</span>)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ul_baseAddr_2 = *(PULONG64)(BaseAddr + i * <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">parse_table_2</span>(ul_baseAddr_2, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">UnDriver</span><span class="params">(PDRIVER_OBJECT driver)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span> </span>&#123;</span><br><span class="line">    ULONG64 tableAddr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">get_PspCidTable</span>(&amp;tableAddr);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;PspCidTable Address = %p \n&quot;</span>, tableAddr);</span><br><span class="line">    <span class="comment">// 获取 _HANDLE_TABLE 的 TableCode</span></span><br><span class="line">    ULONG64 ul_tableCode = *(PULONG64)(((ULONG64) * (PULONG64)tableAddr) + <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;ul_tableCode = %p \n&quot;</span>, ul_tableCode);</span><br><span class="line">    <span class="comment">// 取低 2位（二级制11 = 3）</span></span><br><span class="line">    INT i_low2 = ul_tableCode &amp; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;i_low2 = %X \n&quot;</span>, i_low2);</span><br><span class="line">    <span class="comment">// 一级表</span></span><br><span class="line">    <span class="keyword">if</span> (i_low2 == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// TableCode 低 2位抹零（二级制11 = 3）</span></span><br><span class="line">        <span class="built_in">parse_table_1</span>(ul_tableCode &amp; (~<span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 二级表</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i_low2 == <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// TableCode 低 2位抹零（二级制11 = 3）</span></span><br><span class="line">        <span class="built_in">parse_table_2</span>(ul_tableCode &amp; (~<span class="number">3</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 三级表</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i_low2 == <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// TableCode 低 2位抹零（二级制11 = 3）</span></span><br><span class="line">        <span class="built_in">parse_table_3</span>(ul_tableCode &amp; (~<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;错误,非法! &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    Driver-&gt;DriverUnload = UnDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举Minifilter微过滤驱动"><a href="#枚举Minifilter微过滤驱动" class="headerlink" title="枚举Minifilter微过滤驱动"></a>枚举Minifilter微过滤驱动</h2><p>用<code>FltEnumerateFilters</code>可获取所有过滤器地址。当参数FilterList为NULL则输出系统存在的过滤器数量，为内存地址则枚举系统存在的过滤器信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS FLTAPI <span class="title">FltEnumerateFilters</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    [out] PFLT_FILTER* FilterList,</span></span></span><br><span class="line"><span class="params"><span class="function">    [in]  ULONG    FilterListSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    [out] PULONG    NumberFiltersReturned</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该API返回过滤器对象FLT_FILTER的地址，由此得到记录过滤器PreCall、PostCall、IRP等信息的Operations成员，后者是个PFLT_OPERATION_REGISTRATION结构体指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt fltmgr!_FLT_FILTER</span><br><span class="line">   +0x000 Base             : _FLT_OBJECT</span><br><span class="line">   +0x030 Frame            : Ptr64 _FLTP_FRAME</span><br><span class="line">   +0x038 Name             : _UNICODE_STRING</span><br><span class="line">   +0x048 DefaultAltitude  : _UNICODE_STRING</span><br><span class="line">   +0x058 Flags            : _FLT_FILTER_FLAGS</span><br><span class="line">   +0x060 DriverObject     : Ptr64 _DRIVER_OBJECT</span><br><span class="line">   +0x068 InstanceList     : _FLT_RESOURCE_LIST_HEAD</span><br><span class="line">   +0x0e8 VerifierExtension : Ptr64 _FLT_VERIFIER_EXTENSION</span><br><span class="line">   +0x0f0 VerifiedFiltersLink : _LIST_ENTRY</span><br><span class="line">   +0x100 FilterUnload     : Ptr64     long </span><br><span class="line">   +0x108 InstanceSetup    : Ptr64     long </span><br><span class="line">   +0x110 InstanceQueryTeardown : Ptr64     long </span><br><span class="line">   +0x118 InstanceTeardownStart : Ptr64     void </span><br><span class="line">   +0x120 InstanceTeardownComplete : Ptr64     void </span><br><span class="line">   +0x128 SupportedContextsListHead : Ptr64 _ALLOCATE_CONTEXT_HEADER</span><br><span class="line">   +0x130 SupportedContexts : [7] Ptr64 _ALLOCATE_CONTEXT_HEADER</span><br><span class="line">   +0x168 PreVolumeMount   : Ptr64     _FLT_PREOP_CALLBACK_STATUS </span><br><span class="line">   +0x170 PostVolumeMount  : Ptr64     _FLT_POSTOP_CALLBACK_STATUS </span><br><span class="line">   +0x178 GenerateFileName : Ptr64     long </span><br><span class="line">   +0x180 NormalizeNameComponent : Ptr64     long </span><br><span class="line">   +0x188 NormalizeNameComponentEx : Ptr64     long </span><br><span class="line">   +0x190 NormalizeContextCleanup : Ptr64     void </span><br><span class="line">   +0x198 KtmNotification  : Ptr64     long </span><br><span class="line">   +0x1a0 SectionNotification : Ptr64     long </span><br><span class="line">   +0x1a8 Operations       : Ptr64 _FLT_OPERATION_REGISTRATION</span><br><span class="line">   +0x1b0 OldDriverUnload  : Ptr64     void </span><br><span class="line">   +0x1b8 ActiveOpens      : _FLT_MUTEX_LIST_HEAD</span><br><span class="line">   +0x208 ConnectionList   : _FLT_MUTEX_LIST_HEAD</span><br><span class="line">   +0x258 PortList         : _FLT_MUTEX_LIST_HEAD</span><br><span class="line">   +0x2a8 PortLock         : _EX_PUSH_LOCK</span><br><span class="line">1: kd&gt; dt fltmgr!_FLT_OPERATION_REGISTRATION</span><br><span class="line">   +0x000 MajorFunction    : UChar</span><br><span class="line">   +0x004 Flags            : Uint4B</span><br><span class="line">   +0x008 PreOperation     : Ptr64     _FLT_PREOP_CALLBACK_STATUS </span><br><span class="line">   +0x010 PostOperation    : Ptr64     _FLT_POSTOP_CALLBACK_STATUS </span><br><span class="line">   +0x018 Reserved1        : Ptr64 Void</span><br></pre></td></tr></table></figure>

<p>实现如下，需要手动链接fltMgr.lib。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fltKernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dontuse.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;suppress.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置默认回调</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverDefaultHandle</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    pIrp-&gt;IoStatus.Status = status;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegPath)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    pDriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; IRP_MJ_MAXIMUM_FUNCTION; i++)</span><br><span class="line">        pDriverObject-&gt;MajorFunction[i] = DriverDefaultHandle;</span><br><span class="line">    ULONG ulFilterListSize = <span class="number">0</span>;</span><br><span class="line">    PFLT_FILTER* ppFilterList = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG i = <span class="number">0</span>;</span><br><span class="line">    LONG lOperationsOffset = <span class="number">0</span>;</span><br><span class="line">    PFLT_OPERATION_REGISTRATION pFltOperationRegistration = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取 Minifilter 过滤器Filter 的数量</span></span><br><span class="line">    <span class="built_in">FltEnumerateFilters</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;ulFilterListSize);</span><br><span class="line">    <span class="comment">// 申请内存</span></span><br><span class="line">    ppFilterList = (PFLT_FILTER*)<span class="built_in">ExAllocatePool</span>(NonPagedPool, ulFilterListSize * <span class="built_in">sizeof</span>(PFLT_FILTER));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == ppFilterList)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 获取 Minifilter 中所有过滤器Filter 的信息</span></span><br><span class="line">    status = <span class="built_in">FltEnumerateFilters</span>(ppFilterList, ulFilterListSize, &amp;ulFilterListSize);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;过滤器数量: %d \n&quot;</span>, ulFilterListSize);</span><br><span class="line">    <span class="comment">// 获取 PFLT_FILTER 中 Operations 偏移</span></span><br><span class="line">    lOperationsOffset = <span class="number">0x1A8</span>;</span><br><span class="line">    <span class="comment">// 开始遍历 Minifilter</span></span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ulFilterListSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取 PFLT_FILTER 中 Operations 成员地址</span></span><br><span class="line">            pFltOperationRegistration = (PFLT_OPERATION_REGISTRATION)(*(PVOID*)((PUCHAR)ppFilterList[i] + lOperationsOffset));</span><br><span class="line">            __try &#123;</span><br><span class="line">                <span class="comment">// 同一过滤器下的回调信息</span></span><br><span class="line">                <span class="keyword">while</span> (IRP_MJ_OPERATION_END != pFltOperationRegistration-&gt;MajorFunction) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (IRP_MJ_MAXIMUM_FUNCTION &gt; pFltOperationRegistration-&gt;MajorFunction)</span><br><span class="line">                        <span class="comment">// 显示</span></span><br><span class="line">                        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Filter: %p | IRP: %d | PreFunc: 0x%p |PostFunc = 0x % p \n&quot;</span>, ppFilterList[i], pFltOperationRegistration-&gt;MajorFunction, pFltOperationRegistration-&gt;PreOperation, pFltOperationRegistration-&gt;PostOperation);</span><br><span class="line">                    <span class="comment">// 获取下一个消息回调信息</span></span><br><span class="line">                    pFltOperationRegistration = (PFLT_OPERATION_REGISTRATION)((PUCHAR)pFltOperationRegistration + <span class="built_in">sizeof</span>(FLT_OPERATION_REGISTRATION));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            __except (EXCEPTION_EXECUTE_HANDLER) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;&#125;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">ExFreePool</span>(ppFilterList);</span><br><span class="line">    ppFilterList = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举LoadImage映像回调"><a href="#枚举LoadImage映像回调" class="headerlink" title="枚举LoadImage映像回调"></a>枚举LoadImage映像回调</h2><p>回调数组名为PspLoadImageNotifyRoutine，可在<code>PsSetLoadImageNotifyRoutineEx</code>中找到，该数组还被加密了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; uf PsSetLoadImageNotifyRoutineEx</span><br><span class="line">...</span><br><span class="line">nt!PsSetLoadImageNotifyRoutineEx+0x41:</span><br><span class="line">fffff800`559733c1 488d0d588c5700  lea     rcx,[nt!PspLoadImageNotifyRoutine (fffff800`55eec020)]</span><br><span class="line">fffff800`559733c8 4533c0          xor     r8d,r8d</span><br><span class="line">fffff800`559733cb 488d0cd9        lea     rcx,[rcx+rbx*8]</span><br><span class="line">fffff800`559733cf 488bd7          mov     rdx,rdi</span><br><span class="line">fffff800`559733d2 e8c514c3ff      call    nt!ExCompareExchangeCallBack (fffff800`555a489c)</span><br><span class="line">fffff800`559733d7 84c0            test    al,al</span><br><span class="line">fffff800`559733d9 0f84a0000000    je      nt!PsSetLoadImageNotifyRoutineEx+0xff (fffff800`5597347f)  Branch</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>实现方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windef.h&gt;</span></span></span><br><span class="line"><span class="comment">// 指定内存区域的特征码扫描</span></span><br><span class="line"><span class="function">PVOID <span class="title">SearchMemory</span><span class="params">(PVOID pStartAddress, PVOID pEndAddress, PUCHAR pMemoryData, ULONG ulMemoryDataSize)</span> </span>&#123;</span><br><span class="line">    PVOID pAddress = <span class="literal">NULL</span>;</span><br><span class="line">    PUCHAR i = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG m = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 扫描内存</span></span><br><span class="line">    <span class="keyword">for</span> (i = (PUCHAR)pStartAddress; i &lt; (PUCHAR)pEndAddress; i++) &#123;</span><br><span class="line">        <span class="comment">// 判断特征码</span></span><br><span class="line">        <span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; ulMemoryDataSize; m++)</span><br><span class="line">            <span class="keyword">if</span> (*(PUCHAR)(i + m) != pMemoryData[m])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 判断是否找到符合特征码的地址</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt;= ulMemoryDataSize) &#123;</span><br><span class="line">            <span class="comment">// 找到特征码位置, 获取紧接着特征码的下一地址</span></span><br><span class="line">            pAddress = (PVOID)(i + ulMemoryDataSize);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据特征码获取 PspLoadImageNotifyRoutine 数组地址</span></span><br><span class="line"><span class="function">PVOID <span class="title">SearchPspLoadImageNotifyRoutine</span><span class="params">(PUCHAR pSpecialData, ULONG ulSpecialDataSize)</span> </span>&#123;</span><br><span class="line">    UNICODE_STRING ustrFuncName;</span><br><span class="line">    PVOID pAddress = <span class="literal">NULL</span>;</span><br><span class="line">    LONG lOffset = <span class="number">0</span>;</span><br><span class="line">    PVOID pPsSetLoadImageNotifyRoutine = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pPspLoadImageNotifyRoutine = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 先获取 PsSetLoadImageNotifyRoutineEx 函数地址</span></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;ustrFuncName, <span class="string">L&quot;PsSetLoadImageNotifyRoutineEx&quot;</span>);</span><br><span class="line">    pPsSetLoadImageNotifyRoutine = <span class="built_in">MmGetSystemRoutineAddress</span>(&amp;ustrFuncName);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pPsSetLoadImageNotifyRoutine)</span><br><span class="line">        <span class="keyword">return</span> pPspLoadImageNotifyRoutine;</span><br><span class="line">    <span class="comment">// 查找 PspLoadImageNotifyRoutine 函数地址</span></span><br><span class="line">    pAddress = <span class="built_in">SearchMemory</span>(pPsSetLoadImageNotifyRoutine, (PVOID)((PUCHAR)pPsSetLoadImageNotifyRoutine + <span class="number">0xFF</span>), pSpecialData, ulSpecialDataSize);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pAddress)</span><br><span class="line">        <span class="keyword">return</span> pPspLoadImageNotifyRoutine;</span><br><span class="line">    <span class="comment">// 先获取偏移, 再计算地址</span></span><br><span class="line">    lOffset = *(PLONG)pAddress;</span><br><span class="line">    pPspLoadImageNotifyRoutine = (PVOID)((PUCHAR)pAddress + <span class="built_in">sizeof</span>(LONG) + lOffset);</span><br><span class="line">    <span class="keyword">return</span> pPspLoadImageNotifyRoutine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除回调</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">RemoveNotifyRoutine</span><span class="params">(PVOID pNotifyRoutineAddress)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = <span class="built_in">PsRemoveLoadImageNotifyRoutine</span>((PLOAD_IMAGE_NOTIFY_ROUTINE)pNotifyRoutineAddress);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">UnDriver</span><span class="params">(PDRIVER_OBJECT Driver)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span> </span>&#123;</span><br><span class="line">    PVOID pPspLoadImageNotifyRoutineAddress = <span class="literal">NULL</span>;</span><br><span class="line">    RTL_OSVERSIONINFOW osInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UCHAR pSpecialData[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ULONG ulSpecialDataSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取系统版本信息, 判断系统版本</span></span><br><span class="line">    <span class="built_in">RtlGetVersion</span>(&amp;osInfo);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">10</span> == osInfo.dwMajorVersion) &#123;</span><br><span class="line">        <span class="comment">// 48 8d 0d 88 e8 db ff</span></span><br><span class="line">        <span class="comment">// 查找指令 lea rcx,[nt!PspLoadImageNotifyRoutine (fffff804`44313ce0)]</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        nt!PsSetLoadImageNotifyRoutineEx+0x41:</span></span><br><span class="line"><span class="comment">        fffff801`80748a81 488d0dd8d3dbff lea   rcx, [nt!PspLoadImageNotifyRoutine (fffff801`80505e60)]</span></span><br><span class="line"><span class="comment">        fffff801`80748a88 4533c0     xor   r8d,r8d</span></span><br><span class="line"><span class="comment">        fffff801`80748a8b 488d0cd9    lea   rcx,[rcx+rbx*8]</span></span><br><span class="line"><span class="comment">        fffff801`80748a8f 488bd7     mov   rdx,rdi</span></span><br><span class="line"><span class="comment">        fffff801`80748a92 e80584a3ff   call  nt!ExCompareExchangeCallBack(fffff801`80180e9c)</span></span><br><span class="line"><span class="comment">        fffff801`80748a97 84c0      test  al,al</span></span><br><span class="line"><span class="comment">        fffff801`80748a99 0f849f000000  je  nt!PsSetLoadImageNotifyRoutineEx+0xfe (fffff801`80748b3e) Branch</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        pSpecialData[<span class="number">0</span>] = <span class="number">0x48</span>;</span><br><span class="line">        pSpecialData[<span class="number">1</span>] = <span class="number">0x8D</span>;</span><br><span class="line">        pSpecialData[<span class="number">2</span>] = <span class="number">0x0D</span>;</span><br><span class="line">        ulSpecialDataSize = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据特征码获取地址 获取 PspLoadImageNotifyRoutine 数组地址</span></span><br><span class="line">    pPspLoadImageNotifyRoutineAddress = <span class="built_in">SearchPspLoadImageNotifyRoutine</span>(pSpecialData, ulSpecialDataSize);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;PspLoadImageNotifyRoutine = 0x%p \n&quot;</span>, pPspLoadImageNotifyRoutineAddress);</span><br><span class="line">    <span class="comment">// 遍历回调</span></span><br><span class="line">    ULONG i = <span class="number">0</span>;</span><br><span class="line">    PVOID pNotifyRoutineAddress = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取 PspLoadImageNotifyRoutine 数组地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pPspLoadImageNotifyRoutineAddress)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 获取回调地址并解密</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">        pNotifyRoutineAddress = *(PVOID*)((PUCHAR)pPspLoadImageNotifyRoutineAddress + <span class="built_in">sizeof</span>(PVOID) * i);</span><br><span class="line">        pNotifyRoutineAddress = (PVOID)((ULONG64)pNotifyRoutineAddress &amp; <span class="number">0xfffffffffffffff8</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">MmIsAddressValid</span>(pNotifyRoutineAddress)) &#123;</span><br><span class="line">            pNotifyRoutineAddress = *(PVOID*)pNotifyRoutineAddress;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;序号: %d | 回调地址: 0x%p \n&quot;</span>, i, pNotifyRoutineAddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Driver-&gt;DriverUnload = UnDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举Registry注册表回调"><a href="#枚举Registry注册表回调" class="headerlink" title="枚举Registry注册表回调"></a>枚举Registry注册表回调</h2><p>消息回调链表头为CallbackListHead，是个CM_NOTIFY_ENTRY结构，需要遍历则用<code>ListEntryHead.Flink</code>向下移动指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3: kd&gt; uf nt!CmUnRegisterCallback</span><br><span class="line">...</span><br><span class="line">nt!CmUnRegisterCallback+0x67:</span><br><span class="line">fffff800`55a65b47 4533c0          xor     r8d,r8d</span><br><span class="line">fffff800`55a65b4a 488d542438      lea     rdx,[rsp+38h]</span><br><span class="line">fffff800`55a65b4f 488d0d5a283e00  lea     rcx,[nt!CallbackListHead (fffff800`55e483b0)]</span><br><span class="line">fffff800`55a65b56 e82576dfff      call    nt!CmListGetNextElement (fffff800`5585d180)</span><br><span class="line">fffff800`55a65b5b 488bf8          mov     rdi,rax</span><br><span class="line">fffff800`55a65b5e 4889442440      mov     qword ptr [rsp+40h],rax</span><br><span class="line">fffff800`55a65b63 4885c0          test    rax,rax</span><br><span class="line">fffff800`55a65b66 0f84cf000000    je      nt!CmUnRegisterCallback+0x15b (fffff800`55a65c3b)  Branch</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>实现为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windef.h&gt;</span></span></span><br><span class="line"><span class="comment">// 指定内存区域的特征码扫描</span></span><br><span class="line"><span class="function">PVOID <span class="title">SearchMemory</span><span class="params">(PVOID pStartAddress, PVOID pEndAddress, PUCHAR pMemoryData, ULONG ulMemoryDataSize)</span> </span>&#123;</span><br><span class="line">    PVOID pAddress = <span class="literal">NULL</span>;</span><br><span class="line">    PUCHAR i = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG m = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 扫描内存</span></span><br><span class="line">    <span class="keyword">for</span> (i = (PUCHAR)pStartAddress; i &lt; (PUCHAR)pEndAddress; i++) &#123;</span><br><span class="line">        <span class="comment">// 判断特征码</span></span><br><span class="line">        <span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; ulMemoryDataSize; m++)</span><br><span class="line">            <span class="keyword">if</span> (*(PUCHAR)(i + m) != pMemoryData[m])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 判断是否找到符合特征码的地址</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt;= ulMemoryDataSize) &#123;</span><br><span class="line">            <span class="comment">// 找到特征码位置, 获取紧接着特征码的下一地址</span></span><br><span class="line">            pAddress = (PVOID)(i + ulMemoryDataSize);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据特征码获取 CallbackListHead 链表地址</span></span><br><span class="line"><span class="function">PVOID <span class="title">SearchCallbackListHead</span><span class="params">(PUCHAR pSpecialData, ULONG ulSpecialDataSize, LONG lSpecialOffset)</span> </span>&#123;</span><br><span class="line">    UNICODE_STRING ustrFuncName;</span><br><span class="line">    PVOID pAddress = <span class="literal">NULL</span>;</span><br><span class="line">    LONG lOffset = <span class="number">0</span>;</span><br><span class="line">    PVOID pCmUnRegisterCallback = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pCallbackListHead = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 先获取 CmUnRegisterCallback 函数地址</span></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;ustrFuncName, <span class="string">L&quot;CmUnRegisterCallback&quot;</span>);</span><br><span class="line">    pCmUnRegisterCallback = <span class="built_in">MmGetSystemRoutineAddress</span>(&amp;ustrFuncName);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pCmUnRegisterCallback)</span><br><span class="line">        <span class="keyword">return</span> pCallbackListHead;</span><br><span class="line">    <span class="comment">// 查找 fffff806`3a4271b3 488d0d06eac3ff lea   rcx,[nt!CallbackListHead(fffff806`3a065bc0)]</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    nt!CmUnRegisterCallback+0x6b:</span></span><br><span class="line"><span class="comment">    fffff806`3a4271ab 4533c0     xor   r8d,r8d</span></span><br><span class="line"><span class="comment">    fffff806`3a4271ae 488d542438   lea   rdx,[rsp+38h]</span></span><br><span class="line"><span class="comment">    fffff806`3a4271b3 488d0d06eac3ff lea   rcx,[nt!CallbackListHead(fffff806`3a065bc0)]</span></span><br><span class="line"><span class="comment">    fffff806`3a4271ba e855e2e2ff   call  nt!CmListGetNextElement(fffff806`3a255414)</span></span><br><span class="line"><span class="comment">    fffff806`3a4271bf 488bf8     mov   rdi,rax</span></span><br><span class="line"><span class="comment">    fffff806`3a4271c2 4889442440   mov   qword ptr [rsp+40h],rax</span></span><br><span class="line"><span class="comment">    fffff806`3a4271c7 4885c0     test  rax,rax</span></span><br><span class="line"><span class="comment">    fffff806`3a4271ca 0f84c7000000  je   nt!CmUnRegisterCallback+0x157(fffff806`3a427297) Branch</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pAddress = <span class="built_in">SearchMemory</span>(pCmUnRegisterCallback, (PVOID)((PUCHAR)pCmUnRegisterCallback + <span class="number">0xFF</span>), pSpecialData, ulSpecialDataSize);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pAddress)</span><br><span class="line">        <span class="keyword">return</span> pCallbackListHead;</span><br><span class="line">    <span class="comment">// 先获取偏移再计算地址</span></span><br><span class="line">    lOffset = *(PLONG)((PUCHAR)pAddress + lSpecialOffset);</span><br><span class="line">    pCallbackListHead = (PVOID)((PUCHAR)pAddress + lSpecialOffset + <span class="built_in">sizeof</span>(LONG) + lOffset);</span><br><span class="line">    <span class="keyword">return</span> pCallbackListHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册表回调函数结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CM_NOTIFY_ENTRY</span> &#123;</span><br><span class="line">    LIST_ENTRY  ListEntryHead;</span><br><span class="line">    ULONG  UnKnown1;</span><br><span class="line">    ULONG  UnKnown2;</span><br><span class="line">    LARGE_INTEGER Cookie;</span><br><span class="line">    PVOID  Context;</span><br><span class="line">    PVOID  Function;</span><br><span class="line">&#125;CM_NOTIFY_ENTRY, * PCM_NOTIFY_ENTRY;</span><br><span class="line"><span class="function">VOID <span class="title">UnDriver</span><span class="params">(PDRIVER_OBJECT Driver)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span> </span>&#123;</span><br><span class="line">    PVOID pCallbackListHeadAddress = <span class="literal">NULL</span>;</span><br><span class="line">    RTL_OSVERSIONINFOW osInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UCHAR pSpecialData[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ULONG ulSpecialDataSize = <span class="number">0</span>;</span><br><span class="line">    LONG lSpecialOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查找 fffff806`3a4271b3 488d0d06eac3ff lea   rcx,[nt!CallbackListHead(fffff806`3a065bc0)]</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    nt!CmUnRegisterCallback+0x6b:</span></span><br><span class="line"><span class="comment">    fffff806`3a4271ab 4533c0     xor   r8d,r8d</span></span><br><span class="line"><span class="comment">    fffff806`3a4271ae 488d542438   lea   rdx,[rsp+38h]</span></span><br><span class="line"><span class="comment">    fffff806`3a4271b3 488d0d06eac3ff lea   rcx,[nt!CallbackListHead(fffff806`3a065bc0)]</span></span><br><span class="line"><span class="comment">    fffff806`3a4271ba e855e2e2ff   call  nt!CmListGetNextElement(fffff806`3a255414)</span></span><br><span class="line"><span class="comment">    fffff806`3a4271bf 488bf8     mov   rdi,rax</span></span><br><span class="line"><span class="comment">    fffff806`3a4271c2 4889442440   mov   qword ptr [rsp+40h],rax</span></span><br><span class="line"><span class="comment">    fffff806`3a4271c7 4885c0     test  rax,rax</span></span><br><span class="line"><span class="comment">    fffff806`3a4271ca 0f84c7000000  je   nt!CmUnRegisterCallback+0x157(fffff806`3a427297) Branch</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pSpecialData[<span class="number">0</span>] = <span class="number">0x48</span>;</span><br><span class="line">    pSpecialData[<span class="number">1</span>] = <span class="number">0x8D</span>;</span><br><span class="line">    pSpecialData[<span class="number">2</span>] = <span class="number">0x0D</span>;</span><br><span class="line">    ulSpecialDataSize = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 根据特征码获取地址</span></span><br><span class="line">    pCallbackListHeadAddress = <span class="built_in">SearchCallbackListHead</span>(pSpecialData, ulSpecialDataSize, lSpecialOffset);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;CallbackListHead =&gt; %p \n&quot;</span>, pCallbackListHeadAddress);</span><br><span class="line">    <span class="comment">// 遍历链表结构</span></span><br><span class="line">    ULONG i = <span class="number">0</span>;</span><br><span class="line">    PCM_NOTIFY_ENTRY pNotifyEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pCallbackListHeadAddress)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 开始遍历双向链表</span></span><br><span class="line">    pNotifyEntry = (PCM_NOTIFY_ENTRY)pCallbackListHeadAddress;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 判断pNotifyEntry地址是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (FALSE == <span class="built_in">MmIsAddressValid</span>(pNotifyEntry))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 判断回调函数地址是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">MmIsAddressValid</span>(pNotifyEntry-&gt;Function))</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;回调函数地址: 0x%p | 回调函数Cookie: 0x%I64X\n&quot;</span>, pNotifyEntry-&gt;Function, pNotifyEntry-&gt;Cookie.QuadPart);</span><br><span class="line">        <span class="comment">// 获取下一链表</span></span><br><span class="line">        pNotifyEntry = (PCM_NOTIFY_ENTRY)pNotifyEntry-&gt;ListEntryHead.Flink;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pCallbackListHeadAddress != (PVOID)pNotifyEntry);</span><br><span class="line">    Driver-&gt;DriverUnload = UnDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举进线程ObCall回调"><a href="#枚举进线程ObCall回调" class="headerlink" title="枚举进线程ObCall回调"></a>枚举进线程ObCall回调</h2><p>这里枚举系统中ProcessObCall进程回调和ThreadObCall线程回调，用到的结构体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt nt!_OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +0x000 Length           : Uint2B</span><br><span class="line">   +0x002 ObjectTypeFlags  : Uint2B</span><br><span class="line">   +0x002 CaseInsensitive  : Pos 0, 1 Bit</span><br><span class="line">   +0x002 UnnamedObjectsOnly : Pos 1, 1 Bit</span><br><span class="line">   +0x002 UseDefaultObject : Pos 2, 1 Bit</span><br><span class="line">   +0x002 SecurityRequired : Pos 3, 1 Bit</span><br><span class="line">   +0x002 MaintainHandleCount : Pos 4, 1 Bit</span><br><span class="line">   +0x002 MaintainTypeList : Pos 5, 1 Bit</span><br><span class="line">   +0x002 SupportsObjectCallbacks : Pos 6, 1 Bit</span><br><span class="line">   +0x002 CacheAligned     : Pos 7, 1 Bit</span><br><span class="line">   +0x003 UseExtendedParameters : Pos 0, 1 Bit</span><br><span class="line">   +0x003 Reserved         : Pos 1, 7 Bits</span><br><span class="line">   +0x004 ObjectTypeCode   : Uint4B</span><br><span class="line">   +0x008 InvalidAttributes : Uint4B</span><br><span class="line">   +0x00c GenericMapping   : _GENERIC_MAPPING</span><br><span class="line">   +0x01c ValidAccessMask  : Uint4B</span><br><span class="line">   +0x020 RetainAccess     : Uint4B</span><br><span class="line">   +0x024 PoolType         : _POOL_TYPE</span><br><span class="line">   +0x028 DefaultPagedPoolCharge : Uint4B</span><br><span class="line">   +0x02c DefaultNonPagedPoolCharge : Uint4B</span><br><span class="line">   +0x030 DumpProcedure    : Ptr64     void </span><br><span class="line">   +0x038 OpenProcedure    : Ptr64     long </span><br><span class="line">   +0x040 CloseProcedure   : Ptr64     void </span><br><span class="line">   +0x048 DeleteProcedure  : Ptr64     void </span><br><span class="line">   +0x050 ParseProcedure   : Ptr64     long </span><br><span class="line">   +0x050 ParseProcedureEx : Ptr64     long </span><br><span class="line">   +0x058 SecurityProcedure : Ptr64     long </span><br><span class="line">   +0x060 QueryNameProcedure : Ptr64     long </span><br><span class="line">   +0x068 OkayToCloseProcedure : Ptr64     unsigned char </span><br><span class="line">   +0x070 WaitObjectFlagMask : Uint4B</span><br><span class="line">   +0x074 WaitObjectFlagOffset : Uint2B</span><br><span class="line">   +0x076 WaitObjectPointerOffset : Uint2B</span><br><span class="line">0: kd&gt; dt nt!_OBJECT_TYPE</span><br><span class="line">   +0x000 TypeList         : _LIST_ENTRY</span><br><span class="line">   +0x010 Name             : _UNICODE_STRING</span><br><span class="line">   +0x020 DefaultObject    : Ptr64 Void</span><br><span class="line">   +0x028 Index            : UChar</span><br><span class="line">   +0x02c TotalNumberOfObjects : Uint4B</span><br><span class="line">   +0x030 TotalNumberOfHandles : Uint4B</span><br><span class="line">   +0x034 HighWaterNumberOfObjects : Uint4B</span><br><span class="line">   +0x038 HighWaterNumberOfHandles : Uint4B</span><br><span class="line">   +0x040 TypeInfo         : _OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +0x0b8 TypeLock         : _EX_PUSH_LOCK</span><br><span class="line">   +0x0c0 Key              : Uint4B</span><br><span class="line">   +0x0c8 CallbackList     : _LIST_ENTRY</span><br></pre></td></tr></table></figure>

<p>还有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OB_CALLBACK</span> &#123;</span><br><span class="line">    LIST_ENTRY ListEntry;</span><br><span class="line">    ULONGLONG Unknown;</span><br><span class="line">    HANDLE ObHandle;</span><br><span class="line">    PVOID ObTypeAddr;</span><br><span class="line">    PVOID PreCall;</span><br><span class="line">    PVOID PostCall;</span><br><span class="line">&#125;OB_CALLBACK, * POB_CALLBACK;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>

<p>枚举进程句柄回调：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wdm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OBJECT_TYPE_INITIALIZER</span> &#123;</span><br><span class="line">    USHORT Length;         <span class="comment">// Uint2B</span></span><br><span class="line">    UCHAR ObjectTypeFlags;       <span class="comment">// UChar</span></span><br><span class="line">    ULONG ObjectTypeCode;       <span class="comment">// Uint4B</span></span><br><span class="line">    ULONG InvalidAttributes;      <span class="comment">// Uint4B</span></span><br><span class="line">    GENERIC_MAPPING GenericMapping;  <span class="comment">// _GENERIC_MAPPING</span></span><br><span class="line">    ULONG ValidAccessMask;    <span class="comment">// Uint4B</span></span><br><span class="line">    ULONG RetainAccess;     <span class="comment">// Uint4B</span></span><br><span class="line">    POOL_TYPE PoolType;     <span class="comment">// _POOL_TYPE</span></span><br><span class="line">    ULONG DefaultPagedPoolCharge;  <span class="comment">// Uint4B</span></span><br><span class="line">    ULONG DefaultNonPagedPoolCharge; <span class="comment">// Uint4B</span></span><br><span class="line">    PVOID DumpProcedure;    <span class="comment">// Ptr64   void</span></span><br><span class="line">    PVOID OpenProcedure;    <span class="comment">// Ptr64   long</span></span><br><span class="line">    PVOID CloseProcedure;   <span class="comment">// Ptr64   void</span></span><br><span class="line">    PVOID DeleteProcedure;     <span class="comment">// Ptr64   void</span></span><br><span class="line">    PVOID ParseProcedure;   <span class="comment">// Ptr64   long</span></span><br><span class="line">    PVOID SecurityProcedure;    <span class="comment">// Ptr64   long</span></span><br><span class="line">    PVOID QueryNameProcedure;   <span class="comment">// Ptr64   long</span></span><br><span class="line">    PVOID OkayToCloseProcedure;   <span class="comment">// Ptr64   unsigned char</span></span><br><span class="line">    ULONG WaitObjectFlagMask;   <span class="comment">// Uint4B</span></span><br><span class="line">    USHORT WaitObjectFlagOffset;   <span class="comment">// Uint2B</span></span><br><span class="line">    USHORT WaitObjectPointerOffset;  <span class="comment">// Uint2B</span></span><br><span class="line">&#125;OBJECT_TYPE_INITIALIZER, * POBJECT_TYPE_INITIALIZER;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OBJECT_TYPE</span> &#123;</span><br><span class="line">    LIST_ENTRY TypeList;      <span class="comment">// _LIST_ENTRY</span></span><br><span class="line">    UNICODE_STRING Name;     <span class="comment">// _UNICODE_STRING</span></span><br><span class="line">    PVOID DefaultObject;     <span class="comment">// Ptr64 Void</span></span><br><span class="line">    UCHAR Index;       <span class="comment">// UChar</span></span><br><span class="line">    ULONG TotalNumberOfObjects;    <span class="comment">// Uint4B</span></span><br><span class="line">    ULONG TotalNumberOfHandles;    <span class="comment">// Uint4B</span></span><br><span class="line">    ULONG HighWaterNumberOfObjects;   <span class="comment">// Uint4B</span></span><br><span class="line">    ULONG HighWaterNumberOfHandles;   <span class="comment">// Uint4B</span></span><br><span class="line">    OBJECT_TYPE_INITIALIZER TypeInfo;  <span class="comment">// _OBJECT_TYPE_INITIALIZER</span></span><br><span class="line">    EX_PUSH_LOCK TypeLock;     <span class="comment">// _EX_PUSH_LOCK</span></span><br><span class="line">    ULONG Key;         <span class="comment">// Uint4B</span></span><br><span class="line">    LIST_ENTRY CallbackList;    <span class="comment">// _LIST_ENTRY</span></span><br><span class="line">&#125;OBJECT_TYPE, * POBJECT_TYPE;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OB_CALLBACK</span> &#123;</span><br><span class="line">    LIST_ENTRY ListEntry;</span><br><span class="line">    ULONGLONG Unknown;</span><br><span class="line">    HANDLE ObHandle;</span><br><span class="line">    PVOID ObTypeAddr;</span><br><span class="line">    PVOID PreCall;</span><br><span class="line">    PVOID PostCall;</span><br><span class="line">&#125;OB_CALLBACK, * POB_CALLBACK;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegPath)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    POB_CALLBACK pObCallback = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 直接获取 CallbackList 链表</span></span><br><span class="line">    LIST_ENTRY CallbackList = ((POBJECT_TYPE)(*PsProcessType))-&gt;CallbackList; <span class="comment">//PsProcessType换成PsThreadType即可枚举线程句柄回调</span></span><br><span class="line">    <span class="comment">// 开始遍历</span></span><br><span class="line">    pObCallback = (POB_CALLBACK)CallbackList.Flink;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (FALSE == <span class="built_in">MmIsAddressValid</span>(pObCallback))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pObCallback-&gt;ObHandle)</span><br><span class="line">            <span class="comment">// 显示</span></span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;ObHandle = %p | PreCall = %p | PostCall = %p\n&quot;</span>, pObCallback-&gt;ObHandle, pObCallback-&gt;PreCall, pObCallback-&gt;PostCall);</span><br><span class="line">        <span class="comment">// 获取下一链表信息</span></span><br><span class="line">        pObCallback = (POB_CALLBACK)pObCallback-&gt;ListEntry.Flink;</span><br><span class="line">    &#125; <span class="keyword">while</span> (CallbackList.Flink != (PLIST_ENTRY)pObCallback);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io/2024/12/05/WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%86%85%E6%A0%B8%E6%9E%9A%E4%B8%BE/">https://monoceros406.github.io/2024/12/05/WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%86%85%E6%A0%B8%E6%9E%9A%E4%B8%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://monoceros406.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Win%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/">Win内核安全</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/07/OpenSSL%E5%85%A5%E9%97%A8-%E6%9D%82%E5%87%91%E5%87%BD%E6%95%B0/" title="OpenSSL入门-杂凑函数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">OpenSSL入门-杂凑函数</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/30/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/" title="Windows驱动开发入门-安全进阶"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Windows驱动开发入门-安全进阶</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/28/WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-SSDT-Hook/" title="WindowsAPI编程核心技术-SSDT_Hook"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-28</div><div class="title">WindowsAPI编程核心技术-SSDT_Hook</div></div></a></div><div><a href="/2024/04/24/WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8A%9F%E8%83%BD%E6%8A%80%E6%9C%AF/" title="WindowsAPI编程核心技术-功能技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="title">WindowsAPI编程核心技术-功能技术</div></div></a></div><div><a href="/2024/05/30/WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-Minifilter%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7/" title="WindowsAPI编程核心技术-Minifilter文件监控"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="title">WindowsAPI编程核心技术-Minifilter文件监控</div></div></a></div><div><a href="/2024/04/22/WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/" title="WindowsAPI编程核心技术-加密技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-22</div><div class="title">WindowsAPI编程核心技术-加密技术</div></div></a></div><div><a href="/2024/04/22/WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF/" title="WindowsAPI编程核心技术-压缩技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-22</div><div class="title">WindowsAPI编程核心技术-压缩技术</div></div></a></div><div><a href="/2024/04/14/WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/" title="WindowsAPI编程核心技术-基础扫盲"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-14</div><div class="title">WindowsAPI编程核心技术-基础扫盲</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">Windows系统安全爱好者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">331</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://monoceros406.github.io/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哪里排版出锅了请告诉我QwQ  QQ:1295625063</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#WindowsAPI%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%86%85%E6%A0%B8%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.</span> <span class="toc-text">WindowsAPI编程核心技术-内核枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">枚举用户进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BEIoTimer%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">枚举IoTimer定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BEDpcTimer%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">枚举DpcTimer定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BEPspCidTable%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">枚举PspCidTable句柄表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BEMinifilter%E5%BE%AE%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.5.</span> <span class="toc-text">枚举Minifilter微过滤驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BELoadImage%E6%98%A0%E5%83%8F%E5%9B%9E%E8%B0%83"><span class="toc-number">1.6.</span> <span class="toc-text">枚举LoadImage映像回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BERegistry%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%9B%9E%E8%B0%83"><span class="toc-number">1.7.</span> <span class="toc-text">枚举Registry注册表回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E8%BF%9B%E7%BA%BF%E7%A8%8BObCall%E5%9B%9E%E8%B0%83"><span class="toc-number">1.8.</span> <span class="toc-text">枚举进线程ObCall回调</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/21/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E7%B3%BB%E7%BB%9F%E9%80%89%E9%A1%B9/" title="Linux编程入门-系统选项">Linux编程入门-系统选项</a><time datetime="2025-06-21T10:55:06.000Z" title="发表于 2025-06-21 18:55:06">2025-06-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/15/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E6%97%B6%E9%97%B4/" title="Linux编程入门-时间">Linux编程入门-时间</a><time datetime="2025-06-15T12:50:21.000Z" title="发表于 2025-06-15 20:50:21">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/15/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8/" title="Linux编程入门-用户管理与安全">Linux编程入门-用户管理与安全</a><time datetime="2025-06-15T02:58:13.000Z" title="发表于 2025-06-15 10:58:13">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/15/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="Linux编程入门-内存管理">Linux编程入门-内存管理</a><time datetime="2025-06-15T01:00:35.000Z" title="发表于 2025-06-15 09:00:35">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/14/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E8%BF%9B%E7%A8%8B/" title="Linux编程入门-进程">Linux编程入门-进程</a><time datetime="2025-06-14T14:02:30.000Z" title="发表于 2025-06-14 22:02:30">2025-06-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>