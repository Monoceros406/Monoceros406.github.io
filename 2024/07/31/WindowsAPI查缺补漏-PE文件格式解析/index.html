<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WindowsAPI查缺补漏-PE文件格式解析 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="WindowsAPI查缺补漏-PE文件格式解析碎碎念PE格式为Win32可执行文件采用的文件格式，Win64下称为PE32+。虚拟地址VA表示数据在进程地址空间中内存地址，相对虚拟地址RVA表示数据相对模块基地址偏移，文件偏移地址FOA为文件中数据相对于文件头的偏移。 DOS头DOS MZ头是个IMAGE_DOS_HEADER结构： 12345678910111213141516171819202">
<meta property="og:type" content="article">
<meta property="og:title" content="WindowsAPI查缺补漏-PE文件格式解析">
<meta property="og:url" content="https://monoceros406.github.io/2024/07/31/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="WindowsAPI查缺补漏-PE文件格式解析碎碎念PE格式为Win32可执行文件采用的文件格式，Win64下称为PE32+。虚拟地址VA表示数据在进程地址空间中内存地址，相对虚拟地址RVA表示数据相对模块基地址偏移，文件偏移地址FOA为文件中数据相对于文件头的偏移。 DOS头DOS MZ头是个IMAGE_DOS_HEADER结构： 12345678910111213141516171819202">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://monoceros406.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-07-31T00:51:12.000Z">
<meta property="article:modified_time" content="2025-05-11T02:13:23.806Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="WinAPI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://monoceros406.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://monoceros406.github.io/2024/07/31/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WindowsAPI查缺补漏-PE文件格式解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-11 10:13:23'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="The Blog of Monoceros406" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">331</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/ycy')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">WindowsAPI查缺补漏-PE文件格式解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-31T00:51:12.000Z" title="发表于 2024-07-31 08:51:12">2024-07-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-11T02:13:23.806Z" title="更新于 2025-05-11 10:13:23">2025-05-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="WindowsAPI查缺补漏-PE文件格式解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="WindowsAPI查缺补漏-PE文件格式解析"><a href="#WindowsAPI查缺补漏-PE文件格式解析" class="headerlink" title="WindowsAPI查缺补漏-PE文件格式解析"></a>WindowsAPI查缺补漏-PE文件格式解析</h1><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>PE格式为Win32可执行文件采用的文件格式，Win64下称为PE32+。虚拟地址VA表示数据在进程地址空间中内存地址，相对虚拟地址RVA表示数据相对模块基地址偏移，文件偏移地址FOA为文件中数据相对于文件头的偏移。</p>
<h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><p>DOS MZ头是个IMAGE_DOS_HEADER结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DOS_HEADER</span> &#123;</span><br><span class="line">    WORD   e_magic; <span class="comment">//字符MZ</span></span><br><span class="line">    WORD   e_cblp; <span class="comment">//最后页字节数</span></span><br><span class="line">    WORD   e_cp; <span class="comment">//全部和部分页数</span></span><br><span class="line">    WORD   e_crlc; <span class="comment">//重定向表中指针数</span></span><br><span class="line">    WORD   e_cparhdr; <span class="comment">//DOS MZ长度</span></span><br><span class="line">    WORD   e_minalloc; <span class="comment">//所需最小附加段</span></span><br><span class="line">    WORD   e_maxalloc; <span class="comment">//所需最大附加段</span></span><br><span class="line">    WORD   e_ss; <span class="comment">//DOS代码初始SS值</span></span><br><span class="line">    WORD   e_sp; <span class="comment">//DOS代码初始SP值</span></span><br><span class="line">    WORD   e_csum; <span class="comment">//补码校验值</span></span><br><span class="line">    WORD   e_ip; <span class="comment">//DOS代码初始IP值</span></span><br><span class="line">    WORD   e_cs; <span class="comment">//DOS代码初始CS值</span></span><br><span class="line">    WORD   e_lfarlc; <span class="comment">//重定位表偏移量</span></span><br><span class="line">    WORD   e_ovno; <span class="comment">//覆盖号</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>]; <span class="comment">//保留</span></span><br><span class="line">    WORD   e_oemid; <span class="comment">//OEM标识符</span></span><br><span class="line">    WORD   e_oeminfo; <span class="comment">//OEM信息</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>]; <span class="comment">//保留字段</span></span><br><span class="line">    LONG   e_lfanew; <span class="comment">//PE头偏移地址</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>

<p>除了e_magic和e_lfanew，其他字段全为0也不影响程序运行。DOS Stub也不重要。</p>
<h2 id="PE头"><a href="#PE头" class="headerlink" title="PE头"></a>PE头</h2><p>PE头结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_NT_HEADERS64</span> &#123;</span><br><span class="line">    DWORD Signature; <span class="comment">//值IMAGE_NT_SIGNATURE</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader; <span class="comment">//标准PE头</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader; <span class="comment">//扩展PE头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_NT_HEADERS64                  IMAGE_NT_HEADERS;</span><br></pre></td></tr></table></figure>

<p>其中IMAGE_FILE_HEADER：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span> &#123;</span><br><span class="line">    WORD    Machine; <span class="comment">//运行平台</span></span><br><span class="line">    WORD    NumberOfSections; <span class="comment">//节区数 最大96</span></span><br><span class="line">    DWORD   TimeDateStamp; <span class="comment">//编译器创建PE文件日期时间 UTC</span></span><br><span class="line">    DWORD   PointerToSymbolTable; <span class="comment">//COFF符号表偏移 无符号表0</span></span><br><span class="line">    DWORD   NumberOfSymbols; <span class="comment">//COFF符号数</span></span><br><span class="line">    WORD    SizeOfOptionalHeader; <span class="comment">//扩展PE头结构长度</span></span><br><span class="line">    WORD    Characteristics; <span class="comment">//文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p>Machine可以是IMAGE_FILE_MACHINE_I386、IMAGE_FILE_MACHINE_IA64、IMAGE_FILE_MACHINE_AMD64，具体值有：</p>
<table>
<thead>
<tr>
<th>机器</th>
<th>标志</th>
</tr>
</thead>
<tbody><tr>
<td>Intel i386</td>
<td>0x014C</td>
</tr>
<tr>
<td>MIPS R3000</td>
<td>0x0162</td>
</tr>
<tr>
<td>MIPS R4000</td>
<td>0x0166</td>
</tr>
<tr>
<td>Alpha AXP</td>
<td>0x0184</td>
</tr>
<tr>
<td>Power PC</td>
<td>0x01F0</td>
</tr>
</tbody></table>
<p>Characteristics，可以是组合：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_FILE_RELOCS_STRIPPED</td>
<td>0x0001</td>
<td>无重定位信息</td>
</tr>
<tr>
<td>IMAGE_FILE_EXECUTABLE_IMAGE</td>
<td>0x0002</td>
<td>为可执行文件</td>
</tr>
<tr>
<td>IMAGE_FILE_LINE_NUMS_STRIPPED</td>
<td>0x0004</td>
<td>不存在COFF行号</td>
</tr>
<tr>
<td>IMAGE_FILE_LOCAL_SYMS_STRIPPED</td>
<td>0x0008</td>
<td>不存在COFF符号表</td>
</tr>
<tr>
<td>IMAGE_FILE_LARGE_ADDRESS_AWARE</td>
<td>0x0020</td>
<td>该程序可处理大于2GB内存地址</td>
</tr>
<tr>
<td></td>
<td>0x0080</td>
<td>处理机低位字节相反</td>
</tr>
<tr>
<td>IMAGE_FILE_32BIT_MACHINE</td>
<td>0x0100</td>
<td>只能在32位平台上运行</td>
</tr>
<tr>
<td>IMAGE_FILE_DEBUG_STRIPPED</td>
<td>0x0200</td>
<td>不含调试信息</td>
</tr>
<tr>
<td>IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP</td>
<td>0x0400</td>
<td>位于可移动媒体上时复制到交换文件并运行</td>
</tr>
<tr>
<td>IMAGE_FILE_NET_RUN_FROM_SWAP</td>
<td>0x0800</td>
<td>位于网络上时复制到交换文件并运行</td>
</tr>
<tr>
<td>IMAGE_FILE_SYSTEM</td>
<td>0x1000</td>
<td>系统文件</td>
</tr>
<tr>
<td>IMAGE_FILE_DLL</td>
<td>0x2000</td>
<td>DLL文件</td>
</tr>
<tr>
<td>IMAGE_FILE_UP_SYSTEM_ONLY</td>
<td>0x4000</td>
<td>只能在单处理器计算机上运行</td>
</tr>
<tr>
<td></td>
<td>0x8000</td>
<td>处理机高位字节相反</td>
</tr>
</tbody></table>
<p>扩展PE头结构有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_OPTIONAL_HEADER64</span> &#123;</span><br><span class="line">    <span class="comment">//原COFF 标准字段</span></span><br><span class="line">    WORD        Magic; <span class="comment">//PE文件格式</span></span><br><span class="line">    BYTE        MajorLinkerVersion; <span class="comment">//链接器主版本号</span></span><br><span class="line">    BYTE        MinorLinkerVersion; <span class="comment">//链接器次版本号</span></span><br><span class="line">    DWORD       SizeOfCode; <span class="comment">//可执行代码总大小 对齐后</span></span><br><span class="line">    DWORD       SizeOfInitializedData; <span class="comment">//已初始化数据总大小 对齐后</span></span><br><span class="line">    DWORD       SizeOfUninitializedData; <span class="comment">//未初始化数据总大小 对齐后</span></span><br><span class="line">    DWORD       AddressOfEntryPoint; <span class="comment">//程序执行入口点RVA</span></span><br><span class="line">    DWORD       BaseOfCode; <span class="comment">//代码节RVA</span></span><br><span class="line">    <span class="comment">//扩展字段</span></span><br><span class="line">    ULONGLONG   ImageBase; <span class="comment">//数据节RVA</span></span><br><span class="line">    DWORD       SectionAlignment; <span class="comment">//内存节对齐粒度</span></span><br><span class="line">    DWORD       FileAlignment; <span class="comment">//文件节对齐粒度</span></span><br><span class="line">    WORD        MajorOperatingSystemVersion; <span class="comment">//所需操作系统主版本号</span></span><br><span class="line">    WORD        MinorOperatingSystemVersion; <span class="comment">//所需操作系统次版本号</span></span><br><span class="line">    WORD        MajorImageVersion; <span class="comment">//PE主版本号</span></span><br><span class="line">    WORD        MinorImageVersion; <span class="comment">//PE次版本号</span></span><br><span class="line">    WORD        MajorSubsystemVersion; <span class="comment">//所需子系统主版本号</span></span><br><span class="line">    WORD        MinorSubsystemVersion; <span class="comment">//所需子系统次版本号</span></span><br><span class="line">    DWORD       Win32VersionValue; <span class="comment">//保留</span></span><br><span class="line">    DWORD       SizeOfImage; <span class="comment">//PE内存映像 对齐后</span></span><br><span class="line">    DWORD       SizeOfHeaders; <span class="comment">//DOS头+PE头+节表大小 对齐后</span></span><br><span class="line">    DWORD       CheckSum; <span class="comment">//校验和</span></span><br><span class="line">    WORD        Subsystem; <span class="comment">//所需界面子系统</span></span><br><span class="line">    WORD        DllCharacteristics; <span class="comment">//文件属性</span></span><br><span class="line">    ULONGLONG   SizeOfStackReserve; <span class="comment">//初始化栈大小</span></span><br><span class="line">    ULONGLONG   SizeOfStackCommit; <span class="comment">//初始化实际提交的栈大小</span></span><br><span class="line">    ULONGLONG   SizeOfHeapReserve; <span class="comment">//初始化堆大小</span></span><br><span class="line">    ULONGLONG   SizeOfHeapCommit; <span class="comment">//初始化实际提交的堆大小</span></span><br><span class="line">    DWORD       LoaderFlags; <span class="comment">//调试相关 0</span></span><br><span class="line">    DWORD       NumberOfRvaAndSizes; <span class="comment">//数据目录结构数</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <span class="comment">//数据目录结构</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>

<p>Magic可以是：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_NT_OPTIONAL_HDR32_MAGIC</td>
<td>0x010B</td>
<td>32位可执行映像PE</td>
</tr>
<tr>
<td>IMAGE_NT_OPTIONAL_HDR64_MAGIC</td>
<td>0x020B</td>
<td>64位可执行映像PE32+</td>
</tr>
<tr>
<td>IMAGE_ROM_OPTIONAL_HDR_MAGIC</td>
<td>0x0107</td>
<td>ROM映像</td>
</tr>
</tbody></table>
<p>Subsystem字段可以是：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_SUBSYSTEM_UNKNOWN</td>
<td>未知</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_NATIVE</td>
<td>无需子系统</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_WINDOWS_GUI</td>
<td>Windows GUI子系统</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_WINDOWS_CUI</td>
<td>Windows CUI子系统</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_OS2_CUI</td>
<td>OS&#x2F;2 CUI子系统</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_POSIX_CUI</td>
<td>POSIX CUI子系统</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_WINDOWS_CE_GUI</td>
<td>Windows CE系统</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_EFI_APPLICATION</td>
<td>可扩展固件接口EFI应用程序</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER</td>
<td>具有启动服务的EFI驱动程序</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER</td>
<td>具有运行时服务的EFI驱动程序</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_EFI_ROM</td>
<td>EFI ROM映像</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_XBOX</td>
<td>Xbox系统</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION</td>
<td>引导程序</td>
</tr>
</tbody></table>
<p>DllCharacteristics字段实际上针对任何PE文件，不只是DLL，可以是组合：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA</td>
<td>可处理64位虚拟地址，即PE32+</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE</td>
<td>取消ASLR</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY</td>
<td>强制执行代码完整性检查</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_NX_COMPAT</td>
<td>该PE映像与DEP兼容</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_NO_ISOLATION</td>
<td>可识别但不应隔离</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_NO_SEH</td>
<td>不用SEH</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_NO_BIND</td>
<td>不要绑定PE映像</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_WDM_DRIVER</td>
<td>WDM驱动程序</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</td>
<td>可识别WTS</td>
</tr>
</tbody></table>
<p>数据块结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DATA_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress; <span class="comment">//数据RVA地址</span></span><br><span class="line">    DWORD   Size; <span class="comment">//数据长度</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>数据块顺序依次为：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
<th>节区名</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_DIRECTORY_ENTRY_EXPORT</td>
<td>导出表</td>
<td>.edata</td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_IMPORT</td>
<td>导入表</td>
<td>.idata</td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_RESOURCE</td>
<td>资源表</td>
<td>.rsrc</td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_EXCEPTION</td>
<td>异常表</td>
<td>.pdata</td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_SECURITY</td>
<td>属性证书表</td>
<td></td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_BASERELOC</td>
<td>重定位表</td>
<td>.reloc</td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_DEBUG</td>
<td>调试信息</td>
<td>.debug</td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</td>
<td>平台相关数据</td>
<td></td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_GLOBALPTR</td>
<td>指向全局指针寄存器值</td>
<td></td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_TLS</td>
<td>TLS</td>
<td>.tls</td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</td>
<td>加载配置信息表</td>
<td></td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</td>
<td>绑定导入表</td>
<td></td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_IAT</td>
<td>导入函数地址表IAT</td>
<td></td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</td>
<td>延迟加载导入表</td>
<td></td>
</tr>
<tr>
<td>IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</td>
<td>CLR运行时头部数据</td>
<td>.cormeta</td>
</tr>
</tbody></table>
<h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><p>在IMAGE_NT_HEADERS后紧接着就是IMAGE_SECTION_HEADER用于描述节区信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">//节区名 UTF-8</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   PhysicalAddress;</span><br><span class="line">        DWORD   VirtualSize; <span class="comment">//节区大小 未对齐</span></span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress; <span class="comment">//节区RVA地址</span></span><br><span class="line">    DWORD   SizeOfRawData; <span class="comment">//节区大小 对齐后</span></span><br><span class="line">    DWORD   PointerToRawData; <span class="comment">//节区文件偏移地址FOA</span></span><br><span class="line">    DWORD   PointerToRelocations; <span class="comment">//指向重定位表</span></span><br><span class="line">    DWORD   PointerToLinenumbers; <span class="comment">//行号表指针</span></span><br><span class="line">    WORD    NumberOfRelocations; <span class="comment">//重定位表数</span></span><br><span class="line">    WORD    NumberOfLinenumbers; <span class="comment">//行号表中行号数</span></span><br><span class="line">    DWORD   Characteristics; <span class="comment">//节区属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>Characteristics常用组合有：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_SCN_CNT_CODE</td>
<td>包含可执行代码</td>
</tr>
<tr>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA</td>
<td>包含已初始化数据</td>
</tr>
<tr>
<td>IMAGE_SCN_CNT_UNINITIALIZED_DATA</td>
<td>包含未初始化数据</td>
</tr>
<tr>
<td>IMAGE_SCN_GPREL</td>
<td>包含通过全局指针引用的数据</td>
</tr>
<tr>
<td>IMAGE_SCN_LNK_NRELOC_OVFL</td>
<td>包含扩展重定位</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_DISCARDABLE</td>
<td>可根据需要丢弃</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_NOT_CACHED</td>
<td>无法缓存</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_NOT_PAGED</td>
<td>无法分页</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_SHARED</td>
<td>可在内存中共享</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_EXECUTE</td>
<td>包含可执行属性</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_READ</td>
<td>包含可读属性</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_WRITE</td>
<td>包含可写属性</td>
</tr>
</tbody></table>
<h2 id="小结1"><a href="#小结1" class="headerlink" title="小结1"></a>小结1</h2><p>RVA转FOA：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function">INT <span class="title">RVAToFOA</span><span class="params">(PIMAGE_NT_HEADERS pImageNtHeader, DWORD dwTargetRVA)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    TCHAR szFile[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OPENFILENAME ofn = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ofn.lStructSize = <span class="built_in">sizeof</span>(ofn);</span><br><span class="line">    ofn.hwndOwner = hwndDlg;</span><br><span class="line">    ofn.lpstrFilter = <span class="built_in">TEXT</span>(<span class="string">&quot;exe文件(*.exe)\0*.exe\0dll文件(*.dll)\0*.dll\0All(*.*)\0*.*\0&quot;</span>);</span><br><span class="line">    ofn.nFilterIndex = <span class="number">3</span>;</span><br><span class="line">    ofn.lpstrFile = szFile;</span><br><span class="line">    ofn.lpstrFile[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    ofn.nMaxFile = _countof(szFile);</span><br><span class="line">    ofn.lpstrTitle = <span class="built_in">TEXT</span>(<span class="string">&quot;请选择要打开的PE文件&quot;</span>);</span><br><span class="line">    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;</span><br><span class="line">    HANDLE hFile, hFileMap;</span><br><span class="line">    LPVOID lpMemory;</span><br><span class="line">    LARGE_INTEGER liFileSize;</span><br><span class="line">    PIMAGE_DOS_HEADER pImageDosHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader;</span><br><span class="line">    DWORD dwTargetRVA;</span><br><span class="line">    INT iTargetFOA;</span><br><span class="line">    TCHAR szBuf[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//TCHAR szFOA[64] = TEXT(&quot;0x&quot;);</span></span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_BROWSE: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetOpenFileName</span>(&amp;ofn))</span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_PATH, szFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_CONVERT: &#123;</span><br><span class="line">                    <span class="comment">// 打开一个PE文件</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_PATH, szFile, _countof(szFile));</span><br><span class="line">                    hFile = <span class="built_in">CreateFile</span>(szFile, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFile函数调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">GetFileSizeEx</span>(hFile, &amp;liFileSize);</span><br><span class="line">                        <span class="keyword">if</span> (liFileSize.QuadPart == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;文件大小为0&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                            <span class="keyword">return</span> TRUE;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 为hFile文件对象创建一个文件映射内核对象</span></span><br><span class="line">                    hFileMap = <span class="built_in">CreateFileMapping</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!hFileMap) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFileMapping调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 把文件映射对象hFileMap的全部映射到进程的虚拟地址空间中</span></span><br><span class="line">                    lpMemory = <span class="built_in">MapViewOfFile</span>(hFileMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!lpMemory) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;MapViewOfFile调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 打开的文件是不是PE文件</span></span><br><span class="line">                    pImageDosHeader = (PIMAGE_DOS_HEADER)lpMemory;</span><br><span class="line">                    <span class="keyword">if</span> (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;打开的不是PE文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    pImageNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeader + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">                    <span class="keyword">if</span> (pImageNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;打开的不是PE文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 获取RVA编辑控件中的字符串</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_RVA, szBuf, _countof(szBuf));</span><br><span class="line">                    <span class="comment">// 数值形式的RVA字符串转换为十六进制数值的RVA</span></span><br><span class="line">                    <span class="built_in">swscanf_s</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%X&quot;</span>), &amp;dwTargetRVA);</span><br><span class="line">                    <span class="comment">// RVAToFOA</span></span><br><span class="line">                    <span class="keyword">if</span> ((iTargetFOA = <span class="built_in">RVAToFOA</span>(pImageNtHeader, dwTargetRVA)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// FOA数值转换为字符串</span></span><br><span class="line">                        _itot_s(iTargetFOA, szBuf, _countof(szBuf), <span class="number">16</span>);</span><br><span class="line">                        <span class="comment">// 转换为大写</span></span><br><span class="line">                        _tcsupr_s(szBuf, _tcslen(szBuf) + <span class="number">1</span>);</span><br><span class="line">                        <span class="comment">// 前面添加0x</span></span><br><span class="line">                        <span class="comment">//_tcscat_s(szFOA, _countof(szFOA), szBuf);</span></span><br><span class="line">                        <span class="comment">// 把FOA数值形式的字符串显示到FOA编辑控件中</span></span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_FOA, szBuf);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 清理工作</span></span><br><span class="line">                    <span class="built_in">UnmapViewOfFile</span>(lpMemory);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFileMap);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT <span class="title">RVAToFOA</span><span class="params">(PIMAGE_NT_HEADERS pImageNtHeader, DWORD dwTargetRVA)</span> </span>&#123;</span><br><span class="line">    PIMAGE_SECTION_HEADER pImageSectionHeader;</span><br><span class="line">    INT iTargetFOA = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// PE和PE32+的节表定位不同</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)</span><br><span class="line">        pImageSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pImageNtHeader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS32));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pImageSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pImageNtHeader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64));</span><br><span class="line">    <span class="comment">// 遍历节表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pImageNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((dwTargetRVA &gt;= pImageSectionHeader-&gt;VirtualAddress) &amp;&amp; (dwTargetRVA &lt;= (pImageSectionHeader-&gt;VirtualAddress + pImageSectionHeader-&gt;SizeOfRawData))) &#123;</span><br><span class="line">            iTargetFOA = dwTargetRVA - pImageSectionHeader-&gt;VirtualAddress;</span><br><span class="line">            iTargetFOA += pImageSectionHeader-&gt;PointerToRawData;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 指向下一个节区信息结构</span></span><br><span class="line">        pImageSectionHeader++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> iTargetFOA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p>导入表是一个导入表描述符结构IID数组，即IMAGE_IMPORT_DESCRIPTOR结构，最后以一个内容全为0的该结构结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;</span><br><span class="line">        DWORD   OriginalFirstThunk; <span class="comment">//IMAGE_THUNK_DATA结构 RVA</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp; <span class="comment">//与绑定相关时间戳</span></span><br><span class="line">    DWORD   ForwarderChain; <span class="comment">//首个被转发函数索引 没有为-1</span></span><br><span class="line">    DWORD   Name; <span class="comment">//指向DLL名称字符串 RVA UTF-8</span></span><br><span class="line">    DWORD   FirstThunk; <span class="comment">//IMAGE_THUNK_DATA结构 RVA</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>其中IMAGE_THUNK_DATA64定义如下，这结构就是个ULONGLONG，但不同时刻有不同含义。当ULONGLONG第一位为1时，该值低位为Oridianl，用IMAGE_ORDINAL_FLAG64测试。当第一位为0时，该值为AddressOfData，以函数名字符串形式导入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_THUNK_DATA64</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ULONGLONG ForwarderString;</span><br><span class="line">        ULONGLONG Function; <span class="comment">//导入函数内存地址</span></span><br><span class="line">        ULONGLONG Ordinal; <span class="comment">//导入函数序数</span></span><br><span class="line">        ULONGLONG AddressOfData; <span class="comment">//IMAGE_IMPORT_BY_NAME RVA</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA64;</span><br></pre></td></tr></table></figure>

<p>其中IMAGE_IMPORT_BY_NAME：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_BY_NAME</span> &#123;</span><br><span class="line">    WORD    Hint; <span class="comment">//函数编号 可0</span></span><br><span class="line">    CHAR   Name[<span class="number">1</span>]; <span class="comment">//函数名字符串 UTF-8</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, * PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p>上述OrigninalFirstThunk与FirstThunk内容完全一样，称为双桥结构。但PE文件被映射到内存中后，2桥FirstThunk数组其中元素由记录导入函数名变为函数入口地址。OriginalFirstThunk用于通过函数地址反查导入函数名，有些编译器不用而全填0，称为单桥结构。</p>
<p>FirstThunk指向导入函数内存地址，所有DLL导入函数内存地址数组顺序排列在一起，形成导入函数地址表IAT。OriginalFirstThunk最终指向函数名称形成一个导入函数名称数组，所有DLL导入函数名称数组顺序排列在一起，形成导入函数名称表INT。</p>
<p>绑定输入表结构如下，每个该结构指出一个被绑定输入DLL的时间日期戳：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_BOUND_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    DWORD   TimeDateStamp; <span class="comment">//被输入DLL的时间日期戳</span></span><br><span class="line">    WORD    OffsetModuleName; <span class="comment">//被输入DLL的名称 与第一个该类型结构的偏移</span></span><br><span class="line">    WORD    NumberOfModuleForwarderRefs; <span class="comment">//紧跟该结构的IMAGE_BOUND_FORWARDER_REF结构数</span></span><br><span class="line">&#125; IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>导出表起始位置只有一个导出表目录IMAGE_EXPORT_DIRECOTRY结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_EXPORT_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   Characteristics; <span class="comment">//保留</span></span><br><span class="line">    DWORD   TimeDateStamp; <span class="comment">//时间戳</span></span><br><span class="line">    WORD    MajorVersion; <span class="comment">//保留</span></span><br><span class="line">    WORD    MinorVersion; <span class="comment">//保留</span></span><br><span class="line">    DWORD   Name; <span class="comment">//指向模块文件名字符串RVA UTF-8</span></span><br><span class="line">    DWORD   Base; <span class="comment">//导出函数起始序数</span></span><br><span class="line">    DWORD   NumberOfFunctions; <span class="comment">//导出函数总数</span></span><br><span class="line">    DWORD   NumberOfNames; <span class="comment">//按函数名导出函数总数</span></span><br><span class="line">    DWORD   AddressOfFunctions; <span class="comment">//指向导出函数地址表EAT RVA</span></span><br><span class="line">    DWORD   AddressOfNames; <span class="comment">//指向函数名称地址表ENT RVA</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals; <span class="comment">//指向函数序数表RVA</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>AddressOfFunctions指向全部导出函数入口地址的DWORD数组，每个DWORD表示一个导出函数的RVA内存地址，数组元素个数等于NumberOfFunctions，这些函数既可通过函数名导出，也可通过函数序数导出。AddressOfNames指向函数名称地址DWORD数组，数组中每个DWORD表示一个函数名称RVA，数组元素个数等于NumberOfNames。AddressOfNameOrdinals指向一个WORD数组，每个WORD表示导出函数地址表EAT索引，与AddressOfNames指向的ENT表一一对应。</p>
<p>通过函数名地址表ENT的索引找到函数序数表对应WORD值，该WORD值即为导出函数地址表EAT的索引。</p>
<h2 id="调试目录"><a href="#调试目录" class="headerlink" title="调试目录"></a>调试目录</h2><p>调试目录结构如下，保存存储在文件中变量的类型、尺寸和位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DEBUG_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   Characteristics; <span class="comment">//0</span></span><br><span class="line">    DWORD   TimeDateStamp; <span class="comment">//调试信息的时间日期戳</span></span><br><span class="line">    WORD    MajorVersion; <span class="comment">//未使用</span></span><br><span class="line">    WORD    MinorVersion; <span class="comment">//未使用</span></span><br><span class="line">    DWORD   Type; <span class="comment">//调试信息类型</span></span><br><span class="line">    DWORD   SizeOfData; <span class="comment">//调试数据大小</span></span><br><span class="line">    DWORD   AddressOfRawData; <span class="comment">//被映射内存时调试数据RVA 0为不映射</span></span><br><span class="line">    DWORD   PointerToRawData; <span class="comment">//调试数据文件偏移</span></span><br><span class="line">&#125; IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;</span><br></pre></td></tr></table></figure>

<h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>重定位算法为：操作数绝对地址+(模块实际载入地址-模块建议装载地址)。一个32位内存地址需要4字节，每个直接记录太占空间了。绝对地址相邻重定位项高位地址相同，当以4KB页为单位在页面中寻址时，只需12位内粗泥底质。</p>
<p>重定位表是一个重定位块结构IMAGE_BASE_RELOCATION数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_BASE_RELOCATION</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress; <span class="comment">//重定位内存页起始RVA</span></span><br><span class="line">    DWORD   SizeOfBlock; <span class="comment">//本页重定位块大小 含本结构 单位字节</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>

<p>该结构后紧跟一个WORD数组表示每个重定位项，WORD的高4位表示重定位项类型，低12位为相对页起始地址的相对地址。即操作数绝对地址的RVA等于VirtualAddress+WORD低12位。最后以一个全0的该结构为结束。WORD高4位类型可以是：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_REL_BASED_ABSOLUTE</td>
<td>对齐用，有时用</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_HIGH</td>
<td>操作数绝对地址高16位需被修正，x86常用</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_LOW</td>
<td>操作数绝对地址低16位需被修正</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_HIGHLOW</td>
<td>操作数绝对地址32位都要被修正</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_HIGHADJ</td>
<td>当前项为高16位，下一个重定位项位低16位，即该重定向要占俩重定向位</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_MACHINE_SPECIFIC_5</td>
<td>MIPS平台跳转指令用</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_MACHINE_SPECIFIC_9</td>
<td>MIPS16平台跳转指令用</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_DIR64</td>
<td>64位程序的64位操作操作数绝对地址，x64常用</td>
</tr>
</tbody></table>
<h2 id="PEInfo"><a href="#PEInfo" class="headerlink" title="PEInfo"></a>PEInfo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwndDlg;                 <span class="comment">// 窗口句柄</span></span><br><span class="line">HWND g_hwndEdit;                <span class="comment">// 多行编辑控件窗口句柄</span></span><br><span class="line">LPCTSTR arrDataDirectory[] = &#123; <span class="built_in">TEXT</span>(<span class="string">&quot;导出表\t\t&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;导入表\t\t&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;资源表\t\t&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;异常表\t\t&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;属性证书表\t&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;重定位表\t&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;调试信息\t&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;与平台相关的数据&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;指向全局指针寄存器的值&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;线程局部存储\t&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;加载配置信息表\t&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;绑定导入表\t&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;导入函数地址表IAT&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;延迟加载导入表\t&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;CLR运行时头部数据&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;保留\t\t&quot;</span>) &#125;;</span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 通过指定类型数据(例如导入表、导出表、重定位表等)的RVA得到FOA</span></span><br><span class="line"><span class="function">INT <span class="title">RVAToFOA</span><span class="params">(PIMAGE_NT_HEADERS pImageNtHeader, DWORD dwTargetRVA)</span></span>;</span><br><span class="line"><span class="comment">// 通过一个RVA值获取所在节区的名称</span></span><br><span class="line"><span class="function">LPSTR <span class="title">GetSectionNameByRVA</span><span class="params">(PIMAGE_NT_HEADERS pImageNtHeader, DWORD dwRVA)</span></span>;</span><br><span class="line"><span class="comment">// 通过IMAGE_FILE_HEADER.TimeDateStamp字段获取日期时间格式字符串</span></span><br><span class="line"><span class="function">LPTSTR <span class="title">GetDateTime</span><span class="params">(DWORD dwTimeDateStamp)</span></span>;</span><br><span class="line"><span class="comment">// 获取PE文件基本信息、节区信息、数据块信息</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetBaseInfo</span><span class="params">(PIMAGE_NT_HEADERS pImageNtHeader)</span></span>;</span><br><span class="line"><span class="comment">// 获取导入表中所有dll的导入函数的函数编号和函数名称</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetImportTable</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader)</span></span>;</span><br><span class="line"><span class="comment">// 获取导出表中的所有导出函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetExportTable</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader)</span></span>;</span><br><span class="line"><span class="comment">// 获取重定位表中所有需要重定位的操作数绝对地址的地址(RVA值)</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetRelocationTable</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件所用变量</span></span><br><span class="line">    TCHAR szFile[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OPENFILENAME ofn = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ofn.lStructSize = <span class="built_in">sizeof</span>(ofn);</span><br><span class="line">    ofn.hwndOwner = hwndDlg;</span><br><span class="line">    ofn.lpstrFilter = <span class="built_in">TEXT</span>(<span class="string">&quot;exe文件(*.exe)\0*.exe\0dll文件(*.dll)\0*.dll\0All(*.*)\0*.*\0&quot;</span>);</span><br><span class="line">    ofn.nFilterIndex = <span class="number">3</span>;</span><br><span class="line">    ofn.lpstrFile = szFile;</span><br><span class="line">    ofn.lpstrFile[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    ofn.nMaxFile = _countof(szFile);</span><br><span class="line">    ofn.lpstrTitle = <span class="built_in">TEXT</span>(<span class="string">&quot;请选择要打开的PE文件&quot;</span>);</span><br><span class="line">    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;</span><br><span class="line">    <span class="comment">// 内存映射文件所用变量</span></span><br><span class="line">    HANDLE hFile, hFileMap;</span><br><span class="line">    LPVOID lpMemory;</span><br><span class="line">    LARGE_INTEGER liFileSize;</span><br><span class="line">    <span class="comment">// DOS头指针和PE文件头指针</span></span><br><span class="line">    PIMAGE_DOS_HEADER pImageDosHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader;</span><br><span class="line">    <span class="comment">// 多行编辑控件字体</span></span><br><span class="line">    HFONT hFont;</span><br><span class="line">    <span class="comment">// 调整多行编辑控件窗口大小之用</span></span><br><span class="line">    <span class="type">static</span> RECT rectWindow;</span><br><span class="line">    RECT rectEdit;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> nWidthEdit, nHeightEdit;</span><br><span class="line">    <span class="type">int</span> cx, cy;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            g_hwndDlg = hwndDlg;</span><br><span class="line">            g_hwndEdit = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_INFO);</span><br><span class="line">            <span class="comment">// 设置多行编辑控件为宋体</span></span><br><span class="line">            hFont = <span class="built_in">CreateFont</span>(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, GB2312_CHARSET, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;宋体&quot;</span>));</span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, WM_SETFONT, (WPARAM)hFont, FALSE);</span><br><span class="line">            <span class="comment">// 默认情况下编辑控件最大缓冲区大小约为32KB个字符，设为不限大小</span></span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETLIMITTEXT, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 保存程序窗口大小</span></span><br><span class="line">            <span class="built_in">GetClientRect</span>(hwndDlg, &amp;rectWindow);</span><br><span class="line">            <span class="comment">// 保存多行编辑控件的宽度高度</span></span><br><span class="line">            <span class="built_in">GetWindowRect</span>(g_hwndEdit, &amp;rectEdit);</span><br><span class="line">            nWidthEdit = rectEdit.right - rectEdit.left;</span><br><span class="line">            nHeightEdit = rectEdit.bottom - rectEdit.top;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_SIZE: &#123;</span><br><span class="line">            cx = <span class="built_in">LOWORD</span>(lParam) - rectWindow.right;</span><br><span class="line">            cy = <span class="built_in">HIWORD</span>(lParam) - rectWindow.bottom;</span><br><span class="line">            <span class="built_in">SetWindowPos</span>(g_hwndEdit, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, nWidthEdit + cx, nHeightEdit + cy, SWP_NOZORDER | SWP_NOMOVE);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_BROWSE: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetOpenFileName</span>(&amp;ofn))</span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_PATH, szFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_GET: &#123;</span><br><span class="line">                    <span class="comment">// 打开一个PE文件</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_PATH, szFile, _countof(szFile));</span><br><span class="line">                    hFile = <span class="built_in">CreateFile</span>(szFile, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFile函数调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">GetFileSizeEx</span>(hFile, &amp;liFileSize);</span><br><span class="line">                        <span class="keyword">if</span> (liFileSize.QuadPart == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;文件大小为0&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                            <span class="keyword">return</span> TRUE;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 为hFile文件对象创建一个文件映射内核对象</span></span><br><span class="line">                    hFileMap = <span class="built_in">CreateFileMapping</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!hFileMap) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFileMapping调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 把文件映射对象hFileMap的全部映射到进程的虚拟地址空间中</span></span><br><span class="line">                    lpMemory = <span class="built_in">MapViewOfFile</span>(hFileMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!lpMemory) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;MapViewOfFile调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 打开的文件是不是PE文件</span></span><br><span class="line">                    pImageDosHeader = (PIMAGE_DOS_HEADER)lpMemory;</span><br><span class="line">                    <span class="keyword">if</span> (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;打开的不是PE文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    pImageNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeader + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">                    <span class="keyword">if</span> (pImageNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;打开的不是PE文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 清空编辑控件</span></span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_INFO, <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">                    <span class="comment">//PE文件基本信息、节区信息、数据块信息</span></span><br><span class="line">                    <span class="built_in">GetBaseInfo</span>(pImageNtHeader);</span><br><span class="line">                    <span class="comment">//导入表信息</span></span><br><span class="line">                    <span class="built_in">GetImportTable</span>(pImageDosHeader);</span><br><span class="line">                    <span class="comment">//导出表信息</span></span><br><span class="line">                    <span class="built_in">GetExportTable</span>(pImageDosHeader);</span><br><span class="line">                    <span class="comment">// 重定位表</span></span><br><span class="line">                    <span class="built_in">GetRelocationTable</span>(pImageDosHeader);</span><br><span class="line">                    <span class="comment">// 清理工作</span></span><br><span class="line">                    <span class="built_in">UnmapViewOfFile</span>(lpMemory);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFileMap);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">GetBaseInfo</span><span class="params">(PIMAGE_NT_HEADERS pImageNtHeader)</span> </span>&#123;</span><br><span class="line">    PIMAGE_SECTION_HEADER pImageSectionHeader;</span><br><span class="line">    TCHAR szSectionName[IMAGE_SIZEOF_SHORT_NAME + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// Unicode节区名称</span></span><br><span class="line">    TCHAR szBuf[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 基本信息</span></span><br><span class="line">    <span class="comment">// 如果是PE32+则把pImageNtHeader强制转换为PIMAGE_NT_HEADERS64</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)</span><br><span class="line">        <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;运行平台：\t0x%04X\r\n节区数量：\t0x%04X\r\n创建时间：\t%s\r\n文件属性：\t0x%04X\r\n文件格式：\t0x%04X\r\n建议装载地址：\t0x%016I64X\r\n入口地址：\t0x%08X\r\n内存对齐：\t0x%08X\r\n文件对齐：\t0x%08X\r\n内存映像大小：\t0x%08X\r\n校验和：\t0x%08X\r\n数据目录个数：\t0x%08X\r\n\r\n&quot;</span>), ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;FileHeader.Machine, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;FileHeader.NumberOfSections, <span class="built_in">GetDateTime</span>(((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;FileHeader.TimeDateStamp), ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;FileHeader.Characteristics, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.Magic, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.ImageBase, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.AddressOfEntryPoint, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.SectionAlignment, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.FileAlignment, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.SizeOfImage, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.CheckSum, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.NumberOfRvaAndSizes);</span><br><span class="line">    <span class="comment">// 如果是PE则把pImageNtHeader强制转换为PIMAGE_NT_HEADERS32</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;运行平台：\t0x%04X\r\n节区数量：\t0x%04X\r\n创建时间：\t%s\r\n文件属性：\t0x%04X\r\n文件格式：\t0x%04X\r\n建议装载地址：\t0x%08X\r\n入口地址：\t0x%08X\r\n内存对齐：\t0x%08X\r\n文件对齐：\t0x%08X\r\n内存映像大小：\t0x%08X\r\n校验和：\t0x%08X\r\n数据目录个数：\t0x%08X\r\n\r\n&quot;</span>), ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;FileHeader.Machine, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;FileHeader.NumberOfSections, <span class="built_in">GetDateTime</span>(((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;FileHeader.TimeDateStamp), ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;FileHeader.Characteristics, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.Magic, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.ImageBase, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.AddressOfEntryPoint, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.SectionAlignment, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.FileAlignment, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.SizeOfImage, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.CheckSum, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.NumberOfRvaAndSizes);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">    <span class="comment">// 节区信息</span></span><br><span class="line">    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;节区名称\t节区  RVA\t节区 FOA\t实际大小\t对齐大小\t节区属性\r\n&quot;</span>));</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">    <span class="comment">// PE和PE32+的节表定位不同</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)</span><br><span class="line">        pImageSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pImageNtHeader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS32));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pImageSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pImageNtHeader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64));</span><br><span class="line">    <span class="comment">// 遍历节表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pImageNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">        <span class="comment">// 节区名称</span></span><br><span class="line">        <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, (LPSTR)pImageSectionHeader, IMAGE_SIZEOF_SHORT_NAME, szSectionName, IMAGE_SIZEOF_SHORT_NAME);</span><br><span class="line">        <span class="comment">// 其他信息</span></span><br><span class="line">        <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%-8s\t0x%08X\t0x%08X\t0x%08X\t0x%08X\t0x%08X\r\n&quot;</span>), szSectionName, pImageSectionHeader-&gt;VirtualAddress, pImageSectionHeader-&gt;PointerToRawData, pImageSectionHeader-&gt;Misc.VirtualSize, pImageSectionHeader-&gt;SizeOfRawData, pImageSectionHeader-&gt;Characteristics);</span><br><span class="line">        <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">        <span class="comment">// 指向下一个节区信息结构</span></span><br><span class="line">        pImageSectionHeader++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;\r\n&quot;</span>));</span><br><span class="line">    <span class="comment">// 各种类型数据块的信息</span></span><br><span class="line">    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;索引\t\t数据目录\t\t数据的RVA\t数据的大小\t数据的FOA\t所处的节区\r\n&quot;</span>));</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">    <span class="comment">// 如果是PE32+则把pImageNtHeader强制转换为PIMAGE_NT_HEADERS64</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.NumberOfRvaAndSizes; i++)</span><br><span class="line">            <span class="keyword">if</span> (((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[i].Size != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 所处的节区名称</span></span><br><span class="line">                <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, <span class="built_in">GetSectionNameByRVA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[i].VirtualAddress), IMAGE_SIZEOF_SHORT_NAME, szSectionName, IMAGE_SIZEOF_SHORT_NAME);</span><br><span class="line">                <span class="comment">// 其他信息</span></span><br><span class="line">                <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%d\t\t%s\t0x%08X\t0x%08X\t0x%08X\t%s\r\n&quot;</span>), i, arrDataDirectory[i], ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[i].VirtualAddress, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[i].Size, <span class="built_in">RVAToFOA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[i].VirtualAddress), szSectionName);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是PE则把pImageNtHeader强制转换为PIMAGE_NT_HEADERS32</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.NumberOfRvaAndSizes; i++)</span><br><span class="line">            <span class="keyword">if</span> (((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[i].Size != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 所处的节区名称</span></span><br><span class="line">                <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, <span class="built_in">GetSectionNameByRVA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[i].VirtualAddress), IMAGE_SIZEOF_SHORT_NAME, szSectionName, IMAGE_SIZEOF_SHORT_NAME);</span><br><span class="line">                <span class="comment">// 其他信息</span></span><br><span class="line">                <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%d\t\t%s\t0x%08X\t0x%08X\t0x%08X\t%s\r\n&quot;</span>), i, arrDataDirectory[i], ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[i].VirtualAddress, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[i].Size, <span class="built_in">RVAToFOA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[i].VirtualAddress), szSectionName);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">GetImportTable</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader)</span> </span>&#123;</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader;               <span class="comment">// PE文件头起始地址</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImageImportDescriptor;<span class="comment">// 导入表起始地址</span></span><br><span class="line">    PIMAGE_THUNK_DATA32 pImageThunkData32;          <span class="comment">// IMAGE_THUNK_DATA32数组起始地址</span></span><br><span class="line">    PIMAGE_THUNK_DATA64 pImageThunkData64;          <span class="comment">// IMAGE_THUNK_DATA64数组起始地址</span></span><br><span class="line">    PIMAGE_IMPORT_BY_NAME pImageImportByName;       <span class="comment">// IMAGE_IMPORT_BY_NAME结构指针</span></span><br><span class="line">    TCHAR szDllName[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;                   <span class="comment">// dll名称</span></span><br><span class="line">    TCHAR szFuncName[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;                  <span class="comment">// 函数名称</span></span><br><span class="line">    TCHAR szBuf[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR szImportTableHead[] = <span class="built_in">TEXT</span>(<span class="string">&quot;\r\n\r\n导入表信息：\r\ndll文件名\t\t\t\t\t函数编号\t函数名称\r\n&quot;</span>);</span><br><span class="line">    <span class="comment">// PE文件头起始地址</span></span><br><span class="line">    pImageNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeader + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 如果是PE32+则把pImageNtHeader强制转换为PIMAGE_NT_HEADERS64</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123;</span><br><span class="line">        <span class="comment">// 是否有导入表(当然，没有的可能性不大)</span></span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].Size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        <span class="comment">// 导入表起始地址</span></span><br><span class="line">        pImageImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].VirtualAddress));</span><br><span class="line">        <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szImportTableHead);</span><br><span class="line">        <span class="comment">// 遍历导入表</span></span><br><span class="line">        <span class="keyword">while</span> (pImageImportDescriptor-&gt;OriginalFirstThunk || pImageImportDescriptor-&gt;TimeDateStamp || pImageImportDescriptor-&gt;ForwarderChain || pImageImportDescriptor-&gt;Name || pImageImportDescriptor-&gt;FirstThunk) &#123;</span><br><span class="line">            <span class="comment">// dll名称</span></span><br><span class="line">            <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, (LPSTR)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, pImageImportDescriptor-&gt;Name)), <span class="number">-1</span>, szDllName, _countof(szDllName));</span><br><span class="line">            <span class="comment">// IMAGE_THUNK_DATA64数组起始地址</span></span><br><span class="line">            pImageThunkData64 = (PIMAGE_THUNK_DATA64)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, pImageImportDescriptor-&gt;FirstThunk));</span><br><span class="line">            <span class="keyword">while</span> (pImageThunkData64-&gt;u1.AddressOfData != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 按序号导入还是按函数名称导入</span></span><br><span class="line">                <span class="comment">// IMAGE_IMPORT_BY_NAME结构指针</span></span><br><span class="line">                pImageImportByName = (PIMAGE_IMPORT_BY_NAME)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, pImageThunkData64-&gt;u1.AddressOfData));</span><br><span class="line">                <span class="keyword">if</span> (pImageThunkData64-&gt;u1.AddressOfData &amp; IMAGE_ORDINAL_FLAG64) &#123;</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szFuncName, <span class="built_in">TEXT</span>(<span class="string">&quot;按序号 0x%04X&quot;</span>), pImageThunkData64-&gt;u1.AddressOfData &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%-48s%s\r\n&quot;</span>), szDllName, szFuncName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, pImageImportByName-&gt;Name, <span class="number">-1</span>, szFuncName, _countof(szFuncName));</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%-48s0x%04X\t\t%s\r\n&quot;</span>), szDllName, pImageImportByName-&gt;Hint, szFuncName);</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                <span class="comment">// 指向下一个IMAGE_THUNK_DATA64结构</span></span><br><span class="line">                pImageThunkData64++;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;\r\n&quot;</span>));</span><br><span class="line">            <span class="comment">// 指向下一个导入表描述符</span></span><br><span class="line">            pImageImportDescriptor++;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是PE则把pImageNtHeader强制转换为PIMAGE_NT_HEADERS32</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否有导入表(当然，没有的可能性不大)</span></span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].Size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        <span class="comment">// 导入表起始地址</span></span><br><span class="line">        pImageImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].VirtualAddress));</span><br><span class="line">        <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szImportTableHead);</span><br><span class="line">        <span class="comment">// 遍历导入表</span></span><br><span class="line">        <span class="keyword">while</span> (pImageImportDescriptor-&gt;OriginalFirstThunk || pImageImportDescriptor-&gt;TimeDateStamp || pImageImportDescriptor-&gt;ForwarderChain || pImageImportDescriptor-&gt;Name || pImageImportDescriptor-&gt;FirstThunk) &#123;</span><br><span class="line">            <span class="comment">// dll名称</span></span><br><span class="line">            <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, (LPSTR)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, pImageImportDescriptor-&gt;Name)), <span class="number">-1</span>, szDllName, _countof(szDllName));</span><br><span class="line">            <span class="comment">// IMAGE_THUNK_DATA32数组起始地址</span></span><br><span class="line">            pImageThunkData32 = (PIMAGE_THUNK_DATA32)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, pImageImportDescriptor-&gt;FirstThunk));</span><br><span class="line">            <span class="keyword">while</span> (pImageThunkData32-&gt;u1.AddressOfData != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 按序号导入还是按函数名称导入</span></span><br><span class="line">                <span class="comment">// IMAGE_IMPORT_BY_NAME结构指针</span></span><br><span class="line">                pImageImportByName = (PIMAGE_IMPORT_BY_NAME)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, pImageThunkData32-&gt;u1.AddressOfData));</span><br><span class="line">                <span class="keyword">if</span> (pImageThunkData32-&gt;u1.AddressOfData &amp; IMAGE_ORDINAL_FLAG32) &#123;</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szFuncName, <span class="built_in">TEXT</span>(<span class="string">&quot;按序号 0x%04X&quot;</span>), pImageThunkData32-&gt;u1.AddressOfData &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%-48s%s\r\n&quot;</span>), szDllName, szFuncName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, pImageImportByName-&gt;Name, <span class="number">-1</span>, szFuncName, _countof(szFuncName));</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%-48s0x%04X\t\t%s\r\n&quot;</span>), szDllName, pImageImportByName-&gt;Hint, szFuncName);</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">                <span class="comment">// 指向下一个IMAGE_THUNK_DATA32结构</span></span><br><span class="line">                pImageThunkData32++;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;\r\n&quot;</span>));</span><br><span class="line">            <span class="comment">// 指向下一个导入表描述符</span></span><br><span class="line">            pImageImportDescriptor++;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">GetExportTable</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader)</span> </span>&#123;</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader;                   <span class="comment">// PE文件头起始地址</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImageExportDirectory;      <span class="comment">// 导出表目录结构的起始地址</span></span><br><span class="line">    PDWORD pAddressOfFunctions;                         <span class="comment">// 导出函数地址表的起始地址</span></span><br><span class="line">    PWORD pAddressOfNameOrdinals;                       <span class="comment">// 函数序数表的起始地址</span></span><br><span class="line">    PDWORD pAddressOfNames;                             <span class="comment">// 函数名称地址表的起始地址</span></span><br><span class="line">    TCHAR szModuleName[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;                    <span class="comment">// 模块的原始文件名</span></span><br><span class="line">    TCHAR szFuncName[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;                      <span class="comment">// 函数名称</span></span><br><span class="line">    TCHAR szBuf[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR szExportTableHead[] = <span class="built_in">TEXT</span>(<span class="string">&quot;\r\n导出表信息：\r\n&quot;</span>);</span><br><span class="line">    TCHAR szExportTableFuncs[] = <span class="built_in">TEXT</span>(<span class="string">&quot;函数序数\t函数地址\t函数名称\r\n&quot;</span>);</span><br><span class="line">    <span class="comment">// PE文件头起始地址</span></span><br><span class="line">    pImageNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeader + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// PE和PE32+的导出表目录结构定位不同</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123;</span><br><span class="line">        <span class="comment">// 是否有导出表</span></span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].Size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否有导出表</span></span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].Size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 导出函数地址表的起始地址</span></span><br><span class="line">    pAddressOfFunctions = (PDWORD)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, pImageExportDirectory-&gt;AddressOfFunctions));</span><br><span class="line">    <span class="comment">// 函数序数表的起始地址</span></span><br><span class="line">    pAddressOfNameOrdinals = (PWORD)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, pImageExportDirectory-&gt;AddressOfNameOrdinals));</span><br><span class="line">    <span class="comment">// 函数名称地址表的起始地址</span></span><br><span class="line">    pAddressOfNames = (PDWORD)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, pImageExportDirectory-&gt;AddressOfNames));</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szExportTableHead);</span><br><span class="line">    <span class="comment">// 导出表基本信息</span></span><br><span class="line">    <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, (LPSTR)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, pImageExportDirectory-&gt;Name)), <span class="number">-1</span>, szModuleName, _countof(szModuleName));</span><br><span class="line">    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;模块原始文件名\t\t%s\r\n导出函数的起始序数\t0x%08X\r\n导出函数的总个数\t0x%08X\r\n按名称导出函数的个数\t0x%08X\r\n导出函数地址表的RVA\t0x%08X\r\n函数名称地址表的RVA\t0x%08X\r\n指向函数序数表的RVA\t0x%08X\r\n\r\n&quot;</span>), szModuleName, pImageExportDirectory-&gt;Base, pImageExportDirectory-&gt;NumberOfFunctions, pImageExportDirectory-&gt;NumberOfNames, pImageExportDirectory-&gt;AddressOfFunctions, pImageExportDirectory-&gt;AddressOfNames, pImageExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szExportTableFuncs);</span><br><span class="line">    <span class="comment">// 遍历导出表中的所有导出函数</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImageExportDirectory-&gt;NumberOfFunctions; i++) &#123;</span><br><span class="line">        <span class="comment">// 是否是按函数名称导出，遍历函数序数表</span></span><br><span class="line">        DWORD j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pImageExportDirectory-&gt;NumberOfNames; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == pAddressOfNameOrdinals[j]) &#123;</span><br><span class="line">                <span class="comment">// 获取函数名称</span></span><br><span class="line">                <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, (LPSTR)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, pAddressOfNames[j])), <span class="number">-1</span>, szFuncName, _countof(szFuncName));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="comment">// 如果遍历完函数序数表也没找到索引i，就是按函数序数导出</span></span><br><span class="line">        <span class="keyword">if</span> (j == pImageExportDirectory-&gt;NumberOfNames)</span><br><span class="line">            <span class="built_in">wsprintf</span>(szFuncName, <span class="built_in">TEXT</span>(<span class="string">&quot;按序数导出&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (pAddressOfFunctions[i]) &#123;</span><br><span class="line">            <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;0x%08X\t0x%08X\t%s\r\n&quot;</span>), pImageExportDirectory-&gt;Base + i, pAddressOfFunctions[i], szFuncName);</span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">GetRelocationTable</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader)</span> </span>&#123;</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader;                   <span class="comment">// PE文件头起始地址</span></span><br><span class="line">    PIMAGE_BASE_RELOCATION pImageBaseRelocation;        <span class="comment">// 重定位表的起始地址</span></span><br><span class="line">    PWORD pRelocationItem;                              <span class="comment">// 重定位项数组的起始地址</span></span><br><span class="line">    DWORD dwRelocationItem;                             <span class="comment">// 重定位项的个数</span></span><br><span class="line">    TCHAR szBuf[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR szRelocationTableHead[] = <span class="built_in">TEXT</span>(<span class="string">&quot;\r\n重定位表信息：\r\n&quot;</span>);</span><br><span class="line">    TCHAR szRelocationItemInfo[] = <span class="built_in">TEXT</span>(<span class="string">&quot;类型\t重定位地址\t类型\t重定位地址\t类型\t重定位地址\t类型\t重定位地址\t&quot;</span>);</span><br><span class="line">    <span class="comment">// PE文件头起始地址</span></span><br><span class="line">    pImageNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeader + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// PE和PE32+的重定位表的定位不同</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123;</span><br><span class="line">        <span class="comment">// 是否有重定位表</span></span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].Size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].VirtualAddress));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否有重定位表</span></span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].Size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].VirtualAddress));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szRelocationTableHead);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szRelocationItemInfo);</span><br><span class="line">    <span class="comment">// 遍历重定位表</span></span><br><span class="line">    <span class="keyword">while</span> (pImageBaseRelocation-&gt;VirtualAddress != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 重定位项数组的起始地址</span></span><br><span class="line">        pRelocationItem = (PWORD)((LPBYTE)pImageBaseRelocation + <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line">        <span class="comment">// 重定位项的个数</span></span><br><span class="line">        dwRelocationItem = (pImageBaseRelocation-&gt;SizeOfBlock - <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="built_in">sizeof</span>(WORD);</span><br><span class="line">        <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwRelocationItem; i++) &#123;</span><br><span class="line">            <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;0x%X\t0x%08X\t&quot;</span>), pRelocationItem[i] &gt;&gt; <span class="number">12</span>, pImageBaseRelocation-&gt;VirtualAddress + (pRelocationItem[i] &amp; <span class="number">0x0FFF</span>));</span><br><span class="line">            <span class="comment">// 4组一行</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;\r\n&quot;</span>));</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 页与页之间隔一行</span></span><br><span class="line">        <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">SendMessage</span>(g_hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;\r\n&quot;</span>));</span><br><span class="line">        <span class="comment">// 指向下一个重定位块结构</span></span><br><span class="line">        pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)((LPBYTE)pImageBaseRelocation + pImageBaseRelocation-&gt;SizeOfBlock);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*********************************************************************************</span></span><br><span class="line"><span class="comment">  * 函数功能：通过指定类型数据(例如导入表、导出表、重定位表等)的RVA得到FOA</span></span><br><span class="line"><span class="comment">  * 输入参数的说明：</span></span><br><span class="line"><span class="comment">    1. pImageNtHeader参数表示PE内存映射文件对象中PE文件头的起始地址，必须指定</span></span><br><span class="line"><span class="comment">    2. dwTargetRVA参数表示目标类型数据的RVA，必须指定</span></span><br><span class="line"><span class="comment">  * 返回值：  返回-1表示函数执行失败</span></span><br><span class="line"><span class="comment">**********************************************************************************/</span></span><br><span class="line"><span class="function">INT <span class="title">RVAToFOA</span><span class="params">(PIMAGE_NT_HEADERS pImageNtHeader, DWORD dwTargetRVA)</span> </span>&#123;</span><br><span class="line">    PIMAGE_SECTION_HEADER pImageSectionHeader;</span><br><span class="line">    INT iTargetFOA = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// PE和PE32+的节表定位不同</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)</span><br><span class="line">        pImageSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pImageNtHeader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS32));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pImageSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pImageNtHeader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64));</span><br><span class="line">    <span class="comment">// 遍历节表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pImageNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((dwTargetRVA &gt;= pImageSectionHeader-&gt;VirtualAddress) &amp;&amp; (dwTargetRVA &lt;= (pImageSectionHeader-&gt;VirtualAddress + pImageSectionHeader-&gt;SizeOfRawData))) &#123;</span><br><span class="line">            iTargetFOA = dwTargetRVA - pImageSectionHeader-&gt;VirtualAddress;</span><br><span class="line">            iTargetFOA += pImageSectionHeader-&gt;PointerToRawData;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 指向下一个节区信息结构</span></span><br><span class="line">        pImageSectionHeader++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> iTargetFOA;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*********************************************************************************</span></span><br><span class="line"><span class="comment">  * 函数功能：通过一个RVA值获取所在节区的名称</span></span><br><span class="line"><span class="comment">  * 输入参数的说明：</span></span><br><span class="line"><span class="comment">    1. pImageNtHeader参数表示PE内存映射文件对象中PE文件头的起始地址，必须指定</span></span><br><span class="line"><span class="comment">    2. dwRVA参数表示一个RVA值，必须指定</span></span><br><span class="line"><span class="comment">  * 返回值：  返回NULL表示函数执行失败，请注意返回的节区名称字符串并不一定以零结尾</span></span><br><span class="line"><span class="comment">**********************************************************************************/</span></span><br><span class="line"><span class="function">LPSTR <span class="title">GetSectionNameByRVA</span><span class="params">(PIMAGE_NT_HEADERS pImageNtHeader, DWORD dwRVA)</span> </span>&#123;</span><br><span class="line">    LPSTR lpSectionName = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER pImageSectionHeader;</span><br><span class="line">    <span class="comment">// PE和PE32+的节表定位不同</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)</span><br><span class="line">        pImageSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pImageNtHeader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS32));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pImageSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pImageNtHeader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64));</span><br><span class="line">    <span class="comment">// 遍历节表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pImageNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((dwRVA &gt;= pImageSectionHeader-&gt;VirtualAddress) &amp;&amp; (dwRVA &lt;= (pImageSectionHeader-&gt;VirtualAddress + pImageSectionHeader-&gt;SizeOfRawData)))</span><br><span class="line">            lpSectionName = (LPSTR)pImageSectionHeader;</span><br><span class="line">        <span class="comment">// 指向下一个节区信息结构</span></span><br><span class="line">        pImageSectionHeader++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> lpSectionName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">LPTSTR <span class="title">GetDateTime</span><span class="params">(DWORD dwTimeDateStamp)</span> </span>&#123;</span><br><span class="line">    FILETIME ft, ftLocal;</span><br><span class="line">    SYSTEMTIME st;</span><br><span class="line">    ULARGE_INTEGER uli;</span><br><span class="line">    LPTSTR pszDateTime = <span class="keyword">new</span> TCHAR[<span class="number">64</span>];</span><br><span class="line">    st.wYear = <span class="number">1970</span>;</span><br><span class="line">    st.wMonth = <span class="number">1</span>;</span><br><span class="line">    st.wDay = <span class="number">1</span>;</span><br><span class="line">    st.wHour = <span class="number">0</span>;</span><br><span class="line">    st.wMinute = <span class="number">0</span>;</span><br><span class="line">    st.wSecond = <span class="number">0</span>;</span><br><span class="line">    st.wMilliseconds = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 系统时间转换为文件时间才可以加上已经逝去的时间dwTimeDateStamp</span></span><br><span class="line">    <span class="built_in">SystemTimeToFileTime</span>(&amp;st, &amp;ft);</span><br><span class="line">    <span class="comment">// 文件时间单位是1/1000 0000秒，即1000万分之1秒(100-nanosecond)</span></span><br><span class="line">    <span class="comment">// 不要将指向FILETIME结构的指针强制转换为ULARGE_INTEGER *或__int64 *值</span></span><br><span class="line">    <span class="comment">// 因为这可能导致64位Windows上的对齐错误</span></span><br><span class="line">    uli.HighPart = ft.dwHighDateTime;</span><br><span class="line">    uli.LowPart = ft.dwLowDateTime;</span><br><span class="line">    uli.QuadPart += (ULONGLONG)<span class="number">10000000</span> * dwTimeDateStamp;</span><br><span class="line">    ft.dwHighDateTime = uli.HighPart;</span><br><span class="line">    ft.dwLowDateTime = uli.LowPart;</span><br><span class="line">    <span class="comment">// 将世界时间转换为本地时间(两个参数都是文件时间)</span></span><br><span class="line">    <span class="built_in">FileTimeToLocalFileTime</span>(&amp;ft, &amp;ftLocal);</span><br><span class="line">    <span class="comment">// 再将文件时间转换为系统时间</span></span><br><span class="line">    <span class="built_in">FileTimeToSystemTime</span>(&amp;ftLocal, &amp;st);</span><br><span class="line">    <span class="comment">// 转换为日期时间格式字符串</span></span><br><span class="line">    <span class="built_in">ZeroMemory</span>(pszDateTime, <span class="number">64</span>);</span><br><span class="line">    <span class="built_in">wsprintf</span>(pszDateTime, <span class="built_in">TEXT</span>(<span class="string">&quot;%d年%0.2d月%0.2d日 %0.2d:%0.2d:%0.2d&quot;</span>), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wMinute);</span><br><span class="line">    <span class="keyword">return</span> pszDateTime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="模拟PE加载器"><a href="#模拟PE加载器" class="headerlink" title="模拟PE加载器"></a>模拟PE加载器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwndDlg;</span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 在dll内存映像中根据函数序数获取函数地址(RVA值)</span></span><br><span class="line"><span class="function">INT <span class="title">GetFuncRvaByOrdinal</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader, DWORD dwOrdinal)</span></span>;</span><br><span class="line"><span class="comment">// 在dll内存映像中根据函数名称获取函数地址(RVA值)</span></span><br><span class="line"><span class="function">INT <span class="title">GetFuncRvaByName</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader, LPCTSTR lpFuncName)</span></span>;</span><br><span class="line"><span class="comment">// 加载内存映射文件中的可执行文件到进程内存中执行</span></span><br><span class="line"><span class="function">BOOL <span class="title">LoadExecutable</span><span class="params">(LPVOID lpMemory)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件所用变量</span></span><br><span class="line">    TCHAR szFileName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OPENFILENAME ofn = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ofn.lStructSize = <span class="built_in">sizeof</span>(ofn);</span><br><span class="line">    ofn.hwndOwner = hwndDlg;</span><br><span class="line">    ofn.lpstrFilter = <span class="built_in">TEXT</span>(<span class="string">&quot;exe文件(*.exe)\0*.exe\0dll文件(*.dll)\0*.dll\0All(*.*)\0*.*\0&quot;</span>);</span><br><span class="line">    ofn.nFilterIndex = <span class="number">3</span>;</span><br><span class="line">    ofn.lpstrFile = szFileName;</span><br><span class="line">    ofn.lpstrFile[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    ofn.nMaxFile = _countof(szFileName);</span><br><span class="line">    ofn.lpstrTitle = <span class="built_in">TEXT</span>(<span class="string">&quot;请选择要打开的PE文件&quot;</span>);</span><br><span class="line">    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;</span><br><span class="line">    <span class="comment">// 内存映射文件所用变量</span></span><br><span class="line">    HANDLE hFile, hFileMap;</span><br><span class="line">    LARGE_INTEGER liFileSize;</span><br><span class="line">    LPVOID lpMemory;</span><br><span class="line">    <span class="comment">// DOS头指针和PE文件头指针</span></span><br><span class="line">    PIMAGE_DOS_HEADER pImageDosHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            g_hwndDlg = hwndDlg;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_BROWSE: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetOpenFileName</span>(&amp;ofn))</span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_FILENAME, szFileName);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_LOAD: &#123;</span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(g_hwndDlg, IDC_EDIT_FILENAME, szFileName, _countof(szFileName));</span><br><span class="line">                    <span class="comment">// 打开PE文件</span></span><br><span class="line">                    hFile = <span class="built_in">CreateFile</span>(szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFile函数调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">GetFileSizeEx</span>(hFile, &amp;liFileSize);</span><br><span class="line">                        <span class="keyword">if</span> (liFileSize.QuadPart == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;文件大小为0&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 为hFile文件对象创建一个文件映射内核对象</span></span><br><span class="line">                    hFileMap = <span class="built_in">CreateFileMapping</span>(hFile, <span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!hFileMap) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFileMapping调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 把文件映射对象hFileMap的全部映射到进程的虚拟地址空间中</span></span><br><span class="line">                    lpMemory = <span class="built_in">MapViewOfFile</span>(hFileMap, FILE_MAP_READ | FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!lpMemory) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;MapViewOfFile调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 打开的文件是不是PE文件</span></span><br><span class="line">                    pImageDosHeader = (PIMAGE_DOS_HEADER)lpMemory;</span><br><span class="line">                    <span class="keyword">if</span> (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;打开的不是PE文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    pImageNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeader + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">                    <span class="keyword">if</span> (pImageNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;打开的不是PE文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 加载可执行文件到进程内存中</span></span><br><span class="line">                    <span class="built_in">LoadExecutable</span>(lpMemory);</span><br><span class="line">                    <span class="comment">// 清理工作</span></span><br><span class="line">                    <span class="built_in">UnmapViewOfFile</span>(lpMemory);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFileMap);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT <span class="title">GetFuncRvaByOrdinal</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader, DWORD dwOrdinal)</span> </span>&#123;</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader;               <span class="comment">// PE文件头起始地址</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImageExportDirectory;  <span class="comment">// 导出表目录结构的起始地址</span></span><br><span class="line">    PDWORD pAddressOfFunctions;                     <span class="comment">// 导出函数地址表的起始地址</span></span><br><span class="line">    DWORD dwIndexAddressOfFunctions;                <span class="comment">// 函数在导出函数地址表中的索引</span></span><br><span class="line">    DWORD dwFuncRva;                                <span class="comment">// 函数的RVA</span></span><br><span class="line">    <span class="comment">// PE文件头起始地址</span></span><br><span class="line">    pImageNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeader + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// PE和PE32+的导出表目录结构定位不同</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)</span><br><span class="line">        pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)pImageDosHeader + ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)pImageDosHeader + ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line">    <span class="comment">// 函数在导出函数地址表中的索引</span></span><br><span class="line">    dwIndexAddressOfFunctions = dwOrdinal - pImageExportDirectory-&gt;Base;</span><br><span class="line">    <span class="keyword">if</span> (dwIndexAddressOfFunctions &gt; pImageExportDirectory-&gt;NumberOfFunctions)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 导出函数地址表的起始地址</span></span><br><span class="line">    pAddressOfFunctions = (PDWORD)((LPBYTE)pImageDosHeader + pImageExportDirectory-&gt;AddressOfFunctions);</span><br><span class="line">    dwFuncRva = pAddressOfFunctions[dwIndexAddressOfFunctions];</span><br><span class="line">    <span class="keyword">return</span> dwFuncRva;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT <span class="title">GetFuncRvaByName</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader, LPCTSTR lpFuncName)</span> </span>&#123;</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader;               <span class="comment">// PE文件头起始地址</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImageExportDirectory;  <span class="comment">// 导出表目录结构的起始地址</span></span><br><span class="line">    PDWORD pAddressOfFunctions;                     <span class="comment">// 导出函数地址表的起始地址</span></span><br><span class="line">    PWORD pAddressOfNameOrdinals;                   <span class="comment">// 函数序数表的起始地址</span></span><br><span class="line">    PDWORD pAddressOfNames;                         <span class="comment">// 函数名称地址表的起始地址</span></span><br><span class="line">    LPSTR lpFuncNameInExport;                       <span class="comment">// 函数名称指针</span></span><br><span class="line">    TCHAR szFuncNameInExport[<span class="number">128</span>];                  <span class="comment">// 宽字符函数名称</span></span><br><span class="line">    WORD wOrdinal;                                  <span class="comment">// 函数在导出函数地址表EAT在的索引</span></span><br><span class="line">    DWORD dwFuncRva;                                <span class="comment">// 函数的RVA</span></span><br><span class="line">    <span class="comment">// PE文件头起始地址</span></span><br><span class="line">    pImageNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeader + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// PE和PE32+的导出表目录结构定位不同</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)</span><br><span class="line">        pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)pImageDosHeader + ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)pImageDosHeader + ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line">    <span class="comment">// 导出函数地址表的起始地址</span></span><br><span class="line">    pAddressOfFunctions = (PDWORD)((LPBYTE)pImageDosHeader + pImageExportDirectory-&gt;AddressOfFunctions);</span><br><span class="line">    <span class="comment">// 函数序数表的起始地址</span></span><br><span class="line">    pAddressOfNameOrdinals = (PWORD)((LPBYTE)pImageDosHeader + pImageExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line">    <span class="comment">// 函数名称地址表的起始地址</span></span><br><span class="line">    pAddressOfNames = (PDWORD)((LPBYTE)pImageDosHeader + pImageExportDirectory-&gt;AddressOfNames);</span><br><span class="line">    <span class="comment">// 遍历函数名称地址表</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImageExportDirectory-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">        lpFuncNameInExport = (LPSTR)((LPBYTE)pImageDosHeader + pAddressOfNames[i]);</span><br><span class="line">        <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, lpFuncNameInExport, <span class="number">-1</span>, szFuncNameInExport, _countof(szFuncNameInExport));</span><br><span class="line">        <span class="keyword">if</span> (_tcsicmp(szFuncNameInExport, lpFuncName) == <span class="number">0</span>) &#123;</span><br><span class="line">            wOrdinal = pAddressOfNameOrdinals[i];</span><br><span class="line">            dwFuncRva = pAddressOfFunctions[wOrdinal];</span><br><span class="line">            <span class="keyword">return</span> dwFuncRva;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">LoadExecutable</span><span class="params">(LPVOID lpMemory)</span> </span>&#123;          <span class="comment">// lpMemory是PE内存映射文件基地址</span></span><br><span class="line">    PIMAGE_DOS_HEADER pImageDosHeader;          <span class="comment">// 内存映射文件中的DOS头起始地址</span></span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader;           <span class="comment">// 内存映射文件中的PE文件头起始地址</span></span><br><span class="line">    SIZE_T nSizeOfImage;                        <span class="comment">// PE内存映像大小(基于内存对齐后的大小)</span></span><br><span class="line">    LPVOID lpBaseAddress;                       <span class="comment">// 在本进程中分配内存用于装载可执行文件</span></span><br><span class="line">    DWORD dwSizeOfHeaders;                      <span class="comment">// DOS头+PE头+节表的大小(基于内存对齐后的大小)</span></span><br><span class="line">    WORD wNumberOfSections;                     <span class="comment">// 可执行文件的节区个数</span></span><br><span class="line">    PIMAGE_SECTION_HEADER pImageSectionHeader;  <span class="comment">// 节表的起始地址</span></span><br><span class="line">    <span class="comment">// 获取PE内存映像大小</span></span><br><span class="line">    pImageDosHeader = (PIMAGE_DOS_HEADER)lpMemory;</span><br><span class="line">    pImageNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeader + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">    nSizeOfImage = pImageNtHeader-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line">    <span class="comment">// 在本进程的内存地址空间中分配nSizeOfImage + 20字节大小的可读可写可执行内存</span></span><br><span class="line">    <span class="comment">// 多出的20个字节后面会用到</span></span><br><span class="line">    lpBaseAddress = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, nSizeOfImage + <span class="number">20</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(lpBaseAddress, nSizeOfImage + <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// ***************************************************************************************</span></span><br><span class="line">    <span class="comment">// 把可执行文件按pImageNtHeader.OptionalHeader.SectionAlignment对齐粒度映射到分配的内存中</span></span><br><span class="line">    dwSizeOfHeaders = pImageNtHeader-&gt;OptionalHeader.SizeOfHeaders;</span><br><span class="line">    wNumberOfSections = pImageNtHeader-&gt;FileHeader.NumberOfSections;</span><br><span class="line">    <span class="comment">// 获取节表的起始地址</span></span><br><span class="line">    pImageSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pImageNtHeader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS));</span><br><span class="line">    <span class="comment">// 加载DOS头+PE头+节表</span></span><br><span class="line">    <span class="built_in">memcpy_s</span>(lpBaseAddress, dwSizeOfHeaders, (LPVOID)pImageDosHeader, dwSizeOfHeaders);</span><br><span class="line">    <span class="comment">// 加载所有节区到节表中指定的RVA处</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wNumberOfSections; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pImageSectionHeader-&gt;VirtualAddress == <span class="number">0</span> || pImageSectionHeader-&gt;SizeOfRawData == <span class="number">0</span>) &#123;</span><br><span class="line">            pImageSectionHeader++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">memcpy_s</span>((LPBYTE)lpBaseAddress + pImageSectionHeader-&gt;VirtualAddress, pImageSectionHeader-&gt;SizeOfRawData, (LPBYTE)pImageDosHeader + pImageSectionHeader-&gt;PointerToRawData, pImageSectionHeader-&gt;SizeOfRawData);</span><br><span class="line">        pImageSectionHeader++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ***************************************************************************************</span></span><br><span class="line">    <span class="comment">// 映射到进程中的DOS头和PE文件头起始地址</span></span><br><span class="line">    PIMAGE_DOS_HEADER pImageDosHeaderMap;           <span class="comment">// 映射到进程中的DOS头起始地址</span></span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeaderMap;            <span class="comment">// 映射到进程中的PE文件头起始地址</span></span><br><span class="line">    pImageDosHeaderMap = (PIMAGE_DOS_HEADER)lpBaseAddress;</span><br><span class="line">    pImageNtHeaderMap = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeaderMap + pImageDosHeaderMap-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// ***************************************************************************************</span></span><br><span class="line">    <span class="comment">// 修正映射到进程中的PE内存映像的重定位代码</span></span><br><span class="line">    PIMAGE_BASE_RELOCATION pImageBaseRelocationMap; <span class="comment">// 映射到进程中的重定位表的起始地址</span></span><br><span class="line">    PWORD pRelocationItem;                          <span class="comment">// 重定位项数组的起始地址</span></span><br><span class="line">    DWORD dwRelocationItem;                         <span class="comment">// 重定位项的个数</span></span><br><span class="line">    PDWORD pdwRelocationAddress;                    <span class="comment">// PE重定位地址</span></span><br><span class="line">    PULONGLONG pullRelocationAddress;               <span class="comment">// PE32+重定位地址</span></span><br><span class="line">    DWORD dwRelocationDelta;                        <span class="comment">// PE实际装入地址与建议装载地址的差值</span></span><br><span class="line">    ULONGLONG ullRelocationDelta;                   <span class="comment">// PE32+实际装入地址与建议装载地址的差值</span></span><br><span class="line">    <span class="comment">// 获取重定位表的起始地址</span></span><br><span class="line">    pImageBaseRelocationMap = (PIMAGE_BASE_RELOCATION)((LPBYTE)pImageDosHeaderMap + pImageNtHeaderMap-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].VirtualAddress);</span><br><span class="line">    <span class="comment">// 这里就不判断是否存在重定位表，因为通常都会存在</span></span><br><span class="line">    <span class="comment">// 遍历重定位表</span></span><br><span class="line">    <span class="keyword">while</span> (pImageBaseRelocationMap-&gt;VirtualAddress != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 重定位项数组的起始地址</span></span><br><span class="line">        pRelocationItem = (PWORD)((LPBYTE)pImageBaseRelocationMap + <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line">        <span class="comment">// 重定位项的个数</span></span><br><span class="line">        dwRelocationItem = (pImageBaseRelocationMap-&gt;SizeOfBlock - <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="built_in">sizeof</span>(WORD);</span><br><span class="line">        <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwRelocationItem; i++) &#123;</span><br><span class="line">            <span class="comment">// 区分PE和PE32+的重定位</span></span><br><span class="line">            <span class="keyword">if</span> (pRelocationItem[i] &gt;&gt; <span class="number">12</span> == <span class="number">3</span>) &#123;</span><br><span class="line">                pdwRelocationAddress = (PDWORD)((LPBYTE)pImageDosHeaderMap + pImageBaseRelocationMap-&gt;VirtualAddress + (pRelocationItem[i] &amp; <span class="number">0x0FFF</span>));</span><br><span class="line">                dwRelocationDelta = (DWORD)pImageDosHeaderMap - pImageNtHeaderMap-&gt;OptionalHeader.ImageBase;</span><br><span class="line">                *pdwRelocationAddress += dwRelocationDelta;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pRelocationItem[i] &gt;&gt; <span class="number">12</span> == <span class="number">0xA</span>) &#123;</span><br><span class="line">                pullRelocationAddress = (PULONGLONG)((LPBYTE)pImageDosHeaderMap + pImageBaseRelocationMap-&gt;VirtualAddress + (pRelocationItem[i] &amp; <span class="number">0x0FFF</span>));</span><br><span class="line">                ullRelocationDelta = (ULONGLONG)pImageDosHeaderMap - pImageNtHeaderMap-&gt;OptionalHeader.ImageBase;</span><br><span class="line">                *pullRelocationAddress += ullRelocationDelta;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 指向下一个重定位块结构</span></span><br><span class="line">        pImageBaseRelocationMap = (PIMAGE_BASE_RELOCATION)((LPBYTE)pImageBaseRelocationMap + pImageBaseRelocationMap-&gt;SizeOfBlock);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ***************************************************************************************</span></span><br><span class="line">    <span class="comment">// ***************************************************************************************</span></span><br><span class="line">    <span class="comment">// 修正映射到进程中的PE内存映像的导入函数地址表IAT</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImageImportDescriptor;<span class="comment">// 映射到进程中的导入表起始地址</span></span><br><span class="line">    PIMAGE_THUNK_DATA pImageThunkData;              <span class="comment">// IMAGE_THUNK_DATA数组起始地址</span></span><br><span class="line">    PIMAGE_IMPORT_BY_NAME pImageImportByName;       <span class="comment">// IMAGE_IMPORT_BY_NAME结构指针</span></span><br><span class="line">    TCHAR szDllName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;              <span class="comment">// dll名称</span></span><br><span class="line">    HMODULE hDll;                                   <span class="comment">// dll模块句柄</span></span><br><span class="line">    DWORD dwFuncAddress;                            <span class="comment">// 32位函数地址</span></span><br><span class="line">    ULONGLONG ullFuncAddress;                       <span class="comment">// 64位函数地址</span></span><br><span class="line">    <span class="comment">// 是否有导入表(当然，没有的可能性不大)</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeaderMap-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].Size != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 导入表起始地址</span></span><br><span class="line">        pImageImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((LPBYTE)pImageDosHeaderMap + pImageNtHeaderMap-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].VirtualAddress);</span><br><span class="line">        <span class="comment">// 遍历导入表</span></span><br><span class="line">        <span class="keyword">while</span> (pImageImportDescriptor-&gt;OriginalFirstThunk || pImageImportDescriptor-&gt;TimeDateStamp || pImageImportDescriptor-&gt;ForwarderChain || pImageImportDescriptor-&gt;Name || pImageImportDescriptor-&gt;FirstThunk) &#123;</span><br><span class="line">            <span class="comment">// 在进程中加载dll</span></span><br><span class="line">            <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, (LPSTR)((LPBYTE)pImageDosHeaderMap + pImageImportDescriptor-&gt;Name), <span class="number">-1</span>, szDllName, _countof(szDllName));</span><br><span class="line">            hDll = <span class="built_in">LoadLibrary</span>(szDllName);</span><br><span class="line">            <span class="comment">// IMAGE_THUNK_DATA数组起始地址</span></span><br><span class="line">            pImageThunkData = (PIMAGE_THUNK_DATA)((LPBYTE)pImageDosHeaderMap + pImageImportDescriptor-&gt;FirstThunk);</span><br><span class="line">            <span class="keyword">while</span> (pImageThunkData-&gt;u1.AddressOfData != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 区分PE和PE32+的IAT</span></span><br><span class="line">                <span class="keyword">if</span> (pImageNtHeaderMap-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123;</span><br><span class="line">                    <span class="comment">// 按序号导入还是按函数名称导入</span></span><br><span class="line">                    <span class="keyword">if</span> (pImageThunkData-&gt;u1.AddressOfData &amp; IMAGE_ORDINAL_FLAG32)</span><br><span class="line">                        <span class="comment">// 获取加载的dll中函数的地址</span></span><br><span class="line">                        dwFuncAddress = (DWORD)<span class="built_in">GetProcAddress</span>(hDll, (LPSTR)(pImageThunkData-&gt;u1.AddressOfData &amp; <span class="number">0xFFFF</span>));</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// IMAGE_IMPORT_BY_NAME结构指针</span></span><br><span class="line">                        pImageImportByName = (PIMAGE_IMPORT_BY_NAME)((LPBYTE)pImageDosHeaderMap + pImageThunkData-&gt;u1.AddressOfData);</span><br><span class="line">                        <span class="comment">// 获取加载的dll中函数的地址</span></span><br><span class="line">                        dwFuncAddress = (DWORD)<span class="built_in">GetProcAddress</span>(hDll, (LPSTR)pImageImportByName-&gt;Name);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 修复IAT项</span></span><br><span class="line">                    pImageThunkData-&gt;u1.Function = dwFuncAddress;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 按序号导入还是按函数名称导入</span></span><br><span class="line">                    <span class="keyword">if</span> (pImageThunkData-&gt;u1.AddressOfData &amp; IMAGE_ORDINAL_FLAG64)</span><br><span class="line">                        <span class="comment">// 获取加载的dll中函数的地址</span></span><br><span class="line">                        ullFuncAddress = (ULONGLONG)<span class="built_in">GetProcAddress</span>(hDll, (LPSTR)(pImageThunkData-&gt;u1.AddressOfData &amp; <span class="number">0xFFFF</span>));</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// IMAGE_IMPORT_BY_NAME结构指针</span></span><br><span class="line">                        pImageImportByName = (PIMAGE_IMPORT_BY_NAME)((LPBYTE)pImageDosHeaderMap + pImageThunkData-&gt;u1.AddressOfData);</span><br><span class="line">                        <span class="comment">// 获取加载的dll中函数的地址</span></span><br><span class="line">                        ullFuncAddress = (ULONGLONG)<span class="built_in">GetProcAddress</span>(hDll, (LPSTR)pImageImportByName-&gt;Name);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 修复IAT项</span></span><br><span class="line">                    pImageThunkData-&gt;u1.Function = ullFuncAddress;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 指向下一个IMAGE_THUNK_DATA结构</span></span><br><span class="line">                pImageThunkData++;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 指向下一个导入表描述符</span></span><br><span class="line">            pImageImportDescriptor++;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ***************************************************************************************</span></span><br><span class="line">    <span class="comment">// ***************************************************************************************</span></span><br><span class="line">    <span class="comment">// 修改建议装载地址，并执行可执行文件</span></span><br><span class="line">    LPVOID lpExeEntry;                          <span class="comment">// 可执行文件入口点</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeaderMap-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123;</span><br><span class="line">        ((PIMAGE_NT_HEADERS32)pImageNtHeaderMap)-&gt;OptionalHeader.ImageBase = (DWORD)lpBaseAddress;</span><br><span class="line">        lpExeEntry = (LPVOID)((LPBYTE)pImageDosHeaderMap + ((PIMAGE_NT_HEADERS32)pImageNtHeaderMap)-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ((PIMAGE_NT_HEADERS64)pImageNtHeaderMap)-&gt;OptionalHeader.ImageBase = (ULONGLONG)lpBaseAddress;</span><br><span class="line">        lpExeEntry = (LPVOID)((LPBYTE)pImageDosHeaderMap + ((PIMAGE_NT_HEADERS64)pImageNtHeaderMap)-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 如果本程序编译为64位，不支持内联汇编，因此我们采取直接写入可执行机器码的方式执行exe</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN64</span></span><br><span class="line">    <span class="comment">// mov eax, 0x12345678</span></span><br><span class="line">    <span class="comment">// jmp eax</span></span><br><span class="line">    BYTE bDataJmp[<span class="number">7</span>] = &#123; <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0xE0</span> &#125;;</span><br><span class="line">    *(PINT_PTR)(bDataJmp + <span class="number">1</span>) = (INT_PTR)lpExeEntry;</span><br><span class="line">    <span class="built_in">memcpy_s</span>((LPBYTE)lpBaseAddress + nSizeOfImage, <span class="number">7</span>, bDataJmp, <span class="number">7</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// mov rax, 0x1234567812345678</span></span><br><span class="line">    <span class="comment">// jmp rax</span></span><br><span class="line">    BYTE bDataJmp[<span class="number">12</span>] = &#123; <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0xE0</span> &#125;;</span><br><span class="line">    *(PINT_PTR)(bDataJmp + <span class="number">2</span>) = (INT_PTR)lpExeEntry;</span><br><span class="line">    <span class="built_in">memcpy_s</span>((LPBYTE)lpBaseAddress + nSizeOfImage, <span class="number">12</span>, bDataJmp, <span class="number">12</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 可以根据每个节区的属性设置其对应内存页的内存保护属性，此处省略</span></span><br><span class="line">    <span class="comment">// 是exe还是dll，如果是exe则执行上面的“jmp 入口地址”指令，否则执行DllMain</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeaderMap-&gt;FileHeader.Characteristics &amp; IMAGE_FILE_DLL) &#123;</span><br><span class="line">        <span class="comment">// 执行DllMain入口点函数</span></span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(APIENTRY* pfnDllMain)</span><span class="params">(HMODULE hModule, DWORD ulreason, LPVOID lpReserved)</span></span>;</span><br><span class="line">        pfnDllMain fnDllMain = (pfnDllMain)(lpExeEntry);</span><br><span class="line">        <span class="built_in">fnDllMain</span>((HMODULE)lpBaseAddress, DLL_PROCESS_ATTACH, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 执行一个导出函数试试</span></span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(*pfnShowMessage)</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 如果调用GetProcAddress函数获取ShowMessage函数的地址会提示找不到指定的模块</span></span><br><span class="line">        <span class="comment">/*pfnShowMessage fnShowMessage = (pfnShowMessage) GetProcAddress((HMODULE)lpBaseAddress, &quot;ShowMessage&quot;);*/</span></span><br><span class="line">            <span class="comment">// GetFuncRvaByName是自定义函数，用于获取指定函数的RVA</span></span><br><span class="line">        pfnShowMessage fnShowMessage = (pfnShowMessage)((LPBYTE)lpBaseAddress + <span class="built_in">GetFuncRvaByName</span>((PIMAGE_DOS_HEADER)lpBaseAddress, <span class="built_in">TEXT</span>(<span class="string">&quot;ShowMessage&quot;</span>)));</span><br><span class="line">        <span class="built_in">fnShowMessage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 跳转到exe入口点执行</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">VOID</span>(WINAPI* pfnExe)();</span><br><span class="line">        pfnExe fnExe = (pfnExe)((LPBYTE)lpBaseAddress + nSizeOfImage);</span><br><span class="line">        <span class="built_in">fnExe</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ***************************************************************************************</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="线程局部存储表"><a href="#线程局部存储表" class="headerlink" title="线程局部存储表"></a>线程局部存储表</h2><p>线程局部存储表是个TLS目录IMAGE_TLS_DIRECTORY64结构，TLS模板时存放所有TLS变量初始化值得数据块。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_TLS_DIRECTORY64</span> &#123;</span><br><span class="line">    ULONGLONG StartAddressOfRawData; <span class="comment">//指向TLS模板起始地址 VA</span></span><br><span class="line">    ULONGLONG EndAddressOfRawData; <span class="comment">//指向TLS模板结束地址 VA</span></span><br><span class="line">    ULONGLONG AddressOfIndex; <span class="comment">//指向TLS索引DWORD数组 VA</span></span><br><span class="line">    ULONGLONG AddressOfCallBacks; <span class="comment">//指向TLS回调函数指针的数组 PIMAGE_TLS_CALLBACK类型 VA</span></span><br><span class="line">    DWORD SizeOfZeroFill; <span class="comment">//TLS模板之后填充0的个数</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD Characteristics; <span class="comment">//TLS标志</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD Reserved0 : <span class="number">20</span>;</span><br><span class="line">            DWORD Alignment : <span class="number">4</span>;</span><br><span class="line">            DWORD Reserved1 : <span class="number">8</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY64;</span><br></pre></td></tr></table></figure>

<p>AddressOfCallBacks最后以NULL指针结尾。TLS回调函数定义格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID NTAPI <span class="title">TlsCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID DllHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD Reason, <span class="comment">//回调函数被调用原因 同DllMain</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID Reserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例如添加TLS回调函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADCOUNT 5</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">__declspec(thread) LPVOID gt_lpData = (LPVOID)<span class="number">0x12345678</span>;<span class="comment">// 赋个初值是为了分析TLS表的时候方便查看</span></span><br><span class="line">HWND g_hwndDlg;</span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span>;</span><br><span class="line"><span class="comment">// TLS回调函数</span></span><br><span class="line"><span class="function">VOID NTAPI <span class="title">TlsCallback</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span>;</span><br><span class="line"><span class="comment">// 注册TLS回调函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line">    PIMAGE_TLS_CALLBACK pTlsCallback = TlsCallback;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    HANDLE hThread[THREADCOUNT] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            g_hwndDlg = hwndDlg;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_OK: &#123;</span><br><span class="line">                    <span class="comment">// 创建THREADCOUNT个线程</span></span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(g_hwndDlg, IDC_EDIT_TLSSLOTS, <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; THREADCOUNT; i++)</span><br><span class="line">                        <span class="keyword">if</span> ((hThread[i] = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, (LPVOID)i, <span class="number">0</span>, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">                            <span class="built_in">CloseHandle</span>(hThread[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line">    TCHAR szBuf[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    gt_lpData = <span class="keyword">new</span> BYTE[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(gt_lpData, <span class="number">256</span>);</span><br><span class="line">    <span class="comment">// 每个线程的静态TLS数据显示到编辑控件中</span></span><br><span class="line">    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;线程%d的gt_lpData值：0x%p\r\n&quot;</span>), (INT)lpParameter, gt_lpData);</span><br><span class="line">    <span class="built_in">SendMessage</span>(<span class="built_in">GetDlgItem</span>(g_hwndDlg, IDC_EDIT_TLSSLOTS), EM_SETSEL, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">SendMessage</span>(<span class="built_in">GetDlgItem</span>(g_hwndDlg, IDC_EDIT_TLSSLOTS), EM_REPLACESEL, TRUE, (LPARAM)szBuf);</span><br><span class="line">    <span class="keyword">delete</span>[]gt_lpData;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID NTAPI <span class="title">TlsCallback</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Reason) &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH: &#123;</span><br><span class="line">            <span class="comment">// 启动了一个新进程(包括第一个线程)</span></span><br><span class="line">            <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;我是TLS回调函数&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH: &#123;</span><br><span class="line">            <span class="comment">// 进程将要被终止(包括第一个线程)</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH: &#123;</span><br><span class="line">            <span class="comment">// 创建了一个新线程，创建所有线程时都会发送这个通知，除了第一个线程</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH: &#123;</span><br><span class="line">            <span class="comment">// 线程将要被终止，终止所有线程时都会发送这个通知，除了第一个线程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中节区名叫“.CRT$XLB”，CRT表示使用C运行时机制，X为随机标识，L表示TLS Callback Section，B可以是除A和Z外任意一个字母。当编译为Release时，需要项目属性-&gt;C&#x2F;C++-&gt;优化-&gt;全程序优化设为否，否则TLS回调函数不会被调用。</p>
<h2 id="加载配置信息表"><a href="#加载配置信息表" class="headerlink" title="加载配置信息表"></a>加载配置信息表</h2><p>加载配置信息表是一个加载配置目录IMAGE_LOAD_CONFIG_DIRECTORY64。该表用作异常处理，存放了SEH各种异常句柄。程序发生异常时，系统根据异常类别进行分发处理，并根据句柄实施程序流程转向。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_LOAD_CONFIG_DIRECTORY64</span> &#123;</span><br><span class="line">    DWORD      Size; <span class="comment">//该结构大小</span></span><br><span class="line">    DWORD      TimeDateStamp;</span><br><span class="line">    WORD       MajorVersion;</span><br><span class="line">    WORD       MinorVersion;</span><br><span class="line">    DWORD      GlobalFlagsClear;</span><br><span class="line">    DWORD      GlobalFlagsSet;</span><br><span class="line">    DWORD      CriticalSectionDefaultTimeout;</span><br><span class="line">    ULONGLONG  DeCommitFreeBlockThreshold;</span><br><span class="line">    ULONGLONG  DeCommitTotalFreeThreshold;</span><br><span class="line">    ULONGLONG  LockPrefixTable;</span><br><span class="line">    ULONGLONG  MaximumAllocationSize;</span><br><span class="line">    ULONGLONG  VirtualMemoryThreshold;</span><br><span class="line">    ULONGLONG  ProcessAffinityMask;</span><br><span class="line">    DWORD      ProcessHeapFlags;</span><br><span class="line">    WORD       CSDVersion;</span><br><span class="line">    WORD       DependentLoadFlags;</span><br><span class="line">    ULONGLONG  EditList;</span><br><span class="line">    ULONGLONG  SecurityCookie;</span><br><span class="line">    ULONGLONG  SEHandlerTable; <span class="comment">//指向SEH异常处理程序RVA数组 VA</span></span><br><span class="line">    ULONGLONG  SEHandlerCount; <span class="comment">//SEH异常处理程序个数</span></span><br><span class="line">    ULONGLONG  GuardCFCheckFunctionPointer;</span><br><span class="line">    ULONGLONG  GuardCFDispatchFunctionPointer;</span><br><span class="line">    ULONGLONG  GuardCFFunctionTable;</span><br><span class="line">    ULONGLONG  GuardCFFunctionCount;</span><br><span class="line">    DWORD      GuardFlags;</span><br><span class="line">    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;</span><br><span class="line">    ULONGLONG  GuardAddressTakenIatEntryTable;</span><br><span class="line">    ULONGLONG  GuardAddressTakenIatEntryCount;</span><br><span class="line">    ULONGLONG  GuardLongJumpTargetTable;</span><br><span class="line">    ULONGLONG  GuardLongJumpTargetCount;</span><br><span class="line">    ULONGLONG  DynamicValueRelocTable;</span><br><span class="line">    ULONGLONG  CHPEMetadataPointer;</span><br><span class="line">    ULONGLONG  GuardRFFailureRoutine;</span><br><span class="line">    ULONGLONG  GuardRFFailureRoutineFunctionPointer;</span><br><span class="line">    DWORD      DynamicValueRelocTableOffset;</span><br><span class="line">    WORD       DynamicValueRelocTableSection;</span><br><span class="line">    WORD       Reserved2;</span><br><span class="line">    ULONGLONG  GuardRFVerifyStackPointerFunctionPointer;</span><br><span class="line">    DWORD      HotPatchTableOffset;</span><br><span class="line">    DWORD      Reserved3;</span><br><span class="line">    ULONGLONG  EnclaveConfigurationPointer;</span><br><span class="line">    ULONGLONG  VolatileMetadataPointer;</span><br><span class="line">    ULONGLONG  GuardEHContinuationTable;</span><br><span class="line">    ULONGLONG  GuardEHContinuationCount;</span><br><span class="line">    ULONGLONG  GuardXFGCheckFunctionPointer;</span><br><span class="line">    ULONGLONG  GuardXFGDispatchFunctionPointer;</span><br><span class="line">    ULONGLONG  GuardXFGTableDispatchFunctionPointer;</span><br><span class="line">    ULONGLONG  CastGuardOsDeterminedFailureMode;</span><br><span class="line">    ULONGLONG  GuardMemcpyFunctionPointer;</span><br><span class="line">&#125; IMAGE_LOAD_CONFIG_DIRECTORY64, * PIMAGE_LOAD_CONFIG_DIRECTORY64;</span><br></pre></td></tr></table></figure>

<h2 id="资源表"><a href="#资源表" class="headerlink" title="资源表"></a>资源表</h2><p>资源组织方式类似文件系统的目录组织方式。共有3层目录结构，每层下有若干个目录，每个目录下有若干个目录入口，每个入口结构指向下一层的目录。第1层下只有一个目录，该目录按照资源类型划分，如光标、图标和菜单等入口结构。第2层按照资源ID划分，每个目录下有多个该资源类型的不同ID的资源。第3层按照代码页划分，如简体中文、繁体中文和英语等，该层目录下的个目录入口指向相对应资源数据入口。各资源数据入口指向资源数据。</p>
<p>每个资源目录为IMAGE_RESOURCE_DIRECTORY结构，每个目录入口为IMAGE_RESOURCE_DIRECTORY_ENTRY结构，每个资源数据入口为IMAGE_RESOURCE_DATA_ENTRY结构。</p>
<p>资源目录IMAGE_RESOURCE_DIRECTORY结构如下。用于第1层时，标准资源类型被解释为255一下的一个ID数字，自定义资源结构可以是个字符串或255~65535中ID数字，即NumberOfNamedEntries+NumberOfIdEntries为DirectoryEntries数组元素个数。用于第2层时同理，资源ID可以是一个字符串或1~65525之间的ID数字。用于第3层时，每种标准语言都有预定义ID，如简体中文为0x0804、英语为0x0409等。</p>
<p>对于OffsetToData字段，当在第1或2层时，该字段最高位为1，剩余低位值为一个指向资源目录表的相对资源表的偏移量；当在第3层时，该字段最高位为0，指向资源数据入口结构的相对资源表的偏移量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_RESOURCE_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   Characteristics; <span class="comment">//资源标志 0</span></span><br><span class="line">    DWORD   TimeDateStamp; <span class="comment">//资源编译器创建资源的时间戳 0</span></span><br><span class="line">    WORD    MajorVersion; <span class="comment">//主版本号 0</span></span><br><span class="line">    WORD    MinorVersion; <span class="comment">//次版本号 0</span></span><br><span class="line">    WORD    NumberOfNamedEntries; <span class="comment">//名称命名的资源目录入口结构个数</span></span><br><span class="line">    WORD    NumberOfIdEntries; <span class="comment">//ID命名的资源目录入口结构个数</span></span><br><span class="line">    <span class="comment">//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[]; //紧跟资源目录入口结构数组</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY, * PIMAGE_RESOURCE_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>资源目录入口IMAGE_RESOURCE_DIRECTORY_ENTRY结构如下。用于第1层时，若为标准资源类型，Name最高位为0，剩余低位表示255以下ID数字；若为自定义资源类型，Name最高位为1，剩余低位为指向相对资源表的IMAGE_RESOURCE_DIR_STRING_U结构偏移量，也可以为255~65535中一个ID数字。用于第二层时，Name表示资源ID，或指向相对资源表的IMAGE_RESOURCE_DIRECTORY_ENTRY结构偏移量。用于第3层时表示代码页ID。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD NameOffset : <span class="number">31</span>;</span><br><span class="line">            DWORD NameIsString : <span class="number">1</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">        DWORD   Name; <span class="comment">//资源类型或资源ID或代码页ID</span></span><br><span class="line">        WORD    Id;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   OffsetToData; <span class="comment">//资源数据入口结构或指向下一个资源目录表</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD   OffsetToDirectory : <span class="number">31</span>;</span><br><span class="line">            DWORD   DataIsDirectory : <span class="number">1</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME2;</span><br><span class="line">    &#125; DUMMYUNIONNAME2;</span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY, * PIMAGE_RESOURCE_DIRECTORY_ENTRY;</span><br></pre></td></tr></table></figure>

<p>当为自定义资源类型时，NameString表示资源类型Unicode字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_RESOURCE_DIR_STRING_U</span> &#123;</span><br><span class="line">    WORD    Length; <span class="comment">//Unicode字符串长度</span></span><br><span class="line">    WCHAR   NameString[<span class="number">1</span>]; <span class="comment">//Unicode字符串 不以0结尾</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIR_STRING_U, * PIMAGE_RESOURCE_DIR_STRING_U;</span><br></pre></td></tr></table></figure>

<p>资源数据入口IMAGE_RESOURCE_DATA_ENTRY结构如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_RESOURCE_DATA_ENTRY</span> &#123;</span><br><span class="line">    DWORD   OffsetToData; <span class="comment">//资源数据块RVA</span></span><br><span class="line">    DWORD   Size; <span class="comment">//资源数据块大小 单位字节</span></span><br><span class="line">    DWORD   CodePage; <span class="comment">//用于解码资源数据中码位值的Unicode代码页 0</span></span><br><span class="line">    DWORD   Reserved; <span class="comment">//保留</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DATA_ENTRY, * PIMAGE_RESOURCE_DATA_ENTRY;</span><br></pre></td></tr></table></figure>

<p>预定义资源类型有：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>RT_CURSOR</td>
<td>光标</td>
</tr>
<tr>
<td>RT_BITMAP</td>
<td>位图</td>
</tr>
<tr>
<td>RT_ICON</td>
<td>图标</td>
</tr>
<tr>
<td>RT_MENU</td>
<td>菜单</td>
</tr>
<tr>
<td>RT_DIALOG</td>
<td>对话框</td>
</tr>
<tr>
<td>RT_STRING</td>
<td>字符串表</td>
</tr>
<tr>
<td>RT_FONTDIR</td>
<td>字体目录</td>
</tr>
<tr>
<td>RT_FONT</td>
<td>字体</td>
</tr>
<tr>
<td>RT_ACCELERATOR</td>
<td>加速键</td>
</tr>
<tr>
<td>RT_RCDATA</td>
<td>应用程序定义的资源</td>
</tr>
<tr>
<td>RT_MESSAGETABLE</td>
<td>消息表</td>
</tr>
<tr>
<td>RT_GROUP_CURSOR</td>
<td>光标组</td>
</tr>
<tr>
<td>RT_GROUP_ICON</td>
<td>图标组</td>
</tr>
<tr>
<td>RT_VERSION</td>
<td>程序版本</td>
</tr>
<tr>
<td>RT_DLGINCLUDE</td>
<td>提供符号名称的头文件</td>
</tr>
<tr>
<td>RT_PLUGPLAY</td>
<td>即插即用资源</td>
</tr>
<tr>
<td>RT_VXD</td>
<td>VXD</td>
</tr>
<tr>
<td>RT_ANICURSOR</td>
<td>动态光标</td>
</tr>
<tr>
<td>RT_ANIICON</td>
<td>动态图标</td>
</tr>
<tr>
<td>RT_HTML</td>
<td>HTML</td>
</tr>
<tr>
<td>RT_MANIFEST</td>
<td>清单文件</td>
</tr>
</tbody></table>
<p>常见语言代码页ID有：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x0000</td>
<td>中性语言</td>
</tr>
<tr>
<td>0x0400</td>
<td>程序默认语言</td>
</tr>
<tr>
<td>0x0404</td>
<td>中文 中国台湾</td>
</tr>
<tr>
<td>0x0804</td>
<td>中文 中国</td>
</tr>
<tr>
<td>0x0C04</td>
<td>中文 中国香港</td>
</tr>
<tr>
<td>0x1004</td>
<td>中文 新加坡</td>
</tr>
<tr>
<td>0x0409</td>
<td>英语 美国</td>
</tr>
<tr>
<td>0x0809</td>
<td>英语 英国</td>
</tr>
<tr>
<td>0x0411</td>
<td>日语</td>
</tr>
<tr>
<td>0x412</td>
<td>韩语</td>
</tr>
<tr>
<td>0x0412</td>
<td>俄语</td>
</tr>
</tbody></table>
<p>获取方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CommCtrl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwndDlg;                 <span class="comment">// 窗口句柄</span></span><br><span class="line">HWND g_hwndTree;                <span class="comment">// 树视图控件窗口句柄</span></span><br><span class="line">HWND g_hwndEdit;                <span class="comment">// 多行编辑控件窗口句柄</span></span><br><span class="line">LPCTSTR arrResType[] = &#123; <span class="built_in">TEXT</span>(<span class="string">&quot;未知类型&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;光标&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;位图&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;图标&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;菜单&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;对话框&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;字符串表&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;字体目录&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;字体&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;加速键&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;程序自定义资源&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;消息表&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;光标组&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;未知类型&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;图标组&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;未知类型&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;程序版本&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提供符号名称的头文件&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;未知类型&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;即插即用资源&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;VXD&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;动态光标&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;动态图标&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;HTML&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;清单文件&quot;</span>) &#125;;</span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 通过指定类型数据的RVA得到FOA</span></span><br><span class="line"><span class="function">INT <span class="title">RVAToFOA</span><span class="params">(PIMAGE_NT_HEADERS pImageNtHeader, DWORD dwTargetRVA)</span></span>;</span><br><span class="line"><span class="comment">// 获取资源信息</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetResourceInfo</span><span class="params">(PIMAGE_RESOURCE_DIRECTORY pImageRes, PIMAGE_RESOURCE_DIRECTORY pImageResDir,HTREEITEM hTreeParent, DWORD dwLevel)</span></span>;</span><br><span class="line"><span class="comment">// 获取选定资源的信息</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetSelectedResData</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader, LPBYTE lpResData, DWORD dwResSize)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件所用变量</span></span><br><span class="line">    TCHAR szFile[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OPENFILENAME ofn = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ofn.lStructSize = <span class="built_in">sizeof</span>(ofn);</span><br><span class="line">    ofn.hwndOwner = hwndDlg;</span><br><span class="line">    ofn.lpstrFilter = <span class="built_in">TEXT</span>(<span class="string">&quot;exe文件(*.exe)\0*.exe\0dll文件(*.dll)\0*.dll\0All(*.*)\0*.*\0&quot;</span>);</span><br><span class="line">    ofn.nFilterIndex = <span class="number">3</span>;</span><br><span class="line">    ofn.lpstrFile = szFile;</span><br><span class="line">    ofn.lpstrFile[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    ofn.nMaxFile = _countof(szFile);</span><br><span class="line">    ofn.lpstrTitle = <span class="built_in">TEXT</span>(<span class="string">&quot;请选择要打开的PE文件&quot;</span>);</span><br><span class="line">    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;</span><br><span class="line">    <span class="comment">// 内存映射文件所用变量</span></span><br><span class="line">    <span class="type">static</span> HANDLE hFile, hFileMap;</span><br><span class="line">    <span class="type">static</span> LPVOID lpMemory;</span><br><span class="line">    LARGE_INTEGER liFileSize;</span><br><span class="line">    <span class="comment">// DOS头指针和PE文件头指针</span></span><br><span class="line">    <span class="type">static</span> PIMAGE_DOS_HEADER pImageDosHeader;</span><br><span class="line">    <span class="type">static</span> PIMAGE_NT_HEADERS pImageNtHeader;</span><br><span class="line">    <span class="comment">// 第1层目录中的资源目录结构起始地址，也就是资源表的起始地址</span></span><br><span class="line">    PIMAGE_RESOURCE_DIRECTORY pImageRes;</span><br><span class="line">    <span class="comment">// 多行编辑控件字体</span></span><br><span class="line">    HFONT hFont;</span><br><span class="line">    <span class="comment">// 调整树视图控件和多行编辑控件窗口大小之用</span></span><br><span class="line">    <span class="type">static</span> RECT rectWindow;</span><br><span class="line">    RECT rectTree, rectEdit;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> nWidthTree, nHeightTree, nWidthEdit, nHeightEdit;</span><br><span class="line">    <span class="type">int</span> cx, cy;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            g_hwndDlg = hwndDlg;</span><br><span class="line">            g_hwndTree = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_TREE_RESOURCE);</span><br><span class="line">            g_hwndEdit = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_RESOURCE);</span><br><span class="line">            <span class="comment">// 设置多行编辑控件为宋体</span></span><br><span class="line">            hFont = <span class="built_in">CreateFont</span>(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, GB2312_CHARSET, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;宋体&quot;</span>));</span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, WM_SETFONT, (WPARAM)hFont, FALSE);</span><br><span class="line">            <span class="built_in">DeleteObject</span>(hFont);</span><br><span class="line">            <span class="comment">// 默认情况下编辑控件最大缓冲区大小约为32KB个字符，设为不限大小</span></span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndEdit, EM_SETLIMITTEXT, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 保存程序窗口大小</span></span><br><span class="line">            <span class="built_in">GetClientRect</span>(hwndDlg, &amp;rectWindow);</span><br><span class="line">            <span class="comment">// 保存树视图控件和多行编辑控件的宽度高度</span></span><br><span class="line">            <span class="built_in">GetWindowRect</span>(g_hwndTree, &amp;rectTree);</span><br><span class="line">            nWidthTree = rectTree.right - rectTree.left;</span><br><span class="line">            nHeightTree = rectTree.bottom - rectTree.top;</span><br><span class="line">            <span class="built_in">GetWindowRect</span>(g_hwndEdit, &amp;rectEdit);</span><br><span class="line">            nWidthEdit = rectEdit.right - rectEdit.left;</span><br><span class="line">            nHeightEdit = rectEdit.bottom - rectEdit.top;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_SIZE: &#123;</span><br><span class="line">            cx = <span class="built_in">LOWORD</span>(lParam) - rectWindow.right;</span><br><span class="line">            cy = <span class="built_in">HIWORD</span>(lParam) - rectWindow.bottom;</span><br><span class="line">            <span class="built_in">SetWindowPos</span>(g_hwndTree, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, nWidthTree, nHeightEdit + cy, SWP_NOZORDER | SWP_NOMOVE);</span><br><span class="line">            <span class="built_in">SetWindowPos</span>(g_hwndEdit, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, nWidthEdit + cx, nHeightEdit + cy, SWP_NOZORDER | SWP_NOMOVE);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_BROWSE: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetOpenFileName</span>(&amp;ofn))</span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_FILENAME, szFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_GET: &#123;</span><br><span class="line">                    <span class="comment">// 打开一个PE文件</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_FILENAME, szFile, _countof(szFile));</span><br><span class="line">                    hFile = <span class="built_in">CreateFile</span>(szFile, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFile函数调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">GetFileSizeEx</span>(hFile, &amp;liFileSize);</span><br><span class="line">                        <span class="keyword">if</span> (liFileSize.QuadPart == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;文件大小为0&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                            <span class="keyword">return</span> TRUE;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 为hFile文件对象创建一个文件映射内核对象</span></span><br><span class="line">                    hFileMap = <span class="built_in">CreateFileMapping</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!hFileMap) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFileMapping调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 把文件映射对象hFileMap的全部映射到进程的虚拟地址空间中</span></span><br><span class="line">                    lpMemory = <span class="built_in">MapViewOfFile</span>(hFileMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!lpMemory) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;MapViewOfFile调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 打开的文件是不是PE文件</span></span><br><span class="line">                    pImageDosHeader = (PIMAGE_DOS_HEADER)lpMemory;</span><br><span class="line">                    <span class="keyword">if</span> (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;打开的不是PE文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    pImageNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeader + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">                    <span class="keyword">if</span> (pImageNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;打开的不是PE文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 第1层目录中的资源目录结构起始地址，区分PE和PE32+</span></span><br><span class="line">                    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)</span><br><span class="line">                        pImageRes = (PIMAGE_RESOURCE_DIRECTORY)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS32)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">2</span>].VirtualAddress));</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pImageRes = (PIMAGE_RESOURCE_DIRECTORY)((LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, ((PIMAGE_NT_HEADERS64)pImageNtHeader)-&gt;OptionalHeader.DataDirectory[<span class="number">2</span>].VirtualAddress));</span><br><span class="line">                    <span class="comment">// 清空编辑控件</span></span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_RESOURCE, <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">                    <span class="comment">// 获取资源信息</span></span><br><span class="line">                    <span class="built_in">GetResourceInfo</span>(pImageRes, pImageRes, TVI_ROOT, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="comment">// 清理工作</span></span><br><span class="line">                    <span class="built_in">UnmapViewOfFile</span>(lpMemory);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFileMap);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_NOTIFY: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (((LPNMHDR)lParam)-&gt;code) &#123;</span><br><span class="line">                <span class="keyword">case</span> TVN_SELCHANGED: &#123;</span><br><span class="line">                    LPNMTREEVIEW lpnmTreeView;</span><br><span class="line">                    LPBYTE lpResData;       <span class="comment">// 所选择资源项的资源数据起始地址</span></span><br><span class="line">                    DWORD dwResSize;        <span class="comment">// 所选择资源项的资源数据大小</span></span><br><span class="line">                    lpnmTreeView = (LPNMTREEVIEW)lParam;</span><br><span class="line">                    <span class="keyword">if</span> (lpnmTreeView-&gt;itemNew.lParam != <span class="number">0</span>) &#123;</span><br><span class="line">                        lpResData = (LPBYTE)pImageDosHeader + <span class="built_in">RVAToFOA</span>(pImageNtHeader, ((PIMAGE_RESOURCE_DATA_ENTRY)(lpnmTreeView-&gt;itemNew.lParam))-&gt;OffsetToData);</span><br><span class="line">                        dwResSize = ((PIMAGE_RESOURCE_DATA_ENTRY)(lpnmTreeView-&gt;itemNew.lParam))-&gt;Size;</span><br><span class="line">                        <span class="built_in">GetSelectedResData</span>(pImageDosHeader, lpResData, dwResSize);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT <span class="title">RVAToFOA</span><span class="params">(PIMAGE_NT_HEADERS pImageNtHeader, DWORD dwTargetRVA)</span> </span>&#123;</span><br><span class="line">    PIMAGE_SECTION_HEADER pImageSectionHeader;</span><br><span class="line">    INT iTargetFOA = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// PE和PE32+的节表定位不同</span></span><br><span class="line">    <span class="keyword">if</span> (pImageNtHeader-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)</span><br><span class="line">        pImageSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pImageNtHeader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS32));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pImageSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pImageNtHeader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64));</span><br><span class="line">    <span class="comment">// 遍历节表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pImageNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((dwTargetRVA &gt;= pImageSectionHeader-&gt;VirtualAddress) &amp;&amp; (dwTargetRVA &lt;= (pImageSectionHeader-&gt;VirtualAddress + pImageSectionHeader-&gt;SizeOfRawData))) &#123;</span><br><span class="line">            iTargetFOA = dwTargetRVA - pImageSectionHeader-&gt;VirtualAddress;</span><br><span class="line">            iTargetFOA += pImageSectionHeader-&gt;PointerToRawData;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 指向下一个节区信息结构</span></span><br><span class="line">        pImageSectionHeader++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> iTargetFOA;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*********************************************************************************</span></span><br><span class="line"><span class="comment">  * 函数功能：        获取资源信息</span></span><br><span class="line"><span class="comment">  * 输入参数的说明：</span></span><br><span class="line"><span class="comment">    1. pImageRes参数表示第1层目录中的资源目录结构起始地址，也就是资源表的起始地址，必须指定</span></span><br><span class="line"><span class="comment">    2. pImageResDir参数表示第1～3层目录中的资源目录结构起始地址，必须指定</span></span><br><span class="line"><span class="comment">    3. hTreeParent参数表示树视图控件中父节点的句柄，必须指定</span></span><br><span class="line"><span class="comment">    4. dwLevel参数指定为数值1～3，表示当前调用本函数是为了获取第几层目录的信息，必须指定</span></span><br><span class="line"><span class="comment">  * 该函数为递归函数</span></span><br><span class="line"><span class="comment">**********************************************************************************/</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetResourceInfo</span><span class="params">(PIMAGE_RESOURCE_DIRECTORY pImageRes, PIMAGE_RESOURCE_DIRECTORY pImageResDir, HTREEITEM hTreeParent, DWORD dwLevel)</span> </span>&#123;</span><br><span class="line">    PIMAGE_RESOURCE_DIRECTORY pImageResDirSub;          <span class="comment">// 下一层资源目录结构起始地址</span></span><br><span class="line">    PIMAGE_RESOURCE_DIRECTORY_ENTRY pImageResDirEntry;  <span class="comment">// 资源目录入口结构数组起始地址</span></span><br><span class="line">    WORD wNums;                                         <span class="comment">// 资源目录入口结构数组个数</span></span><br><span class="line">    PIMAGE_RESOURCE_DATA_ENTRY pImageResDataEntry;      <span class="comment">// 资源数据入口结构起始地址</span></span><br><span class="line">    PIMAGE_RESOURCE_DIR_STRING_U pString;</span><br><span class="line">    HTREEITEM hTree;</span><br><span class="line">    TVINSERTSTRUCT tvi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR szResType[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;, szResID[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;, szLanguageID[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR szBuf[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 资源目录入口结构数组起始地址</span></span><br><span class="line">    pImageResDirEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((LPBYTE)pImageResDir + <span class="built_in">sizeof</span>(IMAGE_RESOURCE_DIRECTORY));</span><br><span class="line">    <span class="comment">// 资源目录入口结构数组个数</span></span><br><span class="line">    wNums = pImageResDir-&gt;NumberOfNamedEntries + pImageResDir-&gt;NumberOfIdEntries;</span><br><span class="line">    tvi.item.mask = TVIF_TEXT;</span><br><span class="line">    tvi.hInsertAfter = TVI_LAST;</span><br><span class="line">    tvi.hParent = hTreeParent;</span><br><span class="line">    <span class="keyword">if</span> (dwLevel == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历资源目录入口结构数组</span></span><br><span class="line">        <span class="keyword">for</span> (WORD i = <span class="number">0</span>; i &lt; wNums; i++) &#123;</span><br><span class="line">            <span class="comment">// 资源类型</span></span><br><span class="line">            <span class="keyword">if</span> (pImageResDirEntry[i].Name &amp; <span class="number">0x80000000</span>) &#123;</span><br><span class="line">                pString = (PIMAGE_RESOURCE_DIR_STRING_U)((LPBYTE)pImageRes + (pImageResDirEntry[i].Name &amp; <span class="number">0x7FFFFFFF</span>));</span><br><span class="line">                <span class="built_in">StringCchCopy</span>(szResType, pString-&gt;Length + <span class="number">1</span>, pString-&gt;NameString);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOWORD</span>(pImageResDirEntry[i].Name) &lt;= <span class="number">24</span>)</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szResType, <span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), arrResType[<span class="built_in">LOWORD</span>(pImageResDirEntry[i].Name)]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">wsprintf</span>(szResType, <span class="built_in">TEXT</span>(<span class="string">&quot;%d(自定义ID)&quot;</span>), <span class="built_in">LOWORD</span>(pImageResDirEntry[i].Name));</span><br><span class="line">            &#125;;</span><br><span class="line">            tvi.item.pszText = szResType;</span><br><span class="line">            hTree = (HTREEITEM)<span class="built_in">SendMessage</span>(g_hwndTree, TVM_INSERTITEM, <span class="number">0</span>, (LPARAM)&amp;tvi);</span><br><span class="line">            <span class="comment">// 递归进入第2层</span></span><br><span class="line">            pImageResDirSub = (PIMAGE_RESOURCE_DIRECTORY)((LPBYTE)pImageRes + (pImageResDirEntry[i].OffsetToData &amp; <span class="number">0x7FFFFFFF</span>));</span><br><span class="line">            <span class="built_in">GetResourceInfo</span>(pImageRes, pImageResDirSub, hTree, <span class="number">2</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwLevel == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历资源目录入口结构数组</span></span><br><span class="line">        <span class="keyword">for</span> (WORD i = <span class="number">0</span>; i &lt; wNums; i++) &#123;</span><br><span class="line">            <span class="comment">// 资源ID</span></span><br><span class="line">            <span class="keyword">if</span> (pImageResDirEntry[i].Name &amp; <span class="number">0x80000000</span>) &#123;</span><br><span class="line">                pString = (PIMAGE_RESOURCE_DIR_STRING_U)((LPBYTE)pImageRes + (pImageResDirEntry[i].Name &amp; <span class="number">0x7FFFFFFF</span>));</span><br><span class="line">                <span class="built_in">StringCchCopy</span>(szResID, pString-&gt;Length + <span class="number">1</span>, pString-&gt;NameString);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">wsprintf</span>(szResID, <span class="built_in">TEXT</span>(<span class="string">&quot;%d&quot;</span>), <span class="built_in">LOWORD</span>(pImageResDirEntry[i].Name));</span><br><span class="line">            tvi.item.pszText = szResID;</span><br><span class="line">            hTree = (HTREEITEM)<span class="built_in">SendMessage</span>(g_hwndTree, TVM_INSERTITEM, <span class="number">0</span>, (LPARAM)&amp;tvi);</span><br><span class="line">            <span class="comment">// 递归进入第3层</span></span><br><span class="line">            pImageResDirSub = (PIMAGE_RESOURCE_DIRECTORY)((LPBYTE)pImageRes + (pImageResDirEntry[i].OffsetToData &amp; <span class="number">0x7FFFFFFF</span>));</span><br><span class="line">            <span class="built_in">GetResourceInfo</span>(pImageRes, pImageResDirSub, hTree, <span class="number">3</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历资源目录入口结构数组</span></span><br><span class="line">        <span class="keyword">for</span> (WORD i = <span class="number">0</span>; i &lt; wNums; i++) &#123;</span><br><span class="line">            <span class="comment">// 语言ID</span></span><br><span class="line">            <span class="keyword">if</span> (pImageResDirEntry[i].Name &amp; <span class="number">0x80000000</span>) &#123;</span><br><span class="line">                pString = (PIMAGE_RESOURCE_DIR_STRING_U)((LPBYTE)pImageRes + (pImageResDirEntry[i].Name &amp; <span class="number">0x7FFFFFFF</span>));</span><br><span class="line">                <span class="built_in">StringCchCopy</span>(szLanguageID, pString-&gt;Length + <span class="number">1</span>, pString-&gt;NameString);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">wsprintf</span>(szLanguageID, <span class="built_in">TEXT</span>(<span class="string">&quot;0x%04X&quot;</span>), <span class="built_in">LOWORD</span>(pImageResDirEntry[i].Name));</span><br><span class="line">            <span class="comment">// 资源数据入口结构起始地址</span></span><br><span class="line">            pImageResDataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)((LPBYTE)pImageRes + (pImageResDirEntry[i].OffsetToData));</span><br><span class="line">            <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%s  RVA：0x%08X 大小：0x%X&quot;</span>), szLanguageID, pImageResDataEntry-&gt;OffsetToData, pImageResDataEntry-&gt;Size);</span><br><span class="line">            tvi.item.mask = TVIF_TEXT | TVIF_PARAM;</span><br><span class="line">            tvi.item.pszText = szBuf;</span><br><span class="line">            tvi.item.lParam = (LPARAM)pImageResDataEntry;<span class="comment">// 保存资源数据入口结构起始地址到项目数据</span></span><br><span class="line">            <span class="built_in">SendMessage</span>(g_hwndTree, TVM_INSERTITEM, <span class="number">0</span>, (LPARAM)&amp;tvi);</span><br><span class="line">            <span class="comment">// 递归出口</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">GetSelectedResData</span><span class="params">(PIMAGE_DOS_HEADER pImageDosHeader, LPBYTE lpResData, DWORD dwResSize)</span> </span>&#123;</span><br><span class="line">    DWORD dwFileOffset;             <span class="comment">// 文件偏移</span></span><br><span class="line">    dwFileOffset = lpResData - (LPBYTE)pImageDosHeader;</span><br><span class="line">    <span class="comment">// 没实现自己去搞</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="延迟加载导入表"><a href="#延迟加载导入表" class="headerlink" title="延迟加载导入表"></a>延迟加载导入表</h2><p>延迟加载指的是通过隐式链接的DLL。可执行模块开始运行时并不加载延时加载的DLL，也不会检查该DLL是否存在，只有当代码中调用延迟加载DLL中函数时，系统才实际载入该DLL。设置延迟加载DLL后，编译器在PE文件中创建一个延迟加载导入表，记录可执行模块要导入的DLL以及相关函数信息。</p>
<p>延迟加载导入表是一个延迟加载描述IMAGE_DELAYLOAD_DESCRIPTOR结构数组，结构个数取决要延迟加载的DLL数，每个结构对应一个DLL，以全0该结构结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DELAYLOAD_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD AllAttributes; <span class="comment">//最高位为1表示延迟加载版本2</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD RvaBased : <span class="number">1</span>;</span><br><span class="line">            DWORD ReservedAttributes : <span class="number">31</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; Attributes;</span><br><span class="line">    DWORD DllNameRVA; <span class="comment">//延迟加载DLL名称字符串 UTF-8</span></span><br><span class="line">    DWORD ModuleHandleRVA; <span class="comment">//延迟加载DLL模块句柄RVA</span></span><br><span class="line">    DWORD ImportAddressTableRVA; <span class="comment">//延迟加载DLL的IAT起始地址 RVA IMAGE_THUNK_DATA</span></span><br><span class="line">    DWORD ImportNameTableRVA; <span class="comment">//延迟加载DLL的INT起始地址 RVA IMAGE_THUNK_DATA</span></span><br><span class="line">    DWORD BoundImportAddressTableRVA; <span class="comment">//可选延迟加载DLL的绑定IAT起始地址 RVA</span></span><br><span class="line">    DWORD UnloadInformationTableRVA; <span class="comment">//可选延迟加载DLL的卸载IAT起始地址 RVA</span></span><br><span class="line">    DWORD TimeDateStamp; <span class="comment">//未绑定为0 绑定为绑定的时间戳</span></span><br><span class="line">&#125; IMAGE_DELAYLOAD_DESCRIPTOR, * PIMAGE_DELAYLOAD_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>每个IMAGE_THUNK_DATA表示一个导入函数信息，最后以一个全0该结构结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_THUNK_DATA64</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ULONGLONG ForwarderString;</span><br><span class="line">        ULONGLONG Function;</span><br><span class="line">        ULONGLONG Ordinal;</span><br><span class="line">        ULONGLONG AddressOfData;</span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA64;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA64* PIMAGE_THUNK_DATA64;</span><br></pre></td></tr></table></figure>

<h2 id="校验和与CRC"><a href="#校验和与CRC" class="headerlink" title="校验和与CRC"></a>校验和与CRC</h2><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>计算校验和的过程为：将IMAGE_NT_HEADERS.OptionalHeader.CheckSum字段清零，以WORD为单位对数据块进行带进位的累加，大于WORD部分自动溢出，将累加和与文件长度相加得PE文件校验和。ImageHlp.dll用于操作PE文件，</p>
<h4 id="MapFileAndCheckSum"><a href="#MapFileAndCheckSum" class="headerlink" title="MapFileAndCheckSum"></a>MapFileAndCheckSum</h4><p>计算指定文件校验和：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">MapFileAndCheckSum</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PCTSTR FileName, <span class="comment">//要计算校验和的文件名</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PDWORD HeaderSum, <span class="comment">//接收原始校验和变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PDWORD CheckSum <span class="comment">//接收计算的校验和变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回CHECKSUM_SUCCESS</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;imagehlp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Imagehlp.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件所用变量</span></span><br><span class="line">    TCHAR szFile[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OPENFILENAME ofn = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ofn.lStructSize = <span class="built_in">sizeof</span>(ofn);</span><br><span class="line">    ofn.hwndOwner = hwndDlg;</span><br><span class="line">    ofn.lpstrFilter = <span class="built_in">TEXT</span>(<span class="string">&quot;exe文件(*.exe)\0*.exe\0dll文件(*.dll)\0*.dll\0All(*.*)\0*.*\0&quot;</span>);</span><br><span class="line">    ofn.nFilterIndex = <span class="number">3</span>;</span><br><span class="line">    ofn.lpstrFile = szFile;</span><br><span class="line">    ofn.lpstrFile[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    ofn.nMaxFile = _countof(szFile);</span><br><span class="line">    ofn.lpstrTitle = <span class="built_in">TEXT</span>(<span class="string">&quot;请选择要打开的PE文件&quot;</span>);</span><br><span class="line">    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;</span><br><span class="line">    HANDLE hFile;</span><br><span class="line">    DWORD dwFileSize;</span><br><span class="line">    LPVOID lpMemory;</span><br><span class="line">    PIMAGE_DOS_HEADER pImageDosHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader;</span><br><span class="line">    DWORD dwCheckSum = <span class="number">0</span>;</span><br><span class="line">    DWORD dwCheckSumImageHlp = <span class="number">0</span>;</span><br><span class="line">    DWORD dwCheckSumImageHlpOrigin = <span class="number">0</span>;</span><br><span class="line">    TCHAR szBuf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_BROWSE: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetOpenFileName</span>(&amp;ofn))</span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_FILENAME, szFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_CALC: &#123;</span><br><span class="line">                    <span class="comment">// 打开一个PE文件，并获取文件大小</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_FILENAME, szFile, _countof(szFile));</span><br><span class="line">                    hFile = <span class="built_in">CreateFile</span>(szFile, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">                    dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// 分配内存，复制PE文件</span></span><br><span class="line">                    lpMemory = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwFileSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">                    <span class="built_in">ReadFile</span>(hFile, lpMemory, dwFileSize, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">                    <span class="comment">// 打开的文件是不是PE文件</span></span><br><span class="line">                    pImageDosHeader = (PIMAGE_DOS_HEADER)lpMemory;</span><br><span class="line">                    <span class="keyword">if</span> (pImageDosHeader-&gt;e_magic == IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">                        pImageNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)pImageDosHeader + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">                        <span class="keyword">if</span> (pImageNtHeader-&gt;Signature == IMAGE_NT_SIGNATURE)</span><br><span class="line">                            <span class="comment">// IMAGE_NT_HEADERS.OptionalHeader.CheckSum字段清0</span></span><br><span class="line">                            pImageNtHeader-&gt;OptionalHeader.CheckSum = <span class="number">0</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 计算校验和</span></span><br><span class="line">                    DWORD i;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dwFileSize - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">                        dwCheckSum += *((LPWORD)((LPBYTE)lpMemory + i));</span><br><span class="line">                        dwCheckSum = (dwCheckSum &gt;&gt; <span class="number">16</span>) + (dwCheckSum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">if</span> (i == dwFileSize - <span class="number">1</span>)</span><br><span class="line">                        dwCheckSum += *((LPBYTE)lpMemory + i);</span><br><span class="line">                    dwCheckSum += dwFileSize;</span><br><span class="line">                    <span class="built_in">VirtualFree</span>(lpMemory, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">                    <span class="comment">// 显示自定义算法计算的结果</span></span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;0x%08X&quot;</span>), (DWORD)dwCheckSum);</span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_CUSTOMFUNC, szBuf);</span><br><span class="line">                    <span class="built_in">MapFileAndCheckSum</span>(szFile, &amp;dwCheckSumImageHlpOrigin, &amp;dwCheckSumImageHlp);</span><br><span class="line">                    <span class="comment">// 显示MapFileAndCheckSum函数计算的结果</span></span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;0x%08X&quot;</span>), dwCheckSumImageHlp);</span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_MAPFILEANDCHECKSUM, szBuf);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="CheckSumMappedFile"><a href="#CheckSumMappedFile" class="headerlink" title="CheckSumMappedFile"></a>CheckSumMappedFile</h4><p>计算指定PE文件校验和：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PIMAGE_NT_HEADERS <span class="title">CheckSumMappedFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PVOID BaseAddress, <span class="comment">//PE内存映射文件基地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD FileLength, <span class="comment">//文件大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PDWORD HeaderSum, <span class="comment">//接收原始校验和变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PDWORD CheckSum <span class="comment">//接收计算的校验和变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回PE内存映射文件IMAGE_NT_HEADERS结构的指针 失败NULL</span></span><br></pre></td></tr></table></figure>

<p>调用者可自行通过返回的指针修改IMAGE_NT_HEADERS.OptionalHeader.CheckSum。</p>
<h3 id="循环冗余校验CRC"><a href="#循环冗余校验CRC" class="headerlink" title="循环冗余校验CRC"></a>循环冗余校验CRC</h3><p>常用版本有CRC-8、CRC-12、CRC-16、CRC-CCITT、CRC-32、CRC-32C等。WinRAR、NERO、ARJ、LHA等压缩文件采用CRC-32，磁盘驱动器读写采用CRC-16，通用图像存储格式如GIF、TIFF等也采用CRC。这里实现一个文件或一段数据的CRC-32，可以实现一个自定义函数，也可用NtDll.dll中<code>RtlComputeCrc32</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="comment">//#define Poly 0xEDB88320L                // CRC-32标准</span></span><br><span class="line"><span class="comment">// 生成CRC-32查询表</span></span><br><span class="line"><span class="function">VOID <span class="title">GenerateCRC32Table</span><span class="params">(PUINT pCRC32Table)</span></span>;</span><br><span class="line"><span class="comment">// 计算CRC-32</span></span><br><span class="line"><span class="function">UINT <span class="title">CRC32</span><span class="params">(LPBYTE lpData, UINT nSize)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件所用变量</span></span><br><span class="line">    TCHAR szFile[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OPENFILENAME ofn = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ofn.lStructSize = <span class="built_in">sizeof</span>(ofn);</span><br><span class="line">    ofn.hwndOwner = hwndDlg;</span><br><span class="line">    ofn.lpstrFilter = <span class="built_in">TEXT</span>(<span class="string">&quot;exe文件(*.exe)\0*.exe\0dll文件(*.dll)\0*.dll\0All(*.*)\0*.*\0&quot;</span>);</span><br><span class="line">    ofn.nFilterIndex = <span class="number">3</span>;</span><br><span class="line">    ofn.lpstrFile = szFile;</span><br><span class="line">    ofn.lpstrFile[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    ofn.nMaxFile = _countof(szFile);</span><br><span class="line">    ofn.lpstrTitle = <span class="built_in">TEXT</span>(<span class="string">&quot;请选择要打开的PE文件&quot;</span>);</span><br><span class="line">    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;</span><br><span class="line">    <span class="comment">// 内存映射文件所用变量</span></span><br><span class="line">    HANDLE hFile, hFileMap;</span><br><span class="line">    LPVOID lpMemory;</span><br><span class="line">    LARGE_INTEGER liFileSize;</span><br><span class="line">    UINT nCRC;</span><br><span class="line">    TCHAR szBuf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_BROWSE: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetOpenFileName</span>(&amp;ofn))</span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_FILENAME, szFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_CALC: &#123;</span><br><span class="line">                    <span class="comment">// 打开文件</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_FILENAME, szFile, _countof(szFile));</span><br><span class="line">                    hFile = <span class="built_in">CreateFile</span>(szFile, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFile函数调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">GetFileSizeEx</span>(hFile, &amp;liFileSize);</span><br><span class="line">                        <span class="keyword">if</span> (liFileSize.QuadPart == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;文件大小为0&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                            <span class="keyword">return</span> TRUE;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 为hFile文件对象创建一个文件映射内核对象</span></span><br><span class="line">                    hFileMap = <span class="built_in">CreateFileMapping</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!hFileMap) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;CreateFileMapping调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 把文件映射对象hFileMap的全部映射到进程的虚拟地址空间中</span></span><br><span class="line">                    lpMemory = <span class="built_in">MapViewOfFile</span>(hFileMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!lpMemory) &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;MapViewOfFile调用失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 自定义函数计算CRC-32</span></span><br><span class="line">                    nCRC = <span class="built_in">CRC32</span>((LPBYTE)lpMemory, liFileSize.LowPart);</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;0x%08X&quot;</span>), nCRC);</span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_RESULT, szBuf);</span><br><span class="line">                    <span class="comment">// RtlComputeCrc32计算CRC-32</span></span><br><span class="line">                    <span class="function"><span class="keyword">typedef</span> <span class="title">UINT</span><span class="params">(WINAPI* pfnRtlComputeCrc32)</span><span class="params">(INT dwInitial, LPVOID lpData, INT nLen)</span></span>;</span><br><span class="line">                    pfnRtlComputeCrc32 fnRtlComputeCrc32;</span><br><span class="line">                    fnRtlComputeCrc32 = (pfnRtlComputeCrc32)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;NtDll.dll&quot;</span>)), <span class="string">&quot;RtlComputeCrc32&quot;</span>);</span><br><span class="line">                    nCRC = <span class="built_in">fnRtlComputeCrc32</span>(<span class="number">0</span>, lpMemory, liFileSize.LowPart);  <span class="comment">// 第一个参数指定为0</span></span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;0x%08X&quot;</span>), nCRC);</span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_RESULT2, szBuf);</span><br><span class="line">                    <span class="comment">// 清理工作</span></span><br><span class="line">                    <span class="built_in">UnmapViewOfFile</span>(lpMemory);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFileMap);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Poly 0xEDB88320                 <span class="comment">// CRC-32标准</span></span></span><br><span class="line"><span class="function">VOID <span class="title">GenerateCRC32Table</span><span class="params">(PUINT pCRC32Table)</span> </span>&#123;</span><br><span class="line">    UINT nCrc;</span><br><span class="line">    <span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        nCrc = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (nCrc &amp; <span class="number">0x00000001</span>)</span><br><span class="line">                nCrc = (nCrc &gt;&gt; <span class="number">1</span>) ^ Poly;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nCrc = nCrc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        pCRC32Table[i] = nCrc;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">UINT <span class="title">CRC32</span><span class="params">(LPBYTE lpData, UINT nSize)</span> </span>&#123;</span><br><span class="line">    UINT CRC32Table[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;       <span class="comment">// CRC-32查询表</span></span><br><span class="line">    UINT nCrc = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    <span class="comment">// 生成CRC-32查询表</span></span><br><span class="line">    <span class="built_in">GenerateCRC32Table</span>(CRC32Table);</span><br><span class="line">    <span class="comment">// 计算CRC-32</span></span><br><span class="line">    <span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; nSize; i++)</span><br><span class="line">        nCrc = CRC32Table[(nCrc ^ lpData[i]) &amp; <span class="number">0xFF</span>] ^ (nCrc &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> nCrc ^ <span class="number">0xFFFFFFFF</span>;           <span class="comment">// 按位取反</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="x64下书写汇编"><a href="#x64下书写汇编" class="headerlink" title="x64下书写汇编"></a>x64下书写汇编</h2><p>x64不支持内联汇编，但intrin.h中提供了一系列intrinsic函数，这里就介绍俩。</p>
<h3 id="cpuid-cpuidex"><a href="#cpuid-cpuidex" class="headerlink" title="__cpuid&#x2F;__cpuidex"></a>__cpuid&#x2F;__cpuidex</h3><p>获取CPU信息，如CPU型号和家族等；获取CPU支持的功能，如是否支持MMX、SSE、FPU指令等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VOID __cpuuid(</span><br><span class="line">    _Out_ INT cpuInfo[<span class="number">4</span>], <span class="comment">//返回CPU信息及支持的功能</span></span><br><span class="line">    _In_ INT function_id <span class="comment">//指定要获取的基本信息 功能号 0~3</span></span><br><span class="line">);</span><br><span class="line">VOID __cpuidex(</span><br><span class="line">    _Out_ INT cpuInfo[<span class="number">4</span>],</span><br><span class="line">    _In_ INT function_id,</span><br><span class="line">    _In_ INT subfunction_id <span class="comment">//指定要获取的扩展信息</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该指令原用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 功能号</span><br><span class="line">cpuid</span><br></pre></td></tr></table></figure>

<p>返回后通过eax、ebx、ecx和ebx返回所需信息，这里分别放入cpuInfo数组。获取基本信息时，功能号最高位为0；获取扩展信息时，最高位为1。</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p>不让内联汇编就外联，添加Test.asm汇编源文件。该文件右键打开属性，配置自定义生成工具，命令行选项写以下，表示用ml64.exe编译.asm为.obj到生成配置目录下，用&#x2F;Fo指定输出.obj文件名，用&#x2F;c仅编译不自动链接。生成配置目录即“\项目名\x64\Release”等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ml64 /Fo $(IntDir)%(fileName).obj /c %(fileName).asm</span><br></pre></td></tr></table></figure>

<p>输出选项写以下，表示告诉链接器到哪找.obj文件以完成链接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(IntDir)%(fileName).obj</span><br></pre></td></tr></table></figure>

<p>这里汇编文件为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">GetCPUID proc</span><br><span class="line">    mov r8, rcx</span><br><span class="line">    mov eax, edx</span><br><span class="line">    cpuid</span><br><span class="line">    mov dword ptr [r8], eax</span><br><span class="line">    mov dword ptr [r8 + 0Ch], edx	</span><br><span class="line">    ret</span><br><span class="line">GetCPUID endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>源代码这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 声明引用外部函数</span></span><br><span class="line"><span class="function">EXTERN_C VOID <span class="title">GetCPUID</span><span class="params">(<span class="type">int</span> cpuInfo[<span class="number">4</span>], <span class="type">int</span> function_id)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arrCpuInfo[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR szBuf[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_GET: &#123;</span><br><span class="line">                    <span class="comment">// intrinsic函数</span></span><br><span class="line">                    __cpuid(arrCpuInfo, <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%08X%08X&quot;</span>), arrCpuInfo[<span class="number">3</span>], arrCpuInfo[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_INTRINSIC, szBuf);</span><br><span class="line">                    <span class="comment">// 自定义汇编函数</span></span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(arrCpuInfo, <span class="built_in">sizeof</span>(arrCpuInfo));</span><br><span class="line">                    <span class="built_in">GetCPUID</span>(arrCpuInfo, <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%08X%08X&quot;</span>), arrCpuInfo[<span class="number">3</span>], arrCpuInfo[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_ASM, szBuf);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>写成ShellCode。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arrCpuInfo[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR szBuf[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// GetCPUID函数字节码</span></span><br><span class="line">    BYTE bGetCPUID[] = &#123;</span><br><span class="line">        <span class="number">0x4C</span>, <span class="number">0x8B</span>, <span class="number">0xC1</span>,       <span class="comment">// mov r8, rcx</span></span><br><span class="line">        <span class="number">0x8B</span>, <span class="number">0xC2</span>,             <span class="comment">// mov eax, edx</span></span><br><span class="line">        <span class="number">0x0F</span>, <span class="number">0xA2</span>,             <span class="comment">// cpuid</span></span><br><span class="line">        <span class="number">0x41</span>, <span class="number">0x89</span>, <span class="number">0x00</span>,       <span class="comment">// mov dword ptr [r8], eax</span></span><br><span class="line">        <span class="number">0x41</span>, <span class="number">0x89</span>, <span class="number">0x50</span>, <span class="number">0x0C</span>, <span class="comment">// mov dword ptr [r8 + 0xC], edx</span></span><br><span class="line">        <span class="number">0xC3</span> &#125;;                 <span class="comment">// ret</span></span><br><span class="line">    <span class="comment">// 函数指针变量</span></span><br><span class="line">    <span class="built_in">VOID</span>(*GetCPUID)(<span class="type">int</span> cpuInfo[<span class="number">4</span>], <span class="type">int</span> function_id) = (<span class="built_in">VOID</span>(*)(<span class="type">int</span>*, <span class="type">int</span>))(ULONG_PTR)bGetCPUID;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_GET: &#123;</span><br><span class="line">                    <span class="comment">// intrinsic函数</span></span><br><span class="line">                    __cpuid(arrCpuInfo, <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%08X%08X&quot;</span>), arrCpuInfo[<span class="number">3</span>], arrCpuInfo[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_INTRINSIC, szBuf);</span><br><span class="line">                    <span class="comment">// 自定义汇编函数</span></span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(arrCpuInfo, <span class="built_in">sizeof</span>(arrCpuInfo));</span><br><span class="line">                    <span class="built_in">VirtualProtect</span>(GetCPUID, <span class="built_in">sizeof</span>(bGetCPUID), PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">                    <span class="built_in">GetCPUID</span>(arrCpuInfo, <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">VirtualProtect</span>(GetCPUID, <span class="built_in">sizeof</span>(bGetCPUID), dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;%08X%08X&quot;</span>), arrCpuInfo[<span class="number">3</span>], arrCpuInfo[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_ASM, szBuf);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Detour"><a href="#Detour" class="headerlink" title="Detour"></a>Detour</h2><p>Detour库用于拦截API函数，原理就是将目标函数前几条指令替换为无条件跳转到用户提供的自定义函数的jmp指令。自定义函数完成拦截处理后，恢复执行目标函数被覆盖的前几条指令，并继续执行目标函数后续部分。目标函数执行完后自定义函数返回。</p>
<p>自定义函数在内部实现层次上分为两个函数。执行拦截处理的为Detour绕行函数，其函数参数、函数调用约定和返回值类型必须与目标函数完全一致。Trampoline跳板函数执行目标函数被覆盖的前几条指令并跳转到目标函数后续部分的功能。Trampoline在Detour函数中被调用。</p>
<p>Detour库除了可以对API函数拦截，还可修改可执行文件导入表、项可执行文件添加数据、将DLL加载到目标进程等。该库托管在Github上，自己下载是源码，用x64 Native Tools Command Prompt for VS 2022命令行在Makefile所在目录下用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmake</span><br></pre></td></tr></table></figure>

<p>运行后目录下生成include、lib.X64、bin.X64目录。</p>
<h3 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h3><h4 id="DetourIsHelperProcess"><a href="#DetourIsHelperProcess" class="headerlink" title="DetourIsHelperProcess"></a>DetourIsHelperProcess</h4><p>检查被注入DLL所属当前线程是辅助进程还是目标进程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourIsHelperProcess</span><span class="params">(VOID)</span></span>;</span><br></pre></td></tr></table></figure>

<p>是辅助进程返回TRUE，是目标进程返回FALSE。</p>
<h4 id="DetourRestoreAfterWith"><a href="#DetourRestoreAfterWith" class="headerlink" title="DetourRestoreAfterWith"></a>DetourRestoreAfterWith</h4><p>恢复目标进程导入表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourRestoreAfterWith</span><span class="params">(VOID)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="DetourTransactionBegin"><a href="#DetourTransactionBegin" class="headerlink" title="DetourTransactionBegin"></a>DetourTransactionBegin</h4><p>开启事务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourTransactionBegin</span><span class="params">(VOID)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="DetourUpdateThread"><a href="#DetourUpdateThread" class="headerlink" title="DetourUpdateThread"></a>DetourUpdateThread</h4><p>指定更新线程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">DetourAttach</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_ PVOID* ppPointer, <span class="comment">//目标函数指针地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PVOID pDetour <span class="comment">//自定义函数地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="DetourDetach"><a href="#DetourDetach" class="headerlink" title="DetourDetach"></a>DetourDetach</h4><p>执行Unhook处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">DetourDetach</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_ PVOID* ppPointer,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PVOID pDetour</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="DetourTransactionCommit"><a href="#DetourTransactionCommit" class="headerlink" title="DetourTransactionCommit"></a>DetourTransactionCommit</h4><p>提交事务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">DetourTransactionCommit</span><span class="params">(VOID)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>可执行模块用<code>DetourCreateProcessWithDllEx</code>或<code>DetourCreateProcessWithDlls</code>将被注入DLL加载到目标进程中。内部实现方法是修改目标进程导入表，将被注入DLL对应导入表描述符结构放在导入表最前部，即可在目标进程气都后及执行代码前加载被注入DLL，在被注入DLL中用<code>DetourAttach</code>执行Hook处理。</p>
<p>Detour支持x86与x64之间跨架构创建目标进程，但此时<code>DetourCreateProcessWithDllEx</code>或<code>DetourCreateProcessWithDlls</code>必须创建临时辅助进程，方法是将被注入DLL加载到rundll32.exe进程并用<code>DetourFinishHelperProcess</code>创建一个辅助进程，辅助进程加载被注入DLL副本，保证使用正确的架构代码来修改目标进程IAT。此时要注意：被注入DLL必须导出<code>DetourFinishHelperProcess</code>且导出函数序数为1，否则目标进程无法启动；被注入DLL应在其<code>DllMain</code>中用<code>DetourIsHelperProcess</code>检查其所属当前进程是辅助进程还是目标进程，辅助进程则不应Hook。</p>
<p>执行<code>DetourAttack</code>后DetourExtTextOutW中OriginalExtTextOutW被改为指向Trampoline函数。</p>
<p>本节中，事务是一系列原子性、独占性的操作。操作前要开启事务，最后提交事务，提交后所做操作才会生效。用<code>DetourAttach</code>执行Hook和用<code>DetourDetach</code>执行Unhook前要先用<code>DetourTransactionBegin</code>开启事务，之后用<code>DetourTransactionCommit</code>提交事务，有时用<code>DetourUpdateThread</code>指定受事务影响的需更新的线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;..\..\..\Detours-master\include\detours.h&quot;</span></span></span><br><span class="line"><span class="comment">// 编译为x86时需要使用的.lib</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;..\\..\\..\\Detours-master\\lib.X86\\detours.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 编译为x64时需要使用的.lib</span></span><br><span class="line"><span class="comment">//#pragma comment(lib, &quot;..\\..\\..\\Detours-master\\lib.X64\\detours.lib&quot;)</span></span><br><span class="line"><span class="comment">// 目标函数指针(加static关键字说明仅用于本文件)</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">BOOL</span><span class="params">(WINAPI* OriginalExtTextOutW)</span><span class="params">(HDC hdc, INT x, INT y, UINT options,CONST PRECT lprect, LPCWSTR lpString, UINT c, CONST PINT lpDx)</span> </span>= ExtTextOutW;</span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DetourExtTextOutW</span><span class="params">(HDC hdc, <span class="type">int</span> x, <span class="type">int</span> y, UINT options, RECT* lprect, LPCWSTR lpString, UINT c, INT* lpDx)</span> </span>&#123;</span><br><span class="line">    TCHAR szText1[] = <span class="built_in">TEXT</span>(<span class="string">&quot;屏幕&quot;</span>);</span><br><span class="line">    TCHAR szText2[] = <span class="built_in">TEXT</span>(<span class="string">&quot;用户名&quot;</span>);</span><br><span class="line">    TCHAR szText3[] = <span class="built_in">TEXT</span>(<span class="string">&quot;购买者&quot;</span>);</span><br><span class="line">    TCHAR szTextReplace[] = <span class="built_in">TEXT</span>(<span class="string">&quot;                                                          &quot;</span>);</span><br><span class="line">    LPCTSTR lpStr;</span><br><span class="line">    <span class="keyword">if</span> ((lpStr = _tcsstr(lpString, szText1)) || (lpStr = _tcsstr(lpString, szText2)) || (lpStr = _tcsstr(lpString, szText3)))</span><br><span class="line">        <span class="built_in">memcpy</span>((LPVOID)lpStr, szTextReplace, _tcslen(lpStr) * <span class="built_in">sizeof</span>(TCHAR));</span><br><span class="line">    <span class="built_in">OriginalExtTextOutW</span>(hdc, x, y, options, lprect, lpString, c, lpDx);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前进程是辅助进程则不执行任何处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DetourIsHelperProcess</span>())</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">if</span> (ul_reason_for_call == DLL_PROCESS_ATTACH) &#123;</span><br><span class="line">        <span class="comment">// 恢复当前进程的导入表</span></span><br><span class="line">        <span class="built_in">DetourRestoreAfterWith</span>();</span><br><span class="line">        <span class="comment">// 开启(开始)事务</span></span><br><span class="line">        <span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line">        <span class="comment">// 指定更新线程</span></span><br><span class="line">        <span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line">        <span class="comment">// 执行Hook处理</span></span><br><span class="line">        <span class="built_in">DetourAttach</span>(&amp;(PVOID&amp;)OriginalExtTextOutW, DetourExtTextOutW);</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        <span class="built_in">DetourTransactionCommit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ul_reason_for_call == DLL_PROCESS_DETACH) &#123;</span><br><span class="line">        <span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line">        <span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line">        <span class="comment">// 执行Unhook处理</span></span><br><span class="line">        <span class="built_in">DetourDetach</span>(&amp;(PVOID&amp;)OriginalExtTextOutW, DetourExtTextOutW);</span><br><span class="line">        <span class="built_in">DetourTransactionCommit</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="将DLL加载到目标进程"><a href="#将DLL加载到目标进程" class="headerlink" title="将DLL加载到目标进程"></a>将DLL加载到目标进程</h3><h4 id="DetourCreateProcessWithDllEx"><a href="#DetourCreateProcessWithDllEx" class="headerlink" title="DetourCreateProcessWithDllEx"></a>DetourCreateProcessWithDllEx</h4><p>创建一个新进程并将指定DLL加载到该进程中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourCreateProcessWithDllEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCTSTR lpApplication,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_opt_ LPTSTR lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ BOOL bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPVOID lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCTSTR lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPSTARTUPINFOW lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ LPPROCESS_INFORMATION lpProcessInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPCSTR lpDllName, <span class="comment">//要注入DLL名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINE pfCreateProcessW <span class="comment">//替换CreateProcessW的新函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用标准<code>CreateProcessW</code>时，pfnCreateProcessW可设为NULL。该函数在内部用<code>CreateProcessW</code>，且dwCreationFlags设为CREATE_SUSPENDED以挂起模式创建目标进程。该函数修改目标进程导入表，将指定DLL对应导入表描述符结构放在导入表最前部，然后恢复目标进程执行，系统先加载指定DLL。</p>
<h4 id="DetourCreateProcessWithDlls"><a href="#DetourCreateProcessWithDlls" class="headerlink" title="DetourCreateProcessWithDlls"></a>DetourCreateProcessWithDlls</h4><p>创建一个新线程并将指定的若干个DLL加载到该线程中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourCreateProcessWithDlls</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCTSTR lpApplication,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_opt_ LPTSTR lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ BOOL bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPVOID lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCTSTR lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPSTARTUPINFOW lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ LPPROCESS_INFORMATION lpProcessInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD nDlls, <span class="comment">//rlpDll数组元素个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPCSTR* rlpDlls, <span class="comment">//要注入的DLL名称数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINE pfCreateProcessW</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>描述同<code>DetourCreateProcessWithDllEx</code>。</p>
<h4 id="DetourAttachEx"><a href="#DetourAttachEx" class="headerlink" title="DetourAttachEx"></a>DetourAttachEx</h4><p>同<code>DetourAttach</code>，还可获取Detour函数、Trampoline函数和目标函数地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">DetourAttachEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_ PVOID* ppPointer, <span class="comment">//目标函数指针地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PVOID pDetour, <span class="comment">//自定义函数地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ PDETOUR_TRAMPOLINE ppRealTrampoline, <span class="comment">//返回Trampoline函数地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ PVOID* ppRealTarget, <span class="comment">//返回目标函数地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ PVOID* ppRealDetour <span class="comment">//返回Detour函数地址 </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="DetourFindFunction"><a href="#DetourFindFunction" class="headerlink" title="DetourFindFunction"></a>DetourFindFunction</h4><p>从指定模块中查找指定函数地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">DetourFindFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPCSTR pszModule, <span class="comment">//模块名</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPCSTR pszFunction <span class="comment">//函数名</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回指定函数内存地址 失败NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="DetourCodeFromPointer"><a href="#DetourCodeFromPointer" class="headerlink" title="DetourCodeFromPointer"></a>DetourCodeFromPointer</h4><p>获取指定函数的代码实现地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">DetourCodeFromPointer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PVOID pPointer, <span class="comment">//目标函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ PVOID* ppGlobals <span class="comment">//返回目标函数全局/静态数据地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回目标函数代码实现地址</span></span><br></pre></td></tr></table></figure>

<p>与<code>DetourFindFunction</code>不同的是，可能指定的函数只有个jmp，<code>DetourCodeFromPointer</code>会继续跟进并找到代码实现地址。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LPVOID lpGetCurrentProcess = <span class="literal">NULL</span>, lpRealGetCurrentProcess = <span class="literal">NULL</span>, lpGlobals = <span class="literal">NULL</span>;</span><br><span class="line">TCHAR szBuf[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">lpGetCurrentProcess = <span class="built_in">DetourFindFunction</span>(<span class="string">&quot;kernel32&quot;</span>, <span class="string">&quot;GetCurrentProcess&quot;</span>);</span><br><span class="line">lpRealGetCurrentProcess = <span class="built_in">DetourCodeFromPointer</span>(lpGetCurrentProcess, &amp;lpGlobals);</span><br><span class="line"><span class="built_in">wsprintf</span>(szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;函数指针：0x%p\n 函数代码实现地址：0x%p\n 全局（或静态）数据地址：0x%p\n&quot;</span>), lpGetCurrentProcess, lpRealGetCurrentProcess, lpGlobals);</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, szBuf, <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h4 id="DetourEnumerateModules"><a href="#DetourEnumerateModules" class="headerlink" title="DetourEnumerateModules"></a>DetourEnumerateModules</h4><p>枚举进程中模块：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">DetourEnumerateModules</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HMODULE hModuleLast <span class="comment">//模块句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一次hModuelLast为NULL，函数返回下一个模块句柄，以返回的模块句柄循环调用该函数，直到返回NULL。</p>
<h4 id="DetourGetEntryPoint"><a href="#DetourGetEntryPoint" class="headerlink" title="DetourGetEntryPoint"></a>DetourGetEntryPoint</h4><p>获取模块入口点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">DetourGetEntryPoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HMODULE hModule <span class="comment">//模块句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>hModule为NULL则返回调用进程可执行模块入口点。</p>
<h4 id="DetourEnumerateExports"><a href="#DetourEnumerateExports" class="headerlink" title="DetourEnumerateExports"></a>DetourEnumerateExports</h4><p>枚举模块导出函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourEnumerateExports</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HMODULE hModuel, <span class="comment">//模块句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PVOID pContext, <span class="comment">//传递给回调函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PF_DETOUR_ENUMERATE_EXPORT_CALLBACK pfExport <span class="comment">//回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>每当枚举到一个导出函数，都调用一次回调函数，格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL CALLBACK <span class="title">ExportFunc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PVOID pContext, <span class="comment">//传递来的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG nOrdinal, <span class="comment">//函数序数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR pszName, <span class="comment">//函数名</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PVOID pCode <span class="comment">//函数代码实现地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>需要继续枚举时，回调函数返回TRUE，终止则返回FALSE。</p>
<h4 id="DetourEnumerateImports"><a href="#DetourEnumerateImports" class="headerlink" title="DetourEnumerateImports"></a>DetourEnumerateImports</h4><p>枚举模块导入表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourEnumerateImports</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HMODULE hModule,<span class="comment">//模块句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PVOID pContext, <span class="comment">//传递给pfImportFile和pfImportFunc的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile, <span class="comment">//每枚举到一个DLL时调用</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PF_DETOUR_IMPORT_FUNC_CALLBACK pfImportFunc <span class="comment">//每枚举到一个导入函数时调用</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>还有个<code>DetourEnumerateImportsEx</code>自己去学。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>为了保证DLL中导出函数<code>DetourFinishHelperProcess</code>的导出函数为1，应添加模块定义文件xxx.def：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">    DetourFinishHelperProcess @1</span><br></pre></td></tr></table></figure>

<p>然后分别编译x86和x64两个版本为xxx32.dll和xxx64.dll。<code>DetourCreateProcessWithDllEx</code>和<code>DetourCreateProcessWithDlls</code>发现选错架构的DLL时，会自动改为正确的DLL，但不建议依赖该纠错特性。</p>
<p>注入器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CommCtrl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;..\..\..\Detours-master\include\detours.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 编译为x86时需要使用的.lib</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;..\\..\\..\\Detours-master\\lib.X86\\detours.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 编译为x64时需要使用的.lib</span></span><br><span class="line"><span class="comment">//#pragma comment(lib, &quot;..\\..\\..\\Detours-master\\lib.X64\\detours.lib&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;\&quot;/manifestdependency:type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;*&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    HWND hwndComboDllPath;</span><br><span class="line">    HWND hwndComboTarget;</span><br><span class="line">    CHAR szInjectDll[MAX_PATH] = &#123; <span class="number">0</span> &#125;;       <span class="comment">// 注入dll路径</span></span><br><span class="line">    TCHAR szTargetProcess[MAX_PATH] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 目标程序路径</span></span><br><span class="line">    STARTUPINFO si = &#123; <span class="built_in">sizeof</span>(STARTUPINFO) &#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            hwndComboDllPath = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_COMBO_DLLPATH);</span><br><span class="line">            hwndComboTarget = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_COMBO_TARGET);</span><br><span class="line">            <span class="comment">// 注入dll组合框添加一些列表项</span></span><br><span class="line">            <span class="built_in">SendMessage</span>(hwndComboDllPath, CB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;InjectDll32.dll&quot;</span>));</span><br><span class="line">            <span class="built_in">SendMessage</span>(hwndComboDllPath, CB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;InjectDll64.dll&quot;</span>));</span><br><span class="line">            <span class="built_in">SendMessage</span>(hwndComboDllPath, CB_SETCURSEL, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 目标程序组合框添加一些列表项</span></span><br><span class="line">            <span class="built_in">SendMessage</span>(hwndComboTarget, CB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;FloatingWaterMark32.exe&quot;</span>));</span><br><span class="line">            <span class="built_in">SendMessage</span>(hwndComboTarget, CB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;FloatingWaterMark64.exe&quot;</span>));</span><br><span class="line">            <span class="built_in">SendMessage</span>(hwndComboTarget, CB_SETCURSEL, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_CREATE: &#123;</span><br><span class="line">                    <span class="built_in">GetDlgItemTextA</span>(hwndDlg, IDC_COMBO_DLLPATH, szInjectDll, _countof(szInjectDll));</span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_COMBO_TARGET, szTargetProcess, _countof(szTargetProcess));</span><br><span class="line">                    <span class="built_in">GetStartupInfo</span>(&amp;si);</span><br><span class="line">                    bRet = <span class="built_in">DetourCreateProcessWithDllEx</span>(<span class="literal">NULL</span>, szTargetProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi, szInjectDll, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!bRet)</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;创建目标进程失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;错误提示&quot;</span>), MB_OK);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_CLOSE: &#123;</span><br><span class="line">            <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="编辑可执行文件"><a href="#编辑可执行文件" class="headerlink" title="编辑可执行文件"></a>编辑可执行文件</h3><h4 id="DetourBinaryOpen"><a href="#DetourBinaryOpen" class="headerlink" title="DetourBinaryOpen"></a>DetourBinaryOpen</h4><p>将可执行文件内容读入内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PDETOUR_BINARY <span class="title">DetourBinaryOpen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hFile <span class="comment">//文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回Detour二进制文件对象指针 失败NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="DetourBinarySetPayload"><a href="#DetourBinarySetPayload" class="headerlink" title="DetourBinarySetPayload"></a>DetourBinarySetPayload</h4><p>项Detour二进制文件对象中添加数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">DetourBinarySetPayload</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PDETOUR_BINARY pBinary, <span class="comment">//Detour二进制文件对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ REFGUID rguid, <span class="comment">//要添加的数据自定义GUID</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PVOID pData, <span class="comment">//要添加的数据指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD cbData <span class="comment">//要添加的数据大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回数据实际写入内存地址 失败NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="DetourBinaryFindPayload"><a href="#DetourBinaryFindPayload" class="headerlink" title="DetourBinaryFindPayload"></a>DetourBinaryFindPayload</h4><p>从Detour二进制文件对象中查找指定GUID的数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">DetourBinaryFindPayload</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PDETOUR_BINARY pBinary,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ REFGUID rguid,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PDWORD pcbData <span class="comment">//返回查找到的数据大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回指定数据内存地址 失败NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="DetourBinaryDeletePayload-DetourBinaryPurgePayloads"><a href="#DetourBinaryDeletePayload-DetourBinaryPurgePayloads" class="headerlink" title="DetourBinaryDeletePayload&#x2F;DetourBinaryPurgePayloads"></a>DetourBinaryDeletePayload&#x2F;DetourBinaryPurgePayloads</h4><p>从Detour二进制文件对象中删除指定&#x2F;所有数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourBinaryDeletePayload</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PDETOUR_BINARY pBinary,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ REFGUID rguid</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">DetourBinaryPurgePayloads</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PDETOUR_BINARY pBinary</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="DetourBinaryEditImports"><a href="#DetourBinaryEditImports" class="headerlink" title="DetourBinaryEditImports"></a>DetourBinaryEditImports</h4><p>修改Detour二进制文件对象导入表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourBinaryEditImports</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PDETOUR_BINARY pBinary,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PVOID pContext, <span class="comment">//传递给各个回调函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PF_DETOUR_BINARY_FILE_CALLBACK pfFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PF_DETOUR_COMMIT_CALLBACK pfFinal</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="DetourBinaryResetImports"><a href="#DetourBinaryResetImports" class="headerlink" title="DetourBinaryResetImports"></a>DetourBinaryResetImports</h4><p>重置Detour二进制文件对象导入表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourBinaryResetImports</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PDETOUR_BINARY pBinary</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="DetourBinaryWrite"><a href="#DetourBinaryWrite" class="headerlink" title="DetourBinaryWrite"></a>DetourBinaryWrite</h4><p>将更新写入文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourBinaryWrite</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PDETOUR_BINARY pBinary,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hFile</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="DetourBinaryClose"><a href="#DetourBinaryClose" class="headerlink" title="DetourBinaryClose"></a>DetourBinaryClose</h4><p>关闭 打开的Detour二进制文件对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DetourBinaryClose</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PDETOUR_BINARY pBinary</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="IAT-Hook"><a href="#IAT-Hook" class="headerlink" title="IAT Hook"></a>IAT Hook</h3><p>实现方式为修改API对应IAT项内存地址为自定义函数内存地址。为了栈平衡，自定义函数的参数、调用约定和返回值类型等必须与目标函数一致。</p>
<p>除了修改进程所有模块IAT中目标函数对应IAT项，为了能够在加载模块时加载其他依赖模块，还需Hook掉<code>LoadLibrary*</code>和<code>GetProcAddress</code>等函数。</p>
<h4 id="ImageDirectoryEntryToDataEx"><a href="#ImageDirectoryEntryToDataEx" class="headerlink" title="ImageDirectoryEntryToDataEx"></a>ImageDirectoryEntryToDataEx</h4><p>从普通PE文件或PE内存映像中查找指定数据目录内存地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID IMAGEAPI <span class="title">ImageDirectoryEntryToDataEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PVOID pBase, <span class="comment">//PE或PE内存映像基地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ BOOLEAN bMappedAsImage, <span class="comment">//是否是PE内存映像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ USHORT nDirectoryEntry, <span class="comment">//数据目录索引</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PULONG pSize, <span class="comment">//返回数据目录大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ PIMAGE_SECTION_HEADER* pFoundHeader <span class="comment">//返回数据目录所在节区信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回数据目录内存地址 失败NULL</span></span><br></pre></td></tr></table></figure>

<p>nDirectoryEntry如IMAGE_DIRECTORY_ENTRY_EXPORT为导出表等。</p>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dbghelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Dbghelp.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 目标函数原函数指针(ExtTextOutW; LoadLibrary*; GetProcAddress)</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">BOOL</span><span class="params">(WINAPI* OrigExtTextOutW)</span><span class="params">(HDC hdc, <span class="type">int</span> x, <span class="type">int</span> y, UINT options,<span class="type">const</span> RECT* lprect, LPCWSTR lpString, UINT c, <span class="type">const</span> INT* lpDx)</span> </span>= ExtTextOutW;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">HMODULE</span><span class="params">(WINAPI* OrigLoadLibraryA)</span><span class="params">(LPCSTR lpLibFileName)</span> </span>= LoadLibraryA;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">HMODULE</span><span class="params">(WINAPI* OrigLoadLibraryW)</span><span class="params">(LPCWSTR lpLibFileName)</span> </span>= LoadLibraryW;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">HMODULE</span><span class="params">(WINAPI* OrigLoadLibraryExA)</span><span class="params">(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span> </span>= LoadLibraryExA;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">HMODULE</span><span class="params">(WINAPI* OrigLoadLibraryExW)</span><span class="params">(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span> </span>= LoadLibraryExW;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">FARPROC</span><span class="params">(WINAPI* OrigGetProcAddress)</span><span class="params">(HMODULE hModule, LPCSTR lpProcName)</span> </span>= GetProcAddress;</span><br><span class="line"><span class="comment">// 自定义函数(替换掉ExtTextOutW; LoadLibrary*; GetProcAddress)</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">HookExtTextOutW</span><span class="params">(HDC hdc, <span class="type">int</span> x, <span class="type">int</span> y, UINT options,RECT* lprect, LPCWSTR lpString, UINT c, INT* lpDx)</span></span>;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryA</span><span class="params">(LPCSTR lpLibFileName)</span></span>;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryW</span><span class="params">(LPCWSTR lpLibFileName)</span></span>;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryExA</span><span class="params">(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span></span>;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryExW</span><span class="params">(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span></span>;</span><br><span class="line"><span class="function">FARPROC WINAPI <span class="title">HookGetProcAddress</span><span class="params">(HMODULE hModule, LPCSTR lpProcName)</span></span>;</span><br><span class="line"><span class="comment">// 替换进程的指定模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceIATInOneMod</span><span class="params">(HMODULE hModule, LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span></span>;</span><br><span class="line"><span class="comment">// 替换进程的所有模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">VOID <span class="title">ReplaceIATInAllMod</span><span class="params">(LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span></span>;</span><br><span class="line"><span class="comment">// 替换指定模块导出表中的一个EAT项(导出函数地址)</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceEATInOneMod</span><span class="params">(HMODULE hModule, LPCSTR pszFuncName, PROC pfnNew)</span></span>;</span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call) &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH: &#123;</span><br><span class="line">            <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;gdi32.dll&quot;</span>, (PROC)OrigExtTextOutW, (PROC)HookExtTextOutW);</span><br><span class="line">            <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryA, (PROC)HookLoadLibraryA);</span><br><span class="line">            <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryW, (PROC)HookLoadLibraryW);</span><br><span class="line">            <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExA, (PROC)HookLoadLibraryExA);</span><br><span class="line">            <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExW, (PROC)HookLoadLibraryExW);</span><br><span class="line">            <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigGetProcAddress, (PROC)HookGetProcAddress);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH: &#123;&#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH: &#123;&#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 替换进程的指定模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceIATInOneMod</span><span class="params">(HMODULE hModule, LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span> </span>&#123;</span><br><span class="line">    ULONG                    ulSize;                   <span class="comment">// 导入表的大小</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImageImportDesc = <span class="literal">NULL</span>;  <span class="comment">// 导入表起始地址</span></span><br><span class="line">    PIMAGE_THUNK_DATA        pImageThunkData = <span class="literal">NULL</span>;   <span class="comment">// IMAGE_THUNK_DATA数组起始地址</span></span><br><span class="line">    <span class="comment">// 获取导入表起始地址</span></span><br><span class="line">    pImageImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)<span class="built_in">ImageDirectoryEntryToDataEx</span>(hModule, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &amp;ulSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pImageImportDesc)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 遍历导入表，查找目标函数</span></span><br><span class="line">    <span class="keyword">while</span> (pImageImportDesc-&gt;OriginalFirstThunk || pImageImportDesc-&gt;TimeDateStamp || pImageImportDesc-&gt;ForwarderChain || pImageImportDesc-&gt;Name || pImageImportDesc-&gt;FirstThunk) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_stricmp(pszDllName, (LPSTR)((LPBYTE)hModule + pImageImportDesc-&gt;Name)) == <span class="number">0</span>) &#123;</span><br><span class="line">            pImageThunkData = (PIMAGE_THUNK_DATA)((LPBYTE)hModule + pImageImportDesc-&gt;FirstThunk);</span><br><span class="line">            <span class="keyword">while</span> (pImageThunkData-&gt;u1.AddressOfData != <span class="number">0</span>) &#123;</span><br><span class="line">                PROC* ppfn = (PROC*)&amp;pImageThunkData-&gt;u1.Function;</span><br><span class="line">                <span class="keyword">if</span> (*ppfn == pfnTarget) &#123;</span><br><span class="line">                    DWORD dwOldProtect;</span><br><span class="line">                    BOOL bRet = FALSE;</span><br><span class="line">                    <span class="comment">// 替换目标IAT项的值为pfnNew</span></span><br><span class="line">                    <span class="built_in">VirtualProtect</span>(ppfn, <span class="built_in">sizeof</span>(pfnNew), PAGE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">                    bRet = <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), ppfn, &amp;pfnNew, <span class="built_in">sizeof</span>(pfnNew), <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">VirtualProtect</span>(ppfn, <span class="built_in">sizeof</span>(pfnNew), dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">                    <span class="keyword">return</span> bRet;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 指向下一个IMAGE_THUNK_DATA结构</span></span><br><span class="line">                pImageThunkData++;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 指向下一个导入表描述符</span></span><br><span class="line">        pImageImportDesc++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 替换进程的所有模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">VOID <span class="title">ReplaceIATInAllMod</span><span class="params">(LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span> </span>&#123;</span><br><span class="line">    MEMORY_BASIC_INFORMATION mbi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HMODULE                  hModuleThis;     <span class="comment">// 当前代码所处的模块</span></span><br><span class="line">    HANDLE                   hSnapshot = INVALID_HANDLE_VALUE;</span><br><span class="line">    MODULEENTRY32            me = &#123; <span class="built_in">sizeof</span>(MODULEENTRY32) &#125;;</span><br><span class="line">    BOOL                     bRet = FALSE;</span><br><span class="line">    <span class="built_in">VirtualQuery</span>(ReplaceIATInAllMod, &amp;mbi, <span class="built_in">sizeof</span>(mbi));</span><br><span class="line">    hModuleThis = (HMODULE)mbi.AllocationBase;</span><br><span class="line">    hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    bRet = <span class="built_in">Module32First</span>(hSnapshot, &amp;me);</span><br><span class="line">    <span class="keyword">while</span> (bRet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (me.hModule != hModuleThis)         <span class="comment">// 排除当前代码所处的模块</span></span><br><span class="line">            <span class="built_in">ReplaceIATInOneMod</span>(me.hModule, pszDllName, pfnTarget, pfnNew);</span><br><span class="line">        bRet = <span class="built_in">Module32Next</span>(hSnapshot, &amp;me);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">HookExtTextOutW</span><span class="params">(HDC hdc, <span class="type">int</span> x, <span class="type">int</span> y, UINT options, RECT* lprect, LPCWSTR lpString, UINT c, INT* lpDx)</span> </span>&#123;</span><br><span class="line">    TCHAR szText1[] = <span class="built_in">TEXT</span>(<span class="string">&quot;屏幕&quot;</span>);</span><br><span class="line">    TCHAR szText2[] = <span class="built_in">TEXT</span>(<span class="string">&quot;用户名&quot;</span>);</span><br><span class="line">    TCHAR szText3[] = <span class="built_in">TEXT</span>(<span class="string">&quot;购买者&quot;</span>);</span><br><span class="line">    TCHAR szTextReplace[] = <span class="built_in">TEXT</span>(<span class="string">&quot;                                                          &quot;</span>);</span><br><span class="line">    LPCTSTR lpStr;</span><br><span class="line">    <span class="keyword">if</span> ((lpStr = _tcsstr(lpString, szText1)) || (lpStr = _tcsstr(lpString, szText2)) || (lpStr = _tcsstr(lpString, szText3)))</span><br><span class="line">        <span class="built_in">memcpy</span>((LPVOID)lpStr, szTextReplace, _tcslen(lpStr) * <span class="built_in">sizeof</span>(TCHAR));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">OrigExtTextOutW</span>(hdc, x, y, options, lprect, lpString, c, lpDx);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryA</span><span class="params">(LPCSTR lpLibFileName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用原LoadLibraryA函数</span></span><br><span class="line">    HMODULE hModule = <span class="built_in">OrigLoadLibraryA</span>(lpLibFileName);</span><br><span class="line">    <span class="comment">// 原LoadLibraryA函数执行完毕，进程所有模块的导入表中的相关IAT项再替换一次</span></span><br><span class="line">    <span class="keyword">if</span> (hModule != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;gdi32.dll&quot;</span>, (PROC)OrigExtTextOutW, (PROC)HookExtTextOutW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryA, (PROC)HookLoadLibraryA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryW, (PROC)HookLoadLibraryW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExA, (PROC)HookLoadLibraryExA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExW, (PROC)HookLoadLibraryExW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigGetProcAddress, (PROC)HookGetProcAddress);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryW</span><span class="params">(LPCWSTR lpLibFileName)</span> </span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">OrigLoadLibraryW</span>(lpLibFileName);</span><br><span class="line">    <span class="keyword">if</span> (hModule != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;gdi32.dll&quot;</span>, (PROC)OrigExtTextOutW, (PROC)HookExtTextOutW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryA, (PROC)HookLoadLibraryA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryW, (PROC)HookLoadLibraryW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExA, (PROC)HookLoadLibraryExA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExW, (PROC)HookLoadLibraryExW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigGetProcAddress, (PROC)HookGetProcAddress);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryExA</span><span class="params">(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span> </span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">OrigLoadLibraryExA</span>(lpLibFileName, hFile, dwFlags);</span><br><span class="line">    <span class="keyword">if</span> ((hModule != <span class="literal">NULL</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_DATAFILE) == <span class="number">0</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE) == <span class="number">0</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_IMAGE_RESOURCE) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;gdi32.dll&quot;</span>, (PROC)OrigExtTextOutW, (PROC)HookExtTextOutW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryA, (PROC)HookLoadLibraryA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryW, (PROC)HookLoadLibraryW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExA, (PROC)HookLoadLibraryExA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExW, (PROC)HookLoadLibraryExW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigGetProcAddress, (PROC)HookGetProcAddress);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryExW</span><span class="params">(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span> </span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">OrigLoadLibraryExW</span>(lpLibFileName, hFile, dwFlags);</span><br><span class="line">    <span class="keyword">if</span> ((hModule != <span class="literal">NULL</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_DATAFILE) == <span class="number">0</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE) == <span class="number">0</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_IMAGE_RESOURCE) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;gdi32.dll&quot;</span>, (PROC)OrigExtTextOutW, (PROC)HookExtTextOutW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryA, (PROC)HookLoadLibraryA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryW, (PROC)HookLoadLibraryW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExA, (PROC)HookLoadLibraryExA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExW, (PROC)HookLoadLibraryExW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigGetProcAddress, (PROC)HookGetProcAddress);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FARPROC WINAPI <span class="title">HookGetProcAddress</span><span class="params">(HMODULE hModule, LPCSTR lpProcName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用原GetProcAddress函数</span></span><br><span class="line">    FARPROC pfn = <span class="built_in">OrigGetProcAddress</span>(hModule, lpProcName);</span><br><span class="line">    <span class="comment">// 如果原GetProcAddress函数获取的是ExtTextOutW函数的地址，则替换</span></span><br><span class="line">    <span class="keyword">if</span> (pfn == (FARPROC)OrigExtTextOutW)</span><br><span class="line">        pfn = (FARPROC)HookExtTextOutW;</span><br><span class="line">    <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 替换指定模块导出表中的一个EAT项(导出函数地址)</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceEATInOneMod</span><span class="params">(HMODULE hModule, LPCSTR pszFuncName, PROC pfnNew)</span> </span>&#123;</span><br><span class="line">    ULONG                   ulSize;                         <span class="comment">// 导出表的大小</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImageExportDir = <span class="literal">NULL</span>;         <span class="comment">// 导出表起始地址</span></span><br><span class="line">    PDWORD                  pAddressOfFunctions = <span class="literal">NULL</span>;     <span class="comment">// 导出函数地址表的起始地址</span></span><br><span class="line">    PWORD                   pAddressOfNameOrdinals = <span class="literal">NULL</span>;  <span class="comment">// 函数序数表的起始地址</span></span><br><span class="line">    PDWORD                  pAddressOfNames = <span class="literal">NULL</span>;         <span class="comment">// 函数名称地址表的起始地址</span></span><br><span class="line">    <span class="comment">// 获取导出表起始地址</span></span><br><span class="line">    pImageExportDir = (PIMAGE_EXPORT_DIRECTORY)<span class="built_in">ImageDirectoryEntryToDataEx</span>(hModule, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &amp;ulSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pImageExportDir)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 导出函数地址表、函数序数表、函数名称地址表的起始地址</span></span><br><span class="line">    pAddressOfFunctions = (PDWORD)((LPBYTE)hModule + pImageExportDir-&gt;AddressOfFunctions);</span><br><span class="line">    pAddressOfNameOrdinals = (PWORD)((LPBYTE)hModule + pImageExportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line">    pAddressOfNames = (PDWORD)((LPBYTE)hModule + pImageExportDir-&gt;AddressOfNames);</span><br><span class="line">    <span class="comment">// 遍历函数名称地址表</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImageExportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_stricmp(pszFuncName, (LPSTR)((LPBYTE)hModule + pAddressOfNames[i])) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 已经找到目标函数，获取导出函数地址</span></span><br><span class="line">        PROC* ppfn = (PROC*)&amp;pAddressOfFunctions[pAddressOfNameOrdinals[i]];</span><br><span class="line">        pfnNew = (PROC)((LPBYTE)pfnNew - (LPBYTE)hModule);    <span class="comment">// To RVA</span></span><br><span class="line">        DWORD dwOldProtect;</span><br><span class="line">        BOOL bRet = FALSE;</span><br><span class="line">        <span class="comment">// 替换目标EAT项的值为pfnNew</span></span><br><span class="line">        <span class="built_in">VirtualProtect</span>(ppfn, <span class="built_in">sizeof</span>(pfnNew), PAGE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">        bRet = <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), ppfn, &amp;pfnNew, <span class="built_in">sizeof</span>(pfnNew), <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">VirtualProtect</span>(ppfn, <span class="built_in">sizeof</span>(pfnNew), dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">        <span class="keyword">return</span> bRet;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于延迟加载DLL的情况，录入延迟加载GetMd5.dll中的GetMd5函数，则需要：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dbghelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Dbghelp.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 目标函数原函数指针</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">HMODULE</span><span class="params">(WINAPI* OrigLoadLibraryA)</span><span class="params">(LPCSTR lpLibFileName)</span> </span>= LoadLibraryA;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">HMODULE</span><span class="params">(WINAPI* OrigLoadLibraryW)</span><span class="params">(LPCWSTR lpLibFileName)</span> </span>= LoadLibraryW;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">HMODULE</span><span class="params">(WINAPI* OrigLoadLibraryExA)</span><span class="params">(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span> </span>= LoadLibraryExA;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">HMODULE</span><span class="params">(WINAPI* OrigLoadLibraryExW)</span><span class="params">(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span> </span>= LoadLibraryExW;</span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">HookGetMd5</span><span class="params">(LPCTSTR lpFileName, LPTSTR lpMd5)</span></span>;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryA</span><span class="params">(LPCSTR lpLibFileName)</span></span>;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryW</span><span class="params">(LPCWSTR lpLibFileName)</span></span>;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryExA</span><span class="params">(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span></span>;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryExW</span><span class="params">(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span></span>;</span><br><span class="line"><span class="comment">// 替换进程的指定模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceIATInOneMod</span><span class="params">(HMODULE hModule, LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span></span>;</span><br><span class="line"><span class="comment">// 替换进程的所有模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">VOID <span class="title">ReplaceIATInAllMod</span><span class="params">(LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span></span>;</span><br><span class="line"><span class="comment">// 替换指定模块导出表中的一个EAT项(导出函数地址)</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceEATInOneMod</span><span class="params">(HMODULE hModule, LPCSTR pszFuncName, PROC pfnNew)</span></span>;</span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call) &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH: &#123;</span><br><span class="line">            <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryA, (PROC)HookLoadLibraryA);</span><br><span class="line">            <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryW, (PROC)HookLoadLibraryW);</span><br><span class="line">            <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExA, (PROC)HookLoadLibraryExA);</span><br><span class="line">            <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExW, (PROC)HookLoadLibraryExW);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH: &#123;&#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH: &#123;&#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 替换进程的指定模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceIATInOneMod</span><span class="params">(HMODULE hModule, LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span> </span>&#123;</span><br><span class="line">    ULONG                    ulSize;                   <span class="comment">// 导入表的大小</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImageImportDesc = <span class="literal">NULL</span>;  <span class="comment">// 导入表起始地址</span></span><br><span class="line">    PIMAGE_THUNK_DATA        pImageThunkData = <span class="literal">NULL</span>;   <span class="comment">// IMAGE_THUNK_DATA数组起始地址</span></span><br><span class="line">    <span class="comment">// 获取导入表起始地址</span></span><br><span class="line">    pImageImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)<span class="built_in">ImageDirectoryEntryToDataEx</span>(hModule, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &amp;ulSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pImageImportDesc)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 遍历导入表，查找目标函数</span></span><br><span class="line">    <span class="keyword">while</span> (pImageImportDesc-&gt;OriginalFirstThunk || pImageImportDesc-&gt;TimeDateStamp || pImageImportDesc-&gt;ForwarderChain || pImageImportDesc-&gt;Name || pImageImportDesc-&gt;FirstThunk) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_stricmp(pszDllName, (LPSTR)((LPBYTE)hModule + pImageImportDesc-&gt;Name)) == <span class="number">0</span>) &#123;</span><br><span class="line">            pImageThunkData = (PIMAGE_THUNK_DATA)((LPBYTE)hModule + pImageImportDesc-&gt;FirstThunk);</span><br><span class="line">            <span class="keyword">while</span> (pImageThunkData-&gt;u1.AddressOfData != <span class="number">0</span>) &#123;</span><br><span class="line">                PROC* ppfn = (PROC*)&amp;pImageThunkData-&gt;u1.Function;</span><br><span class="line">                <span class="keyword">if</span> (*ppfn == pfnTarget) &#123;</span><br><span class="line">                    DWORD dwOldProtect;</span><br><span class="line">                    BOOL bRet = FALSE;</span><br><span class="line">                    <span class="comment">// 替换目标IAT项的值为pfnNew</span></span><br><span class="line">                    <span class="built_in">VirtualProtect</span>(ppfn, <span class="built_in">sizeof</span>(pfnNew), PAGE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">                    bRet = <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), ppfn, &amp;pfnNew, <span class="built_in">sizeof</span>(pfnNew), <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">VirtualProtect</span>(ppfn, <span class="built_in">sizeof</span>(pfnNew), dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">                    <span class="keyword">return</span> bRet;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 指向下一个IMAGE_THUNK_DATA结构</span></span><br><span class="line">                pImageThunkData++;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 指向下一个导入表描述符</span></span><br><span class="line">        pImageImportDesc++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 替换进程的所有模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">VOID <span class="title">ReplaceIATInAllMod</span><span class="params">(LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span> </span>&#123;</span><br><span class="line">    MEMORY_BASIC_INFORMATION mbi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HMODULE                  hModuleThis;     <span class="comment">// 当前代码所处的模块</span></span><br><span class="line">    HANDLE                   hSnapshot = INVALID_HANDLE_VALUE;</span><br><span class="line">    MODULEENTRY32            me = &#123; <span class="built_in">sizeof</span>(MODULEENTRY32) &#125;;</span><br><span class="line">    BOOL                     bRet = FALSE;</span><br><span class="line">    <span class="built_in">VirtualQuery</span>(ReplaceIATInAllMod, &amp;mbi, <span class="built_in">sizeof</span>(mbi));</span><br><span class="line">    hModuleThis = (HMODULE)mbi.AllocationBase;</span><br><span class="line">    hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    bRet = <span class="built_in">Module32First</span>(hSnapshot, &amp;me);</span><br><span class="line">    <span class="keyword">while</span> (bRet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (me.hModule != hModuleThis)         <span class="comment">// 排除当前代码所处的模块</span></span><br><span class="line">            <span class="built_in">ReplaceIATInOneMod</span>(me.hModule, pszDllName, pfnTarget, pfnNew);</span><br><span class="line">        bRet = <span class="built_in">Module32Next</span>(hSnapshot, &amp;me);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">HookGetMd5</span><span class="params">(LPCTSTR lpFileName, LPTSTR lpMd5)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;延迟加载dll中的GetMd5函数已被Hook&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryA</span><span class="params">(LPCSTR lpLibFileName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用原LoadLibraryA函数</span></span><br><span class="line">    HMODULE hModule = <span class="built_in">OrigLoadLibraryA</span>(lpLibFileName);</span><br><span class="line">    <span class="comment">// 原LoadLibraryA函数执行完毕，进程所有模块的导入表中的相关IAT项再替换一次</span></span><br><span class="line">    <span class="keyword">if</span> (hModule != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryA, (PROC)HookLoadLibraryA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryW, (PROC)HookLoadLibraryW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExA, (PROC)HookLoadLibraryExA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExW, (PROC)HookLoadLibraryExW);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(lpLibFileName, <span class="string">&quot;GetMd5.dll&quot;</span>))</span><br><span class="line">            <span class="built_in">ReplaceEATInOneMod</span>(hModule, <span class="string">&quot;GetMd5&quot;</span>, (PROC)HookGetMd5);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryW</span><span class="params">(LPCWSTR lpLibFileName)</span> </span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">OrigLoadLibraryW</span>(lpLibFileName);</span><br><span class="line">    <span class="keyword">if</span> (hModule != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryA, (PROC)HookLoadLibraryA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryW, (PROC)HookLoadLibraryW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExA, (PROC)HookLoadLibraryExA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExW, (PROC)HookLoadLibraryExW);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">wcsstr</span>(lpLibFileName, <span class="string">L&quot;GetMd5.dll&quot;</span>))</span><br><span class="line">            <span class="built_in">ReplaceEATInOneMod</span>(hModule, <span class="string">&quot;GetMd5&quot;</span>, (PROC)HookGetMd5);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryExA</span><span class="params">(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span> </span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">OrigLoadLibraryExA</span>(lpLibFileName, hFile, dwFlags);</span><br><span class="line">    <span class="keyword">if</span> ((hModule != <span class="literal">NULL</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_DATAFILE) == <span class="number">0</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE) == <span class="number">0</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_IMAGE_RESOURCE) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryA, (PROC)HookLoadLibraryA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryW, (PROC)HookLoadLibraryW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExA, (PROC)HookLoadLibraryExA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExW, (PROC)HookLoadLibraryExW);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(lpLibFileName, <span class="string">&quot;GetMd5.dll&quot;</span>))</span><br><span class="line">            <span class="built_in">ReplaceEATInOneMod</span>(hModule, <span class="string">&quot;GetMd5&quot;</span>, (PROC)HookGetMd5);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">HookLoadLibraryExW</span><span class="params">(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</span> </span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">OrigLoadLibraryExW</span>(lpLibFileName, hFile, dwFlags);</span><br><span class="line">    <span class="keyword">if</span> ((hModule != <span class="literal">NULL</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_DATAFILE) == <span class="number">0</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE) == <span class="number">0</span>) &amp;&amp; ((dwFlags &amp; LOAD_LIBRARY_AS_IMAGE_RESOURCE) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryA, (PROC)HookLoadLibraryA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryW, (PROC)HookLoadLibraryW);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExA, (PROC)HookLoadLibraryExA);</span><br><span class="line">        <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigLoadLibraryExW, (PROC)HookLoadLibraryExW);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">wcsstr</span>(lpLibFileName, <span class="string">L&quot;GetMd5.dll&quot;</span>))</span><br><span class="line">            <span class="built_in">ReplaceEATInOneMod</span>(hModule, <span class="string">&quot;GetMd5&quot;</span>, (PROC)HookGetMd5);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 替换指定模块导出表中的一个EAT项(导出函数地址)</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceEATInOneMod</span><span class="params">(HMODULE hModule, LPCSTR pszFuncName, PROC pfnNew)</span> </span>&#123;</span><br><span class="line">    ULONG                   ulSize;                         <span class="comment">// 导出表的大小</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImageExportDir = <span class="literal">NULL</span>;         <span class="comment">// 导出表起始地址</span></span><br><span class="line">    PDWORD                  pAddressOfFunctions = <span class="literal">NULL</span>;     <span class="comment">// 导出函数地址表的起始地址</span></span><br><span class="line">    PWORD                   pAddressOfNameOrdinals = <span class="literal">NULL</span>;  <span class="comment">// 函数序数表的起始地址</span></span><br><span class="line">    PDWORD                  pAddressOfNames = <span class="literal">NULL</span>;         <span class="comment">// 函数名称地址表的起始地址</span></span><br><span class="line">    <span class="comment">// 获取导出表起始地址</span></span><br><span class="line">    pImageExportDir = (PIMAGE_EXPORT_DIRECTORY)<span class="built_in">ImageDirectoryEntryToDataEx</span>(hModule, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &amp;ulSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pImageExportDir)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 导出函数地址表、函数序数表、函数名称地址表的起始地址</span></span><br><span class="line">    pAddressOfFunctions = (PDWORD)((LPBYTE)hModule + pImageExportDir-&gt;AddressOfFunctions);</span><br><span class="line">    pAddressOfNameOrdinals = (PWORD)((LPBYTE)hModule + pImageExportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line">    pAddressOfNames = (PDWORD)((LPBYTE)hModule + pImageExportDir-&gt;AddressOfNames);</span><br><span class="line">    <span class="comment">// 遍历函数名称地址表</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImageExportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_stricmp(pszFuncName, (LPSTR)((LPBYTE)hModule + pAddressOfNames[i])) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 已经找到目标函数，获取导出函数地址</span></span><br><span class="line">        PROC* ppfn = (PROC*)&amp;pAddressOfFunctions[pAddressOfNameOrdinals[i]];</span><br><span class="line">        pfnNew = (PROC)((LPBYTE)pfnNew - (LPBYTE)hModule);    <span class="comment">// To RVA</span></span><br><span class="line">        DWORD dwOldProtect;</span><br><span class="line">        BOOL bRet = FALSE;</span><br><span class="line">        <span class="comment">// 替换目标EAT项的值为pfnNew</span></span><br><span class="line">        <span class="built_in">VirtualProtect</span>(ppfn, <span class="built_in">sizeof</span>(pfnNew), PAGE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">        bRet = <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), ppfn, &amp;pfnNew, <span class="built_in">sizeof</span>(pfnNew), <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">VirtualProtect</span>(ppfn, <span class="built_in">sizeof</span>(pfnNew), dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">        <span class="keyword">return</span> bRet;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外因延迟加载使用<code>GetProcAddress</code>获取函数地址，所以只Hook掉该函数也可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dbghelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Dbghelp.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 目标函数原函数指针</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">FARPROC</span><span class="params">(WINAPI* OrigGetProcAddress)</span><span class="params">(HMODULE hModule, LPCSTR lpProcName)</span> </span>= GetProcAddress;</span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">HookGetMd5</span><span class="params">(LPCTSTR lpFileName, LPTSTR lpMd5)</span></span>;</span><br><span class="line"><span class="function">FARPROC WINAPI <span class="title">HookGetProcAddress</span><span class="params">(HMODULE hModule, LPCSTR lpProcName)</span></span>;</span><br><span class="line"><span class="comment">// 替换进程的指定模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceIATInOneMod</span><span class="params">(HMODULE hModule, LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span></span>;</span><br><span class="line"><span class="comment">// 替换进程的所有模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">VOID <span class="title">ReplaceIATInAllMod</span><span class="params">(LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span></span>;</span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call) &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH: &#123;</span><br><span class="line">            <span class="built_in">ReplaceIATInAllMod</span>(<span class="string">&quot;kernel32.dll&quot;</span>, (PROC)OrigGetProcAddress, (PROC)HookGetProcAddress);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH: &#123;&#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH: &#123;&#125;;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 替换进程的指定模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceIATInOneMod</span><span class="params">(HMODULE hModule, LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span> </span>&#123;</span><br><span class="line">    ULONG                    ulSize;                   <span class="comment">// 导入表的大小</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImageImportDesc = <span class="literal">NULL</span>;  <span class="comment">// 导入表起始地址</span></span><br><span class="line">    PIMAGE_THUNK_DATA        pImageThunkData = <span class="literal">NULL</span>;   <span class="comment">// IMAGE_THUNK_DATA数组起始地址</span></span><br><span class="line">    <span class="comment">// 获取导入表起始地址</span></span><br><span class="line">    pImageImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)<span class="built_in">ImageDirectoryEntryToDataEx</span>(hModule, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &amp;ulSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pImageImportDesc)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 遍历导入表，查找目标函数</span></span><br><span class="line">    <span class="keyword">while</span> (pImageImportDesc-&gt;OriginalFirstThunk || pImageImportDesc-&gt;TimeDateStamp || pImageImportDesc-&gt;ForwarderChain || pImageImportDesc-&gt;Name || pImageImportDesc-&gt;FirstThunk) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_stricmp(pszDllName, (LPSTR)((LPBYTE)hModule + pImageImportDesc-&gt;Name)) == <span class="number">0</span>) &#123;</span><br><span class="line">            pImageThunkData = (PIMAGE_THUNK_DATA)((LPBYTE)hModule + pImageImportDesc-&gt;FirstThunk);</span><br><span class="line">            <span class="keyword">while</span> (pImageThunkData-&gt;u1.AddressOfData != <span class="number">0</span>) &#123;</span><br><span class="line">                PROC* ppfn = (PROC*)&amp;pImageThunkData-&gt;u1.Function;</span><br><span class="line">                <span class="keyword">if</span> (*ppfn == pfnTarget) &#123;</span><br><span class="line">                    DWORD dwOldProtect;</span><br><span class="line">                    BOOL bRet = FALSE;</span><br><span class="line">                    <span class="comment">// 替换目标IAT项的值为pfnNew</span></span><br><span class="line">                    <span class="built_in">VirtualProtect</span>(ppfn, <span class="built_in">sizeof</span>(pfnNew), PAGE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">                    bRet = <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), ppfn, &amp;pfnNew, <span class="built_in">sizeof</span>(pfnNew), <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">VirtualProtect</span>(ppfn, <span class="built_in">sizeof</span>(pfnNew), dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">                    <span class="keyword">return</span> bRet;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 指向下一个IMAGE_THUNK_DATA结构</span></span><br><span class="line">                pImageThunkData++;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 指向下一个导入表描述符</span></span><br><span class="line">        pImageImportDesc++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 替换进程的所有模块导入表中的一个IAT项(导入函数地址)</span></span><br><span class="line"><span class="function">VOID <span class="title">ReplaceIATInAllMod</span><span class="params">(LPCSTR pszDllName, PROC pfnTarget, PROC pfnNew)</span> </span>&#123;</span><br><span class="line">    MEMORY_BASIC_INFORMATION mbi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HMODULE                  hModuleThis;     <span class="comment">// 当前代码所处的模块</span></span><br><span class="line">    HANDLE                   hSnapshot = INVALID_HANDLE_VALUE;</span><br><span class="line">    MODULEENTRY32            me = &#123; <span class="built_in">sizeof</span>(MODULEENTRY32) &#125;;</span><br><span class="line">    BOOL                     bRet = FALSE;</span><br><span class="line">    <span class="built_in">VirtualQuery</span>(ReplaceIATInAllMod, &amp;mbi, <span class="built_in">sizeof</span>(mbi));</span><br><span class="line">    hModuleThis = (HMODULE)mbi.AllocationBase;</span><br><span class="line">    hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    bRet = <span class="built_in">Module32First</span>(hSnapshot, &amp;me);</span><br><span class="line">    <span class="keyword">while</span> (bRet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (me.hModule != hModuleThis)         <span class="comment">// 排除当前代码所处的模块</span></span><br><span class="line">            <span class="built_in">ReplaceIATInOneMod</span>(me.hModule, pszDllName, pfnTarget, pfnNew);</span><br><span class="line">        bRet = <span class="built_in">Module32Next</span>(hSnapshot, &amp;me);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">HookGetMd5</span><span class="params">(LPCTSTR lpFileName, LPTSTR lpMd5)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;延迟加载dll中的GetMd5函数已被Hook&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FARPROC WINAPI <span class="title">HookGetProcAddress</span><span class="params">(HMODULE hModule, LPCSTR lpProcName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用原GetProcAddress函数</span></span><br><span class="line">    FARPROC pfn = <span class="built_in">OrigGetProcAddress</span>(hModule, lpProcName);</span><br><span class="line">    <span class="comment">// 如果原GetProcAddress函数获取的是GetMd5函数的地址，则替换</span></span><br><span class="line">    <span class="keyword">if</span> (_stricmp(lpProcName, <span class="string">&quot;GetMd5&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        pfn = (FARPROC)HookGetMd5;</span><br><span class="line">    <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io/2024/07/31/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/">https://monoceros406.github.io/2024/07/31/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://monoceros406.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/WinAPI/">WinAPI</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/06/Windows%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2-%E6%89%98%E7%AE%A1/" title="Windows软件调试初探-托管"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Windows软件调试初探-托管</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/26/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="WindowsAPI查缺补漏-WinSock网络编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">WindowsAPI查缺补漏-WinSock网络编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/21/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-INI%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%93%8D%E4%BD%9C/" title="WindowsAPI查缺补漏-INI配置文件与注册表操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="title">WindowsAPI查缺补漏-INI配置文件与注册表操作</div></div></a></div><div><a href="/2024/06/12/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="WindowsAPI查缺补漏-内存管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="title">WindowsAPI查缺补漏-内存管理</div></div></a></div><div><a href="/2024/07/13/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%89%AA%E8%B4%B4%E6%9D%BF/" title="WindowsAPI查缺补漏-剪贴板"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-13</div><div class="title">WindowsAPI查缺补漏-剪贴板</div></div></a></div><div><a href="/2024/06/05/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="WindowsAPI查缺补漏-多线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-05</div><div class="title">WindowsAPI查缺补漏-多线程</div></div></a></div><div><a href="/2024/07/14/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" title="WindowsAPI查缺补漏-动态链接库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-14</div><div class="title">WindowsAPI查缺补漏-动态链接库</div></div></a></div><div><a href="/2024/07/22/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E6%9D%82%E8%B0%88/" title="WindowsAPI查缺补漏-杂谈"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-22</div><div class="title">WindowsAPI查缺补漏-杂谈</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">Windows系统安全爱好者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">331</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://monoceros406.github.io/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哪里排版出锅了请告诉我QwQ  QQ:1295625063</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">WindowsAPI查缺补漏-PE文件格式解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%8E%E7%A2%8E%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">碎碎念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOS%E5%A4%B4"><span class="toc-number">1.2.</span> <span class="toc-text">DOS头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PE%E5%A4%B4"><span class="toc-number">1.3.</span> <span class="toc-text">PE头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">节表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%931"><span class="toc-number">1.5.</span> <span class="toc-text">小结1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text">导入表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E8%A1%A8"><span class="toc-number">1.7.</span> <span class="toc-text">导出表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%9B%AE%E5%BD%95"><span class="toc-number">1.8.</span> <span class="toc-text">调试目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-number">1.9.</span> <span class="toc-text">重定位表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PEInfo"><span class="toc-number">1.10.</span> <span class="toc-text">PEInfo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9FPE%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.11.</span> <span class="toc-text">模拟PE加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%E8%A1%A8"><span class="toc-number">1.12.</span> <span class="toc-text">线程局部存储表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E8%A1%A8"><span class="toc-number">1.13.</span> <span class="toc-text">加载配置信息表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E8%A1%A8"><span class="toc-number">1.14.</span> <span class="toc-text">资源表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="toc-number">1.15.</span> <span class="toc-text">延迟加载导入表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C%E4%B8%8ECRC"><span class="toc-number">1.16.</span> <span class="toc-text">校验和与CRC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="toc-number">1.16.1.</span> <span class="toc-text">校验和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MapFileAndCheckSum"><span class="toc-number">1.16.1.1.</span> <span class="toc-text">MapFileAndCheckSum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CheckSumMappedFile"><span class="toc-number">1.16.1.2.</span> <span class="toc-text">CheckSumMappedFile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8CCRC"><span class="toc-number">1.16.2.</span> <span class="toc-text">循环冗余校验CRC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x64%E4%B8%8B%E4%B9%A6%E5%86%99%E6%B1%87%E7%BC%96"><span class="toc-number">1.17.</span> <span class="toc-text">x64下书写汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpuid-cpuidex"><span class="toc-number">1.17.1.</span> <span class="toc-text">__cpuid&#x2F;__cpuidex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E4%B8%80"><span class="toc-number">1.17.2.</span> <span class="toc-text">法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E4%BA%8C"><span class="toc-number">1.17.3.</span> <span class="toc-text">法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Detour"><span class="toc-number">1.18.</span> <span class="toc-text">Detour</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DLL%E6%B3%A8%E5%85%A5"><span class="toc-number">1.18.1.</span> <span class="toc-text">DLL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourIsHelperProcess"><span class="toc-number">1.18.1.1.</span> <span class="toc-text">DetourIsHelperProcess</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourRestoreAfterWith"><span class="toc-number">1.18.1.2.</span> <span class="toc-text">DetourRestoreAfterWith</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourTransactionBegin"><span class="toc-number">1.18.1.3.</span> <span class="toc-text">DetourTransactionBegin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourUpdateThread"><span class="toc-number">1.18.1.4.</span> <span class="toc-text">DetourUpdateThread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourDetach"><span class="toc-number">1.18.1.5.</span> <span class="toc-text">DetourDetach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourTransactionCommit"><span class="toc-number">1.18.1.6.</span> <span class="toc-text">DetourTransactionCommit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.18.1.7.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86DLL%E5%8A%A0%E8%BD%BD%E5%88%B0%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.18.2.</span> <span class="toc-text">将DLL加载到目标进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourCreateProcessWithDllEx"><span class="toc-number">1.18.2.1.</span> <span class="toc-text">DetourCreateProcessWithDllEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourCreateProcessWithDlls"><span class="toc-number">1.18.2.2.</span> <span class="toc-text">DetourCreateProcessWithDlls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourAttachEx"><span class="toc-number">1.18.2.3.</span> <span class="toc-text">DetourAttachEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourFindFunction"><span class="toc-number">1.18.2.4.</span> <span class="toc-text">DetourFindFunction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourCodeFromPointer"><span class="toc-number">1.18.2.5.</span> <span class="toc-text">DetourCodeFromPointer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourEnumerateModules"><span class="toc-number">1.18.2.6.</span> <span class="toc-text">DetourEnumerateModules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourGetEntryPoint"><span class="toc-number">1.18.2.7.</span> <span class="toc-text">DetourGetEntryPoint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourEnumerateExports"><span class="toc-number">1.18.2.8.</span> <span class="toc-text">DetourEnumerateExports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourEnumerateImports"><span class="toc-number">1.18.2.9.</span> <span class="toc-text">DetourEnumerateImports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">1.18.2.10.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">1.18.3.</span> <span class="toc-text">编辑可执行文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourBinaryOpen"><span class="toc-number">1.18.3.1.</span> <span class="toc-text">DetourBinaryOpen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourBinarySetPayload"><span class="toc-number">1.18.3.2.</span> <span class="toc-text">DetourBinarySetPayload</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourBinaryFindPayload"><span class="toc-number">1.18.3.3.</span> <span class="toc-text">DetourBinaryFindPayload</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourBinaryDeletePayload-DetourBinaryPurgePayloads"><span class="toc-number">1.18.3.4.</span> <span class="toc-text">DetourBinaryDeletePayload&#x2F;DetourBinaryPurgePayloads</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourBinaryEditImports"><span class="toc-number">1.18.3.5.</span> <span class="toc-text">DetourBinaryEditImports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourBinaryResetImports"><span class="toc-number">1.18.3.6.</span> <span class="toc-text">DetourBinaryResetImports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourBinaryWrite"><span class="toc-number">1.18.3.7.</span> <span class="toc-text">DetourBinaryWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetourBinaryClose"><span class="toc-number">1.18.3.8.</span> <span class="toc-text">DetourBinaryClose</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAT-Hook"><span class="toc-number">1.18.4.</span> <span class="toc-text">IAT Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ImageDirectoryEntryToDataEx"><span class="toc-number">1.18.4.1.</span> <span class="toc-text">ImageDirectoryEntryToDataEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-number">1.18.4.2.</span> <span class="toc-text">例子</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/21/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E7%B3%BB%E7%BB%9F%E9%80%89%E9%A1%B9/" title="Linux编程入门-系统选项">Linux编程入门-系统选项</a><time datetime="2025-06-21T10:55:06.000Z" title="发表于 2025-06-21 18:55:06">2025-06-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/15/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E6%97%B6%E9%97%B4/" title="Linux编程入门-时间">Linux编程入门-时间</a><time datetime="2025-06-15T12:50:21.000Z" title="发表于 2025-06-15 20:50:21">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/15/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8/" title="Linux编程入门-用户管理与安全">Linux编程入门-用户管理与安全</a><time datetime="2025-06-15T02:58:13.000Z" title="发表于 2025-06-15 10:58:13">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/15/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="Linux编程入门-内存管理">Linux编程入门-内存管理</a><time datetime="2025-06-15T01:00:35.000Z" title="发表于 2025-06-15 09:00:35">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/14/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E8%BF%9B%E7%A8%8B/" title="Linux编程入门-进程">Linux编程入门-进程</a><time datetime="2025-06-14T14:02:30.000Z" title="发表于 2025-06-14 22:02:30">2025-06-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>