<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WindowsAPI查缺补漏-WinSock网络编程 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="WindowsAPI查缺补漏-WinSock网络编程碎碎念Windows套接字即WinSock以UNIX的伯克利套接字规范为标准，包含同名接口函数，用法也一致。WinSock结课Windows消息机制又增加了许多扩展函数。 TCP&#x2F;IP规定统一使用大端序传输数据，也称为网络字节顺序。本篇不讲计网，自己去学。 这节内容真是吔屎了...前面基础WinSock编程不支持Unicode还得转，看个乐子就行">
<meta property="og:type" content="article">
<meta property="og:title" content="WindowsAPI查缺补漏-WinSock网络编程">
<meta property="og:url" content="http://monoceros.github.io/2024/07/26/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="WindowsAPI查缺补漏-WinSock网络编程碎碎念Windows套接字即WinSock以UNIX的伯克利套接字规范为标准，包含同名接口函数，用法也一致。WinSock结课Windows消息机制又增加了许多扩展函数。 TCP&#x2F;IP规定统一使用大端序传输数据，也称为网络字节顺序。本篇不讲计网，自己去学。 这节内容真是吔屎了...前面基础WinSock编程不支持Unicode还得转，看个乐子就行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://monoceros.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-07-26T07:48:34.000Z">
<meta property="article:modified_time" content="2024-07-29T12:23:16.057Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="逆向工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://monoceros.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://monoceros.github.io/2024/07/26/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WindowsAPI查缺补漏-WinSock网络编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-29 20:23:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">258</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/ycy')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">WindowsAPI查缺补漏-WinSock网络编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-26T07:48:34.000Z" title="发表于 2024-07-26 15:48:34">2024-07-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-29T12:23:16.057Z" title="更新于 2024-07-29 20:23:16">2024-07-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="WindowsAPI查缺补漏-WinSock网络编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="WindowsAPI查缺补漏-WinSock网络编程"><a href="#WindowsAPI查缺补漏-WinSock网络编程" class="headerlink" title="WindowsAPI查缺补漏-WinSock网络编程"></a>WindowsAPI查缺补漏-WinSock网络编程</h1><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>Windows套接字即WinSock以UNIX的伯克利套接字规范为标准，包含同名接口函数，用法也一致。WinSock结课Windows消息机制又增加了许多扩展函数。</p>
<p>TCP/IP规定统一使用大端序传输数据，也称为网络字节顺序。本篇不讲计网，自己去学。</p>
<p>这节内容真是吔屎了...前面基础WinSock编程不支持Unicode还得转，看个乐子就行了，重点在后面I/O模型。</p>
<p>代码例子有ANSI和Unicode混用的情况，纯属懒得改了，用的时候小心点儿。</p>
<p>本篇只讲TCP和UDP连接，想学HTTP啥的可以关上了。</p>
<p>学习本篇需要智商在线，不在线的先去听《大香蕉》洗一下脑子。</p>
<h2 id="地址表示"><a href="#地址表示" class="headerlink" title="地址表示"></a>地址表示</h2><p>在sockaddr_in结构中同时指定IP地址和端口号。下文定义中出现sockaddr结构的均是为了兼容1.0旧版本，都可以当作sockaddr_in使。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">	SHORT sin_family; <span class="comment">//地址家族 AF_INET</span></span><br><span class="line">	USHORT sin_port; <span class="comment">//端口号</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">//IP地址</span></span><br><span class="line">	CHAR sin_zero[<span class="number">8</span>]; <span class="comment">//0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于sin_port要转为网络字节顺序，有以下函数可借助使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u_short <span class="title">htons</span><span class="params">(u_short hostshort)</span></span>; <span class="comment">//把u_short型从主机字节顺序转换为TCP/IP网络字节顺序</span></span><br><span class="line"><span class="function">u_long <span class="title">htonl</span><span class="params">(u_long hostlong)</span></span>; <span class="comment">//把u_long型从主机字节顺序转换为TCP/IP网络字节顺序</span></span><br><span class="line"><span class="function">u_short <span class="title">ntohs</span><span class="params">(u_short netshort)</span></span>; <span class="comment">//把u_short型从TCP/IP网络字节顺序转换为主机字节顺序</span></span><br><span class="line"><span class="function">u_long <span class="title">ntohl</span><span class="params">(u_long netlong)</span></span>; <span class="comment">//把u_long型从TCP/IP网络字节顺序转换为主机字节顺序</span></span><br></pre></td></tr></table></figure>
<p>in_addr结构用来表示IP地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			u_char s_b1, s_b2, s_b3, s_b4; <span class="comment">//4个u_char表示IP地址</span></span><br><span class="line">		&#125;S_un_b;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			u_short s_w1, s_w2; <span class="comment">//2个u_short表示IP地址</span></span><br><span class="line">		&#125;S_un_w;</span><br><span class="line">		u_long S_addr; <span class="comment">//1个u_long表示IP地址</span></span><br><span class="line">	&#125;S_un;</span><br><span class="line">&#125;IN_ADDR,*PIN_ADDR,FAR *LPIN_ADDR;</span><br></pre></td></tr></table></figure>
<p>常用函数有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典版</span></span><br><span class="line"><span class="function">ULONG <span class="title">inet_addr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ CONST PCHAR cp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//把IP地址字符串转为网络字节序u_long型</span></span><br><span class="line"><span class="function">PCHAR FAR <span class="title">inet_ntoa</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ <span class="keyword">struct</span> in_addr in</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//把一个in_addr转换为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新版</span></span><br><span class="line"><span class="function">INT WSAAPI <span class="title">InetPton</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	INT Family, <span class="comment">//地址家族</span></span></span></span><br><span class="line"><span class="params"><span class="function">	PCTSTR pszAddrString, <span class="comment">//IP地址字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID pAddrBuf <span class="comment">//返回网络字节顺序IP地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">PCTSTR WSAAPI <span class="title">InetNtop</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	INT Family, <span class="comment">//地址家族</span></span></span></span><br><span class="line"><span class="params"><span class="function">	CONST PVOID pAddr, <span class="comment">//网络字节顺序IP地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">	PTSTR pStringBuf, <span class="comment">//返回IP地址字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T StringBufSize <span class="comment">//缓冲区长度 单位字符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>常用的初始化方法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典版</span></span><br><span class="line">sockaddr_in sockAddr;</span><br><span class="line">sockAddr.sin_family = AF_INET;</span><br><span class="line">sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">12345</span>);</span><br><span class="line">sockAddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//新版</span></span><br><span class="line">sockaddr_in sockAddr;</span><br><span class="line">sockAddr.sin_family = AF_INET;</span><br><span class="line">sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">12345</span>);</span><br><span class="line"><span class="built_in">InetPton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;sockAddr.sin_addr.S_un.S_addr);</span><br></pre></td></tr></table></figure>
<h2 id="WinSock网络编程"><a href="#WinSock网络编程" class="headerlink" title="WinSock网络编程"></a>WinSock网络编程</h2><h3 id="WSAStartup"><a href="#WSAStartup" class="headerlink" title="WSAStartup"></a>WSAStartup</h3><p>初始化WinSock库：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">WSAStartup</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ WORD wVersionRequested, <span class="comment">//希望使用的socket版本</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPWSADATA lpWSAData <span class="comment">//返回动态链接库详细信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回0</span></span><br></pre></td></tr></table></figure>
<p>wVersionRequested高字节为副版本号，低字节为主版本号。目前WinSock版本为2.2，需要包含WinSock2.h、用DLL为Ws2_32.dll，但Ws2_32.lib在VS中没有得自己搞。</p>
<p>lpWSAData有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">WSAData</span> &#123;</span><br><span class="line">	WORD                    wVersion; <span class="comment">//希望程序使用的WinSock版本</span></span><br><span class="line">	WORD                    wHighVersion; <span class="comment">//实际可支持的最高WinSock版本</span></span><br><span class="line">	USHORT                  iMaxSockets; <span class="comment">//已废弃</span></span><br><span class="line">	USHORT                  iMaxUdpDg; <span class="comment">//已废弃</span></span><br><span class="line">	CHAR FAR*               lpVendorInfo; <span class="comment">//已废弃</span></span><br><span class="line">	CHAR                    szDescription[WSADESCRIPTION_LEN + <span class="number">1</span>]; <span class="comment">//返回对WinSock实现的描述</span></span><br><span class="line">	CHAR                    szSystemStatus[WSASYS_STATUS_LEN + <span class="number">1</span>]; <span class="comment">//返回相对状态或配置信息</span></span><br><span class="line">&#125; WSADATA;</span><br></pre></td></tr></table></figure>
<p>例如常用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;Ws2_32&quot;</span>)</span></span><br><span class="line"><span class="function">INT <span class="title">main</span><span class="params">(INT argc, PTCHAR argv[])</span> </span>&#123;</span><br><span class="line">	WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//WinSock初始化失败</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="WSACleanup"><a href="#WSACleanup" class="headerlink" title="WSACleanup"></a>WSACleanup</h3><p>释放WinSock资源：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">WSACleanup</span><span class="params">(VOID)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>创建套接字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET WSAAPI <span class="title">socket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT af, <span class="comment">//地址家族</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT type, <span class="comment">//套接字类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT protocol <span class="comment">//协议类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回新建套接字句柄 错误INVALID_SOCKET 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<p>对于af有AF_INET或AF_INET6，分别为IPv4或IPv6。type常用的有：SOCK_STREAM流式套接字，只能读取TCP包；SOCK_DGRAM数据报套接字，只能读取UDP包；SOCK_RAW原始套接字，可读写内核未处理的IP包，能对网络底层传输机制进行控制。protocal需要配合type使用，有IPPROTO_TCP、IPPROTO_UDP等，为0表示t自动选择ype对应的默认协议。</p>
<p>Windows对原始套接字搞了一堆安全限制，这玩意儿容易被蠕虫用上。</p>
<p>例如常用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SOCKET socketListen = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (socketListen == INVALID_SOCKET) &#123;</span><br><span class="line">	<span class="comment">//创建套接字失败</span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="closesocket"><a href="#closesocket" class="headerlink" title="closesocket"></a>closesocket</h3><p>关闭套接字资源：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">closesocket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>将本地地址与监听套接字关联起来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//监听套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ CONST <span class="keyword">struct</span> sockaddr FAR* name, <span class="comment">//sockaddr_in结构地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT namelen <span class="comment">//sockaddr_in结构长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回0 失败SOCKET_ERROR 用WSAGetLastError获取错误信息</span></span><br></pre></td></tr></table></figure>
<p>例如常用方法如下，当<code>sockAddr.sin_addr.S_un.S_addr</code>为INADDR_ANY表示在本机所有IP地址上进行监听，多网卡时很好使，端口号设为0表示系统自动分配唯一端口号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(socketListen, (sockaddr*)&amp;sockAddr, <span class="built_in">sizeof</span>(sockAddr)) == SOCKET_ERROR) &#123;</span><br><span class="line">	<span class="comment">//绑定失败</span></span><br><span class="line">	<span class="built_in">closesocket</span>(socketListen);</span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="getsockname"><a href="#getsockname" class="headerlink" title="getsockname"></a>getsockname</h3><p>获取分配给监听套接字的地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">getsockname</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ <span class="keyword">struct</span> sockaddr* name, <span class="comment">//返回地址信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PINT namelen <span class="comment">//结构体长 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回0 失败SOCEKT_ERROR 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><p>使主动连接套接字变为被动连接套接字，使一个进程可接收其他进程请求，变成一个服务器进程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">listen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//监听套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT backlog <span class="comment">//连接队列最大长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回0 失败SOCKET_ERROR 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<p>backlog设为SOMAXCONN表示系统将其设为最大合理值，队列满后拒绝新连接请求并出现错误WSAECONNREFUSED。例如常用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(socketListen, SOMAXCONN) == SOCKET_ERROR) &#123;</span><br><span class="line">	<span class="comment">//进入监听状态失败</span></span><br><span class="line">	<span class="built_in">closesocket</span>(socketListen);</span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p>从套接字等待连接队列中抽取第一个连接并接受，成功则返回一个套接字句柄用于实际通信，原监听套接字仍保持监听状态。失败返回INVALID_SOCKET，用<code>WSAGetLastError</code>获取错误代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//监听套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ <span class="keyword">struct</span> sockaddr* addr, <span class="comment">//返回客户端地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PINT addrlen <span class="comment">//结构体长</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当队列中无等待连接时该函数阻塞调用进程直至新进程出现后才返回，所以一般新建进程负责通信。但这样也不合理，最好用I/O异步模型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in sockAddrClient;</span><br><span class="line">INT nAddrlen = <span class="built_in">sizeof</span>(sockAddrClient);</span><br><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">	socketAccept = <span class="built_in">accept</span>(socektListen, (sockaddr*)&amp;sockAddrClient, &amp;nAddrlen);</span><br><span class="line">	<span class="keyword">if</span> (socketAccept == INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="comment">//接受连接请求失败</span></span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="send-recv"><a href="#send-recv" class="headerlink" title="send/recv"></a>send/recv</h3><p>在已连接的套接字上发送/接收数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//已连接的通信套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ CONST PCHAR buf, <span class="comment">//要发送数据的缓冲区指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT len, <span class="comment">//缓冲区长度 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT flags <span class="comment">//0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回发送字节数 超过len则返回SOCKET_ERROR 用WSAGetLastError获取错误代码</span></span><br><span class="line"><span class="function">INT <span class="title">recv</span><span class="params">( <span class="comment">//都同上</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ PCHAR buf,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT len,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT flags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>与服务器建立连接：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//通信套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ CONST <span class="keyword">struct</span> sockaddr* name, <span class="comment">//服务器套接字</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT namelen <span class="comment">//name结构长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回0 失败SOCKET_ERROR 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<h3 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h3><p>向指定目的地发送数据，适用于UDP：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">sendto</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ CONST PCHAR buf, <span class="comment">//要发送数据缓冲区指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT len, <span class="comment">//缓冲区长度 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT flags, <span class="comment">//0</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ CONST <span class="keyword">struct</span> sockaddr* to, <span class="comment">//目的地地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT tolen <span class="comment">//结构体长</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//返回发送字节数 大于len返回SOCKET_ERROR 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<h3 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h3><p>接收数据报，返回源地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">recvfrom</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ PCHAR buf, <span class="comment">//接收数据缓冲区指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT len, <span class="comment">//缓冲区长度 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT flags, <span class="comment">//0</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ <span class="keyword">struct</span> sockaddr* from, <span class="comment">//返回源地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PINT fromlen <span class="comment">//结构体长</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//返回接收到的字节数 连接已被关闭返回0 失败SOCKET_ERROR 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<h3 id="例子：TCP"><a href="#例子：TCP" class="headerlink" title="例子：TCP"></a>例子：TCP</h3><p>下面这个例子用的ANSI编码，看看就行了，重点在后面。</p>
<p>服务端源文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>           <span class="comment">// Winsock2头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span>           <span class="comment">// inet_pton / inet_ntop需要使用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32&quot;</span>)  <span class="comment">// Winsock2导入库</span></span></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwnd;            <span class="comment">// 窗口句柄</span></span><br><span class="line">HWND g_hListContent;    <span class="comment">// 聊天内容列表框窗口句柄</span></span><br><span class="line">HWND g_hEditMsg;        <span class="comment">// 消息输入框窗口句柄</span></span><br><span class="line">HWND g_hBtnSend;        <span class="comment">// 发送按钮窗口句柄</span></span><br><span class="line">SOCKET g_socketListen = INVALID_SOCKET;   <span class="comment">// 监听套接字句柄</span></span><br><span class="line">SOCKET g_socketAccept = INVALID_SOCKET;   <span class="comment">// 通信套接字句柄</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 对话框初始化</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span></span>;</span><br><span class="line"><span class="comment">// 按下启动服务按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 按下发送按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 服务器接收数据线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">RecvProc</span><span class="params">(LPVOID lpParam)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_SERVER_DIALOG), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="built_in">OnInit</span>(hwndDlg);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="comment">// 关闭套接字，释放WinSock库</span></span><br><span class="line">                    <span class="keyword">if</span> (g_socketAccept != INVALID_SOCKET)</span><br><span class="line">                        <span class="built_in">closesocket</span>(g_socketAccept);</span><br><span class="line">                    <span class="keyword">if</span> (g_socketListen != INVALID_SOCKET)</span><br><span class="line">                        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">                    <span class="built_in">WSACleanup</span>();</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, IDCANCEL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_START: &#123;</span><br><span class="line">                    <span class="built_in">OnStart</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SEND: &#123;</span><br><span class="line">                    <span class="built_in">OnSend</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span> </span>&#123;</span><br><span class="line">    g_hwnd = hwndDlg;</span><br><span class="line">    g_hListContent = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_LIST_CONTENT);</span><br><span class="line">    g_hEditMsg = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_MSG);</span><br><span class="line">    g_hBtnSend = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_BTN_SEND);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 1、初始化WinSock库</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;初始化WinSock库失败！&quot;</span>, <span class="string">&quot;WSAStartup Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 2、创建用于监听所有客户端请求的套接字</span></span><br><span class="line">    g_socketListen = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_socketListen == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;创建监听套接字失败！&quot;</span>, <span class="string">&quot;socket Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 3、将监听套接字与指定的IP地址、端口号捆绑</span></span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    sockAddr.sin_family = AF_INET;</span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">    sockAddr.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(g_socketListen, (sockaddr*)&amp;sockAddr, <span class="built_in">sizeof</span>(sockAddr)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;将监听套接字与指定的IP地址、端口号捆绑失败！&quot;</span>, <span class="string">&quot;bind Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 4、使监听套节字进入监听(等待被连接)状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(g_socketListen, <span class="number">1</span>) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;使监听套节字进入监听(等待被连接)状态失败！&quot;</span>, <span class="string">&quot;listen Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 服务器监听中...</span></span><br><span class="line">    <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;服务器监听中...&quot;</span>, <span class="string">&quot;服务启动成功&quot;</span>, MB_OK);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(<span class="built_in">GetDlgItem</span>(g_hwnd, IDC_BTN_START), FALSE);</span><br><span class="line">    <span class="comment">// 5、等待连接请求，返回用于服务器客户端通信的套接字句柄</span></span><br><span class="line">    sockaddr_in sockAddrClient;             <span class="comment">// 调用accept返回客户端的IP地址、端口号</span></span><br><span class="line">    <span class="type">int</span> nAddrlen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">    g_socketAccept = <span class="built_in">accept</span>(g_socketListen, (sockaddr*)&amp;sockAddrClient, &amp;nAddrlen);</span><br><span class="line">    <span class="keyword">if</span> (g_socketAccept == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;接受连接请求失败！&quot;</span>, <span class="string">&quot;accept Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 6、接受客户的连接请求成功，收发数据</span></span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szIP[<span class="number">24</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;sockAddrClient.sin_addr.S_un.S_addr, szIP, _countof(szIP));</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szBuf, <span class="string">&quot;客户端[%s:%d]已连接！&quot;</span>, szIP, <span class="built_in">ntohs</span>(sockAddrClient.sin_port));</span><br><span class="line">    <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, TRUE);</span><br><span class="line">    <span class="comment">// 创建线程，接收客户端数据</span></span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, RecvProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szShow[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetWindowTextA</span>(g_hEditMsg, szBuf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szShow, <span class="string">&quot;服务器说：%s&quot;</span>, szBuf);</span><br><span class="line">    <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szShow);</span><br><span class="line">    <span class="built_in">send</span>(g_socketAccept, szShow, <span class="built_in">strlen</span>(szShow), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">SetWindowTextA</span>(g_hEditMsg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">RecvProc</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> nRet = SOCKET_ERROR;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">        nRet = <span class="built_in">recv</span>(g_socketAccept, szBuf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nRet &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 收到客户端数据</span></span><br><span class="line">            <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户端源文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>           <span class="comment">// WinSock2头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span>           <span class="comment">// inet_pton / inet_ntop需要使用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32&quot;</span>)  <span class="comment">// WinSock2导入库</span></span></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwnd;            <span class="comment">// 窗口句柄</span></span><br><span class="line">HWND g_hListContent;    <span class="comment">// 聊天内容列表框窗口句柄</span></span><br><span class="line">HWND g_hEditMsg;        <span class="comment">// 消息输入框窗口句柄</span></span><br><span class="line">HWND g_hBtnSend;        <span class="comment">// 发送按钮窗口句柄</span></span><br><span class="line">SOCKET g_socketClient = INVALID_SOCKET; <span class="comment">// 通信套接字句柄</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 对话框初始化</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span></span>;</span><br><span class="line"><span class="comment">// 按下连接按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnConnect</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 按下发送按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 客户端接收数据线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">RecvProc</span><span class="params">(LPVOID lpParam)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_CLIENT_DIALOG), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="built_in">OnInit</span>(hwndDlg);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="comment">// 关闭套接字，释放WinSock库</span></span><br><span class="line">                    <span class="keyword">if</span> (g_socketClient != INVALID_SOCKET)</span><br><span class="line">                        <span class="built_in">closesocket</span>(g_socketClient);</span><br><span class="line">                    <span class="built_in">WSACleanup</span>();</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, IDCANCEL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_CONNECT: &#123;</span><br><span class="line">                    <span class="built_in">OnConnect</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SEND: &#123;</span><br><span class="line">                    <span class="built_in">OnSend</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span> </span>&#123;</span><br><span class="line">    g_hwnd = hwndDlg;</span><br><span class="line">    g_hListContent = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_LIST_CONTENT);</span><br><span class="line">    g_hEditMsg = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_MSG);</span><br><span class="line">    g_hBtnSend = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_BTN_SEND);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 按下连接按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    sockaddr_in sockAddrServer;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 1、初始化WinSock库</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;初始化WinSock库失败！&quot;</span>, <span class="string">&quot;WSAStartup Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 2、创建与服务器的通信套接字</span></span><br><span class="line">    g_socketClient = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_socketClient == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;创建与服务器的通信套接字失败！&quot;</span>, <span class="string">&quot;socket Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 3、与服务器建立连接</span></span><br><span class="line">    sockAddrServer.sin_family = AF_INET;</span><br><span class="line">    sockAddrServer.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;sockAddrServer.sin_addr.S_un.S_addr);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(g_socketClient, (sockaddr*)&amp;sockAddrServer, <span class="built_in">sizeof</span>(sockAddrServer)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;与服务器建立连接失败！&quot;</span>, <span class="string">&quot;connect Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketClient);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 4、建立连接成功，收发数据</span></span><br><span class="line">    <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">&quot;已连接到服务器！&quot;</span>);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(<span class="built_in">GetDlgItem</span>(g_hwnd, IDC_BTN_CONNECT), FALSE);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, TRUE);</span><br><span class="line">    <span class="comment">// 创建线程，接收服务器数据</span></span><br><span class="line">    <span class="keyword">if</span> ((hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, RecvProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 按下发送按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szShow[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetWindowTextA</span>(g_hEditMsg, szBuf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szShow, <span class="string">&quot;客户端说：%s&quot;</span>, szBuf);</span><br><span class="line">    <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szShow);</span><br><span class="line">    <span class="built_in">send</span>(g_socketClient, szShow, <span class="built_in">strlen</span>(szShow), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">SetWindowTextA</span>(g_hEditMsg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">RecvProc</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> nRet = SOCKET_ERROR;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">        nRet = <span class="built_in">recv</span>(g_socketClient, szBuf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nRet &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 收到服务器数据</span></span><br><span class="line">            <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例子：UDP"><a href="#例子：UDP" class="headerlink" title="例子：UDP"></a>例子：UDP</h3><p>服务端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>           <span class="comment">// WinSock2头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span>           <span class="comment">// inet_pton inet_ntop需要使用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32&quot;</span>)  <span class="comment">// WinSock2导入库</span></span></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SOCKET socketSendRecv = INVALID_SOCKET; <span class="comment">// 服务器的收发数据套接字</span></span><br><span class="line">    sockaddr_in addrServer, addrClient;     <span class="comment">// 服务器、客户端地址</span></span><br><span class="line">    <span class="type">int</span> nAddrLen = <span class="built_in">sizeof</span>(sockaddr_in);     <span class="comment">// sockaddr_in结构体的长度</span></span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;           <span class="comment">// 接收数据缓冲区</span></span><br><span class="line">    CHAR szIP[<span class="number">24</span>] = &#123; <span class="number">0</span> &#125;;                  <span class="comment">// 客户端IP地址</span></span><br><span class="line">    <span class="comment">// 初始化WinSock库</span></span><br><span class="line">    <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa);</span><br><span class="line">    <span class="comment">// 创建收发数据套接字</span></span><br><span class="line">    socketSendRecv = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">    <span class="comment">// 将收发数据套接字绑定到任意IP地址和指定端口</span></span><br><span class="line">    addrServer.sin_family = AF_INET;</span><br><span class="line">    addrServer.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">    addrServer.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">    <span class="built_in">bind</span>(socketSendRecv, (SOCKADDR*)&amp;addrServer, <span class="built_in">sizeof</span>(addrServer));</span><br><span class="line">    <span class="comment">// 从客户端接收数据，recvfrom函数会在参数addrClient中返回客户端的IP地址和端口号</span></span><br><span class="line">    <span class="built_in">recvfrom</span>(socketSendRecv, szBuf, BUF_SIZE, <span class="number">0</span>, (SOCKADDR*)&amp;addrClient, &amp;nAddrLen);</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;addrClient.sin_addr.S_un.S_addr, szIP, _countof(szIP));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从客户端[%s:%d]接收到数据：%s\n&quot;</span>, szIP, <span class="built_in">ntohs</span>(addrClient.sin_port), szBuf);</span><br><span class="line">    <span class="comment">// 把收到的数据发送回去</span></span><br><span class="line">    <span class="built_in">sendto</span>(socketSendRecv, szBuf, <span class="built_in">strlen</span>(szBuf), <span class="number">0</span>, (SOCKADDR*)&amp;addrClient, nAddrLen);</span><br><span class="line">    <span class="comment">// 关闭收发数据套接字，释放WinSock库</span></span><br><span class="line">    <span class="built_in">closesocket</span>(socketSendRecv);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>           <span class="comment">// WinSock2头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span>           <span class="comment">// inet_pton inet_ntop需要使用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32&quot;</span>)  <span class="comment">// WinSock2导入库</span></span></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SOCKET socketSendRecv = INVALID_SOCKET; <span class="comment">// 客户端的收发数据套接字</span></span><br><span class="line">    sockaddr_in addrServer;                 <span class="comment">// 服务器地址</span></span><br><span class="line">    <span class="type">int</span> nAddrLen = <span class="built_in">sizeof</span>(sockaddr_in);     <span class="comment">// sockaddr_in结构体的长度</span></span><br><span class="line">    CHAR szBuf[BUF_SIZE] = <span class="string">&quot;你好，老王！&quot;</span>;  <span class="comment">// 发送数据缓冲区</span></span><br><span class="line">    CHAR szIP[<span class="number">24</span>] = &#123; <span class="number">0</span> &#125;;                  <span class="comment">// 服务器IP地址</span></span><br><span class="line">    <span class="comment">// 初始化WinSock库</span></span><br><span class="line">    <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa);</span><br><span class="line">    <span class="comment">// 创建收发数据套接字</span></span><br><span class="line">    socketSendRecv = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">    <span class="comment">// 向服务器发送数据</span></span><br><span class="line">    addrServer.sin_family = AF_INET;</span><br><span class="line">    addrServer.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addrServer.sin_addr.S_un.S_addr);</span><br><span class="line">    <span class="built_in">sendto</span>(socketSendRecv, szBuf, <span class="built_in">strlen</span>(szBuf), <span class="number">0</span>, (SOCKADDR*)&amp;addrServer, nAddrLen);</span><br><span class="line">    <span class="comment">// 从服务器接收数据</span></span><br><span class="line">    sockaddr_in addr;   <span class="comment">// 看一下recvfrom返回的服务器IP地址和端口号</span></span><br><span class="line">    <span class="built_in">ZeroMemory</span>(szBuf, <span class="built_in">sizeof</span>(szBuf));</span><br><span class="line">    <span class="built_in">recvfrom</span>(socketSendRecv, szBuf, BUF_SIZE, <span class="number">0</span>, (sockaddr*)&amp;addr, &amp;nAddrLen);</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;addr.sin_addr.S_un.S_addr, szIP, _countof(szIP));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从服务器[%s:%d]返回数据：%s\n&quot;</span>, szIP, <span class="built_in">ntohs</span>(addr.sin_port), szBuf);</span><br><span class="line">    <span class="comment">// 关闭收发数据套接字，释放WinSock库</span></span><br><span class="line">    <span class="built_in">closesocket</span>(socketSendRecv);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h2><h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><h4 id="ioctlsocket"><a href="#ioctlsocket" class="headerlink" title="ioctlsocket"></a>ioctlsocket</h4><p>使套接字工作在非阻塞模式下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">ioctlsocket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LONG cmd, <span class="comment">//执行的命令</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PULONG argp <span class="comment">//指向cmd参数的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回0 失败SOCKET_ERROR 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<p>cmd有FIONBIO、FIONREAD、SIOCATMARK等参数，自己去学。</p>
<p>例如设置为非阻塞模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ULONG ulArgp = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">ioctlsocket</span>(socketListen, FIONBIO, &amp;ulArgp); <span class="comment">//argp为非0即可 恢复设置为0</span></span><br></pre></td></tr></table></figure>
<p>此后每次发送、接收或管理连接时大多会因操作还未完成而失败，<code>WSAGetLastError</code>返回WSAEWOULDBLOCK，则需要多次调用直到返回成功。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>数据结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// 套接字对象链表所用结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SOCKETOBJ</span>&#123;</span><br><span class="line">    SOCKET      m_socket;   <span class="comment">// 通信套接字句柄</span></span><br><span class="line">    CHAR        m_szIP[<span class="number">16</span>]; <span class="comment">// 客户端IP</span></span><br><span class="line">    USHORT      m_usPort;   <span class="comment">// 客户端端口号</span></span><br><span class="line">    _SOCKETOBJ  *m_pNext;   <span class="comment">// 下一个套接字对象结构体指针</span></span><br><span class="line">&#125;SOCKETOBJ, *PSOCKETOBJ;</span><br><span class="line">PSOCKETOBJ g_pSocketObjHeader;  <span class="comment">// 套接字对象链表表头</span></span><br><span class="line"><span class="type">int</span> g_nTotalClient;             <span class="comment">// 客户端总数量</span></span><br><span class="line">CRITICAL_SECTION g_cs;          <span class="comment">// 临界区对象，用于同步对套接字对象链表的操作</span></span><br><span class="line"><span class="comment">// 创建一个套接字对象</span></span><br><span class="line"><span class="function">PSOCKETOBJ <span class="title">CreateSocketObj</span><span class="params">(SOCKET s)</span> </span>&#123;</span><br><span class="line">    PSOCKETOBJ pSocketObj = <span class="keyword">new</span> SOCKETOBJ;</span><br><span class="line">    <span class="keyword">if</span> (pSocketObj == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">EnterCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    pSocketObj-&gt;m_socket = s;</span><br><span class="line">    <span class="comment">// 添加第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (g_pSocketObjHeader == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        g_pSocketObjHeader = pSocketObj;</span><br><span class="line">        g_pSocketObjHeader-&gt;m_pNext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pSocketObj-&gt;m_pNext = g_pSocketObjHeader;</span><br><span class="line">        g_pSocketObjHeader = pSocketObj;</span><br><span class="line">    &#125;;</span><br><span class="line">    g_nTotalClient++;</span><br><span class="line">    <span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    <span class="keyword">return</span> pSocketObj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 释放一个套接字对象</span></span><br><span class="line"><span class="function">VOID <span class="title">FreeSocketObj</span><span class="params">(PSOCKETOBJ pSocketObj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">EnterCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    PSOCKETOBJ p = g_pSocketObjHeader;</span><br><span class="line">    <span class="keyword">if</span> (p == pSocketObj)    <span class="comment">// 移除的是头结点</span></span><br><span class="line">        g_pSocketObjHeader = g_pSocketObjHeader-&gt;m_pNext;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;m_pNext == pSocketObj) &#123;</span><br><span class="line">                p-&gt;m_pNext = pSocketObj-&gt;m_pNext;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            p = p-&gt;m_pNext;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">if</span> (pSocketObj-&gt;m_socket != INVALID_SOCKET)</span><br><span class="line">        <span class="built_in">closesocket</span>(pSocketObj-&gt;m_socket);</span><br><span class="line">    <span class="keyword">delete</span> pSocketObj;</span><br><span class="line">    g_nTotalClient--;</span><br><span class="line">    <span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 根据套接字查找套接字对象</span></span><br><span class="line"><span class="function">PSOCKETOBJ <span class="title">FindSocketObj</span><span class="params">(SOCKET s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">EnterCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    PSOCKETOBJ pSocketObj = g_pSocketObjHeader;</span><br><span class="line">    <span class="keyword">while</span> (pSocketObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pSocketObj-&gt;m_socket == s) &#123;</span><br><span class="line">            <span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);</span><br><span class="line">            <span class="keyword">return</span> pSocketObj;</span><br><span class="line">        &#125;;</span><br><span class="line">        pSocketObj = pSocketObj-&gt;m_pNext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 释放所有套接字对象</span></span><br><span class="line"><span class="function">VOID <span class="title">DeleteAllSocketObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SOCKETOBJ socketObj;</span><br><span class="line">    PSOCKETOBJ pSocketObj = g_pSocketObjHeader;</span><br><span class="line">    <span class="keyword">while</span> (pSocketObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        socketObj = *pSocketObj;</span><br><span class="line">        <span class="keyword">if</span> (pSocketObj-&gt;m_socket != INVALID_SOCKET)</span><br><span class="line">            <span class="built_in">closesocket</span>(pSocketObj-&gt;m_socket);</span><br><span class="line">        <span class="keyword">delete</span> pSocketObj;</span><br><span class="line">        pSocketObj = socketObj.m_pNext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>服务端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>           <span class="comment">// Winsock2头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span>           <span class="comment">// inet_pton / inet_ntop需要使用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SOCKETOBJ.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32&quot;</span>)  <span class="comment">// Winsock2导入库</span></span></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwnd;            <span class="comment">// 窗口句柄</span></span><br><span class="line">HWND g_hListContent;    <span class="comment">// 聊天内容列表框窗口句柄</span></span><br><span class="line">HWND g_hEditMsg;        <span class="comment">// 消息输入框窗口句柄</span></span><br><span class="line">HWND g_hBtnSend;        <span class="comment">// 发送按钮窗口句柄</span></span><br><span class="line">SOCKET g_socketListen = INVALID_SOCKET;   <span class="comment">// 监听套接字句柄</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 对话框初始化</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span></span>;</span><br><span class="line"><span class="comment">// 按下启动服务按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 按下发送按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 服务器接收每一个客户端数据的线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">RecvProc</span><span class="params">(LPVOID lpParam)</span></span>;</span><br><span class="line"><span class="comment">// 循环等待客户端连接请求的线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">AcceptProc</span><span class="params">(LPVOID lpParam)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_SERVER_DIALOG), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="built_in">OnInit</span>(hwndDlg);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="comment">// 关闭套接字，释放WinSock库</span></span><br><span class="line">                    <span class="keyword">if</span> (g_socketListen != INVALID_SOCKET)</span><br><span class="line">                        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">                    <span class="built_in">WSACleanup</span>();</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, IDCANCEL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_START: &#123;</span><br><span class="line">                    <span class="built_in">OnStart</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SEND: &#123;</span><br><span class="line">                    <span class="built_in">OnSend</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span> </span>&#123;</span><br><span class="line">    WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 1、初始化WinSock库</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;初始化WinSock库失败！&quot;</span>, <span class="string">&quot;WSAStartup Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 初始化临界区对象，用于同步对套接字对象的访问</span></span><br><span class="line">    <span class="built_in">InitializeCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    g_hwnd = hwndDlg;</span><br><span class="line">    g_hListContent = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_LIST_CONTENT);</span><br><span class="line">    g_hEditMsg = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_MSG);</span><br><span class="line">    g_hBtnSend = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_BTN_SEND);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2、创建用于监听所有客户端请求的套接字</span></span><br><span class="line">    g_socketListen = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_socketListen == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;创建监听套接字失败！&quot;</span>, <span class="string">&quot;socket Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 3、将监听套接字与指定的IP地址、端口号捆绑</span></span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    sockAddr.sin_family = AF_INET;</span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">    sockAddr.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(g_socketListen, (sockaddr*)&amp;sockAddr, <span class="built_in">sizeof</span>(sockAddr)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;将监听套接字与指定的IP地址、端口号捆绑失败！&quot;</span>,<span class="string">&quot;bind Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 4、使监听套节字进入监听(等待被连接)状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(g_socketListen, SOMAXCONN) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;使监听套节字进入监听(等待被连接)状态失败！&quot;</span>, <span class="string">&quot;listen Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 服务器监听中...</span></span><br><span class="line">    <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;服务器监听中...&quot;</span>, <span class="string">&quot;服务启动成功&quot;</span>, MB_OK);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(<span class="built_in">GetDlgItem</span>(g_hwnd, IDC_BTN_START), FALSE);</span><br><span class="line">    <span class="comment">// 5、创建一个新线程循环等待连接请求</span></span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, AcceptProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szMsg[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetWindowTextA</span>(g_hEditMsg, szBuf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;服务器说：%s&quot;</span>, szBuf);</span><br><span class="line">    <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">    <span class="built_in">SetWindowTextA</span>(g_hEditMsg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 向每一个客户端发送数据</span></span><br><span class="line">    PSOCKETOBJ p = g_pSocketObjHeader;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">send</span>(p-&gt;m_socket, szMsg, <span class="built_in">strlen</span>(szMsg), <span class="number">0</span>);</span><br><span class="line">        p = p-&gt;m_pNext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">RecvProc</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    SOCKET socketAccept = (SOCKET)lpParam;</span><br><span class="line">    PSOCKETOBJ pSocketObj = <span class="built_in">FindSocketObj</span>(socketAccept);</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;           <span class="comment">// 接收数据缓冲区</span></span><br><span class="line">    CHAR szMsg[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> nRet = SOCKET_ERROR;                <span class="comment">// I/O操作返回值</span></span><br><span class="line">    PSOCKETOBJ p;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">        nRet = <span class="built_in">recv</span>(socketAccept, szBuf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nRet &gt; <span class="number">0</span>) &#123;  <span class="comment">// 接收到客户端数据</span></span><br><span class="line">            <span class="built_in">ZeroMemory</span>(szMsg, BUF_SIZE);    <span class="comment">// 组合为 客户端[XXX.XXX.XXX.<span class="doctag">XXX:</span>XXXX]说：......</span></span><br><span class="line">            <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;客户端[%s:%d]说：%s&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort, szBuf);</span><br><span class="line">            <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">            <span class="comment">// 把收到的数据分发到每一个客户端</span></span><br><span class="line">            p = g_pSocketObjHeader;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;m_socket != socketAccept)</span><br><span class="line">                    <span class="built_in">send</span>(p-&gt;m_socket, szMsg, <span class="built_in">strlen</span>(szMsg), <span class="number">0</span>);</span><br><span class="line">                p = p-&gt;m_pNext;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;         <span class="comment">// 连接已关闭</span></span><br><span class="line">            <span class="built_in">ZeroMemory</span>(szMsg, BUF_SIZE);    <span class="comment">// 组合为 客户端[XXX.XXX.XXX.<span class="doctag">XXX:</span>XXXX] 已退出！</span></span><br><span class="line">            <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;客户端[%s:%d] 已退出！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">            <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">            <span class="built_in">FreeSocketObj</span>(pSocketObj);</span><br><span class="line">            <span class="comment">// 如果没有客户端在线了，禁用发送按钮</span></span><br><span class="line">            <span class="keyword">if</span> (g_nTotalClient == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">AcceptProc</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    SOCKET socketAccept = INVALID_SOCKET;   <span class="comment">// 通信套接字句柄</span></span><br><span class="line">    sockaddr_in sockAddrClient;</span><br><span class="line">    <span class="type">int</span> nAddrlen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        socketAccept = <span class="built_in">accept</span>(g_socketListen, (sockaddr*)&amp;sockAddrClient, &amp;nAddrlen);</span><br><span class="line">        <span class="keyword">if</span> (socketAccept == INVALID_SOCKET) &#123;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 6、接受客户的连接请求成功</span></span><br><span class="line">        <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">        <span class="comment">// 创建一个套接字对象，保存客户端IP地址、端口号</span></span><br><span class="line">        PSOCKETOBJ pSocketObj = <span class="built_in">CreateSocketObj</span>(socketAccept);</span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;sockAddrClient.sin_addr.S_un.S_addr, pSocketObj-&gt;m_szIP, _countof(pSocketObj-&gt;m_szIP));</span><br><span class="line">        pSocketObj-&gt;m_usPort = <span class="built_in">ntohs</span>(sockAddrClient.sin_port);</span><br><span class="line">        <span class="built_in">wsprintfA</span>(szBuf, <span class="string">&quot;客户端[%s:%d] 已连接！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">        <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">        <span class="built_in">EnableWindow</span>(g_hBtnSend, TRUE);</span><br><span class="line">        <span class="comment">// 创建线程，接收客户端数据</span></span><br><span class="line">        <span class="keyword">if</span> ((hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, RecvProc, (LPVOID)socketAccept, <span class="number">0</span>, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>           <span class="comment">// Winsock2头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span>           <span class="comment">// inet_pton / inet_ntop需要使用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32&quot;</span>)  <span class="comment">// Winsock2导入库</span></span></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwnd;            <span class="comment">// 窗口句柄</span></span><br><span class="line">HWND g_hListContent;    <span class="comment">// 聊天内容列表框窗口句柄</span></span><br><span class="line">HWND g_hEditMsg;        <span class="comment">// 消息输入框窗口句柄</span></span><br><span class="line">HWND g_hBtnSend;        <span class="comment">// 发送按钮窗口句柄</span></span><br><span class="line">HWND g_hBtnConnect;     <span class="comment">// 连接按钮窗口句柄</span></span><br><span class="line">SOCKET g_socketClient = INVALID_SOCKET; <span class="comment">// 通信套接字句柄</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 对话框初始化</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span></span>;</span><br><span class="line"><span class="comment">// 按下连接按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnConnect</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 按下发送按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 客户端接收数据的线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">RecvProc</span><span class="params">(LPVOID lpParam)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_CLIENT_DIALOG), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="built_in">OnInit</span>(hwndDlg);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g_socketClient != INVALID_SOCKET)</span><br><span class="line">                        <span class="built_in">closesocket</span>(g_socketClient);</span><br><span class="line">                    <span class="built_in">WSACleanup</span>();</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, IDCANCEL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_CONNECT: &#123;</span><br><span class="line">                    <span class="built_in">OnConnect</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SEND: &#123;</span><br><span class="line">                    <span class="built_in">OnSend</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span> </span>&#123;</span><br><span class="line">    g_hwnd = hwndDlg;</span><br><span class="line">    g_hListContent = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_LIST_CONTENT);</span><br><span class="line">    g_hEditMsg = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_MSG);</span><br><span class="line">    g_hBtnSend = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_BTN_SEND);</span><br><span class="line">    g_hBtnConnect = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_BTN_CONNECT);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 按下连接按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    sockaddr_in sockAddrServer;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 1、初始化WinSock库</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;初始化WinSock库失败！&quot;</span>, <span class="string">&quot;WSAStartup Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 2、创建与服务器的通信套接字</span></span><br><span class="line">    g_socketClient = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_socketClient == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;创建与服务器的通信套接字失败！&quot;</span>, <span class="string">&quot;socket Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 3、与服务器建立连接</span></span><br><span class="line">    sockAddrServer.sin_family = AF_INET;</span><br><span class="line">    sockAddrServer.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;sockAddrServer.sin_addr.S_un.S_addr);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(g_socketClient, (sockaddr*)&amp;sockAddrServer, <span class="built_in">sizeof</span>(sockAddrServer)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;与服务器建立连接失败！&quot;</span>, <span class="string">&quot;connect Error&quot;</span>, MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketClient);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 4、建立连接成功，收发数据</span></span><br><span class="line">    <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">&quot;已连接到服务器！&quot;</span>);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnConnect, FALSE);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, TRUE);</span><br><span class="line">    <span class="comment">// 创建线程，接收服务器数据</span></span><br><span class="line">    <span class="keyword">if</span> ((hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, RecvProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 按下发送按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szMsg[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetWindowTextA</span>(g_hEditMsg, szBuf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;我说：%s&quot;</span>, szBuf);</span><br><span class="line">    <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">    <span class="built_in">send</span>(g_socketClient, szBuf, <span class="built_in">strlen</span>(szBuf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">SetWindowTextA</span>(g_hEditMsg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">RecvProc</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> nRet = SOCKET_ERROR;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">        nRet = <span class="built_in">recv</span>(g_socketClient, szBuf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nRet &gt; <span class="number">0</span>)   <span class="comment">// 收到服务器数据</span></span><br><span class="line">            <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">        <span class="keyword">else</span> &#123;           <span class="comment">// 与服务器连接已关闭</span></span><br><span class="line">            <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">&quot;与服务器连接已关闭！&quot;</span>);</span><br><span class="line">            <span class="built_in">EnableWindow</span>(g_hBtnConnect, TRUE);</span><br><span class="line">            <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">            <span class="built_in">closesocket</span>(g_socketClient);</span><br><span class="line">            <span class="built_in">WSACleanup</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="select模型"><a href="#select模型" class="headerlink" title="select模型"></a>select模型</h3><p>同时管理多个套接字，管理多个连接，用集合表示管理的多个套接字。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>检查若干个套接字状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT nIds, <span class="comment">//忽略</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ fd_set* readfds, <span class="comment">//指向一组套接字集合指针 用于检查可读性</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ fd_set* writefds, <span class="comment">//指向一组套接字集合指针 用于检查可写性</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ fd_set* exceptfds, <span class="comment">//指向一组套接字集合指针 用于检查错误</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ CONST <span class="keyword">struct</span> timeval* timeout <span class="comment">//函数等待最大时间 直到至少一个套接字满足指定条件 NULL无限等待 &#123;0,0&#125;立即返回</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回发生网络时间的套接字句柄数 超时返回0 错误返回SOCKET_ERROR 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<p>其中fd_set结构把多个套接字连接在一起，形成套接字集合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">fd_set</span> &#123;</span><br><span class="line">	u_int   fd_count; <span class="comment">//套接字句柄数目 即fd_array大小</span></span><br><span class="line">	SOCKET  fd_array[FD_SETSIZE]; <span class="comment">//套接字句柄数组</span></span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure>
<p>还有宏用于操作和检查套接字集合：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FD_CLR(s,*set)</code></td>
<td>从集合中删除套接字s</td>
</tr>
<tr>
<td><code>FD_SET(s,*set)</code></td>
<td>把套接字s添加到集合中</td>
</tr>
<tr>
<td><code>FD_ISSET(s,*set)</code></td>
<td>当套接字s为集合成员则返回非0，否则0</td>
</tr>
<tr>
<td><code>FD_ZERO(*set)</code></td>
<td>初始化套接字集合为空集合，使用前总应清空</td>
</tr>
</tbody>
</table>
</div>
<p>对于readfds标识要检查可读性套接字的集合。当套接字处于监听状态，一旦接收到连接请求，将被标记为可读的，从而保证在不阻塞情况下完成<code>accept</code>调用。对于其他套接字，可读性意味队列数据可读取，保证对<code>recv</code>、<code>WSARecv</code>、<code>WSARecvFrom</code>、<code>recvfrom</code>调用不阻塞。对于面向连接的套接字，可读性指示已从对方接收到关闭套接字的请求。当套接字发生以下网络事件时将更新可读性套接字集合：</p>
<ul>
<li><code>listen</code>已被调用，<code>accept</code>调用正在挂起，接下来将完成<code>accept</code>调用。</li>
<li>可以接收数据。</li>
<li>连接已关闭/重置/终止。</li>
</ul>
<p>对于writefds标识要检查可写性套接字的集合。当套接字正处理一个非阻塞<code>connect</code>调用，一旦连接建立成功完成，套接字是可写的。若套接字没处理<code>connect</code>调用，可写性意味可调用<code>send</code>、<code>sendto</code>或<code>WSASendto</code>进行发送。当套接字发生以下网络事件时将更新可写性套接字集合：</p>
<ul>
<li>如果处理非阻塞<code>connect</code>调用，<code>connect</code>已成功。</li>
<li>可发送数据。</li>
</ul>
<p>对于exceptfds检查OOB数据是否存在的或发生任何异常错误的套接字。当套接字发生以下网络事件时将更新异常套接字集合：</p>
<ul>
<li>如果处理非阻塞<code>connect</code>调用，<code>connect</code>调用失败。</li>
<li>OOB数据可用于读取。</li>
</ul>
<p><code>select</code>返回时会更新相关集合，把没有发生可读写网络事件的套接字从集合中移除，即会破坏原集合。3个参数中可任意2个为NULL，不是NULL的那个至少包含一个套接字句柄。集合中套接字数目最大为FD_SETSIZE，默认64，可在包含WinSock2.h前将该值定义为别的值，但最大不能超过WinSock下层协议限制的1024个。</p>
<p>对于timeval结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123; <span class="comment">//时间间隔</span></span><br><span class="line">	LONG    tv_sec; <span class="comment">//单位秒</span></span><br><span class="line">	LONG    tv_usec; <span class="comment">//单位微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>修改上面那个例子一个函数即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">AcceptProc</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    SOCKET socketAccept = INVALID_SOCKET;   <span class="comment">// 通信套接字句柄</span></span><br><span class="line">    sockaddr_in sockAddrClient;</span><br><span class="line">    <span class="type">int</span> nAddrlen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szMsg[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    fd_set fd;</span><br><span class="line">    PSOCKETOBJ pSocketObj, p;</span><br><span class="line">    <span class="type">int</span> nRet = SOCKET_ERROR;</span><br><span class="line">    <span class="comment">// (1)、初始化一个可读性套节字集合readfds，添加监听套节字句柄到这个集合</span></span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;readfds);</span><br><span class="line">    <span class="built_in">FD_SET</span>(g_socketListen, &amp;readfds);</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="comment">// 复制一份套接字集合</span></span><br><span class="line">        fd = readfds;</span><br><span class="line">        <span class="comment">// (2)、把timeout参数设置为NULL，select调用将无限期阻塞</span></span><br><span class="line">        nRet = <span class="built_in">select</span>(<span class="number">0</span>, &amp;fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (nRet &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// (3)、将原readfds集合与经过select函数处理过的fd集合比较</span></span><br><span class="line">        <span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; readfds.fd_count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">FD_ISSET</span>(readfds.fd_array[i], &amp;fd))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (readfds.fd_array[i] == g_socketListen) &#123; <span class="comment">// ①-是监听套接字，可读性表示需接受新连接</span></span><br><span class="line">                <span class="keyword">if</span> (readfds.fd_count &lt; FD_SETSIZE) &#123;</span><br><span class="line">                    socketAccept = <span class="built_in">accept</span>(g_socketListen, (sockaddr*)&amp;sockAddrClient, &amp;nAddrlen);</span><br><span class="line">                    <span class="keyword">if</span> (socketAccept == INVALID_SOCKET)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// (4)、把通信套接字添加到原readfds集合</span></span><br><span class="line">                    <span class="built_in">FD_SET</span>(socketAccept, &amp;readfds);</span><br><span class="line">                    <span class="comment">// 6、接受客户的连接请求成功</span></span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">                    <span class="comment">// 创建一个套接字对象，保存客户端IP地址、端口号</span></span><br><span class="line">                    pSocketObj = <span class="built_in">CreateSocketObj</span>(socketAccept);</span><br><span class="line">                    <span class="built_in">inet_ntop</span>(AF_INET, &amp;sockAddrClient.sin_addr.S_un.S_addr, pSocketObj-&gt;m_szIP, _countof(pSocketObj-&gt;m_szIP));</span><br><span class="line">                    pSocketObj-&gt;m_usPort = <span class="built_in">ntohs</span>(sockAddrClient.sin_port);</span><br><span class="line">                    <span class="built_in">wsprintfA</span>(szBuf, <span class="string">&quot;客户端[%s:%d] 已连接！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">                    <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">                    <span class="built_in">EnableWindow</span>(g_hBtnSend, TRUE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">MessageBoxA</span>(g_hwnd, <span class="string">&quot;客户端连接数太多！&quot;</span>, <span class="string">&quot;accept Error&quot;</span>, MB_OK);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pSocketObj = <span class="built_in">FindSocketObj</span>(readfds.fd_array[i]);</span><br><span class="line">                <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">                nRet = SOCKET_ERROR;</span><br><span class="line">                nRet = <span class="built_in">recv</span>(pSocketObj-&gt;m_socket, szBuf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (nRet &gt; <span class="number">0</span>) &#123;                          <span class="comment">// ②-是通信套接字，接收到客户端数据</span></span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(szMsg, BUF_SIZE);</span><br><span class="line">                    <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;客户端[%s:%d]说：%s&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort, szBuf);</span><br><span class="line">                    <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">                    <span class="comment">// 把收到的数据分发到每一个客户端</span></span><br><span class="line">                    p = g_pSocketObjHeader;</span><br><span class="line">                    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (p-&gt;m_socket != pSocketObj-&gt;m_socket)</span><br><span class="line">                            <span class="built_in">send</span>(p-&gt;m_socket, szMsg, <span class="built_in">strlen</span>(szMsg), <span class="number">0</span>);</span><br><span class="line">                        p = p-&gt;m_pNext;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;                                   <span class="comment">// ③-是通信套接字，连接已关闭</span></span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(szMsg, BUF_SIZE);</span><br><span class="line">                    <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;客户端[%s:%d] 已退出！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">                    <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">                    <span class="built_in">FD_CLR</span>(readfds.fd_array[i], &amp;readfds);</span><br><span class="line">                    <span class="built_in">FreeSocketObj</span>(pSocketObj);</span><br><span class="line">                    <span class="comment">// 如果没有客户端在线了，禁用发送按钮</span></span><br><span class="line">                    <span class="keyword">if</span> (g_nTotalClient == <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;   <span class="comment">// for循环</span></span><br><span class="line">    &#125;;      <span class="comment">// while循环</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="WSAAsyncSelect模型"><a href="#WSAAsyncSelect模型" class="headerlink" title="WSAAsyncSelect模型"></a>WSAAsyncSelect模型</h3><p>即异步选择模型，允许应用程序以Windows消息形式接收网络事件通知，为每个套接字绑定一个消息。当套接字上出现事先设置的事件时，系统给应用程序发送一个消息。优点是在系统开销不太大情况下同时处理多个客户端连接，缺点是不需要窗口也得搞个窗口用于处理套接字网络事件。</p>
<h4 id="WSAAsyncSelect"><a href="#WSAAsyncSelect" class="headerlink" title="WSAAsyncSelect"></a>WSAAsyncSelect</h4><p>通知指定套接字又网络事件发生：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">WSAAsyncSelect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//需要消息通知的套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HWND hWnd, <span class="comment">//网络事件发生时 将接收消息的窗口</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ UINT wMsg, <span class="comment">//网络事件发生时，接收到的消息类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LONG lEvent <span class="comment">//指定应用程序感兴趣的网络事件组合</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回0 失败SOCKET_ERROR 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<p>函数在检测到由lEvent指定的任何网络事件发生时向窗口hWnd发送wMsg消息，wParam标识发生网络事件的套接字句柄，lParam低位字指定已发生的网络事件，高位字包含错误代码。本函数自动将套接字设置为非阻塞模式，要手动用<code>ioctlsocket</code>或<code>WSAIoctl</code>重设为阻塞模式前，应用本函数清除与套接字相关联的事件记录，即lEvent设为0。</p>
<p>lEvent有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>枚举值</th>
<th>希望接收的通知</th>
<th>事件发生时调用的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>FD_READ</td>
<td>读就绪</td>
<td><code>recv</code>、<code>recvfrom</code>、<code>WSARecv</code>、<code>WSARecvFrom</code></td>
</tr>
<tr>
<td>FD_WRITE</td>
<td>写就绪</td>
<td><code>send</code>、<code>sendto</code>、<code>WSASend</code>、<code>WSASendTo</code></td>
</tr>
<tr>
<td>FD_ACCEPT</td>
<td>有连接接入</td>
<td><code>accept</code>、<code>WSAAccept</code></td>
</tr>
<tr>
<td>FD_CONNECT</td>
<td>连接完成</td>
<td></td>
</tr>
<tr>
<td>FD_CLOSE</td>
<td>套接字关闭</td>
<td></td>
</tr>
<tr>
<td>FD_OOB</td>
<td>带外数据到达</td>
<td><code>recv</code>、<code>recvfrom</code>、<code>WSARecv</code>、<code>WSARecvFrom</code></td>
</tr>
<tr>
<td>FD_QOS</td>
<td>套接字服务质量QoS更改</td>
<td><code>WSAIoctl</code>（SIO_GET_QOS）</td>
</tr>
<tr>
<td>FD_GROUP_QOS（废弃）</td>
<td>套接字组服务质量更改</td>
<td></td>
</tr>
<tr>
<td>FD_ROUTING_INTERFACE_CHANGE</td>
<td>指定目的地路由接口更改</td>
<td><code>WSAIoctl</code>（SIO_ROUTING_INTERFACE_CHANGE）</td>
</tr>
<tr>
<td>FD_ADDRESS_LIST_CHANGE</td>
<td>套接字协议族本地地址列表更改</td>
<td><code>WSAIoctl</code>（SIO_ADDRESS_LIST_CHANGE）</td>
</tr>
</tbody>
</table>
</div>
<p>对于同一个套接字，只能在同一个消息中处理不同网络事件，而不能为不同网络事件指定不同消息。</p>
<p>可用宏<code>WSAGETSELECTEVENT(lParam)</code>获取错误代码，用<code>WSAGETSELECTERROR(lParam)</code>获取事件代码。</p>
<p>该函数已过时，被WSAEventSelect替代，使用时要用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br></pre></td></tr></table></figure>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p>例子同上，仅服务端发生变化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>           <span class="comment">// Winsock2头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span>           <span class="comment">// inet_pton / inet_ntop需要使用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SOCKETOBJ.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32&quot;</span>)  <span class="comment">// Winsock2导入库</span></span></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="comment">// 自定义网络事件通知消息类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> WM_SOCKET = WM_APP + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwnd;            <span class="comment">// 窗口句柄</span></span><br><span class="line">HWND g_hListContent;    <span class="comment">// 聊天内容列表框窗口句柄</span></span><br><span class="line">HWND g_hEditMsg;        <span class="comment">// 消息输入框窗口句柄</span></span><br><span class="line">HWND g_hBtnSend;        <span class="comment">// 发送按钮窗口句柄</span></span><br><span class="line">SOCKET g_socketListen = INVALID_SOCKET; <span class="comment">// 监听套接字句柄</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 对话框初始化</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span></span>;</span><br><span class="line"><span class="comment">// 按下启动服务按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 按下发送按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 服务器接收每一个客户端数据</span></span><br><span class="line"><span class="function">VOID <span class="title">OnRecv</span><span class="params">(SOCKET s)</span></span>;</span><br><span class="line"><span class="comment">// 接受客户端连接请求</span></span><br><span class="line"><span class="function">VOID <span class="title">OnAccept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 客户端关闭连接</span></span><br><span class="line"><span class="function">VOID <span class="title">OnClose</span><span class="params">(SOCKET s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_SERVER_DIALOG), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    SOCKET s;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="built_in">OnInit</span>(hwndDlg);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="comment">// 关闭套接字，释放WinSock库</span></span><br><span class="line">                    <span class="keyword">if</span> (g_socketListen != INVALID_SOCKET)</span><br><span class="line">                        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">                    <span class="built_in">WSACleanup</span>();</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, IDCANCEL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_START: &#123;</span><br><span class="line">                    <span class="built_in">OnStart</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SEND: &#123;</span><br><span class="line">                    <span class="built_in">OnSend</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_SOCKET: &#123;</span><br><span class="line">            <span class="comment">// wParam参数标识了发生网络事件的套接字句柄</span></span><br><span class="line">            s = wParam;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">WSAGETSELECTEVENT</span>(lParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> FD_ACCEPT: &#123; <span class="comment">// 接受客户端连接</span></span><br><span class="line">                    <span class="built_in">OnAccept</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> FD_READ: &#123;   <span class="comment">// 接收客户端数据</span></span><br><span class="line">                    <span class="built_in">OnRecv</span>(s);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> FD_WRITE: &#123;  <span class="comment">// 发送数据，本例不需要处理，因为是按下发送按钮才发送</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> FD_CLOSE: &#123;  <span class="comment">// 客户端连接关闭</span></span><br><span class="line">                    <span class="built_in">OnClose</span>(s);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span> </span>&#123;</span><br><span class="line">    WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 1、初始化WinSock库</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;初始化WinSock库失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;WSAStartup Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 初始化临界区对象，用于同步对套接字对象的访问</span></span><br><span class="line">    <span class="built_in">InitializeCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    g_hwnd = hwndDlg;</span><br><span class="line">    g_hListContent = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_LIST_CONTENT);</span><br><span class="line">    g_hEditMsg = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_MSG);</span><br><span class="line">    g_hBtnSend = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_BTN_SEND);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2、创建用于监听所有客户端请求的套接字</span></span><br><span class="line">    g_socketListen = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_socketListen == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;创建监听套接字失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;socket Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置监听套接字为网络事件窗口消息通知</span></span><br><span class="line">    <span class="built_in">WSAAsyncSelect</span>(g_socketListen, g_hwnd, WM_SOCKET, FD_ACCEPT<span class="comment">/* | FD_CLOSE*/</span>);</span><br><span class="line">    <span class="comment">// 3、将监听套接字与指定的IP地址、端口号捆绑</span></span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    sockAddr.sin_family = AF_INET;</span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">    sockAddr.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(g_socketListen, (sockaddr*)&amp;sockAddr, <span class="built_in">sizeof</span>(sockAddr)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;将监听套接字与指定的IP地址、端口号捆绑失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;bind Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 4、使监听套节字进入监听(等待被连接)状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(g_socketListen, SOMAXCONN) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;使监听套节字进入监听(等待被连接)状态失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;listen Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 服务器监听中...</span></span><br><span class="line">    <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;服务器监听中...&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;服务启动成功&quot;</span>), MB_OK);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(<span class="built_in">GetDlgItem</span>(g_hwnd, IDC_BTN_START), FALSE);</span><br><span class="line">    <span class="comment">// 5、创建一个新线程循环等待连接请求</span></span><br><span class="line">    <span class="comment">// CloseHandle(CreateThread(NULL, 0, AcceptProc, NULL, 0, NULL));</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szMsg[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetWindowTextA</span>(g_hEditMsg, szBuf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;服务器说：%s&quot;</span>, szBuf);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">    <span class="built_in">SetWindowTextA</span>(g_hEditMsg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 向每一个客户端发送数据</span></span><br><span class="line">    PSOCKETOBJ p = g_pSocketObjHeader;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">send</span>(p-&gt;m_socket, szMsg, <span class="built_in">strlen</span>(szMsg), <span class="number">0</span>);</span><br><span class="line">        p = p-&gt;m_pNext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SOCKET socketAccept = INVALID_SOCKET;   <span class="comment">// 通信套接字句柄</span></span><br><span class="line">    sockaddr_in sockAddrClient;</span><br><span class="line">    <span class="type">int</span> nAddrlen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">    socketAccept = <span class="built_in">accept</span>(g_socketListen, (sockaddr*)&amp;sockAddrClient, &amp;nAddrlen);</span><br><span class="line">    <span class="keyword">if</span> (socketAccept == INVALID_SOCKET)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置通信套接字为网络事件窗口消息通知类型</span></span><br><span class="line">    <span class="built_in">WSAAsyncSelect</span>(socketAccept, g_hwnd, WM_SOCKET, FD_READ | FD_WRITE | FD_CLOSE);</span><br><span class="line">    <span class="comment">// 6、接受客户的连接请求成功</span></span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PSOCKETOBJ pSocketObj = <span class="built_in">CreateSocketObj</span>(socketAccept);</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;sockAddrClient.sin_addr.S_un.S_addr, pSocketObj-&gt;m_szIP, _countof(pSocketObj-&gt;m_szIP));</span><br><span class="line">    pSocketObj-&gt;m_usPort = <span class="built_in">ntohs</span>(sockAddrClient.sin_port);</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szBuf, <span class="string">&quot;客户端[%s:%d] 已连接！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, TRUE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnRecv</span><span class="params">(SOCKET s)</span> </span>&#123;</span><br><span class="line">    PSOCKETOBJ pSocketObj = <span class="built_in">FindSocketObj</span>(s);</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> nRet = SOCKET_ERROR;</span><br><span class="line">    nRet = <span class="built_in">recv</span>(pSocketObj-&gt;m_socket, szBuf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nRet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        CHAR szMsg[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;客户端[%s:%d]说：%s&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort, szBuf);</span><br><span class="line">        <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">        <span class="comment">// 把收到的数据分发到每一个客户端</span></span><br><span class="line">        PSOCKETOBJ p = g_pSocketObjHeader;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;m_socket != pSocketObj-&gt;m_socket)</span><br><span class="line">                <span class="built_in">send</span>(p-&gt;m_socket, szMsg, <span class="built_in">strlen</span>(szMsg), <span class="number">0</span>);</span><br><span class="line">            p = p-&gt;m_pNext;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnClose</span><span class="params">(SOCKET s)</span> </span>&#123;</span><br><span class="line">    PSOCKETOBJ pSocketObj = <span class="built_in">FindSocketObj</span>(s);</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szBuf, <span class="string">&quot;客户端[%s:%d] 已退出！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">    <span class="built_in">FreeSocketObj</span>(pSocketObj);</span><br><span class="line">    <span class="comment">// 如果没有客户端在线了，禁用发送按钮</span></span><br><span class="line">    <span class="keyword">if</span> (g_nTotalClient == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="WSAEventSelect模型"><a href="#WSAEventSelect模型" class="headerlink" title="WSAEventSelect模型"></a>WSAEventSelect模型</h3><p>即事件选择模型。在多个套接字上接收网络事件通知，将事件对象与网络事件集合绑定，当发生网络事件时，应用程序以事件形式接收网络事件通知。缺点是一个线程中最多只能等待64个事件，再多了就得创建多线程。</p>
<h4 id="WSAEventSelect"><a href="#WSAEventSelect" class="headerlink" title="WSAEventSelect"></a>WSAEventSelect</h4><p>将一个事件对象与网络事件集合关联在一起。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">WSAEventSelect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//需要事件通知的套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ WSAEVENT hEventObject, <span class="comment">//关联的事件对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LONG lNetworkEvents <span class="comment">//指定应用程序感兴趣的网络事件集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回0 失败SOCKET_ERROR 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<p>该函数自动将套接字设置为非阻塞模式，要用<code>ioctlsocket</code>或<code>WSAIoctl</code>手动设置为阻塞模式前，用该函数清除与套接字相关联的事件记录，其中lNetworkEvents为0、hEventObject为NULL。这里lNetworkEvents与<code>WSAAsyncSelect</code>用法一样。对于同一个套接字，无法为不同网络事件指定不同事件对象，否则调用时将取消先前指定的事件对象。要取消指定套接字上网络事件的关联时，lNetworkEvents为0，hEventObject被忽略随便填。</p>
<h4 id="WSACreateEvent"><a href="#WSACreateEvent" class="headerlink" title="WSACreateEvent"></a>WSACreateEvent</h4><p>创建一个未命名的初始状态为未触发的手动重置事件对象，子进程不能继承返回的事件对象句柄。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WSAEVENT <span class="title">WSACreateEvent</span><span class="params">(VOID)</span></span>; <span class="comment">//成功返回事件对象句柄 失败WSA_INVALID_EVENT 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<h4 id="WSAResetEvent"><a href="#WSAResetEvent" class="headerlink" title="WSAResetEvent"></a>WSAResetEvent</h4><p>将事件对象从已触发状态重置为未触发状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WSAResetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ WSAEVENT hEvent <span class="comment">//事件对象句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="WSASetEvent"><a href="#WSASetEvent" class="headerlink" title="WSASetEvent"></a>WSASetEvent</h4><p>将指定事件对象设置为已触发状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WSASetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ WSAEVENT hEvent <span class="comment">//事件对象句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="WSACloseEvent"><a href="#WSACloseEvent" class="headerlink" title="WSACloseEvent"></a>WSACloseEvent</h4><p>关闭事件对象句柄，释放事件对象占用的资源：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WSACloseEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ WSAEVENT hEvent <span class="comment">//事件对象句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="WSAWaitForMultipleEvents"><a href="#WSAWaitForMultipleEvents" class="headerlink" title="WSAWaitForMultipleEvents"></a>WSAWaitForMultipleEvents</h4><p>进入等待状态，直到指定的一个或全部事件对象已触发、超时或I/O完成例程已执行时返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WSAWaitForMultipleEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD cEvents, <span class="comment">//lphEvents数组中事件对象句柄数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ CONST WSAEVENT* lphEvents, <span class="comment">//事件对象句柄数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ BOOL fWaitAll, <span class="comment">//是否等待所有事件对象变为触发状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwTimeout, <span class="comment">//超时事件 单位毫秒</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ BOOL fAlertable <span class="comment">//当系统将一个I/O完成例程放入队列执行时 该函数是否返回</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>lphEvents数组最大只能64个。对于fWaitAll为TRUE则当lphEvents数组中所有事件对象都触发时函数才返回，返回值减WSA_WAIT_EVENT_0为事件对象在数组中最小的一个索引；为FALSE则任一事件对象触发就返回，返回值同理。dwTimeout为0时立即返回，为WSA_INFINITE时函数永远等待。fAlertable为TRUE则线程处于可通知等待状态，该函数可在系统执行I/O完成例程时返回WSA_WAIT_IO_COMPLETION，此时等待的事件对象未触发，需要再次调用该函数；为FALSE则线程处于不通知等待状态，不执行I/O完成例程。</p>
<p>函数成功则返回值可以是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>返回值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>WSA_WAIT_EVENT_0~WSA_WAIT_EVENT_0+cEvents-1</td>
<td></td>
</tr>
<tr>
<td>WSA_WAIT_IO_COMPLETION</td>
<td></td>
</tr>
<tr>
<td>WSA_WAIT_TIMEOUT</td>
<td>超时且fWaitAll指定条件不满足</td>
</tr>
<tr>
<td>WSA_WAIT_FAILED</td>
<td>失败</td>
</tr>
</tbody>
</table>
</div>
<h4 id="WSAEnumNetworkEvents"><a href="#WSAEnumNetworkEvents" class="headerlink" title="WSAEnumNetworkEvents"></a>WSAEnumNetworkEvents</h4><p>检查指定的套接字发生了哪些网络事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">WSAEnumNetworkEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ WSAEVENT hEventObject, <span class="comment">//事件对象句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPWSANETWORKEVENTS lpNetworkEvents</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回0 失败SOCKET_ERROR 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<p>hEventObject为NULL时表示不重置事件对象，否则函数执行后把该事件对象重置为未触发状态。WSANETWORKEVENTS结构有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WSANETWORKEVENTS</span> &#123;</span><br><span class="line">    LONG lNetworkEvents; <span class="comment">//发生哪些网络事件</span></span><br><span class="line">    INT iErrorCode[FD_MAX_EVENTS]; <span class="comment">//相关错误代码数组</span></span><br><span class="line">&#125; WSANETWORKEVENTS, FAR* LPWSANETWORKEVENTS;</span><br></pre></td></tr></table></figure>
<h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><p>还是上面那个例子，只需修改服务端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>           <span class="comment">// Winsock2头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span>           <span class="comment">// inet_pton / inet_ntop需要使用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SOCKETOBJ.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32&quot;</span>)  <span class="comment">// Winsock2导入库</span></span></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwnd;            <span class="comment">// 窗口句柄</span></span><br><span class="line">HWND g_hListContent;    <span class="comment">// 聊天内容列表框窗口句柄</span></span><br><span class="line">HWND g_hEditMsg;        <span class="comment">// 消息输入框窗口句柄</span></span><br><span class="line">HWND g_hBtnSend;        <span class="comment">// 发送按钮窗口句柄</span></span><br><span class="line">SOCKET g_socketListen = INVALID_SOCKET;         <span class="comment">// 监听套接字句柄</span></span><br><span class="line">WSAEVENT g_eventArray[WSA_MAXIMUM_WAIT_EVENTS]; <span class="comment">// 所有事件对象句柄数组</span></span><br><span class="line">SOCKET g_socketArray[WSA_MAXIMUM_WAIT_EVENTS];  <span class="comment">// 所有套接字句柄数组</span></span><br><span class="line"><span class="type">int</span> g_nTotalEvent;                              <span class="comment">// 所有事件对象句柄总数</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 对话框初始化</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span></span>;</span><br><span class="line"><span class="comment">// 按下启动服务按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 按下发送按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 在所有事件对象上循环等待网络事件</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WaitProc</span><span class="params">(LPVOID lpParam)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_SERVER_DIALOG), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="built_in">OnInit</span>(hwndDlg);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="comment">// 关闭套接字，释放WinSock库</span></span><br><span class="line">                    <span class="keyword">if</span> (g_socketListen != INVALID_SOCKET)</span><br><span class="line">                        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">                    <span class="built_in">WSACleanup</span>();</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, IDCANCEL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_START: &#123;</span><br><span class="line">                    <span class="built_in">OnStart</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SEND: &#123;</span><br><span class="line">                    <span class="built_in">OnSend</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span> </span>&#123;</span><br><span class="line">    WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 1、初始化WinSock库</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;初始化WinSock库失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;WSAStartup Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 初始化临界区对象，用于同步对套接字对象的访问</span></span><br><span class="line">    <span class="built_in">InitializeCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    g_hwnd = hwndDlg;</span><br><span class="line">    g_hListContent = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_LIST_CONTENT);</span><br><span class="line">    g_hEditMsg = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_MSG);</span><br><span class="line">    g_hBtnSend = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_BTN_SEND);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2、创建用于监听所有客户端请求的套接字</span></span><br><span class="line">    g_socketListen = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_socketListen == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;创建监听套接字失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;socket Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建事件对象，为监听套接字把该事件对象与一些网络事件相关联</span></span><br><span class="line">    WSAEVENT hEvent = <span class="built_in">WSACreateEvent</span>();</span><br><span class="line">    <span class="built_in">WSAEventSelect</span>(g_socketListen, hEvent, FD_ACCEPT<span class="comment">/* | FD_CLOSE*/</span>);</span><br><span class="line">    <span class="comment">// 把事件对象和监听套接字放入相关数组中</span></span><br><span class="line">    g_eventArray[g_nTotalEvent] = hEvent;</span><br><span class="line">    g_socketArray[g_nTotalEvent] = g_socketListen;</span><br><span class="line">    g_nTotalEvent++;</span><br><span class="line">    <span class="comment">// 3、将监听套接字与指定的IP地址、端口号捆绑</span></span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    sockAddr.sin_family = AF_INET;</span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">    sockAddr.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(g_socketListen, (sockaddr*)&amp;sockAddr, <span class="built_in">sizeof</span>(sockAddr)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;将监听套接字与指定的IP地址、端口号捆绑失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;bind Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 4、使监听套节字进入监听(等待被连接)状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(g_socketListen, SOMAXCONN) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;使监听套节字进入监听(等待被连接)状态失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;listen Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 服务器监听中...</span></span><br><span class="line">    <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;服务器监听中...&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;服务启动成功&quot;</span>), MB_OK);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(<span class="built_in">GetDlgItem</span>(g_hwnd, IDC_BTN_START), FALSE);</span><br><span class="line">    <span class="comment">// 创建一个新线程在所有事件对象上循环等待网络事件</span></span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, WaitProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szMsg[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetWindowTextA</span>(g_hEditMsg, szBuf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;服务器说：%s&quot;</span>, szBuf);</span><br><span class="line">    <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">    <span class="built_in">SetWindowTextA</span>(g_hEditMsg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 向每一个客户端发送数据</span></span><br><span class="line">    PSOCKETOBJ p = g_pSocketObjHeader;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">send</span>(p-&gt;m_socket, szMsg, <span class="built_in">strlen</span>(szMsg), <span class="number">0</span>);</span><br><span class="line">        p = p-&gt;m_pNext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WaitProc</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    SOCKET socketAccept = INVALID_SOCKET;   <span class="comment">// 通信套接字句柄</span></span><br><span class="line">    sockaddr_in sockAddrClient;</span><br><span class="line">    <span class="type">int</span> nAddrlen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">    <span class="type">int</span> nIndex;                             <span class="comment">// WSAWaitForMultipleEvents返回值</span></span><br><span class="line">    WSANETWORKEVENTS networkEvents;         <span class="comment">// WSAEnumNetworkEvents函数用的结构</span></span><br><span class="line">    WSAEVENT hEvent = <span class="literal">NULL</span>;</span><br><span class="line">    PSOCKETOBJ pSocketObj;</span><br><span class="line">    <span class="type">int</span> nRet = SOCKET_ERROR;                <span class="comment">// I/O操作返回值</span></span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szMsg[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="comment">// 在所有事件对象上等待，有任何一个事件对象触发，函数就返回</span></span><br><span class="line">        nIndex = <span class="built_in">WSAWaitForMultipleEvents</span>(g_nTotalEvent, g_eventArray, FALSE, WSA_INFINITE, FALSE);</span><br><span class="line">        nIndex = nIndex - WSA_WAIT_EVENT_0;</span><br><span class="line">        <span class="comment">// 查看触发的事件对象对应的套接字发生了哪些网络事件</span></span><br><span class="line">        <span class="built_in">WSAEnumNetworkEvents</span>(g_socketArray[nIndex], g_eventArray[nIndex], &amp;networkEvents);</span><br><span class="line">        <span class="comment">// 接受客户端连接FD_ACCEPT网络事件</span></span><br><span class="line">        <span class="keyword">if</span> (networkEvents.lNetworkEvents &amp; FD_ACCEPT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g_nTotalEvent &gt;= WSA_MAXIMUM_WAIT_EVENTS) &#123;</span><br><span class="line">                <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;客户端连接数太多！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;accept Error&quot;</span>), MB_OK);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            socketAccept = <span class="built_in">accept</span>(g_socketListen, (sockaddr*)&amp;sockAddrClient, &amp;nAddrlen);</span><br><span class="line">            <span class="keyword">if</span> (socketAccept == INVALID_SOCKET) &#123;</span><br><span class="line">                <span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 6、接受客户的连接请求成功</span></span><br><span class="line">            <span class="comment">// 创建事件对象，为通信套接字把该事件对象与一些网络事件相关联</span></span><br><span class="line">            hEvent = <span class="built_in">WSACreateEvent</span>();</span><br><span class="line">            <span class="built_in">WSAEventSelect</span>(socketAccept, hEvent, FD_READ | FD_WRITE | FD_CLOSE);</span><br><span class="line">            <span class="comment">// 把事件对象和通信套接字放入相关数组中</span></span><br><span class="line">            g_eventArray[g_nTotalEvent] = hEvent;</span><br><span class="line">            g_socketArray[g_nTotalEvent] = socketAccept;</span><br><span class="line">            g_nTotalEvent++;</span><br><span class="line">            <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">            <span class="comment">// 创建一个套接字对象，保存客户端IP地址、端口号</span></span><br><span class="line">            PSOCKETOBJ pSocketObj = <span class="built_in">CreateSocketObj</span>(socketAccept);</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;sockAddrClient.sin_addr.S_un.S_addr, pSocketObj-&gt;m_szIP, _countof(pSocketObj-&gt;m_szIP));</span><br><span class="line">            pSocketObj-&gt;m_usPort = <span class="built_in">ntohs</span>(sockAddrClient.sin_port);</span><br><span class="line">            <span class="built_in">wsprintfA</span>(szBuf, <span class="string">&quot;客户端[%s:%d] 已连接！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">            <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">            <span class="built_in">EnableWindow</span>(g_hBtnSend, TRUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接收客户端数据FD_READ网络事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (networkEvents.lNetworkEvents &amp; FD_READ) &#123;</span><br><span class="line">            pSocketObj = <span class="built_in">FindSocketObj</span>(g_socketArray[nIndex]);</span><br><span class="line">            <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">            nRet = SOCKET_ERROR;</span><br><span class="line">            nRet = <span class="built_in">recv</span>(g_socketArray[nIndex], szBuf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (nRet &gt; <span class="number">0</span>) &#123;  <span class="comment">// 接收到客户端数据</span></span><br><span class="line">                <span class="built_in">ZeroMemory</span>(szMsg, BUF_SIZE);</span><br><span class="line">                <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;客户端[%s:%d]说：%s&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort, szBuf);</span><br><span class="line">                <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">                <span class="comment">// 把收到的数据分发到每一个客户端</span></span><br><span class="line">                PSOCKETOBJ p = g_pSocketObjHeader;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;m_socket != g_socketArray[nIndex])</span><br><span class="line">                        <span class="built_in">send</span>(p-&gt;m_socket, szMsg, <span class="built_in">strlen</span>(szMsg), <span class="number">0</span>);</span><br><span class="line">                    p = p-&gt;m_pNext;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送数据FD_WRITE网络事件，本例不需要处理，因为是按下发送按钮才发送</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (networkEvents.lNetworkEvents &amp; FD_WRITE) &#123;&#125;</span><br><span class="line">        <span class="comment">// 客户端连接关闭FD_CLOSE网络事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (networkEvents.lNetworkEvents &amp; FD_CLOSE) &#123;</span><br><span class="line">            <span class="built_in">ZeroMemory</span>(szMsg, BUF_SIZE);</span><br><span class="line">            pSocketObj = <span class="built_in">FindSocketObj</span>(g_socketArray[nIndex]);</span><br><span class="line">            <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;客户端[%s:%d] 已退出！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">            <span class="built_in">SendMessageA</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">            <span class="built_in">FreeSocketObj</span>(pSocketObj);</span><br><span class="line">            <span class="comment">// 更新事件对象、套接字数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = nIndex; j &lt; g_nTotalEvent - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                g_eventArray[j] = g_eventArray[j + <span class="number">1</span>];</span><br><span class="line">                g_socketArray[j] = g_socketArray[j + <span class="number">1</span>];</span><br><span class="line">            &#125;;</span><br><span class="line">            g_nTotalEvent--;</span><br><span class="line">            <span class="comment">// 如果没有客户端在线了，禁用发送按钮</span></span><br><span class="line">            <span class="keyword">if</span> (g_nTotalClient == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Overlapped模型"><a href="#Overlapped模型" class="headerlink" title="Overlapped模型"></a>Overlapped模型</h3><p>即重叠模型，允许应用程序一次投递多个I/O请求。程序非阻塞调用I/O函数，当I/O操作完成时应用程序将接到通知。通知方式有事件通知和完成例程两种。</p>
<h4 id="WSASocket"><a href="#WSASocket" class="headerlink" title="WSASocket"></a>WSASocket</h4><p>创建一个重叠套接字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">WSASocket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ INT af, <span class="comment">//地址家族</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ INT type, <span class="comment">//套接字类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ INT protocol, <span class="comment">//协议类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPWSAPROTOCOL_INFO lpProtocolInfo, <span class="comment">//特征</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ GROUP g, <span class="comment">//保留 套接字组</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwFlags <span class="comment">//属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回新套接字句柄 失败INVALID_SOCKET 用WSAGetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<p>此模型需要dwFlags为WSA_FLAG_OVERLAPPED。当dwFlags为NULL时等于<code>socket</code>。</p>
<h4 id="AcceptEx"><a href="#AcceptEx" class="headerlink" title="AcceptEx"></a>AcceptEx</h4><p>接受一个客户端连接，返回本地地址和远程地址，并接收客户端发送的第一块数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">AcceptEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SOCKET sListenSocket, <span class="comment">//监听套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SOCKET sAcceptSocket, <span class="comment">//通信套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PVOID lpOutputBuffer, <span class="comment">//返回信息缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwReceiveDataLength, <span class="comment">//缓冲区第一块数据缓冲区字节数 为0不接收</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwLocalAddressLength, <span class="comment">//缓冲区为本地地址信息保留的字节数 至少比传输协议sockaddr_in最大地址长度多16字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwRemoteAddressLength, <span class="comment">//缓冲区为远程地址信息保留的字节数 长度同上</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ LPDWORD lpdwBytesReceived, <span class="comment">//同步模式下实际接收到的第一块数据的字节数 重叠模式无意义</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回TRUE 失败FALSE WSAGetLastError获取错误码</span></span><br></pre></td></tr></table></figure>
<p>错误码为ERROR_IO_PENDING则操作已启动；为WSAECONNRESET则连接请求已传入，但随后远程客户端在接收函数调用前终止。</p>
<p>该函数在Mswsock.h中定义，需要Mswsock.lib，但函数指针可以通过<code>WSAIoctl</code>动态获得。</p>
<h4 id="WSAIoctl"><a href="#WSAIoctl" class="headerlink" title="WSAIoctl"></a>WSAIoctl</h4><p>不知道用来干啥，但能用来获取某些函数指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">WSAIoctl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SOCKET s, <span class="comment">//套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwIoControlCode, <span class="comment">//操作控制代码</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPVOID lpvInBuffer, <span class="comment">//输入缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD cbInBuffer, <span class="comment">//输入缓冲区大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ LPVOID lpvOutBuffer, <span class="comment">//输出缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD cbOutBuffer, <span class="comment">//输出缓冲区 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ LPDWORD lpcbBytesReturned, <span class="comment">//指向实际输出字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPWSAOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine <span class="comment">//完成例程</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回0 失败SOCKET_ERROR 用WSAGetLastError获取错误码</span></span><br></pre></td></tr></table></figure>
<p>获取<code>AcceptEx</code>一般方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;MSWSock.h&gt;</span></span></span><br><span class="line">LPFN_ACCEPTEX lpfnAcceptEx = <span class="literal">NULL</span>;</span><br><span class="line">GUID GuidAcceptEx = WSAID_ACCEPTEX;</span><br><span class="line">DWORD dwBytes;</span><br><span class="line"><span class="built_in">WSAIoctl</span>(socketListen, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidAcceptEx, <span class="built_in">sizeof</span>(GuidAcceptEx), &amp;lpfnAcceptEx, <span class="built_in">sizeof</span>(lpfnAcceptEx), &amp;dwBytes, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>获取<code>GetAcceptExSockaddrs</code>修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPFN_GETACCEPTEXSOCKADDRS lpfnGetAcceptExSockaddrs = <span class="literal">NULL</span>;</span><br><span class="line">GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<h4 id="GetAcceptExSockaddrs"><a href="#GetAcceptExSockaddrs" class="headerlink" title="GetAcceptExSockaddrs"></a>GetAcceptExSockaddrs</h4><p>将<code>AcceptEx</code>返回的信息缓冲区解析为3个不同的部分：第一块数据、本地套接字地址和远程套接字地址。当<code>AcceptEx</code>连接成功且用<code>setsockopt</code>在接受的套接字上设置了SO_UPDATE_ACCEPT_CONTEXT选项，则可用<code>getsockname</code>获取与接受套接字相关联的本地地址，用<code>getpeername</code>获取与所接受套接字相关联的远程地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">GetAcceptExSockaddrs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PVOID lpOutputBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwReceiveDataLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwLocalAddressLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwRemoteAddressLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ LPSOCKADDR* LocalSockaddr, <span class="comment">//本地地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ LPINT LocalSockaddrLength, <span class="comment">//本地地址大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ LPSOCKADDR* RemoteSockaddr, <span class="comment">//远程地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ LPINT RemoteSockaddrLength <span class="comment">//远程地址大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>前4个参数与传递个<code>AcceptEx</code>的参数相等。</p>
<p>该函数在Mswsock.dll中导出，需要Mswsock.lib，但也可以用<code>WSAIoctl</code>动态获取。</p>
<h4 id="WSASend-WSARecv"><a href="#WSASend-WSARecv" class="headerlink" title="WSASend/WSARecv"></a>WSASend/WSARecv</h4><p>在指定套接字上发送/接收数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">WSASend</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPWSABUF lpBuffers,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwBufferCount, <span class="comment">//lpBuffers数组元素数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPDWORD lpNumberOfBytesSent,  <span class="comment">//返回实际发送字节数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwFlags, <span class="comment">//调用行为标志 可0</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPWSAOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine <span class="comment">//完成例程</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">INT <span class="title">WSARecv</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ LPWSABUF lpBuffers,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwBufferCount,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPDWORD lpNumberOfBytesRecvd,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ LPDWORD lpFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPWSAOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于lpBuffers有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WSABUF</span> &#123;</span><br><span class="line">	ULONG len; <span class="comment">//缓冲区长度 单位字节</span></span><br><span class="line">	_Field_size_bytes_(len) CHAR FAR* buf; <span class="comment">//缓冲区指针</span></span><br><span class="line">&#125; WSABUF, FAR* LPWSABUF;</span><br></pre></td></tr></table></figure>
<p>当且仅当lpOverlapped不为NULL时，lpNumberOfBytesSent应为NULL。WSAOVERLAPPED为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OVERLAPPED</span> &#123;</span><br><span class="line">	ULONG_PTR Internal; <span class="comment">//I/O请求状态代码</span></span><br><span class="line">	ULONG_PTR InternalHigh; <span class="comment">//已传输字节数</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			DWORD Offset;</span><br><span class="line">			DWORD OffsetHigh;</span><br><span class="line">		&#125; DUMMYSTRUCTNAME; <span class="comment">//非文件对象为0</span></span><br><span class="line">		PVOID Pointer; <span class="comment">//保留</span></span><br><span class="line">	&#125; DUMMYUNIONNAME;</span><br><span class="line">	HANDLE    hEvent; <span class="comment">//WSAEVENT事件对象</span></span><br><span class="line">&#125; OVERLAPPED, * LPOVERLAPPED;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSAOVERLAPPED OVERLAPPED</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OVERLAPPED</span>* LPWSAOVERLAPPED</span><br></pre></td></tr></table></figure>
<p>Internal返回I/O请求错误码，发出请求时该字段为STATUS_PENGING表示操作尚未开始。当lpCompletionRoutine为NULL则hEvent必须包含一个有效WSAEVENT事件对象句柄。</p>
<p>完成例程函数格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">CompletionROUTINE</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwError, <span class="comment">//完成状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD cbTransferred, <span class="comment">//发送字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPWSAOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwFlags <span class="comment">//0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当I/O操作立即完成时lpNumberOfBytesSent参数才返回数据，函数返回0，失败返回SOCKET_ERROR，用<code>WSAGetLastError</code>返回错误代码。错误代码为WSA_IO_PENDING为成功启动重叠操作并在稍后完成发送操作。任何其他错误代码表示未成功启动重叠操作，并不会出现完成通知。</p>
<p>为了传递更多信息，通常自定义一个OVERLAPPED结构，其中第一个字段为原OVERLAPPED结构，其后的部分称为I/O唯一数据或单I/O数据。每次用I/O操作函数都要创建一个该结构，一个I/O请求对应一个，I/O操作后立即释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PERIODATA</span> &#123;</span><br><span class="line">	OVERLAPPED m_overlapped; <span class="comment">//重叠结构</span></span><br><span class="line">	SOCKET m_socket; <span class="comment">//通信套接字句柄</span></span><br><span class="line">	WSABUF m_wsaBuf; <span class="comment">//缓冲区结构</span></span><br><span class="line">	CHAR m_szBuffer[BUF_SIZE]; <span class="comment">//缓冲区</span></span><br><span class="line">	IOOPERATION m_ioOperation; <span class="comment">//操作类型</span></span><br><span class="line">	_PERIODATA* m_pNext;</span><br><span class="line">&#125;PERIODATA, * PPERIODATA;</span><br></pre></td></tr></table></figure>
<p>举例用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PERIODATA perIoData;</span><br><span class="line"><span class="built_in">WSARecv</span>(socket, ..., (LPOVERLAPPED)&amp;perIoData, <span class="literal">NULL</span>); <span class="comment">//法1</span></span><br><span class="line"><span class="built_in">WSARecv</span>(socket, ..., &amp;perIoData.m_overlapped, <span class="literal">NULL</span>); <span class="comment">//法2</span></span><br></pre></td></tr></table></figure>
<h4 id="WSAGetOverlappedResult"><a href="#WSAGetOverlappedResult" class="headerlink" title="WSAGetOverlappedResult"></a>WSAGetOverlappedResult</h4><p>判断I/O调用结果是否成功：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WSAAPI <span class="title">WSAGetOverlappedResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPWSAOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPDWORD lpcbTransfer, <span class="comment">//返回实际发送或接收的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ BOOL fWait, <span class="comment">//是否等待重叠I/O操作完成</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPDWORD lpdwFlags <span class="comment">//返回调用行为标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当fWait为TRUE则直到I/O操作完成后才返回，只有采用基于事件完成通知时才能为TRUE；为FALSE且I/O操作仍在进行时函数返回FALSE，<code>WSAGetLastError</code>返回错误码WSA_IO_INCOMPLETE。</p>
<p>成功则返回TRUE，并更新lpcbTransfer指向的值，表示重叠操作已完成；失败返回FALSE，lpcbTransfer无意义，表示重叠操作未完成、重叠操作已完成或若干参数存在错误。</p>
<h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><p>重写上面服务端。OVERLAPPED结构定义头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="comment">// I/O操作类型，接受连接、接收数据、发送数据</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IOOPERATION</span> &#123;</span><br><span class="line">    IO_UNKNOWN, IO_ACCEPT, IO_READ, IO_WRITE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 自定义重叠结构，OVERLAPPED结构和I/O唯一数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PERIODATA</span>&#123;</span><br><span class="line">    OVERLAPPED  m_overlapped;           <span class="comment">// 重叠结构</span></span><br><span class="line">    SOCKET      m_socket;               <span class="comment">// 通信套接字句柄</span></span><br><span class="line">    WSABUF      m_wsaBuf;               <span class="comment">// 缓冲区结构</span></span><br><span class="line">    CHAR        m_szBuffer[BUF_SIZE];   <span class="comment">// 缓冲区</span></span><br><span class="line">    IOOPERATION m_ioOperation;          <span class="comment">// 操作类型</span></span><br><span class="line">    _PERIODATA  *m_pNext;</span><br><span class="line">&#125;PERIODATA, *PPERIODATA;</span><br><span class="line">PPERIODATA g_pPerIODataHeader;          <span class="comment">// 自定义重叠结构链表表头</span></span><br><span class="line"><span class="comment">// 创建一个自定义重叠结构</span></span><br><span class="line"><span class="function">PPERIODATA <span class="title">CreatePerIOData</span><span class="params">(SOCKET s)</span> </span>&#123;</span><br><span class="line">    PPERIODATA pPerIOData = <span class="keyword">new</span> PERIODATA;</span><br><span class="line">    <span class="keyword">if</span> (pPerIOData == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(pPerIOData, <span class="built_in">sizeof</span>(PERIODATA));</span><br><span class="line">    pPerIOData-&gt;m_socket = s;</span><br><span class="line">    pPerIOData-&gt;m_overlapped.hEvent = <span class="built_in">WSACreateEvent</span>();</span><br><span class="line">    <span class="built_in">EnterCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    <span class="comment">// 添加第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (g_pPerIODataHeader == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        g_pPerIODataHeader = pPerIOData;</span><br><span class="line">        g_pPerIODataHeader-&gt;m_pNext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pPerIOData-&gt;m_pNext = g_pPerIODataHeader;</span><br><span class="line">        g_pPerIODataHeader = pPerIOData;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    <span class="keyword">return</span> pPerIOData;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 释放一个自定义重叠结构</span></span><br><span class="line"><span class="function">VOID <span class="title">FreePerIOData</span><span class="params">(PPERIODATA pPerIOData)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">EnterCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    PPERIODATA p = g_pPerIODataHeader;</span><br><span class="line">    <span class="keyword">if</span> (p == pPerIOData)    <span class="comment">// 移除的是头结点</span></span><br><span class="line">        g_pPerIODataHeader = g_pPerIODataHeader-&gt;m_pNext;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;m_pNext == pPerIOData) &#123;</span><br><span class="line">                p-&gt;m_pNext = pPerIOData-&gt;m_pNext;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            p = p-&gt;m_pNext;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">if</span> (pPerIOData-&gt;m_overlapped.hEvent)</span><br><span class="line">        <span class="built_in">WSACloseEvent</span>(pPerIOData-&gt;m_overlapped.hEvent);</span><br><span class="line">    <span class="keyword">delete</span> pPerIOData;</span><br><span class="line">    <span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 根据事件对象查找自定义重叠结构</span></span><br><span class="line"><span class="function">PPERIODATA <span class="title">FindPerIOData</span><span class="params">(HANDLE hEvent)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">EnterCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    PPERIODATA pPerIOData = g_pPerIODataHeader;</span><br><span class="line">    <span class="keyword">while</span> (pPerIOData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pPerIOData-&gt;m_overlapped.hEvent == hEvent) &#123;</span><br><span class="line">            <span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);</span><br><span class="line">            <span class="keyword">return</span> pPerIOData;</span><br><span class="line">        &#125;;</span><br><span class="line">        pPerIOData = pPerIOData-&gt;m_pNext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 释放所有自定义重叠结构</span></span><br><span class="line"><span class="function">VOID <span class="title">DeleteAllPerIOData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PERIODATA perIOData;</span><br><span class="line">    PPERIODATA pPerIOData = g_pPerIODataHeader;</span><br><span class="line">    <span class="keyword">while</span> (pPerIOData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perIOData = *pPerIOData;</span><br><span class="line">        <span class="keyword">if</span> (pPerIOData-&gt;m_overlapped.hEvent)</span><br><span class="line">            <span class="built_in">WSACloseEvent</span>(pPerIOData-&gt;m_overlapped.hEvent);</span><br><span class="line">        <span class="keyword">delete</span> pPerIOData;</span><br><span class="line">        pPerIOData = perIOData.m_pNext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>服务端源代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>           <span class="comment">// Winsock2头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span>           <span class="comment">// inet_pton / inet_ntop需要使用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Mswsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SOCKETOBJ.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PERIODATA.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32&quot;</span>)  <span class="comment">// Winsock2导入库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Mswsock&quot;</span>) <span class="comment">// Mswsock导入库</span></span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwnd;            <span class="comment">// 窗口句柄</span></span><br><span class="line">HWND g_hListContent;    <span class="comment">// 聊天内容列表框窗口句柄</span></span><br><span class="line">HWND g_hEditMsg;        <span class="comment">// 消息输入框窗口句柄</span></span><br><span class="line">HWND g_hBtnSend;        <span class="comment">// 发送按钮窗口句柄</span></span><br><span class="line">SOCKET g_socketListen = INVALID_SOCKET; <span class="comment">// 监听套接字句柄</span></span><br><span class="line">WSAEVENT g_eventArray[WSA_MAXIMUM_WAIT_EVENTS]; <span class="comment">// 所有事件对象句柄数组</span></span><br><span class="line"><span class="type">int</span> g_nTotalEvent;                              <span class="comment">// 所有事件对象句柄总数</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 对话框初始化</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span></span>;</span><br><span class="line"><span class="comment">// 按下启动服务按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 在所有事件对象上循环等待网络事件</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WaitProc</span><span class="params">(LPVOID lpParam)</span></span>;</span><br><span class="line"><span class="comment">// 投递接受连接I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostAccept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 投递发送数据I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostSend</span><span class="params">(PSOCKETOBJ pSocketObj, LPTSTR pStr, <span class="type">int</span> nLen)</span></span>;</span><br><span class="line"><span class="comment">// 投递接收数据I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostRecv</span><span class="params">(PSOCKETOBJ pSocketObj)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_SERVER_DIALOG), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szMsg[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PSOCKETOBJ p;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="built_in">OnInit</span>(hwndDlg);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="comment">// 关闭套接字，释放WinSock库</span></span><br><span class="line">                    <span class="keyword">if</span> (g_socketListen != INVALID_SOCKET)</span><br><span class="line">                        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">                    <span class="built_in">WSACleanup</span>();</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, IDCANCEL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_START: &#123;</span><br><span class="line">                    <span class="built_in">OnStart</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SEND: &#123;</span><br><span class="line">                    <span class="built_in">GetWindowText</span>(g_hEditMsg, szBuf, BUF_SIZE);</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szMsg, <span class="string">&quot;服务器说：%s&quot;</span>, szBuf);</span><br><span class="line">                    <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">                    <span class="built_in">SetWindowText</span>(g_hEditMsg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                    <span class="comment">// 向每一个客户端发送数据</span></span><br><span class="line">                    p = g_pSocketObjHeader;</span><br><span class="line">                    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="built_in">PostSend</span>(p, szMsg, <span class="built_in">strlen</span>(szMsg));</span><br><span class="line">                        p = p-&gt;m_pNext;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span> </span>&#123;</span><br><span class="line">    WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 1、初始化WinSock库</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;初始化WinSock库失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;WSAStartup Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 初始化临界区对象，用于同步对套接字对象的访问</span></span><br><span class="line">    <span class="built_in">InitializeCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    g_hwnd = hwndDlg;</span><br><span class="line">    g_hListContent = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_LIST_CONTENT);</span><br><span class="line">    g_hEditMsg = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_MSG);</span><br><span class="line">    g_hBtnSend = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_BTN_SEND);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2、创建用于监听所有客户端请求的套接字</span></span><br><span class="line">    g_socketListen = <span class="built_in">WSASocket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">    <span class="keyword">if</span> (g_socketListen == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;创建监听套接字失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;socket Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 3、将监听套接字与指定的IP地址、端口号捆绑</span></span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    sockAddr.sin_family = AF_INET;</span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">    sockAddr.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(g_socketListen, (sockaddr*)&amp;sockAddr, <span class="built_in">sizeof</span>(sockAddr)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;将监听套接字与指定的IP地址、端口号捆绑失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;bind Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 4、使监听套节字进入监听(等待被连接)状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(g_socketListen, SOMAXCONN) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;使监听套节字进入监听(等待被连接)状态失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;listen Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 服务器监听中...</span></span><br><span class="line">    <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;服务器监听中...&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;服务启动成功&quot;</span>), MB_OK);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(<span class="built_in">GetDlgItem</span>(g_hwnd, IDC_BTN_START), FALSE);</span><br><span class="line">    <span class="comment">// 在所有事件对象上循环等待网络事件，本程序只用了一个线程</span></span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, WaitProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="comment">// 在此先投递几个接受连接I/O请求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        <span class="built_in">PostAccept</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WaitProc</span><span class="params">(LPVOID lpParam)</span></span>&#123;</span><br><span class="line">    sockaddr_in* pRemoteSockaddr;</span><br><span class="line">    sockaddr_in* pLocalSockaddr;</span><br><span class="line">    <span class="type">int</span> nAddrlen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">    <span class="type">int</span> nIndex;                             <span class="comment">// WSAWaitForMultipleEvents返回值</span></span><br><span class="line">    PPERIODATA pPerIOData = <span class="literal">NULL</span>;           <span class="comment">// 自定义重叠结构指针</span></span><br><span class="line">    PSOCKETOBJ pSocketObj = <span class="literal">NULL</span>;           <span class="comment">// 套接字对象结构指针</span></span><br><span class="line">    PSOCKETOBJ pSocketObjAccept = <span class="literal">NULL</span>;     <span class="comment">// 套接字对象结构指针，接受连接成功以后创建的</span></span><br><span class="line">    DWORD dwTransfer;                       <span class="comment">// WSAGetOverlappedResult函数参数</span></span><br><span class="line">    DWORD dwFlags = <span class="number">0</span>;                      <span class="comment">// WSAGetOverlappedResult函数参数</span></span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (TRUE)&#123;</span><br><span class="line">        <span class="comment">// 在所有事件对象上等待，有任何一个事件对象触发，函数就返回</span></span><br><span class="line">        nIndex = <span class="built_in">WSAWaitForMultipleEvents</span>(g_nTotalEvent, g_eventArray, FALSE, <span class="number">1000</span>, FALSE);</span><br><span class="line">        <span class="keyword">if</span> (nIndex == WSA_WAIT_TIMEOUT || nIndex == WSA_WAIT_FAILED)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        nIndex = nIndex - WSA_WAIT_EVENT_0;</span><br><span class="line">        <span class="built_in">WSAResetEvent</span>(g_eventArray[nIndex]);</span><br><span class="line">        <span class="comment">// 获取指定套接字上重叠I/O操作的结果</span></span><br><span class="line">        pPerIOData = <span class="built_in">FindPerIOData</span>(g_eventArray[nIndex]);</span><br><span class="line">        pSocketObj = <span class="built_in">FindSocketObj</span>(pPerIOData-&gt;m_socket);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        bRet = <span class="built_in">WSAGetOverlappedResult</span>(pPerIOData-&gt;m_socket, &amp;pPerIOData-&gt;m_overlapped,&amp;dwTransfer, TRUE, &amp;dwFlags);</span><br><span class="line">        <span class="keyword">if</span> (!bRet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pSocketObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">                <span class="built_in">wsprintf</span>(szBuf, <span class="string">&quot;客户端[%s:%d] 已退出！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">                <span class="built_in">FreeSocketObj</span>(pSocketObj);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 释放自定义重叠结构</span></span><br><span class="line">            <span class="built_in">FreePerIOData</span>(pPerIOData);</span><br><span class="line">            <span class="comment">// 更新事件对象数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = nIndex; j &lt; g_nTotalEvent - <span class="number">1</span>; j++)</span><br><span class="line">                g_eventArray[j] = g_eventArray[j + <span class="number">1</span>];</span><br><span class="line">            g_nTotalEvent--;</span><br><span class="line">            <span class="comment">// 如果没有客户端在线了，禁用发送按钮</span></span><br><span class="line">            <span class="keyword">if</span> (g_nTotalClient == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 处理已成功完成的I/O请求</span></span><br><span class="line">        <span class="keyword">switch</span> (pPerIOData-&gt;m_ioOperation) &#123;</span><br><span class="line">            <span class="keyword">case</span> IO_ACCEPT: &#123;</span><br><span class="line">                pSocketObjAccept = <span class="built_in">CreateSocketObj</span>(pPerIOData-&gt;m_socket);</span><br><span class="line">                <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">                <span class="built_in">GetAcceptExSockaddrs</span>(pPerIOData-&gt;m_szBuffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockaddr_in) + <span class="number">16</span>, <span class="built_in">sizeof</span>(sockaddr_in) + <span class="number">16</span>, (LPSOCKADDR*)&amp;pLocalSockaddr, &amp;nAddrlen, (LPSOCKADDR*)&amp;pRemoteSockaddr, &amp;nAddrlen);</span><br><span class="line">                <span class="built_in">inet_ntop</span>(AF_INET, &amp;pRemoteSockaddr-&gt;sin_addr.S_un.S_addr, pSocketObjAccept-&gt;m_szIP, _countof(pSocketObjAccept-&gt;m_szIP));</span><br><span class="line">                pSocketObjAccept-&gt;m_usPort = <span class="built_in">ntohs</span>(pRemoteSockaddr-&gt;sin_port);</span><br><span class="line">                <span class="built_in">wsprintf</span>(szBuf, <span class="string">&quot;客户端[%s:%d] 已连接！&quot;</span>, pSocketObjAccept-&gt;m_szIP, pSocketObjAccept-&gt;m_usPort);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">                <span class="built_in">EnableWindow</span>(g_hBtnSend, TRUE);</span><br><span class="line">                <span class="comment">// 释放自定义重叠结构</span></span><br><span class="line">                <span class="built_in">FreePerIOData</span>(pPerIOData);</span><br><span class="line">                <span class="comment">// 更新事件对象数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = nIndex; j &lt; g_nTotalEvent - <span class="number">1</span>; j++)</span><br><span class="line">                    g_eventArray[j] = g_eventArray[j + <span class="number">1</span>];</span><br><span class="line">                g_nTotalEvent--;</span><br><span class="line">                <span class="built_in">PostRecv</span>(pSocketObjAccept);</span><br><span class="line">                <span class="built_in">PostAccept</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">case</span> IO_READ: &#123;</span><br><span class="line">                <span class="keyword">if</span> (dwTransfer &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="string">&quot;客户端[%s:%d]说：%s&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort, pPerIOData-&gt;m_szBuffer);</span><br><span class="line">                    <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">                    <span class="comment">// 把收到的数据分发到每一个客户端</span></span><br><span class="line">                    PSOCKETOBJ p = g_pSocketObjHeader;</span><br><span class="line">                    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (p-&gt;m_socket != pPerIOData-&gt;m_socket)</span><br><span class="line">                            <span class="built_in">PostSend</span>(p, szBuf, <span class="built_in">strlen</span>(szBuf));</span><br><span class="line">                        p = p-&gt;m_pNext;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="built_in">PostRecv</span>(pSocketObj);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="string">&quot;客户端[%s:%d] 已退出！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">                    <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">                    <span class="built_in">FreeSocketObj</span>(pSocketObj);</span><br><span class="line">                    <span class="comment">// 如果没有客户端在线了，禁用发送按钮</span></span><br><span class="line">                    <span class="keyword">if</span> (g_nTotalClient == <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 释放自定义重叠结构</span></span><br><span class="line">                <span class="built_in">FreePerIOData</span>(pPerIOData);</span><br><span class="line">                <span class="comment">// 更新事件对象数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = nIndex; j &lt; g_nTotalEvent - <span class="number">1</span>; j++)</span><br><span class="line">                    g_eventArray[j] = g_eventArray[j + <span class="number">1</span>];</span><br><span class="line">                g_nTotalEvent--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">case</span> IO_WRITE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (dwTransfer &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">                    <span class="built_in">wsprintf</span>(szBuf, <span class="string">&quot;客户端[%s:%d] 已退出！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">                    <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">                    <span class="built_in">FreeSocketObj</span>(pSocketObj);</span><br><span class="line">                    <span class="comment">// 如果没有客户端在线了，禁用发送按钮</span></span><br><span class="line">                    <span class="keyword">if</span> (g_nTotalClient == <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 释放自定义重叠结构</span></span><br><span class="line">                <span class="built_in">FreePerIOData</span>(pPerIOData);</span><br><span class="line">                <span class="comment">// 更新事件对象数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = nIndex; j &lt; g_nTotalEvent - <span class="number">1</span>; j++)</span><br><span class="line">                    g_eventArray[j] = g_eventArray[j + <span class="number">1</span>];</span><br><span class="line">                g_nTotalEvent--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 投递接受连接I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SOCKET socketAccept = INVALID_SOCKET;   <span class="comment">// 通信套接字句柄</span></span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    socketAccept = <span class="built_in">WSASocket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">    <span class="keyword">if</span> (socketAccept == INVALID_SOCKET)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 为接受连接创建一个自定义重叠结构</span></span><br><span class="line">    PPERIODATA pPerIOData = <span class="built_in">CreatePerIOData</span>(socketAccept);</span><br><span class="line">    pPerIOData-&gt;m_ioOperation = IO_ACCEPT;</span><br><span class="line">    <span class="comment">// 事件对象数组</span></span><br><span class="line">    g_eventArray[g_nTotalEvent] = pPerIOData-&gt;m_overlapped.hEvent;</span><br><span class="line">    g_nTotalEvent++;</span><br><span class="line">    bRet = <span class="built_in">AcceptEx</span>(g_socketListen, socketAccept, pPerIOData-&gt;m_szBuffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockaddr_in) + <span class="number">16</span>, <span class="built_in">sizeof</span>(sockaddr_in) + <span class="number">16</span>, <span class="literal">NULL</span>, (LPOVERLAPPED)pPerIOData);</span><br><span class="line">    <span class="keyword">if</span> (!bRet)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WSAGetLastError</span>() != WSA_IO_PENDING)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 投递发送数据I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostSend</span><span class="params">(PSOCKETOBJ pSocketObj, LPTSTR pStr, <span class="type">int</span> nLen)</span> </span>&#123;</span><br><span class="line">    DWORD dwFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 为发送数据创建一个自定义重叠结构</span></span><br><span class="line">    PPERIODATA pPerIOData = <span class="built_in">CreatePerIOData</span>(pSocketObj-&gt;m_socket);</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(pPerIOData-&gt;m_szBuffer, BUF_SIZE);</span><br><span class="line">    <span class="built_in">StringCchCopy</span>(pPerIOData-&gt;m_szBuffer, BUF_SIZE, pStr);</span><br><span class="line">    pPerIOData-&gt;m_wsaBuf.buf = pPerIOData-&gt;m_szBuffer;</span><br><span class="line">    pPerIOData-&gt;m_wsaBuf.len = nLen;</span><br><span class="line">    pPerIOData-&gt;m_ioOperation = IO_WRITE;</span><br><span class="line">    <span class="comment">// 事件对象数组</span></span><br><span class="line">    g_eventArray[g_nTotalEvent] = pPerIOData-&gt;m_overlapped.hEvent;</span><br><span class="line">    g_nTotalEvent++;</span><br><span class="line">    <span class="type">int</span> nRet = <span class="built_in">WSASend</span>(pSocketObj-&gt;m_socket, &amp;pPerIOData-&gt;m_wsaBuf, <span class="number">1</span>, <span class="literal">NULL</span>, dwFlags, (LPOVERLAPPED)pPerIOData, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (nRet == SOCKET_ERROR)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WSAGetLastError</span>() != WSA_IO_PENDING)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 投递接收数据I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostRecv</span><span class="params">(PSOCKETOBJ pSocketObj)</span> </span>&#123;</span><br><span class="line">    DWORD dwFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 为接收数据创建一个自定义重叠结构</span></span><br><span class="line">    PPERIODATA pPerIOData = <span class="built_in">CreatePerIOData</span>(pSocketObj-&gt;m_socket);</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(pPerIOData-&gt;m_szBuffer, BUF_SIZE);</span><br><span class="line">    pPerIOData-&gt;m_wsaBuf.buf = pPerIOData-&gt;m_szBuffer;</span><br><span class="line">    pPerIOData-&gt;m_wsaBuf.len = BUF_SIZE;</span><br><span class="line">    pPerIOData-&gt;m_ioOperation = IO_READ;</span><br><span class="line">    <span class="comment">// 事件对象数组</span></span><br><span class="line">    g_eventArray[g_nTotalEvent] = pPerIOData-&gt;m_overlapped.hEvent;</span><br><span class="line">    g_nTotalEvent++;</span><br><span class="line">    <span class="type">int</span> nRet = <span class="built_in">WSARecv</span>(pSocketObj-&gt;m_socket, &amp;pPerIOData-&gt;m_wsaBuf, <span class="number">1</span>, <span class="literal">NULL</span>, &amp;dwFlags, (LPOVERLAPPED)pPerIOData, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (nRet == SOCKET_ERROR)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WSAGetLastError</span>() != WSA_IO_PENDING)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="I-O完成端口IOCP模型"><a href="#I-O完成端口IOCP模型" class="headerlink" title="I/O完成端口IOCP模型"></a>I/O完成端口IOCP模型</h3><p>该模型使用线程池处理异步I/O请求，可管理成百上千个套接字，广泛用于各类高性能服务器，如Apache等。</p>
<p>完成端口是一个Windows I/O结构，可看作一个队列，它接收文件、套接字、邮件槽、管道等多种对象句柄，系统把重叠I/O操作完成事件通知放入队列。它是一个内核对象，单仅与创建它的进程关联，不能进程间共享。创建一个I/O完成端口时，系统维护设备列表、I/O完成队列、等待线程队列、以释放线程列表和已暂停线程列表，没有安全属性结构。</p>
<p>设备列表表示与完成端口关联的若干个设备，每一项都包含设备句柄和完成键，用<code>CreateIoCompletionPort</code>将I/O完成端口与指定句柄关联。</p>
<p>当一个异步I/O操作完成后，完成端口将该操作添加到I/O完成队列末尾，其中每一项都是一个完成包。每个完成包包含传输字节数、完成键、OVERLAPPED结构地址和状态代码。</p>
<p>当线程池中线程从I/O完成队列中获取I/O完成包时，调用线程ID会被添加到等待队列中，等待队列中每一项都包含一个线程ID。当I/O完成队列中出现一项时等待线程队列中一个线程将被唤醒，注意此过程以栈形式进行，即晚进入睡眠状态的线程先被唤醒。对于I/O请求少的用少量线程即可应付，剩下的一直休眠就行，系统也可将未被调度的线程内存资源交换到硬盘上并清除处理器中对应的高速缓存。</p>
<p>当完成端口唤醒一个线程时，该线程ID保存到已释放线程列表中。当一个以释放线程因某些情况进入等待状态时，完成端口将该线程ID从已释放线程列表移除并放进已暂停线程列表。</p>
<p>根据创建完成端口时指定的并发线程数，完成端口将尽可能多的线程保持在已释放线程列表中。当某已释放线程因某些原因进入等待状态时，该线程进入已暂停线程列表，同时已释放线程列表缩减一项，完成端口便可释放另一个正在等待线程。当该被等待线程再次被唤醒时，则离开已暂停线程列表重新进入已释放线程列表，意味着有时已释放线程列表中线程数量会大于允许的最大并发线程数量。但在正在运行线程数量降到允许最大并发线程数前，完成端口不会再继续唤醒其他线程。这就是为啥线程池中线程数量应大于完成端口中设置的并发线程数量。</p>
<h4 id="CreateIoCompletionPort"><a href="#CreateIoCompletionPort" class="headerlink" title="CreateIoCompletionPort"></a>CreateIoCompletionPort</h4><p>创建一个I/O完成端口对象并将其指定句柄关联，或仅创建一个句柄关联的I/O完成端口，以后再关联。句柄与I/O完成端口关联后即可接收文件句柄I/O操作通知。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateIoCompletionPort</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE FileHandle, <span class="comment">//已打开的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ HANDLE ExistingCompletionPort, <span class="comment">//已存在的I/O完成端口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ ULONG_PTR CompletionKey, <span class="comment">//完成键 传递给处理函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD NumberOfConcurrentThreads <span class="comment">//同时处理I/O完成端口的I/O操作最大线程数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回I/O完成端口句柄 失败NULL 用GetLastError获取错误代码</span></span><br></pre></td></tr></table></figure>
<p>FileHandler设为INVALID_HANDLE_VALUE则仅创建一个I/O完成端口，不与句柄关联，此时ExistingCompletionPort必须为NULL，CompletionKey将被忽略。ExistingCompletionPort为NULL时，如果FileHandle有效，则创建新I/O完成端口并关联，无效则函数返回新I/O完成端口句柄且不关联。NumberOfConcurrentThreads为0则分配处理器数量相同的线程个数。</p>
<p>用<code>CloseHandle</code>关闭I/O完成端口句柄。</p>
<h4 id="GetQueuedCompletionStatus"><a href="#GetQueuedCompletionStatus" class="headerlink" title="GetQueuedCompletionStatus"></a>GetQueuedCompletionStatus</h4><p>向完成端口关联套接字句柄后即可在套接字上投递重叠I/O请求，在以后某时间用OVERLAPPED结构接收之前I/O请求结果结果。I/O操作完成后系统向完成端口对象发送一个完成包，I/O完成端口以队列方式管理完成包。</p>
<p>用<code>GetQueuedCompletionStatus</code>从完成队列中取出完成包：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetQueuedCompletionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE CompletionPort, <span class="comment">//完成端口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPDWORD lpNumberOfBytes, <span class="comment">//返回已完成I/O操作所发送或接收的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ PULONG_PTR lpCompletionKey, <span class="comment">//返回与文件句柄关联的完成键</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPOVERLAPPED* lpOverlapped, <span class="comment">//返回I/O操作函数指定的OVERLAPPED结构地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwMilliseconds <span class="comment">//超时时间 等待完成包出现在完成队列的毫秒数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功TRUE 失败FALSE 用GetLastError</span></span><br></pre></td></tr></table></figure>
<p>等待时调用线程切换到睡眠模式超时则函数返回FALSE，lpOverlapped为NULL。dwMilliseconds为INFINITE则永不超时，为0且无I/O操作已完成并退出队列则立即返回。</p>
<p>用<code>CloseHandle</code>关闭一个完成端口时，系统将所有等待该函数返回的线程唤醒并立即返回FALSE，<code>GetLastError</code>返回ERROR_ABANDONED_WAIT_0。</p>
<h4 id="PostQueuedCompletionStatus"><a href="#PostQueuedCompletionStatus" class="headerlink" title="PostQueuedCompletionStatus"></a>PostQueuedCompletionStatus</h4><p>将一个自定义I/O完成包投递到I/O完成队列，也可以执行些自定义操作，还可以与线程池中线程通信。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">PostQueuedCompletionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE CompletionPort, <span class="comment">//I/O完成端口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwNumberOfBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ ULONG_PTR dwCompletionKey,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>后仨参数为<code>GetQueuedCompletionStatus</code>对应返回参数。</p>
<h4 id="GetQueuedCompletionStatusEx"><a href="#GetQueuedCompletionStatusEx" class="headerlink" title="GetQueuedCompletionStatusEx"></a>GetQueuedCompletionStatusEx</h4><p>当预计有大量I/O操作完成包时，用该函数从I/O完成队列中一次获取多个完成包，避免多个线程同时等待完成包，从而避免因线程切换带来的系统开销。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetQueuedCompletionStatusEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE CompletionPort, <span class="comment">//完成端口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ LPOVERLAPPED_ENTRY lpCompletionPortEntries,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ ULONG ulCount, <span class="comment">//lpCompletionPortEntries数组元素个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ PULONG pulNumEntriesRemoved, <span class="comment">//从I/O完成队列实际删除的完成包数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwMilliseconds, <span class="comment">//超时时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ BOOL fAlertable <span class="comment">//调用线程是否处于可通知等待状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中OVERLAPPED_ENTRY结构有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OVERLAPPED_ENTRY</span> &#123;</span><br><span class="line">	ULONG_PTR lpCompletionKey; <span class="comment">//完成键</span></span><br><span class="line">	LPOVERLAPPED lpOverlapped;</span><br><span class="line">	ULONG_PTR Internal; <span class="comment">//保留</span></span><br><span class="line">	DWORD dwNumberOfBytesTransferred; <span class="comment">//已传输字节数</span></span><br><span class="line">&#125; OVERLAPPED_ENTRY, * LPOVERLAPPED_ENTRY;</span><br></pre></td></tr></table></figure>
<p>当fAlertable为TRUE时，若I/O完成队列中无完成包，则调用线程进入可通知等待状态，系统将I/O完成例程或APC排队到线程并执行时函数返回；为FALSE则在获取到完成包或超时前不返回。</p>
<h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><p>重写服务端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>           <span class="comment">// Winsock2头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span>           <span class="comment">// inet_pton / inet_ntop需要使用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Mswsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SOCKETOBJ.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32&quot;</span>)  <span class="comment">// Winsock2导入库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Mswsock&quot;</span>) <span class="comment">// Mswsock导入库</span></span></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="comment">// I/O操作类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IOOPERATION</span>&#123;</span><br><span class="line">   IO_ACCEPT, IO_READ, IO_WRITE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// OVERLAPPED结构和I/O唯一数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PERIODATA</span>&#123;</span><br><span class="line">   OVERLAPPED  m_overlapped;   <span class="comment">// 重叠结构</span></span><br><span class="line">   SOCKET      m_socket;       <span class="comment">// 通信套接字句柄</span></span><br><span class="line">   WSABUF      m_wsaBuf;</span><br><span class="line">   CHAR        m_szBuffer[BUF_SIZE];</span><br><span class="line">   IOOPERATION m_ioOperation;  <span class="comment">// 操作类型</span></span><br><span class="line">&#125;PERIODATA, * PPERIODATA;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwnd;            <span class="comment">// 窗口句柄</span></span><br><span class="line">HWND g_hListContent;    <span class="comment">// 聊天内容列表框窗口句柄</span></span><br><span class="line">HWND g_hEditMsg;        <span class="comment">// 消息输入框窗口句柄</span></span><br><span class="line">HWND g_hBtnSend;        <span class="comment">// 发送按钮窗口句柄</span></span><br><span class="line">SOCKET g_socketListen;      <span class="comment">// 监听套接字句柄</span></span><br><span class="line">HANDLE g_hCompletionPort;   <span class="comment">// 完成端口句柄</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 对话框初始化</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span></span>;</span><br><span class="line"><span class="comment">// 按下启动服务按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// TrySubmitThreadpoolCallback的回调函数</span></span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">WorkerThreadProc</span><span class="params">(PTP_CALLBACK_INSTANCE Instance, PVOID Context)</span></span>;</span><br><span class="line"><span class="comment">// 投递接受连接I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostAccept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 投递发送数据I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostSend</span><span class="params">(SOCKET s, LPTSTR pStr, <span class="type">int</span> nLen)</span></span>;</span><br><span class="line"><span class="comment">// 投递接收数据I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostRecv</span><span class="params">(SOCKET s)</span></span>;</span><br><span class="line"><span class="comment">// 按下发送按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取逻辑处理器和物理处理器个数</span></span><br><span class="line"><span class="function">ULARGE_INTEGER <span class="title">GetProcessorInformation</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_SERVER_DIALOG), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="built_in">OnInit</span>(hwndDlg);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="comment">// 关闭完成端口</span></span><br><span class="line">                    <span class="keyword">if</span> (g_hCompletionPort)</span><br><span class="line">                        <span class="built_in">CloseHandle</span>(g_hCompletionPort);</span><br><span class="line">                    <span class="comment">// 关闭套接字，释放WinSock库</span></span><br><span class="line">                    <span class="keyword">if</span> (g_socketListen != INVALID_SOCKET)</span><br><span class="line">                        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">                    <span class="built_in">WSACleanup</span>();</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, IDCANCEL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_START: &#123;</span><br><span class="line">                    <span class="built_in">OnStart</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SEND: &#123;</span><br><span class="line">                    <span class="built_in">OnSend</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">VOID <span class="title">OnInit</span><span class="params">(HWND hwndDlg)</span> </span>&#123;</span><br><span class="line">    WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 1、初始化WinSock库</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;初始化WinSock库失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;WSAStartup Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 初始化临界区对象，用于同步对套接字对象的访问</span></span><br><span class="line">    <span class="built_in">InitializeCriticalSection</span>(&amp;g_cs);</span><br><span class="line">    g_hwnd = hwndDlg;</span><br><span class="line">    g_hListContent = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_LIST_CONTENT);</span><br><span class="line">    g_hEditMsg = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_EDIT_MSG);</span><br><span class="line">    g_hBtnSend = <span class="built_in">GetDlgItem</span>(hwndDlg, IDC_BTN_SEND);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID <span class="title">OnStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ULARGE_INTEGER uli = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 2、创建用于监听所有客户端请求的套接字</span></span><br><span class="line">    g_socketListen = <span class="built_in">WSASocket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">    <span class="keyword">if</span> (g_socketListen == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;创建监听套接字失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;socket Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 3、将监听套接字与指定的IP地址、端口号捆绑</span></span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    sockAddr.sin_family = AF_INET;</span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">    sockAddr.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(g_socketListen, (sockaddr*)&amp;sockAddr, <span class="built_in">sizeof</span>(sockAddr)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;将监听套接字与指定的IP地址、端口号捆绑失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;bind Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 4、使监听套节字进入监听(等待被连接)状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(g_socketListen, SOMAXCONN) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;使监听套节字进入监听(等待被连接)状态失败！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;listen Error&quot;</span>), MB_OK);</span><br><span class="line">        <span class="built_in">closesocket</span>(g_socketListen);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 服务器监听中...</span></span><br><span class="line">    <span class="built_in">MessageBox</span>(g_hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;服务器监听中...&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;服务启动成功&quot;</span>), MB_OK);</span><br><span class="line">    <span class="built_in">EnableWindow</span>(<span class="built_in">GetDlgItem</span>(g_hwnd, IDC_BTN_START), FALSE);</span><br><span class="line">    <span class="comment">// 5、</span></span><br><span class="line">    <span class="comment">// 创建I/O完成端口，当GetQueuedCompletionStatus函数返回FALSE</span></span><br><span class="line">    <span class="comment">// 并且错误代码为ERROR_ABANDONED_WAIT_0的时候可以确定完成端口已关闭</span></span><br><span class="line">    g_hCompletionPort = <span class="built_in">CreateIoCompletionPort</span>(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置线程池中工作线程的回调函数，线程池会决定如何管理工作线程</span></span><br><span class="line">    <span class="built_in">TrySubmitThreadpoolCallback</span>(WorkerThreadProc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 添加监听套接字节点</span></span><br><span class="line">    PSOCKETOBJ pSocketObj = <span class="built_in">CreateSocketObj</span>(g_socketListen);</span><br><span class="line">    <span class="comment">// 将监听套接字与完成端口g_hCompletionPort相关联，pSocket作为句柄唯一数据</span></span><br><span class="line">    <span class="built_in">CreateIoCompletionPort</span>((HANDLE)g_socketListen, g_hCompletionPort, (ULONG_PTR)pSocketObj, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 在此先投递物理处理器 * 2个接受连接I/O请求，GetProcessorInformation是自定义函数</span></span><br><span class="line">    uli = <span class="built_in">GetProcessorInformation</span>();</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; uli.HighPart * <span class="number">2</span>; i++)</span><br><span class="line">        <span class="built_in">PostAccept</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// TrySubmitThreadpoolCallback的回调函数</span></span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">WorkerThreadProc</span><span class="params">(PTP_CALLBACK_INSTANCE Instance, PVOID Context)</span> </span>&#123;</span><br><span class="line">    sockaddr_in* pRemoteSockaddr;</span><br><span class="line">    sockaddr_in* pLocalSockaddr;</span><br><span class="line">    <span class="type">int</span> nAddrlen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">    PSOCKETOBJ pSocketObj = <span class="literal">NULL</span>;   <span class="comment">// 返回与套接字相关联的单句柄数据</span></span><br><span class="line">    PPERIODATA pPerIOData = <span class="literal">NULL</span>;   <span class="comment">// 返回I/O操作函数指定的OVERLAPPED结构的地址</span></span><br><span class="line">    DWORD dwTrans;                  <span class="comment">// 返回已完成的I/O操作所发送或接收的字节数</span></span><br><span class="line">    PSOCKETOBJ pSocket;             <span class="comment">// 接受连接成功以后，添加一个套接字信息节点</span></span><br><span class="line">    BOOL bRet;</span><br><span class="line">    PSOCKETOBJ p;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        bRet = <span class="built_in">GetQueuedCompletionStatus</span>(g_hCompletionPort, &amp;dwTrans, (PULONG_PTR)&amp;pSocketObj, (LPOVERLAPPED*)&amp;pPerIOData, INFINITE);</span><br><span class="line">        <span class="keyword">if</span> (!bRet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_ABANDONED_WAIT_0)   <span class="comment">// 完成端口已关闭</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;                                            <span class="comment">// 客户端已关闭</span></span><br><span class="line">                <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">                <span class="built_in">wsprintf</span>(szBuf, <span class="string">&quot;客户端[%s:%d] 已退出！&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">                <span class="comment">// 释放句柄唯一数据</span></span><br><span class="line">                <span class="built_in">FreeSocketObj</span>(pSocketObj);</span><br><span class="line">                <span class="comment">// 释放I/O唯一数据</span></span><br><span class="line">                <span class="keyword">delete</span> pPerIOData;</span><br><span class="line">                <span class="comment">// 如果没有客户端在线了，禁用发送按钮</span></span><br><span class="line">                <span class="keyword">if</span> (g_nTotalClient == <span class="number">1</span>)                    <span class="comment">// 监听套接字占用了一个结构，所以是1</span></span><br><span class="line">                    <span class="built_in">EnableWindow</span>(g_hBtnSend, FALSE);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 对已完成的I/O操作进行处理，进行到这里，接受连接或数据收发工作已经完成了</span></span><br><span class="line">        <span class="keyword">switch</span> (pPerIOData-&gt;m_ioOperation) &#123;</span><br><span class="line">            <span class="keyword">case</span> IO_ACCEPT: &#123;</span><br><span class="line">                <span class="comment">// 接受连接已成功，创建套接字信息结构，添加一个节点</span></span><br><span class="line">                pSocket = <span class="built_in">CreateSocketObj</span>(pPerIOData-&gt;m_socket);</span><br><span class="line">                <span class="comment">// 将通信套接字与完成端口g_hCompletionPort相关联，pSocket作为句柄唯一数据</span></span><br><span class="line">                <span class="built_in">CreateIoCompletionPort</span>((HANDLE)pSocket-&gt;m_socket, g_hCompletionPort, (ULONG_PTR)pSocket, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">                <span class="built_in">GetAcceptExSockaddrs</span>(pPerIOData-&gt;m_szBuffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockaddr_in) + <span class="number">16</span>, <span class="built_in">sizeof</span>(sockaddr_in) + <span class="number">16</span>, (LPSOCKADDR*)&amp;pLocalSockaddr, &amp;nAddrlen, (LPSOCKADDR*)&amp;pRemoteSockaddr, &amp;nAddrlen);</span><br><span class="line">                <span class="built_in">inet_ntop</span>(AF_INET, &amp;pRemoteSockaddr-&gt;sin_addr.S_un.S_addr, pSocket-&gt;m_szIP, _countof(pSocket-&gt;m_szIP));</span><br><span class="line">                pSocket-&gt;m_usPort = <span class="built_in">ntohs</span>(pRemoteSockaddr-&gt;sin_port);</span><br><span class="line">                <span class="built_in">wsprintf</span>(szBuf, <span class="string">&quot;客户端[%s:%d] 已连接！&quot;</span>, pSocket-&gt;m_szIP, pSocket-&gt;m_usPort);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">                <span class="built_in">EnableWindow</span>(g_hBtnSend, TRUE);</span><br><span class="line">                <span class="comment">// 释放I/O唯一数据</span></span><br><span class="line">                <span class="keyword">delete</span> pPerIOData;</span><br><span class="line">                <span class="comment">// 投递一个接收数据请求</span></span><br><span class="line">                <span class="built_in">PostRecv</span>(pSocket-&gt;m_socket);</span><br><span class="line">                <span class="comment">// 继续投递一个接受连接请求</span></span><br><span class="line">                <span class="built_in">PostAccept</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">case</span> IO_READ: &#123;</span><br><span class="line">                <span class="built_in">ZeroMemory</span>(szBuf, BUF_SIZE);</span><br><span class="line">                <span class="built_in">wsprintf</span>(szBuf, <span class="string">&quot;客户端[%s:%d]说：%s&quot;</span>, pSocketObj-&gt;m_szIP, pSocketObj-&gt;m_usPort, pPerIOData-&gt;m_szBuffer);</span><br><span class="line">                <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">                <span class="comment">// 释放I/O唯一数据</span></span><br><span class="line">                <span class="keyword">delete</span> pPerIOData;</span><br><span class="line">                <span class="comment">// 把收到的数据分发到每一个客户端</span></span><br><span class="line">                p = g_pSocketObjHeader;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;m_socket != g_socketListen &amp;&amp; p-&gt;m_socket != pSocketObj-&gt;m_socket)</span><br><span class="line">                        <span class="built_in">PostSend</span>(p-&gt;m_socket, szBuf, <span class="built_in">strlen</span>(szBuf));</span><br><span class="line">                    p = p-&gt;m_pNext;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 继续投递接收数据请求</span></span><br><span class="line">                <span class="built_in">PostRecv</span>(pSocketObj-&gt;m_socket);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">case</span> IO_WRITE: &#123;</span><br><span class="line">                <span class="comment">// 释放I/O唯一数据</span></span><br><span class="line">                <span class="keyword">delete</span> pPerIOData;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 投递接受连接I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PPERIODATA pPerIOData = <span class="keyword">new</span> PERIODATA;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;pPerIOData-&gt;m_overlapped, <span class="built_in">sizeof</span>(OVERLAPPED));</span><br><span class="line">    pPerIOData-&gt;m_ioOperation = IO_ACCEPT;</span><br><span class="line">    SOCKET socketAccept = <span class="built_in">WSASocket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">    pPerIOData-&gt;m_socket = socketAccept;</span><br><span class="line">    BOOL bRet = <span class="built_in">AcceptEx</span>(g_socketListen, socketAccept, pPerIOData-&gt;m_szBuffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockaddr_in) + <span class="number">16</span>, <span class="built_in">sizeof</span>(sockaddr_in) + <span class="number">16</span>, <span class="literal">NULL</span>, (LPOVERLAPPED)pPerIOData);</span><br><span class="line">    <span class="keyword">if</span> (!bRet)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WSAGetLastError</span>() != WSA_IO_PENDING)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 投递发送数据I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostSend</span><span class="params">(SOCKET s, LPTSTR pStr, <span class="type">int</span> nLen)</span> </span>&#123;</span><br><span class="line">    DWORD dwFlags = <span class="number">0</span>;</span><br><span class="line">    PPERIODATA pPerIOData = <span class="keyword">new</span> PERIODATA;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;pPerIOData-&gt;m_overlapped, <span class="built_in">sizeof</span>(OVERLAPPED));</span><br><span class="line">    pPerIOData-&gt;m_ioOperation = IO_WRITE;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(pPerIOData-&gt;m_szBuffer, BUF_SIZE);</span><br><span class="line">    <span class="built_in">StringCchCopy</span>(pPerIOData-&gt;m_szBuffer, BUF_SIZE, pStr);</span><br><span class="line">    pPerIOData-&gt;m_wsaBuf.buf = pPerIOData-&gt;m_szBuffer;</span><br><span class="line">    pPerIOData-&gt;m_wsaBuf.len = BUF_SIZE;</span><br><span class="line">    <span class="type">int</span> nRet = <span class="built_in">WSASend</span>(s, &amp;pPerIOData-&gt;m_wsaBuf, <span class="number">1</span>, <span class="literal">NULL</span>, dwFlags, (LPOVERLAPPED)pPerIOData, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (nRet == SOCKET_ERROR)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WSAGetLastError</span>() != WSA_IO_PENDING)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 投递接收数据I/O请求</span></span><br><span class="line"><span class="function">BOOL <span class="title">PostRecv</span><span class="params">(SOCKET s)</span> </span>&#123;</span><br><span class="line">    DWORD dwFlags = <span class="number">0</span>;</span><br><span class="line">    PPERIODATA pPerIOData = <span class="keyword">new</span> PERIODATA;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;pPerIOData-&gt;m_overlapped, <span class="built_in">sizeof</span>(OVERLAPPED));</span><br><span class="line">    pPerIOData-&gt;m_ioOperation = IO_READ;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(pPerIOData-&gt;m_szBuffer, BUF_SIZE);</span><br><span class="line">    pPerIOData-&gt;m_wsaBuf.buf = pPerIOData-&gt;m_szBuffer;</span><br><span class="line">    pPerIOData-&gt;m_wsaBuf.len = BUF_SIZE;</span><br><span class="line">    <span class="type">int</span> nRet = <span class="built_in">WSARecv</span>(s, &amp;pPerIOData-&gt;m_wsaBuf, <span class="number">1</span>, <span class="literal">NULL</span>, &amp;dwFlags, (LPOVERLAPPED)pPerIOData, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (nRet == SOCKET_ERROR)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WSAGetLastError</span>() != WSA_IO_PENDING)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 按下发送按钮</span></span><br><span class="line"><span class="function">VOID <span class="title">OnSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CHAR szBuf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szMsg[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetWindowText</span>(g_hEditMsg, szBuf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">wsprintf</span>(szMsg, <span class="string">&quot;服务器说：%s&quot;</span>, szBuf);</span><br><span class="line">    <span class="built_in">SendMessage</span>(g_hListContent, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szMsg);</span><br><span class="line">    <span class="built_in">SetWindowText</span>(g_hEditMsg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 向每一个客户端发送数据</span></span><br><span class="line">    PSOCKETOBJ p = g_pSocketObjHeader;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;m_socket != g_socketListen)</span><br><span class="line">            <span class="built_in">PostSend</span>(p-&gt;m_socket, szMsg, <span class="built_in">strlen</span>(szMsg));</span><br><span class="line">        p = p-&gt;m_pNext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">DWORD <span class="title">CountSetBits</span><span class="params">(ULONG_PTR bitMask)</span> </span>&#123;</span><br><span class="line">    DWORD     LSHIFT = <span class="built_in">sizeof</span>(ULONG_PTR) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line">    DWORD     bitSetCount = <span class="number">0</span>;</span><br><span class="line">    ULONG_PTR bitTest = (ULONG_PTR)<span class="number">1</span> &lt;&lt; LSHIFT;</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt;= LSHIFT; ++i) &#123;</span><br><span class="line">        bitSetCount += ((bitMask &amp; bitTest) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        bitTest /= <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> bitSetCount;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ULARGE_INTEGER <span class="title">GetProcessorInformation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION pBuf = <span class="literal">NULL</span>;    <span class="comment">// 缓冲区指针</span></span><br><span class="line">    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION pTemp = <span class="literal">NULL</span>;   <span class="comment">// 临时指针</span></span><br><span class="line">    DWORD          dwReturnedLength = <span class="number">0</span>;       <span class="comment">// GetLogicalProcessorInformation函数所用参数</span></span><br><span class="line">    DWORD          dwLogicalProcessorCount = <span class="number">0</span>;<span class="comment">// 逻辑处理器个数</span></span><br><span class="line">    DWORD          dwProcessorCoreCount = <span class="number">0</span>;   <span class="comment">// 物理处理器个数</span></span><br><span class="line">    DWORD          dwByteOffset = <span class="number">0</span>;           <span class="comment">// </span></span><br><span class="line">    ULARGE_INTEGER uli = &#123; <span class="number">0</span> &#125;;                <span class="comment">// 返回值，低、高DWORD分别表示逻辑、物理处理器个数</span></span><br><span class="line">    <span class="comment">// 第1次调用</span></span><br><span class="line">    <span class="built_in">GetLogicalProcessorInformation</span>(pBuf, &amp;dwReturnedLength);</span><br><span class="line">    pBuf = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)<span class="keyword">new</span> BYTE[dwReturnedLength];</span><br><span class="line">    <span class="comment">// 第2次调用</span></span><br><span class="line">    <span class="built_in">GetLogicalProcessorInformation</span>(pBuf, &amp;dwReturnedLength);</span><br><span class="line">    pTemp = pBuf;</span><br><span class="line">    <span class="keyword">while</span> (dwByteOffset + <span class="built_in">sizeof</span>(SYSTEM_LOGICAL_PROCESSOR_INFORMATION) &lt;= dwReturnedLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pTemp-&gt;Relationship == RelationProcessorCore) &#123;</span><br><span class="line">            <span class="comment">// 物理处理器个数</span></span><br><span class="line">            dwProcessorCoreCount++;</span><br><span class="line">            <span class="comment">// 逻辑处理器个数，一个超线程核心可以有多个逻辑处理器</span></span><br><span class="line">            dwLogicalProcessorCount += <span class="built_in">CountSetBits</span>(pTemp-&gt;ProcessorMask);</span><br><span class="line">        &#125;;</span><br><span class="line">        dwByteOffset += <span class="built_in">sizeof</span>(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);</span><br><span class="line">        pTemp++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">delete</span>[] pBuf;</span><br><span class="line">    uli.LowPart = dwLogicalProcessorCount;</span><br><span class="line">    uli.HighPart = dwProcessorCoreCount;</span><br><span class="line">    <span class="keyword">return</span> uli;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><p>文件复制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;\&quot;/manifestdependency:type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;*&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="comment">// I/O操作类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IOOPERATION</span> &#123; IO_UNKNOWN, IO_READ, IO_WRITE &#125;;</span><br><span class="line"><span class="comment">// I/O唯一数据类，继承自OVERLAPPED结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PERIODATA</span> : <span class="keyword">public</span> OVERLAPPED &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PERIODATA</span>() &#123;</span><br><span class="line">        Internal = InternalHigh = <span class="number">0</span>;</span><br><span class="line">        Offset = OffsetHigh = <span class="number">0</span>;</span><br><span class="line">        hEvent = <span class="literal">NULL</span>;</span><br><span class="line">        m_nBuffSize = <span class="number">0</span>;</span><br><span class="line">        m_pData = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">PERIODATA</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pData != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">VirtualFree</span>(m_pData, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">BOOL <span class="title">AllocBuffer</span><span class="params">(SIZE_T nBuffSize)</span> </span>&#123;</span><br><span class="line">        m_nBuffSize = nBuffSize;</span><br><span class="line">        m_pData = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, m_nBuffSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">        <span class="keyword">return</span> m_pData != <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">BOOL <span class="title">Read</span><span class="params">(HANDLE hFile, PLARGE_INTEGER pliOffset = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pliOffset != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Offset = pliOffset-&gt;LowPart;</span><br><span class="line">            OffsetHigh = pliOffset-&gt;HighPart;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ReadFile</span>(hFile, m_pData, m_nBuffSize, <span class="literal">NULL</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">BOOL <span class="title">Write</span><span class="params">(HANDLE hFile, PLARGE_INTEGER pliOffset = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pliOffset != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Offset = pliOffset-&gt;LowPart;</span><br><span class="line">            OffsetHigh = pliOffset-&gt;HighPart;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">WriteFile</span>(hFile, m_pData, m_nBuffSize, <span class="literal">NULL</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SIZE_T m_nBuffSize;</span><br><span class="line">    LPVOID  m_pData;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE               (64 * 1024)     <span class="comment">// 缓冲区大小，内存分配粒度大小64K</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PENDING_IO_REQS   4               <span class="comment">// 最大I/O请求数</span></span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwndDlg;                               <span class="comment">// 程序窗口句柄</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">FileCopy</span><span class="params">(LPCTSTR pszFileSrc, LPCTSTR pszFileDest)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    TCHAR         szFileSrc[MAX_PATH] = &#123; <span class="number">0</span> &#125;;         <span class="comment">// 返回用户选择的文件名的缓冲区</span></span><br><span class="line">    HANDLE        hFileSrc = INVALID_HANDLE_VALUE;     <span class="comment">// 源文件句柄</span></span><br><span class="line">    LARGE_INTEGER liFileSizeSrc = &#123; <span class="number">0</span> &#125;;               <span class="comment">// 源文件大小</span></span><br><span class="line">    TCHAR         szFileSize[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;              <span class="comment">// 源文件大小的字符串形式</span></span><br><span class="line">    TCHAR         szFileDest[MAX_PATH] = &#123; <span class="number">0</span> &#125;;        <span class="comment">// 目标文件名缓冲区</span></span><br><span class="line">    LPTSTR        lpStr;</span><br><span class="line">    TCHAR         szBuf[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OPENFILENAME ofn = &#123; <span class="built_in">sizeof</span>(OPENFILENAME) &#125;;</span><br><span class="line">    ofn.hwndOwner = hwndDlg;</span><br><span class="line">    ofn.lpstrFilter = <span class="built_in">TEXT</span>(<span class="string">&quot;All(*.*)\0*.*\0&quot;</span>);</span><br><span class="line">    ofn.lpstrFile = szFileSrc;                   <span class="comment">// 返回用户选择的文件名的缓冲区</span></span><br><span class="line">    ofn.lpstrFile[<span class="number">0</span>] = <span class="literal">NULL</span>;                     <span class="comment">// 不需要初始化文件名编辑控件</span></span><br><span class="line">    ofn.nMaxFile = _countof(szFileSrc);</span><br><span class="line">    ofn.lpstrInitialDir = <span class="built_in">TEXT</span>(<span class="string">&quot;C:\\&quot;</span>);          <span class="comment">// 初始目录</span></span><br><span class="line">    ofn.lpstrTitle = <span class="built_in">TEXT</span>(<span class="string">&quot;请选择要打开的文件&quot;</span>); <span class="comment">// 对话框标题栏中显示的字符串</span></span><br><span class="line">    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_CREATEPROMPT;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            g_hwndDlg = hwndDlg;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_OPEN: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetOpenFileName</span>(&amp;ofn)) &#123;</span><br><span class="line">                        <span class="comment">// 显示文件路径</span></span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_FILEPATH, szFileSrc);</span><br><span class="line">                        <span class="comment">// 获取、显示文件大小</span></span><br><span class="line">                        hFileSrc = <span class="built_in">CreateFile</span>(szFileSrc, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="keyword">if</span> (hFileSrc == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">                            <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;打开文件失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                            <span class="keyword">return</span> TRUE;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="built_in">GetFileSizeEx</span>(hFileSrc, &amp;liFileSizeSrc);</span><br><span class="line">                        _i64tot_s(liFileSizeSrc.QuadPart, szFileSize, _countof(szFileSize), <span class="number">10</span>);</span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_FILESIZE, szFileSize);</span><br><span class="line">                        <span class="built_in">CloseHandle</span>(hFileSrc);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_COPY: &#123;</span><br><span class="line">                    <span class="comment">// 获取源文件路径</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_FILEPATH, szFileSrc, _countof(szFileSrc));</span><br><span class="line">                    <span class="comment">// 设置目标文件路径，拼接目标文件名为“源文件名_复制.xxx”</span></span><br><span class="line">                    <span class="built_in">StringCchCopy</span>(szFileDest, _countof(szFileDest), szFileSrc);</span><br><span class="line">                    lpStr = _tcsrchr(szFileDest, <span class="built_in">TEXT</span>(<span class="string">&#x27;.&#x27;</span>));                    <span class="comment">// &quot;.xxx&quot;</span></span><br><span class="line">                    <span class="built_in">StringCchCopy</span>(szBuf, _countof(szBuf), lpStr);               <span class="comment">// 临时保存&quot;.xxx&quot;到szBuf</span></span><br><span class="line">                    <span class="built_in">StringCchCopy</span>(lpStr, _countof(szFileDest), <span class="built_in">TEXT</span>(<span class="string">&quot;_复制&quot;</span>));  <span class="comment">// &quot;源文件名_复制&quot;</span></span><br><span class="line">                    <span class="built_in">StringCchCat</span>(szFileDest, _countof(szFileDest), szBuf);      <span class="comment">// &quot;源文件名_复制.xxx&quot;</span></span><br><span class="line">                    <span class="comment">// 开始复制工作</span></span><br><span class="line">                    <span class="built_in">FileCopy</span>(szFileSrc, szFileDest);</span><br><span class="line">                    <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;复制工作完成&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_CLOSE: &#123;</span><br><span class="line">            <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">FileCopy</span><span class="params">(LPCTSTR pszFileSrc, LPCTSTR pszFileDest)</span> </span>&#123;</span><br><span class="line">    HANDLE        hFileSrc = INVALID_HANDLE_VALUE;     <span class="comment">// 源文件句柄</span></span><br><span class="line">    HANDLE        hFileDest = INVALID_HANDLE_VALUE;    <span class="comment">// 目标文件句柄</span></span><br><span class="line">    LARGE_INTEGER liFileSizeSrc = &#123; <span class="number">0</span> &#125;;               <span class="comment">// 源文件大小</span></span><br><span class="line">    LARGE_INTEGER liFileSizeDest = &#123; <span class="number">0</span> &#125;;              <span class="comment">// 目标文件大小</span></span><br><span class="line">    HANDLE        hCompletionPort;                     <span class="comment">// 完成端口句柄</span></span><br><span class="line">    PERIODATA     arrPerIOData[MAX_PENDING_IO_REQS];   <span class="comment">// I/O唯一数据对象数组</span></span><br><span class="line">    LARGE_INTEGER liNextReadOffset = &#123; <span class="number">0</span> &#125;;            <span class="comment">// 读取源文件使用的文件偏移</span></span><br><span class="line">    INT           nReadsInProgress = <span class="number">0</span>;                <span class="comment">// 正在进行中的读取请求的个数</span></span><br><span class="line">    INT           nWritesInProgress = <span class="number">0</span>;               <span class="comment">// 正在进行中的写入请求的个数</span></span><br><span class="line">    <span class="comment">// 打开源文件，不使用系统缓存，异步I/O</span></span><br><span class="line">    hFileSrc = <span class="built_in">CreateFile</span>(pszFileSrc, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFileSrc == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;打开文件失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建目标文件，最后一个参数设置为hFileSrc表示目标文件使用和源文件相同的属性</span></span><br><span class="line">    hFileDest = <span class="built_in">CreateFile</span>(pszFileDest, GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED, hFileSrc);</span><br><span class="line">    <span class="keyword">if</span> (hFileDest == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;创建文件失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 获取源文件大小</span></span><br><span class="line">    <span class="built_in">GetFileSizeEx</span>(hFileSrc, &amp;liFileSizeSrc);</span><br><span class="line">    <span class="comment">// 目标文件大小设置为内存分配粒度的整数倍</span></span><br><span class="line">    liFileSizeDest.QuadPart = ((liFileSizeSrc.QuadPart / BUFSIZE) * BUFSIZE) + (((liFileSizeSrc.QuadPart % BUFSIZE) &gt; <span class="number">0</span>) ? BUFSIZE : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置目标文件大小，扩展到内存分配粒度的整数倍，这是为了以内存分配粒度为单位进行I/O操作</span></span><br><span class="line">    <span class="built_in">SetFilePointerEx</span>(hFileDest, liFileSizeDest, <span class="literal">NULL</span>, FILE_BEGIN);</span><br><span class="line">    <span class="built_in">SetEndOfFile</span>(hFileDest);</span><br><span class="line">    <span class="comment">// 创建I/O完成端口，并将其与源文件和目标文件的文件句柄相关联，注意使用了不同的完成键</span></span><br><span class="line">    hCompletionPort = <span class="built_in">CreateIoCompletionPort</span>(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hCompletionPort != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">CreateIoCompletionPort</span>(hFileSrc, hCompletionPort, IO_READ, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">CreateIoCompletionPort</span>(hFileDest, hCompletionPort, IO_WRITE, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 在此先投递MAX_PENDING_IO_REQS(这里是4)个写入操作完成数据包，从而开始读取源文件工作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_PENDING_IO_REQS; i++) &#123;</span><br><span class="line">        arrPerIOData[i].<span class="built_in">AllocBuffer</span>(BUFSIZE);</span><br><span class="line">        <span class="built_in">PostQueuedCompletionStatus</span>(hCompletionPort, <span class="number">0</span>, IO_WRITE, &amp;arrPerIOData[i]);</span><br><span class="line">        nWritesInProgress++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 循环直至所有I/O操作完成</span></span><br><span class="line">    <span class="keyword">while</span> ((nReadsInProgress &gt; <span class="number">0</span>) || (nWritesInProgress &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        ULONG_PTR  CompletionKey;</span><br><span class="line">        DWORD      dwNumberOfBytesTransferred;</span><br><span class="line">        PERIODATA* pPerIOData;</span><br><span class="line">        <span class="built_in">GetQueuedCompletionStatus</span>(hCompletionPort, &amp;dwNumberOfBytesTransferred, &amp;CompletionKey, (LPOVERLAPPED*)&amp;pPerIOData, INFINITE);</span><br><span class="line">        <span class="keyword">switch</span> (CompletionKey) &#123;</span><br><span class="line">            <span class="keyword">case</span> IO_READ: &#123;    <span class="comment">// 读取源文件的一部分操作完成，开始写入目标文件</span></span><br><span class="line">                nReadsInProgress--;</span><br><span class="line">                pPerIOData-&gt;<span class="built_in">Write</span>(hFileDest);</span><br><span class="line">                nWritesInProgress++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">case</span> IO_WRITE: &#123;   <span class="comment">// 写入目标文件的一部分操作完成，开始读取源文件</span></span><br><span class="line">                nWritesInProgress--;</span><br><span class="line">                <span class="keyword">if</span> (liNextReadOffset.QuadPart &lt; liFileSizeDest.QuadPart) &#123;</span><br><span class="line">                    pPerIOData-&gt;<span class="built_in">Read</span>(hFileSrc, &amp;liNextReadOffset);</span><br><span class="line">                    nReadsInProgress++;</span><br><span class="line">                    liNextReadOffset.QuadPart += BUFSIZE;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 复制操作已经完成，清理工作</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFileSrc);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFileDest);</span><br><span class="line">    <span class="keyword">if</span> (hCompletionPort != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hCompletionPort);</span><br><span class="line">    <span class="comment">// 设置目标文件为实际大小，这次不使用FILE_FLAG_NO_BUFFERING，文件操作不受扇区大小对齐这个限制</span></span><br><span class="line">    hFileDest = <span class="built_in">CreateFile</span>(pszFileDest, GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFileDest == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;设置目标文件大小失败&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">SetFilePointerEx</span>(hFileDest, liFileSizeSrc, <span class="literal">NULL</span>, FILE_BEGIN);</span><br><span class="line">        <span class="built_in">SetEndOfFile</span>(hFileDest);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFileDest);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="碎碎念-1"><a href="#碎碎念-1" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>线程池是代表应用程序高效执行异步回调的工作线程的集合，用于减少应用程序线程数量并提供对工作线程的管理。主要应用于：</p>
<ul>
<li>高度并行的应用程序，可异步调度大量小型工作项，如分布式索引搜索、网络I/O。</li>
<li>需要频繁创建和销毁进程且每个进程运行时间短的应用程序，线程池可降低线程管理复杂度和线程创建和销毁的系统开销。</li>
<li>在后台并行处理独立工作项的应用程序，如加载多个选项卡。</li>
<li>在内核对象上执行独占等待或在一个对象上等待某事件从而阻塞的应用程序。</li>
<li>创建一个线程以等待某个事件的应用程序。</li>
</ul>
<h3 id="工作对象"><a href="#工作对象" class="headerlink" title="工作对象"></a>工作对象</h3><p>这小节好好学，下面几小节有些重复的东西就懒得写了。</p>
<h4 id="TrySubmitThreadpoolCallback"><a href="#TrySubmitThreadpoolCallback" class="headerlink" title="TrySubmitThreadpoolCallback"></a>TrySubmitThreadpoolCallback</h4><p>设置线程池工作线程调用的回调函数。线程池技术这里不讲。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">TrySubmitThreadpoolCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ PTP_SIMPLE_CALLBACK pfns, <span class="comment">//回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID pv, <span class="comment">//传递给回调函数的自定义数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PTP_CALLBACK_ENVIRON pcbe <span class="comment">//回调环境</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中回调函数格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">SimpleCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE Instance, <span class="comment">//回调实例</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID pv <span class="comment">//传递来的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="CreateThreadpoolWork"><a href="#CreateThreadpoolWork" class="headerlink" title="CreateThreadpoolWork"></a>CreateThreadpoolWork</h4><p>创建一个线程池工作对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PTP_WORK WINAPI <span class="title">CreateThreadpoolWork</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ PTP_WORK_CALLBACK pfnwk, <span class="comment">//回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID pv, <span class="comment">//传递给回调函数的自定义数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PTP_CALLBACK_ENVIRON pcbe <span class="comment">//回调环境</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回指向线程池工作对象定义的指针 失败NULL 用GetLastError</span></span><br></pre></td></tr></table></figure>
<p>每次将工作对象提交到线程池中时，线程池中工作线程都会调用该回调函数。pcbe一般用<code>InitializeThreadpoolEnvironment</code>，也可为NULL表示回调函数在默认回调环境中执行，即默认线程池。</p>
<p>回调函数定义格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">WorkCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE Instance,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID Context, <span class="comment">//传递来的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_WORK Work</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="SubmitThreadpoolWork"><a href="#SubmitThreadpoolWork" class="headerlink" title="SubmitThreadpoolWork"></a>SubmitThreadpoolWork</h4><p>将一个工作对象提交到线程池：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">SubmitThreadpoolWork</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_WORK pwk</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>有时<code>TrySubmitThreadpoolCallback</code>会因内存不足或限额而失败，这时可用<code>CreateThreadpoolWork</code>显式创建一个工作对象，再用该函数将工作对象提交到线程池中。该函数无返回值，因为它不会失败。</p>
<h4 id="WaitForThreadpoolWorkCallbacks"><a href="#WaitForThreadpoolWorkCallbacks" class="headerlink" title="WaitForThreadpoolWorkCallbacks"></a>WaitForThreadpoolWorkCallbacks</h4><p>等待工作对象回调函数执行完成，还可选择是否取消未开始执行的工作对象中的回调函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">WaitForThreadpoolWorkCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_WORK pwk, <span class="comment">//工作对象定义</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ BOOL fCancelPendingCallbacks <span class="comment">//是否取消未开始执行的工作对象中的回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当工作对象尚未提交时，函数立即返回。</p>
<h4 id="CloseThreadpoolWork"><a href="#CloseThreadpoolWork" class="headerlink" title="CloseThreadpoolWork"></a>CloseThreadpoolWork</h4><p>关闭并释放指定工作对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">CloseThreadpoolWork</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_WORK pwk</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当工作对象中没有未完成的回调函数，则立即释放工作对象；若有尚未完成的回调函数，则再回调函数执行完后异步释放工作对象。</p>
<p>若存在与工作对象关联的清理组则无需用改函数，用<code>CloseThreadpoolCleanupGroupMembers</code>释放与清理组关联的工作对象、计时器对象和等待对象。</p>
<h3 id="计时器对象"><a href="#计时器对象" class="headerlink" title="计时器对象"></a>计时器对象</h3><h4 id="CreateThreadpoolTimer"><a href="#CreateThreadpoolTimer" class="headerlink" title="CreateThreadpoolTimer"></a>CreateThreadpoolTimer</h4><p>创建一个线程池计时器对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PTP_TIMER WINAPI <span class="title">CreateThreadpoolTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ PTP_TIMER_CALLBACK pfnti, <span class="comment">//时间已到时调用的回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID pv, <span class="comment">//传递给回调函数的自定义参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PTP_CALLBACK_ENVIRON pcbe</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回指向线程池计时器对象定义的指针 失败NULL 用GetLastError</span></span><br></pre></td></tr></table></figure>
<p>回调函数格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">TimerCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE Instance,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID Context,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_TIMER Timer</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="SetThreadpoolTimer"><a href="#SetThreadpoolTimer" class="headerlink" title="SetThreadpoolTimer"></a>SetThreadpoolTimer</h4><p>设置线程池计时器对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">SetThreadpoolTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_TIMER pti,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PFILETIME pftDueTime, <span class="comment">//计时器对象触发UTC时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD msPeriod, <span class="comment">//多久触发一次 单位毫秒</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ DWORD msWindowLength <span class="comment">//执行计时器对象回调前可延迟的最长时间 单位毫秒</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>pftDueTime为正数时表示一个UTC绝对时间，程序可取的SYSTEMTIME时间，用<code>SystemTimeToFileTime</code>转为本地文件时间，再用<code>LocalFileTimeToFileTime</code>转为UTC文件时间。pftDueTime为NULL时停用计时器对象回调函数，正在执行的不受影响。pftDueTime指向全0的FILETIME结构时立即触发。pftDueTime为负数表示相对时间，单位100纳秒。</p>
<p>msPeriod为正数，直到<code>CloseThreadpoolTimer</code>关闭计时器对象或用<code>SetThreadpoolTimer</code>重新设置计时器对象。msPeriod为0表示一次性的。</p>
<p>回调函数会在从指定的触发时间到指定的触发时间加msWindowLength毫秒这个范围内触发，系统尽量安排若干个计时器对象同时触发，减少线程环境切换、线程唤醒及睡眠等电源和系统开销。</p>
<p>重新设置可再次调用该函数直接改。</p>
<h4 id="WaitForThreadpoolTimerCallbacks"><a href="#WaitForThreadpoolTimerCallbacks" class="headerlink" title="WaitForThreadpoolTimerCallbacks"></a>WaitForThreadpoolTimerCallbacks</h4><p>等待计时器对象回调函数执行完成，还可选择是否取消未开始执行的计时器对象中的回调函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">WaitForThreadpoolTimerCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_TIMER pti,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ BOOL fCancelPendingCallbacks</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="CloseThreadpoolTimer"><a href="#CloseThreadpoolTimer" class="headerlink" title="CloseThreadpoolTimer"></a>CloseThreadpoolTimer</h4><p>关闭并释放指定计时器对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">CloseThreadpoolTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_TIMER pti</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当计时器对象中没有未完成的回调函数，则立即释放计时器对象；若有尚未完成的回调函数，则再回调函数执行完后异步释放计时器对象。</p>
<p>若存在与计时器对象关联的清理组则无需用改函数，用<code>CloseThreadpoolCleanupGroupMembers</code>释放与清理组关联的工作对象、计时器对象和等待对象。</p>
<p>但在该函数后仍可能会有计时器对象的回调函数执行，一般释放时需要：用<code>SetThreadpoolTimer(Ex)</code>且pftDueTime为NULL，msPeriod和msWindowLength为0，再用<code>WaitForThreadpoolTimerCallbacks</code>且fCancelPendingCallbacks为TRUE，最后用该函数。</p>
<h4 id="IsThreadpoolTimerSet"><a href="#IsThreadpoolTimerSet" class="headerlink" title="IsThreadpoolTimerSet"></a>IsThreadpoolTimerSet</h4><p>判断指定计时器对象是否被<code>SetThreadpoolTimer(Ex)</code>设置，且pftDueTime为非NULL。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">IsThreadpoolTimerSet</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_TIMER pti</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h3><h4 id="CreateThreadpoolWait"><a href="#CreateThreadpoolWait" class="headerlink" title="CreateThreadpoolWait"></a>CreateThreadpoolWait</h4><p>创建一个线程池等待对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PTP_WAIT WINAPI <span class="title">CreateThreadpoolWait</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ PTP_WAIT_CALLBACK pfnwa, <span class="comment">//等待的内核对象触发或超时时被调用的回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID pv, <span class="comment">//传递给回调函数的自定义数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PTP_CALLBACK_ENVIRON pcbe <span class="comment">//回调环境</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回指向线程池等待对象定义 失败NULL 用GetLastError</span></span><br></pre></td></tr></table></figure>
<p>回调函数定义格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">WaitCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE Instance, <span class="comment">//回调实例定义</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID Context, <span class="comment">//传递来的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_WAIT Wait, <span class="comment">//生成回调等待对象定义</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ TP_WAIT_RESULT WaitResult <span class="comment">//等待结果</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>WaitResult可以是WAIT_OBJECT_0和WAIT_TIMEOUT。</p>
<h4 id="SetThreadpoolWait"><a href="#SetThreadpoolWait" class="headerlink" title="SetThreadpoolWait"></a>SetThreadpoolWait</h4><p>设置等待对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">SetThreadpoolWait</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_WAIT pwa, <span class="comment">//等待对象定义</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ HANDLE h, <span class="comment">//内核对象句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PFILETIME pftTimeout <span class="comment">//超时时间 UTC</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>h为NULL表示停用等待对象回调函数，正在执行的回调函数不受影响。pftDueTime为正数时表示一个UTC绝对时间，程序可取的SYSTEMTIME时间，用<code>SystemTimeToFileTime</code>转为本地文件时间，再用<code>LocalFileTimeToFileTime</code>转为UTC文件时间。pftDueTime为NULL时停用等待对象回调函数，正在执行的不受影响。pftDueTime指向全0的FILETIME结构时立即触发。pftDueTime为负数表示相对时间，单位100纳秒。</p>
<p>一个等待对象只能等待一个内核对象句柄，重复调用本函数设置等待对象将替换之前的句柄。内核对象触发后变为不活跃状态，还使用则必须用该函数设置。</p>
<h4 id="WaitForThreadpoolWaitCallbacks"><a href="#WaitForThreadpoolWaitCallbacks" class="headerlink" title="WaitForThreadpoolWaitCallbacks"></a>WaitForThreadpoolWaitCallbacks</h4><p>等待等待对象回调函数执行完，还可选择是否取消尚未开始执行的等待对象中的回调函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">WaitForThreadpoolWaitCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_WAIT pwa,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ BOOL fCancelPendingCallbacks</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="CloseThreadpoolWait"><a href="#CloseThreadpoolWait" class="headerlink" title="CloseThreadpoolWait"></a>CloseThreadpoolWait</h4><p>关闭并释放指定等待对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">CloseThreadpoolWait</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_WAIT pwa</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但在该函数后仍可能会有等待对象的回调函数执行，一般释放时需要：用<code>SetThreadpoolTimer(Ex)</code>且h为NULL，再用<code>WaitForThreadpoolTimerCallbacks</code>且fCancelPendingCallbacks为TRUE，最后用该函数。</p>
<h3 id="线程池I-O完成对象"><a href="#线程池I-O完成对象" class="headerlink" title="线程池I/O完成对象"></a>线程池I/O完成对象</h3><h4 id="CreateThreadpoolIo"><a href="#CreateThreadpoolIo" class="headerlink" title="CreateThreadpoolIo"></a>CreateThreadpoolIo</h4><p>创建一个I/O完成对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PTP_IO WINAPI <span class="title">CreateThreadpoolIo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE fl, <span class="comment">//绑定到I/O完成对象的文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ PTP_WIN32_IO_CALLBACK pfnio, <span class="comment">//回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID pv, <span class="comment">//传递给回调函数的自定义数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PTP_CALLBACK_ENVIRON pcbe <span class="comment">//回调环境</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回指向线程池I/O完成对象定义的指针 失败NULL 用GetLastError</span></span><br></pre></td></tr></table></figure>
<p>回调函数定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">IoCompletionCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE Instance,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID Context, <span class="comment">//传递来的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID Overlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ ULONG IoResult, <span class="comment">//I/O操作结果 成功NO_ERROR 否则失败</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ ULONG_PTR NumberOfBytes, <span class="comment">//已传输字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_IO Io</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="StartThreadpoolIo"><a href="#StartThreadpoolIo" class="headerlink" title="StartThreadpoolIo"></a>StartThreadpoolIo</h4><p>创建一个I/O完成对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">StartThreadpoolIo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_IO pio</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>启动每个异步I/O操作前都要用一次该函数，否则线程池将忽略异步I/O操作完成回调，并导致内存破坏。当异步I/O操作失败，即操作结果不是NO_ERROR时，必须用<code>CancelThreadpoolIo</code>取消本次完成通知。当绑定到I/O完成对象的文件句柄有FILE_SKIP_COMPLETION_PORT_ON_SUCCESS通知模式，且异步I/O操作成功返回，则不会调用I/O完成对象回调函数，这时也必须用<code>CancelThreadpoolIo</code>取消本次完成通知。</p>
<h4 id="CancelThreadpoolIo"><a href="#CancelThreadpoolIo" class="headerlink" title="CancelThreadpoolIo"></a>CancelThreadpoolIo</h4><p>取消通过<code>StartThreadpoolIo</code>得到的完成通知：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">CancelThreadpoolIo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_IO pio</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="WaitForThreadpoolIoCallbacks"><a href="#WaitForThreadpoolIoCallbacks" class="headerlink" title="WaitForThreadpoolIoCallbacks"></a>WaitForThreadpoolIoCallbacks</h4><p>等待I/O完成对象回调函数执行完，还可选择是否取消尚未开始执行的I/O完成对象中的回调函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">WaitForThreadpoolIoCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_IO pio,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ BOOL fCancelPendingCallbacks</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="CloseThreadpoolIo"><a href="#CloseThreadpoolIo" class="headerlink" title="CloseThreadpoolIo"></a>CloseThreadpoolIo</h4><p>关闭并释放指定I/O完成对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">CloseThreadpoolIo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_IO pio</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若I/O完成对象中存在尚未完成的回调函数时，执行完后异步释放I/O完成对象。用该函数前，应先关闭关联的文件句柄并等待所有未完成异步I/O操作完成，用后不可再向I/O完成对象发起任何I/O请求。</p>
<p>I/O请求可在线程池任何进程上执行，调用取消函数和处理I/O函数可能不是同一个线程，取消线程池线程上I/O请求需要同步，否则导致未知I/O错误。方法是对异步I/O用<code>CancelIoEx</code>时指定所需取消I/O请求的OVERLAPPED结构地址，或自己搞个同步机制确保目标线程用<code>CancelIoEx</code>后没有再启动其他I/O请求。</p>
<h3 id="回调函数返回时"><a href="#回调函数返回时" class="headerlink" title="回调函数返回时"></a>回调函数返回时</h3><h4 id="WhenCallbackReturns"><a href="#WhenCallbackReturns" class="headerlink" title="*WhenCallbackReturns"></a>*WhenCallbackReturns</h4><p>线程池释放指定关键段对象、互斥量对象、信号量对象的所有权、将指定事件对象设为有信号状态、卸载指定DLL。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">LeaveCriticalSectionWhenCallbackReturns</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE pci,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PCRITICAL_SECITION pCS</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">VOID WINAPI <span class="title">ReleaseMutexWhenCallbackReturns</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE pci,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hMutex</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">VOID WINAPI <span class="title">ReleaseSemaphoreWhenCallbackReturns</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE pci,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hSemaphore,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwReleaseCount</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">VOID WINAPI <span class="title">SetEventWhenCallbackReturns</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE pci,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE hEvent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">VOID WINAPI <span class="title">FreeLibraryWhenCallbackReturns</span><span class="params">( <span class="comment">//回调函数在DLL时 所在回调函数完成后卸载DLL</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE pci,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HMODULE hModule</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述函数会自动调用<code>LeaveCriticalSection</code>、<code>ReleaseMutex</code>、<code>ReleaseSemaphore</code>、<code>SetEvent</code>或<code>FreeLibrary</code>，且上述函数只能用其中一个，否则后一个调用覆盖前一个调用。</p>
<h4 id="CallbackMayRunLong"><a href="#CallbackMayRunLong" class="headerlink" title="CallbackMayRunLong"></a>CallbackMayRunLong</h4><p>表示回调函数操作需要较长时间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CallbackMayRunLong</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE pci</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数返回TRUE表示线程池中有另外的线程或能创建新线程处理其他工作项，这时当前回调函数可放心使用当前线程；返回FALSE时线程池只能在延迟一段时间后尝试创建新线程，这样将影响线程池执行效率，所以这种情况下建议将当前回调函数分块处理。</p>
<h4 id="DisassociateCurrentThreadFromCallback"><a href="#DisassociateCurrentThreadFromCallback" class="headerlink" title="DisassociateCurrentThreadFromCallback"></a>DisassociateCurrentThreadFromCallback</h4><p>解除当前正在执行的回调函数与发起回调的对象之间的关联，当前线程将不再为该对象执行回调函数。若当前线程为最后一个代表该对象执行回调的线程，则任何等待对象回调完成的线程都将被释放。说白了就是宣告线程池工作完成，任何因用<code>WaitForThreadpool*Callbacks</code>函数而阻塞的线程可尽快返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">DisassociateCurrentThreadFromCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_INSTANCE pci</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="新线程池对象"><a href="#新线程池对象" class="headerlink" title="新线程池对象"></a>新线程池对象</h3><h4 id="CreateThreadpool"><a href="#CreateThreadpool" class="headerlink" title="CreateThreadpool"></a>CreateThreadpool</h4><p>不适用进程默认线程池，创建一个新的线程池以执行回调。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PTP_POOL WINAPI <span class="title">CreateThreadpool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Reserved_ PVOID reserved <span class="comment">//NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回指向新线程池定义的指针 失败NULL 用GetLastError</span></span><br></pre></td></tr></table></figure>
<h4 id="SetThreadpoolThreadMinimum-SetThreadpoolThreadMaximum"><a href="#SetThreadpoolThreadMinimum-SetThreadpoolThreadMaximum" class="headerlink" title="SetThreadpoolThreadMinimum/SetThreadpoolThreadMaximum"></a>SetThreadpoolThreadMinimum/SetThreadpoolThreadMaximum</h4><p>设置线程池最小/最大并发数，默认最小并发数为1，最大为500。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">SetThreadpoolThreadMinimum</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_POOL ptpp,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwMinThreadCount</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">VOID WINAPI <span class="title">SetThreadpoolThreadMaximum</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_POOL ptpp,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD dwMaxThreadCount</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>最大和最小并发线程数为相同值时，线程池创建一组在线程池生命周期内永不被销毁的线程。</p>
<h4 id="InitializzeThreadpoolEnvironment"><a href="#InitializzeThreadpoolEnvironment" class="headerlink" title="InitializzeThreadpoolEnvironment"></a>InitializzeThreadpoolEnvironment</h4><p>初始化一个回调环境定义TP_CALLBACK_ENVIRON结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">InitializeThreadpoolEnvironment</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ PTP_CALLBACK_ENVIRON pcbe</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="SetThreadpoolCallbackPool"><a href="#SetThreadpoolCallbackPool" class="headerlink" title="SetThreadpoolCallbackPool"></a>SetThreadpoolCallbackPool</h4><p>设置指定线程池回调环境：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">SetThreadpoolCallbackPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_ENVIRON pcbe,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ PTP_POOL</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="DestroyThreadpoolEnvironment"><a href="#DestroyThreadpoolEnvironment" class="headerlink" title="DestroyThreadpoolEnvironment"></a>DestroyThreadpoolEnvironment</h4><p>销毁回调环境：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DestroyThreadpoolEnvironment</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_ENVIRON pcbe</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="CloseThreadpool"><a href="#CloseThreadpool" class="headerlink" title="CloseThreadpool"></a>CloseThreadpool</h4><p>关闭并释放线程池：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">CloseThreadpool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_POOL ptpp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="SetThreadpoolCallbackRunsLong"><a href="#SetThreadpoolCallbackRunsLong" class="headerlink" title="SetThreadpoolCallbackRunsLong"></a>SetThreadpoolCallbackRunsLong</h4><p>表示与回调环境相关联的回调函数需要较长时间完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">SetThreadpoolCallbackRunsLong</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_ENVIRON pcbe</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="SetThreadpoolCallbackLibrary"><a href="#SetThreadpoolCallbackLibrary" class="headerlink" title="SetThreadpoolCallbackLibrary"></a>SetThreadpoolCallbackLibrary</h4><p>通知线程池只要有未完成的回调，就要确保指定DLL保持加载状态。若回调函数可能获取加载程序锁，则用该函数防止<code>DllMain</code>中一个线程正等待回调函数结束而另一个正执行回调函数的线程尝试获取加载程序锁时发生死锁。若包含回调函数的DLL可能被卸载，则<code>DllMain</code>清理代码必须在释放对象前取消未完成的回调。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">SetThreadpoolCallbackLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_ENVIRON pcbe,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ PVOID pModule</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="线程池清理组"><a href="#线程池清理组" class="headerlink" title="线程池清理组"></a>线程池清理组</h3><p>通过回调环境将工作对象、计时器对象、等待对象或I/O完成对象与清理组关联，用释放清理组函数时自动清理上述对象。</p>
<h4 id="CreateThreadpoolCleanupGroup"><a href="#CreateThreadpoolCleanupGroup" class="headerlink" title="CreateThreadpoolCleanupGroup"></a>CreateThreadpoolCleanupGroup</h4><p>创建一个线程池清理组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PTP_CLEANUP_GROUP WINAPI <span class="title">CreateThreadpoolCleanupGroup</span><span class="params">(VOID)</span></span>; <span class="comment">//成功返回指向新线程池清理组定义 失败NULL 用GetLastError</span></span><br></pre></td></tr></table></figure>
<h4 id="SetThreadpoolCallbackCleanupGroup"><a href="#SetThreadpoolCallbackCleanupGroup" class="headerlink" title="SetThreadpoolCallbackCleanupGroup"></a>SetThreadpoolCallbackCleanupGroup</h4><p>将清理组与指定回调环境相关联：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">SetThreadpoolCallbackCleanupGroup</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CALLBACK_ENVIRON pcbe,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ PTP_CLEANUP_GROUP ptpcg,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng <span class="comment">//清理回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>释放线程池关联对象前取消清理组，或用<code>CloseThreadpoolCleanupGroupMembers</code>时，调用pfng回调函数。</p>
<p>回调函数定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID NTAPI <span class="title">CleanupGroupCancelCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID ObjectContext, <span class="comment">//创建对象时指定的自定义数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID CleanupContext <span class="comment">//释放清理组成员时传递来的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>用<code>CreateThreadpool*</code>导致从清理组中隐式添加一个成员，用<code>CloseThreadpool*</code>隐式删除一个成员。</p>
<h4 id="CloseThreadpoolCleanupGroupMembers"><a href="#CloseThreadpoolCleanupGroupMembers" class="headerlink" title="CloseThreadpoolCleanupGroupMembers"></a>CloseThreadpoolCleanupGroupMembers</h4><p>释放指定清理组中所有成员，等待所有进行中的回调函数执行完，还可选择是否取消任何未完成的回调函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">CloseThreadpoolCleanupGroupMembers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CLEANUP_GROUP ptpcg,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ BOOL fCancelPendingCallbacks, <span class="comment">//是否取消尚未开始执行对象中的回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ PVOID pvCleanupContext <span class="comment">//传递给清理回调函数的自定义数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数会阻塞，直到所有正在执行的任何回调函数完成。函数返回后清理组中任何对象都被释放，不能通过<code>CloseThreadpoolWork</code>等单独释放任何对象。关闭清理组不影响关联回调环境，回调环境直到<code>DestroyThreadpoolEnvironment</code>前会一直存在。该函数也不关闭清理组本身。</p>
<h4 id="CloseThreadpoolCleanupGroup"><a href="#CloseThreadpoolCleanupGroup" class="headerlink" title="CloseThreadpoolCleanupGroup"></a>CloseThreadpoolCleanupGroup</h4><p>关闭清理组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">CloseThreadpoolCleanupGroup</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PTP_CLEANUP_GROUP ptpcg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="例子1-1"><a href="#例子1-1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;\&quot;/manifestdependency:type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;*&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND     g_hwndDlg;</span><br><span class="line">PTP_WORK g_pTpWork;</span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 工作对象回调函数</span></span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">WorkCallback</span><span class="params">(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            g_hwndDlg = hwndDlg;</span><br><span class="line">            <span class="comment">// 创建一个工作对象</span></span><br><span class="line">            g_pTpWork = <span class="built_in">CreateThreadpoolWork</span>(WorkCallback, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (g_pTpWork == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">ExitProcess</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SUBMIT: &#123;</span><br><span class="line">                    <span class="built_in">SendMessage</span>(<span class="built_in">GetDlgItem</span>(g_hwndDlg, IDC_LIST_INFO), LB_RESETCONTENT, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">// 提交工作对象</span></span><br><span class="line">                    <span class="built_in">SubmitThreadpoolWork</span>(g_pTpWork);</span><br><span class="line">                    <span class="built_in">SubmitThreadpoolWork</span>(g_pTpWork);</span><br><span class="line">                    <span class="built_in">SubmitThreadpoolWork</span>(g_pTpWork);</span><br><span class="line">                    <span class="built_in">SubmitThreadpoolWork</span>(g_pTpWork);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_CLOSE: &#123;</span><br><span class="line">            <span class="comment">// 关闭工作对象</span></span><br><span class="line">            <span class="keyword">if</span> (g_pTpWork != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">CloseThreadpoolWork</span>(g_pTpWork);</span><br><span class="line">            <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">WorkCallback</span><span class="params">(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work)</span> </span>&#123;</span><br><span class="line">    DWORD dwThreadId = <span class="built_in">GetCurrentThreadId</span>();</span><br><span class="line">    TCHAR szBuf[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">StringCchPrintf</span>(szBuf, _countof(szBuf), <span class="built_in">TEXT</span>(<span class="string">&quot;线程ID[%d]\t开始工作&quot;</span>), dwThreadId);</span><br><span class="line">    <span class="built_in">SendMessage</span>(<span class="built_in">GetDlgItem</span>(g_hwndDlg, IDC_LIST_INFO), LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">StringCchPrintf</span>(szBuf, _countof(szBuf), <span class="built_in">TEXT</span>(<span class="string">&quot;线程ID[%d]\t工作完成&quot;</span>), dwThreadId);</span><br><span class="line">    <span class="built_in">SendMessage</span>(<span class="built_in">GetDlgItem</span>(g_hwndDlg, IDC_LIST_INFO), LB_ADDSTRING, <span class="number">0</span>, (LPARAM)szBuf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例子2-1"><a href="#例子2-1" class="headerlink" title="例子2"></a>例子2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Commctrl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;\&quot;/manifestdependency:type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;*&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="comment">// 1秒，10000000个100纳秒</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nSecond = <span class="number">10000000</span>;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">PTP_TIMER g_pTpTimer;</span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 计时器对象回调函数</span></span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">TimerCallback</span><span class="params">(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_TIMER Timer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    SYSTEMTIME st = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FILETIME ftLocal = &#123; <span class="number">0</span> &#125;, ftUTC = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//ULARGE_INTEGER uli = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="comment">// 创建一个计时器对象</span></span><br><span class="line">            g_pTpTimer = <span class="built_in">CreateThreadpoolTimer</span>(TimerCallback, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SET: &#123;&#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_RESET: &#123;</span><br><span class="line">                    <span class="comment">//// 自定义一个时间</span></span><br><span class="line">                    <span class="comment">//st.wYear = 2021;</span></span><br><span class="line">                    <span class="comment">//st.wMonth = 8;</span></span><br><span class="line">                    <span class="comment">//st.wDay = 7;</span></span><br><span class="line">                    <span class="comment">//st.wHour = 18;</span></span><br><span class="line">                    <span class="comment">//st.wMinute = 28;</span></span><br><span class="line">                    <span class="comment">//st.wSecond = 0;</span></span><br><span class="line">                    <span class="comment">//st.wMilliseconds = 0;</span></span><br><span class="line">                    <span class="comment">// 获取日期时间控件的时间</span></span><br><span class="line">                    <span class="built_in">SendDlgItemMessage</span>(hwndDlg, IDC_DATETIMEPICKER, DTM_GETSYSTEMTIME, <span class="number">0</span>, (LPARAM)&amp;st);</span><br><span class="line">                    <span class="comment">// 系统时间转换成FILETIME时间</span></span><br><span class="line">                    <span class="built_in">SystemTimeToFileTime</span>(&amp;st, &amp;ftLocal);</span><br><span class="line">                    <span class="comment">// 本地FILETIME时间转换成UTC的FILETIME时间</span></span><br><span class="line">                    <span class="built_in">LocalFileTimeToFileTime</span>(&amp;ftLocal, &amp;ftUTC);</span><br><span class="line">                    <span class="comment">// 设置计时器对象</span></span><br><span class="line">                    <span class="built_in">SetThreadpoolTimer</span>(g_pTpTimer, &amp;ftUTC, <span class="number">5000</span>, <span class="number">10</span>);</span><br><span class="line">                    <span class="comment">//// 相对时间的计时器对象</span></span><br><span class="line">                    <span class="comment">//uli.QuadPart = (ULONGLONG)-(10 * nSecond);</span></span><br><span class="line">                    <span class="comment">//ftUTC.dwHighDateTime = uli.HighPart;</span></span><br><span class="line">                    <span class="comment">//ftUTC.dwLowDateTime = uli.LowPart;</span></span><br><span class="line">                    <span class="comment">//SetThreadpoolTimer(g_pTpTimer, &amp;ftUTC, 5000, 10);</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_STOP: &#123;</span><br><span class="line">                    <span class="comment">// 停止计时器对象</span></span><br><span class="line">                    <span class="built_in">SetThreadpoolTimer</span>(g_pTpTimer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="comment">// 关闭并释放计时器对象</span></span><br><span class="line">                    <span class="built_in">SetThreadpoolTimer</span>(g_pTpTimer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">WaitForThreadpoolTimerCallbacks</span>(g_pTpTimer, TRUE);</span><br><span class="line">                    <span class="built_in">CloseThreadpoolTimer</span>(g_pTpTimer);</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">TimerCallback</span><span class="params">(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_TIMER Timer)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;open&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;Calc.exe&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, SW_SHOW);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="IPHelper"><a href="#IPHelper" class="headerlink" title="IPHelper"></a>IPHelper</h2><p>由IPHLPAPI.dll提供，头文件IPHlpApi.h，导入库为IPHlpApi.lib。</p>
<h3 id="获取本地计算机网络适配器信息"><a href="#获取本地计算机网络适配器信息" class="headerlink" title="获取本地计算机网络适配器信息"></a>获取本地计算机网络适配器信息</h3><h4 id="GetAdaptersInfo"><a href="#GetAdaptersInfo" class="headerlink" title="GetAdaptersInfo"></a>GetAdaptersInfo</h4><p>获取本地计算机网络适配器信息，已废弃用<code>GetAdaptersAddress</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetAdaptersInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ PIP_ADAPTER_INFO pAdapterInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PULONG pOutBufLen <span class="comment">//缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若pOutBufLen不够则该参数返回所需大小，返回错误码ERROR_BUFFER_OVERFLOW，执行成功返回ERROR_SUCCESS。IP_ADAPTER_INFO结构有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IP_ADAPTER_INFO</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_IP_ADAPTER_INFO</span>* Next; <span class="comment">//列表中下一个适配器指针</span></span><br><span class="line">	DWORD ComboIndex; <span class="comment">//保留</span></span><br><span class="line">	<span class="type">char</span> AdapterName[MAX_ADAPTER_NAME_LENGTH + <span class="number">4</span>]; <span class="comment">//适配器名称</span></span><br><span class="line">	<span class="type">char</span> Description[MAX_ADAPTER_DESCRIPTION_LENGTH + <span class="number">4</span>]; <span class="comment">//适配器描述</span></span><br><span class="line">	UINT AddressLength; <span class="comment">//适配器MAC地址长度</span></span><br><span class="line">	BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH]; <span class="comment">//适配器MAC地址 字节数组</span></span><br><span class="line">	DWORD Index; <span class="comment">//适配器索引</span></span><br><span class="line">	UINT Type; <span class="comment">//适配器类型</span></span><br><span class="line">	UINT DhcpEnabled; <span class="comment">//是否为此适配器启用DHCP</span></span><br><span class="line">	PIP_ADDR_STRING CurrentIpAddress; <span class="comment">//保留</span></span><br><span class="line">	IP_ADDR_STRING IpAddressList; <span class="comment">//与此适配器关联的IPv4地址列表</span></span><br><span class="line">	IP_ADDR_STRING GatewayList; <span class="comment">//适配器定义的IP地址默认网关</span></span><br><span class="line">	IP_ADDR_STRING DhcpServer; <span class="comment">//适配器定义的DHCP服务器IP地址</span></span><br><span class="line">	BOOL HaveWins; <span class="comment">//此适配器是否使用WINS</span></span><br><span class="line">	IP_ADDR_STRING PrimaryWinsServer; <span class="comment">//主WINS服务器IPv4地址</span></span><br><span class="line">	IP_ADDR_STRING SecondaryWinsServer; <span class="comment">//辅助WINS服务器IPv4地址</span></span><br><span class="line">	<span class="type">time_t</span> LeaseObtained; <span class="comment">//当前DHCP租约时间</span></span><br><span class="line">	<span class="type">time_t</span> LeaseExpires; <span class="comment">//当前DHCP租约期满时间</span></span><br><span class="line">&#125; IP_ADAPTER_INFO, * PIP_ADAPTER_INFO;</span><br></pre></td></tr></table></figure>
<h4 id="GetAdaptersAddress"><a href="#GetAdaptersAddress" class="headerlink" title="GetAdaptersAddress"></a>GetAdaptersAddress</h4><p>获取与本地计算机上的网络适配器相关联的IPv4和IPv6地址信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG WINAPI <span class="title">GetAdaptersAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ ULONG Family, <span class="comment">//地址簇</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ ULONG Flags, <span class="comment">//地址类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ PVOID Reserved, <span class="comment">//保留</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PIP_ADAPTER_ADDRESS AdapterAddresses,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_ PULONG SizePointer <span class="comment">//缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回ERROR_SUCCESS</span></span><br></pre></td></tr></table></figure>
<p>Family可以是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>枚举值</th>
<th>返回内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>AF_UNSPEC</td>
<td>返回与IPv4或IPv6相关适配器的IPv4和IPv6地址</td>
</tr>
<tr>
<td>AF_INET</td>
<td>只返回与IPv4相关的适配器的IPv4地址</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>只返回与IPv6相关的适配器的IPv6地址</td>
</tr>
</tbody>
</table>
</div>
<p>IP_ADAPTER_ADDRESS结构太复杂了自己去学。</p>
<h4 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>               <span class="comment">// WinSock2头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;IPHlpApi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32&quot;</span>)      <span class="comment">// WinSock2导入库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;IPHlpApi&quot;</span>)    <span class="comment">// IPHlpApi导入库</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PIP_ADAPTER_INFO pAdapterInfo = <span class="literal">NULL</span>;   <span class="comment">// IP_ADAPTER_INFO结构体链表缓冲区的指针</span></span><br><span class="line">    PIP_ADAPTER_INFO pAdapter = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG ulOutBufLen = <span class="number">0</span>;                  <span class="comment">// 缓冲区的大小</span></span><br><span class="line">    <span class="comment">// 第一次调用返回所需缓冲区大小，然后分配缓冲区</span></span><br><span class="line">    <span class="built_in">GetAdaptersInfo</span>(pAdapterInfo, &amp;ulOutBufLen);</span><br><span class="line">    pAdapterInfo = (PIP_ADAPTER_INFO)<span class="keyword">new</span> CHAR[ulOutBufLen];</span><br><span class="line">    <span class="comment">// 第二次调用返回所需的适配器信息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetAdaptersInfo</span>(pAdapterInfo, &amp;ulOutBufLen) == ERROR_SUCCESS) &#123;</span><br><span class="line">        pAdapter = pAdapterInfo;</span><br><span class="line">        <span class="keyword">while</span> (pAdapter) &#123;</span><br><span class="line">            <span class="comment">// 适配器的名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;适配器的名称：\t%s\n&quot;</span>, pAdapter-&gt;AdapterName);</span><br><span class="line">            <span class="comment">// 适配器的描述</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;适配器的描述：\t%s\n&quot;</span>, pAdapter-&gt;Description);</span><br><span class="line">            <span class="comment">// 适配器的Mac地址</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;适配器Mac地址：\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; pAdapter-&gt;AddressLength; i++)</span><br><span class="line">                <span class="keyword">if</span> (i == (pAdapter-&gt;AddressLength - <span class="number">1</span>))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%02X\n&quot;</span>, (<span class="type">int</span>)pAdapter-&gt;Address[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%02X-&quot;</span>, (<span class="type">int</span>)pAdapter-&gt;Address[i]);</span><br><span class="line">            <span class="comment">// IP地址</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;IP地址：\t%s\n&quot;</span>, pAdapter-&gt;IpAddressList.IpAddress.String);</span><br><span class="line">            <span class="comment">// 子网掩码</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子网掩码：\t%s\n&quot;</span>, pAdapter-&gt;IpAddressList.IpMask.String);</span><br><span class="line">            <span class="comment">// 默认网关</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;默认网关：\t%s\n&quot;</span>, pAdapter-&gt;GatewayList.IpAddress.String);</span><br><span class="line">            <span class="comment">// 是否为此适配器启用动态主机配置协议(DHCP)</span></span><br><span class="line">            <span class="keyword">if</span> (pAdapter-&gt;DhcpEnabled) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;启用DHCP：\t是\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;DHCP服务器：\t%s\n&quot;</span>, pAdapter-&gt;DhcpServer.IpAddress.String);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;启用DHCP：\t否\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;**********************************************************\n&quot;</span>);</span><br><span class="line">            pAdapter = pAdapter-&gt;Next;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GetAdaptersInfo函数调用失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] pAdapterInfo;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><h4 id="ConnectEx"><a href="#ConnectEx" class="headerlink" title="ConnectEx"></a>ConnectEx</h4><p>建立到指定面向连接的套接字的连接，并可在建立连接口发送一块数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL PASCAL <span class="title">ConnectEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ SOCKET s, <span class="comment">//套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ CONST <span class="keyword">struct</span> sockaddr* name, <span class="comment">//指定服务器IP地址与端口号</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT namelen, <span class="comment">//name结构长度 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PVOID lpSendBuffer, <span class="comment">//建立连接后要发送数据的缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ DWORD dwSendDataLength, <span class="comment">//缓冲区大小 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ LPDWORD lpdwBytesSend, <span class="comment">//返回建立连接后实际发送的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回TRUE 失败FALSE 用WSAGetLastError</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(*LPFN_CONNECTEX)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>错误代码为ERROR_IO_PENDING表示连接操作已成功启动但仍在进行。该函数可用<code>WSAIoctl</code>动态获得，GUID为WSAID_CONNECTEX。</p>
<h4 id="gethostname"><a href="#gethostname" class="headerlink" title="gethostname"></a>gethostname</h4><p>获取本地计算机标准主机名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">gethostname</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ PCHAR name, <span class="comment">//接收缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ INT namelen <span class="comment">//缓冲区长度 单位字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回0 失败SOCKET_ERROR 用WSAGetLastError</span></span><br></pre></td></tr></table></figure>
<h4 id="gethostbyname"><a href="#gethostbyname" class="headerlink" title="gethostbyname"></a>gethostbyname</h4><p>返回指定主机名的主机名称和地址信息，已废弃用<code>getaddrinfo</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="function">FAR <span class="title">gethostbyname</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ CONST PCHAR name <span class="comment">//主机名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回hostent结构指针 失败NULL 用WSAGetLastError</span></span><br></pre></td></tr></table></figure>
<p>其中hostent结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>  <span class="title class_">hostent</span> &#123;</span><br><span class="line">	CHAR    FAR* h_name; <span class="comment">//主机名称</span></span><br><span class="line">	CHAR    FAR* FAR* h_aliases; <span class="comment">//主机名称别名</span></span><br><span class="line">	SHORT   h_addrtype; <span class="comment">//地址类型 通常AF_INET</span></span><br><span class="line">	SHORT   h_length; <span class="comment">//地址长度 单位字节</span></span><br><span class="line">	CHAR    FAR* FAR* h_addr_list; <span class="comment">//网络字节顺序的主机地址列表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> h_addr  h_addr_list[0]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHAR szBuf[<span class="number">64</span>], szIP[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">gethostname</span>(szBuf, _countof(szBuf));</span><br><span class="line">hostent* pHost = <span class="built_in">gethostbyname</span>(szBuf);</span><br><span class="line"><span class="built_in">inet_ntop</span>(AF_INET, pHost-&gt;h_addr_list[<span class="number">0</span>], szIP, _countof(szIP));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, szIP);</span><br></pre></td></tr></table></figure>
<h4 id="TransmitFile"><a href="#TransmitFile" class="headerlink" title="TransmitFile"></a>TransmitFile</h4><p>在一个已连接的套接字上传输文件数据。该函数用系统缓存管理器获取文件数据，在套接字上提供高性能文件数据传输。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL PASCAL <span class="title">TransmitFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	SOCKET hSocket, <span class="comment">//面向连接的套接字句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE hFile, <span class="comment">//已打开的要传输的文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD nNumberOfBytesToWrite, <span class="comment">//要传输的文件的字节数 0为整个文件</span></span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD nNumberOfBytesPerRead, <span class="comment">//每次发送数据块大小 0为默认大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">	LPOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, <span class="comment">//传输文件缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwFlags <span class="comment">//调用行为</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回TRUE 失败FALSE 用WSAGetLastError</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(*LPFN_TRANSMITFILE)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过设置lpOverlapped结构的Offset和OffsetHigh字段，指定文件开始数据传输的偏移量。lpOverlapped为NULL时数据传输从文件当前字节偏移量开始；不为NULL时可能该函数返回前重叠I/O请求不会完成，那么该函数返回FALSE，错误码为ERROR_IO_PENDING或WSA_IO_PENDING，文件传输完成后系统将重叠结构hEvent字段或hSocket指定的套接字指定事件设置为已触发状态。lpTransmitBuffers涉及发送文件数据前后要发送的数据，只想传输文件数据则设置为NULL。dwFlags可以是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>TF_DISCONNECT</td>
<td>该函数操作进入等待队列后，发起一个传输层断开动作</td>
</tr>
<tr>
<td>TF_REUSE_SOCKET</td>
<td>为套接字句柄重用做准备，即该函数完成后仍可被用作<code>AcceptEx</code>的客户机套接字，必须同时指定TF_DISCONNECT</td>
</tr>
<tr>
<td>TF_USE_DEFAULT_WORKER</td>
<td>文件传输使用系统默认线程，用于发送大型文件</td>
</tr>
<tr>
<td>TF_USE_SYSTEM_THREAD</td>
<td>该操作用系统默认线程执行</td>
</tr>
<tr>
<td>TF_USE_KERNEL_APC</td>
<td>用内核异步过程调用处理该请求，而不用工作线程</td>
</tr>
<tr>
<td>TF_WRITE_BEHIND</td>
<td>该请求应立即返回，即使远端未确认已收到数据，不能与TF_DISCONNECT或TF_REUSE_SOCKET同时使用</td>
</tr>
</tbody>
</table>
</div>
<p>该函数可用<code>WSAIoctl</code>动态获得，GUID为WSAID_TRANSMITFILE。</p>
<h4 id="URLDownloadToFile"><a href="#URLDownloadToFile" class="headerlink" title="URLDownloadToFile"></a>URLDownloadToFile</h4><p>从网络上下载一个文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">URLDownloadToFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPUNKNOWN pCaller, <span class="comment">//调用应用程序不是ActiveX组件时为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPCTSTR szURL, <span class="comment">//要下载的URL字符串 可HTTP或HTTPS</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPCTSTR szFileName, <span class="comment">//要下载的文件本地保存路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Reserved_ DWORD dwReserved, <span class="comment">//0</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPBINDSTATUSCALLBACK lpfnCB</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCHAR szURL[] = <span class="built_in">TEXT</span>(<span class="string">&quot;https://xxx/xxx.iso&quot;</span>), szFileName[] = <span class="built_in">TEXT</span>(<span class="string">&quot;D:\\xxx\\xxx.iso&quot;</span>);</span><br><span class="line"><span class="built_in">URLDownloadToFile</span>(<span class="literal">NULL</span>, szURL, szFileName, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h2 id="时间校对"><a href="#时间校对" class="headerlink" title="时间校对"></a>时间校对</h2><p>有三种时间服务协议，自己去找国内可用的时间服务器。</p>
<p>时间日期协议RFC-867定义使用ASCⅡ字符串准确表示日期和时间；时间协议提供32位数组表示从UTC至今秒数；网络时间协议较复杂。这里举例用时间协议。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32&quot;</span>)</span></span><br><span class="line"><span class="comment">// 根据时间协议Time Protocol返回的时间更新系统时间</span></span><br><span class="line"><span class="function">VOID <span class="title">SetTimeFromTP</span><span class="params">(ULONG ulTime)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WSADATA wsa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SOCKET socketClient = INVALID_SOCKET;</span><br><span class="line">    sockaddr_in addrServer; <span class="comment">// 时间服务器的地址</span></span><br><span class="line">    <span class="type">int</span> nRet;</span><br><span class="line">    <span class="comment">// 1、初始化WinSock库</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2、创建与服务器进行通信的套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((socketClient = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3、使用connect函数来请求与服务器连接</span></span><br><span class="line">    addrServer.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;132.163.97.1&quot;</span>, (LPVOID)(&amp;addrServer.sin_addr.S_un.S_addr));</span><br><span class="line">    addrServer.sin_port = <span class="built_in">htons</span>(<span class="number">37</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(socketClient, (sockaddr*)&amp;addrServer, <span class="built_in">sizeof</span>(addrServer)) == SOCKET_ERROR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 4、接收时间协议返回的时间，自1900年1月1日0点0分0秒0毫秒逝去的毫秒数</span></span><br><span class="line">    ULONG ulTime = <span class="number">0</span>;</span><br><span class="line">    nRet = <span class="built_in">recv</span>(socketClient, (PCHAR)&amp;ulTime, <span class="built_in">sizeof</span>(ulTime), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nRet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 网络字节序到本机字节序</span></span><br><span class="line">        ulTime = <span class="built_in">ntohl</span>(ulTime);</span><br><span class="line">        <span class="built_in">SetTimeFromTP</span>(ulTime);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功与时间服务器的时间同步！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;时间服务器未能返回时间！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">closesocket</span>(socketClient);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 根据时间协议Time Protocol返回的时间更新系统时间</span></span><br><span class="line"><span class="function">VOID <span class="title">SetTimeFromTP</span><span class="params">(ULONG ulTime)</span> </span>&#123;</span><br><span class="line">    FILETIME ft;</span><br><span class="line">    SYSTEMTIME st;</span><br><span class="line">    ULARGE_INTEGER uli;</span><br><span class="line">    st.wYear = <span class="number">1900</span>;</span><br><span class="line">    st.wMonth = <span class="number">1</span>;</span><br><span class="line">    st.wDay = <span class="number">1</span>;</span><br><span class="line">    st.wHour = <span class="number">0</span>;</span><br><span class="line">    st.wMinute = <span class="number">0</span>;</span><br><span class="line">    st.wSecond = <span class="number">0</span>;</span><br><span class="line">    st.wMilliseconds = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 系统时间转换为文件时间才可以加上已经逝去的时间ulTime</span></span><br><span class="line">    <span class="built_in">SystemTimeToFileTime</span>(&amp;st, &amp;ft);</span><br><span class="line">    <span class="comment">// 文件时间单位是1/1000 0000秒，即1000万分之1秒(100-nanosecond)</span></span><br><span class="line">    <span class="comment">// 不要将指向FILETIME结构的指针强制转换为ULARGE_INTEGER *或__int64 *值，</span></span><br><span class="line">    <span class="comment">// 因为这可能导致64位Windows上的对齐错误</span></span><br><span class="line">    uli.HighPart = ft.dwHighDateTime;</span><br><span class="line">    uli.LowPart = ft.dwLowDateTime;</span><br><span class="line">    uli.QuadPart += (ULONGLONG)<span class="number">10000000</span> * ulTime;</span><br><span class="line">    ft.dwHighDateTime = uli.HighPart;</span><br><span class="line">    ft.dwLowDateTime = uli.LowPart;</span><br><span class="line">    <span class="comment">// 再将文件时间转换为系统时间，更新系统时间</span></span><br><span class="line">    <span class="built_in">FileTimeToSystemTime</span>(&amp;ft, &amp;st);</span><br><span class="line">    <span class="built_in">SetSystemTime</span>(&amp;st);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="系统网络连接"><a href="#系统网络连接" class="headerlink" title="系统网络连接"></a>系统网络连接</h2><p>断开网络就是把所有网卡都禁用了，恢复连接就是启用所有网卡。设备的启用、禁用就是对该设备的卸载和重安装。</p>
<h3 id="UuidFromString"><a href="#UuidFromString" class="headerlink" title="UuidFromString"></a>UuidFromString</h3><p>把一个UUID字符串转换为UUID类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RPC_STATUS RPC_ENTRY <span class="title">UuidFromStringW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ RPC_WSTR StringUuid, <span class="comment">//UUID字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ UUID* Uuid</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回RPC_S_OK 失败RPC_S_INVALID_STRING_UUID</span></span><br><span class="line"><span class="function">RPC_STATUS RPC_ENTRY <span class="title">UuidFromStringA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ RPC_CSTR StringUuid, <span class="comment">//UUID字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ UUID* Uuid</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> _Null_terminated_ USHORT __RPC_FAR* RPC_WSTR;</span><br><span class="line"><span class="keyword">typedef</span> _Null_terminated_ UCHAR __RPC_FAR* RPC_CSTR;</span><br><span class="line"><span class="keyword">typedef</span> GUID UUID;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_GUID</span> &#123;</span><br><span class="line">    ULONG  Data1;</span><br><span class="line">    USHORT Data2;</span><br><span class="line">    USHORT Data3;</span><br><span class="line">    UCHAR  Data4[ <span class="number">8</span> ];</span><br><span class="line">&#125; GUID;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GUID guid;</span><br><span class="line"><span class="built_in">UuidFromString</span>((RPC_WSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;4D36E972-E325-11CE-BFC1-08002BE10318&quot;</span>), &amp;guid);</span><br></pre></td></tr></table></figure>
<h3 id="SetupDiGetClassDevs"><a href="#SetupDiGetClassDevs" class="headerlink" title="SetupDiGetClassDevs"></a>SetupDiGetClassDevs</h3><p>返回一个包含本机所有被请求设备的设备信息集句柄：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDEVINFO <span class="title">SetupDiGetClassDevs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ CONST GUID* ClassGuid, <span class="comment">//设备安装/接口类的GUID</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PCTSTR Enumerator, <span class="comment">//PnP枚举器GUID 或符号名称 或PnP设备实例ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ HWND hwndParent, <span class="comment">//与设备信息集中安装设备实例关联的用户界面窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD Flags <span class="comment">//设备安装/接口类标志 过滤指定设备信息集中设备</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回设备信息集句柄 失败INVALID_HANDLE_VALUE 用GetLastError</span></span><br></pre></td></tr></table></figure>
<p>Flags可以是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DIGCF_ALLCLASSES</td>
<td>返回所有设备安装/接口类已安装设备列表，ClassGuid为NULL</td>
</tr>
<tr>
<td>DIGCF_PRESENT</td>
<td>仅返回系统当前存在的设备</td>
</tr>
<tr>
<td>DIGCF_PROFILE</td>
<td>仅返回属于当前硬件配置文件的设备</td>
</tr>
</tbody>
</table>
</div>
<h3 id="SetupDiEnumDeviceInfo"><a href="#SetupDiEnumDeviceInfo" class="headerlink" title="SetupDiEnumDeviceInfo"></a>SetupDiEnumDeviceInfo</h3><p>枚举设备信息集中的设备，返回一个设备的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetupDiEnumDeviceInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HDEVINFO DeviceInfoSet, <span class="comment">//设备信息集句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD MemberIndex, <span class="comment">//设备索引 从0开始</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_ PSP_DEVINFO_DATA DeviceInfoData <span class="comment">//返回指定设备信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功TRUE 失败FALSE 用GetLastError</span></span><br></pre></td></tr></table></figure>
<p>MemberIndex开始为0，依次递增，直到枚举完毕返回FALSE，错误码ERROR_NO_MORE_ITEMS。其中SP_DEVINFO_DATA结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SP_DEVINFO_DATA</span> &#123;</span><br><span class="line">	DWORD     cbSize; <span class="comment">//该结构大小</span></span><br><span class="line">	GUID      ClassGuid; <span class="comment">//设备安装类GUID</span></span><br><span class="line">	DWORD     DevInst; <span class="comment">//设备实例句柄</span></span><br><span class="line">	ULONG_PTR Reserved;</span><br><span class="line">&#125; SP_DEVINFO_DATA, * PSP_DEVINFO_DATA;</span><br></pre></td></tr></table></figure>
<h3 id="SetupDiSetClassInstallParams"><a href="#SetupDiSetClassInstallParams" class="headerlink" title="SetupDiSetClassInstallParams"></a>SetupDiSetClassInstallParams</h3><p>设置或清除设备信息集或特定设备的类安装参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetupDiSetClassInstallParams</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HDEVINFO DeviceInfoSet, <span class="comment">//设备信息集句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PSP_DEVINFO_DATA DeviceInfoData,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PSP_CLASSINSTALL_HEADER ClassInstallParams, <span class="comment">//设置或清除安装参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DWORD ClassInstallParamsSize <span class="comment">//ClassInstallParams结构大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里ClassInstallParams改用SP_PROPCHANGE_PARAMS结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SP_PROPCHANGE_PARAMS</span> &#123;</span><br><span class="line">	SP_CLASSINSTALL_HEADER ClassInstallHeader;</span><br><span class="line">	DWORD                  StateChange;</span><br><span class="line">	DWORD                  Scope;</span><br><span class="line">	DWORD                  HwProfile;</span><br><span class="line">&#125; SP_PROPCHANGE_PARAMS, * PSP_PROPCHANGE_PARAMS;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SP_CLASSINSTALL_HEADER</span> &#123;</span><br><span class="line">	DWORD       cbSize;</span><br><span class="line">	DI_FUNCTION InstallFunction; <span class="comment">//设备安装请求代码</span></span><br><span class="line">&#125; SP_CLASSINSTALL_HEADER, * PSP_CLASSINSTALL_HEADER;</span><br></pre></td></tr></table></figure>
<p>其中InstallFunction需要为DIF_PROPERTYCHANGE表示要更改设备安装属性，StateChange为DICS_ENABLE或DICS_DISABLE表示启用或禁用，Scope为DICS_FLAG_GLOBAL表示全局作用域。</p>
<h3 id="SetupDiCallClassInstaller"><a href="#SetupDiCallClassInstaller" class="headerlink" title="SetupDiCallClassInstaller"></a>SetupDiCallClassInstaller</h3><p>执行设备安装：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetupDiCallClassInstaller</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ DI_FUNCTION InstallFunction,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HDEVINFO DeviceInfoSet, <span class="comment">//设备信息集句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PSP_DEVINFO_DATA DeviceInfoData</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中InstallFunction设置为DIF_PROPERTYCHANGE表示要更改设备安装属性。</p>
<h3 id="SetupDiDestroyDeviceInfoList"><a href="#SetupDiDestroyDeviceInfoList" class="headerlink" title="SetupDiDestroyDeviceInfoList"></a>SetupDiDestroyDeviceInfoList</h3><p>删除设备信息集并释放相关内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetupDiDestroyDeviceInfoList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HDEVINFO DeviceInfoSet</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h3><p>COM组件法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;NetCon.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">ConnectNetwork</span><span class="params">(BOOL bConnect)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_CONNECT: &#123;</span><br><span class="line">                    <span class="built_in">ConnectNetwork</span>(TRUE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_DISCONNECT: &#123;</span><br><span class="line">                    <span class="built_in">ConnectNetwork</span>(FALSE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">ConnectNetwork</span><span class="params">(BOOL bConnect)</span> </span>&#123;</span><br><span class="line">    HRESULT hr;</span><br><span class="line">    INetConnectionManager* pNetConnManager;</span><br><span class="line">    INetConnection* pNetConn;</span><br><span class="line">    IEnumNetConnection* pEnumNetConn;</span><br><span class="line">    ULONG                   uCeltFetched;</span><br><span class="line">    <span class="built_in">CoInitializeEx</span>(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    hr = <span class="built_in">CoCreateInstance</span>(CLSID_ConnectionManager, <span class="literal">NULL</span>, CLSCTX_SERVER, IID_INetConnectionManager, (LPVOID*)&amp;pNetConnManager);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    pNetConnManager-&gt;<span class="built_in">EnumConnections</span>(NCME_DEFAULT, &amp;pEnumNetConn);</span><br><span class="line">    pNetConnManager-&gt;<span class="built_in">Release</span>();</span><br><span class="line">    <span class="keyword">if</span> (pEnumNetConn == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">while</span> (pEnumNetConn-&gt;<span class="built_in">Next</span>(<span class="number">1</span>, &amp;pNetConn, &amp;uCeltFetched) == S_OK)</span><br><span class="line">        <span class="keyword">if</span> (bConnect)</span><br><span class="line">            pNetConn-&gt;<span class="built_in">Connect</span>();              <span class="comment">//启用连接</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pNetConn-&gt;<span class="built_in">Disconnect</span>();           <span class="comment">//禁用连接</span></span><br><span class="line">    <span class="built_in">CoUninitialize</span>();</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SetupAPI法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SetupAPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Rpcrt4&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;SetupAPI&quot;</span>)</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HWND g_hwndDlg;</span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">ConnectNetwork</span><span class="params">(BOOL bConnect)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            g_hwndDlg = hwndDlg;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_CONNECT: &#123;</span><br><span class="line">                    <span class="built_in">ConnectNetwork</span>(TRUE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_DISCONNECT: &#123;</span><br><span class="line">                    <span class="built_in">ConnectNetwork</span>(FALSE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDCANCEL: &#123;</span><br><span class="line">                    <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">ConnectNetwork</span><span class="params">(BOOL bConnect)</span> </span>&#123;</span><br><span class="line">    GUID guid;</span><br><span class="line">    DWORD dwNewState;</span><br><span class="line">    HDEVINFO hDevInfoSet;</span><br><span class="line">    SP_DEVINFO_DATA spDevInfoData;</span><br><span class="line">    <span class="type">int</span> nDeviceIndex = <span class="number">0</span>;</span><br><span class="line">    SP_PROPCHANGE_PARAMS spPropChangeParams;</span><br><span class="line">    <span class="keyword">if</span> (bConnect)</span><br><span class="line">        dwNewState = DICS_ENABLE;     <span class="comment">//启用</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dwNewState = DICS_DISABLE;    <span class="comment">//禁用</span></span><br><span class="line">    <span class="comment">// 网卡安装类GUID</span></span><br><span class="line">    <span class="built_in">UuidFromString</span>((RPC_WSTR)<span class="built_in">TEXT</span>(<span class="string">&quot;4D36E972-E325-11CE-BFC1-08002BE10318&quot;</span>), &amp;guid);</span><br><span class="line">    <span class="comment">// 获取设备信息集句柄</span></span><br><span class="line">    hDevInfoSet = <span class="built_in">SetupDiGetClassDevs</span>(&amp;guid, <span class="literal">NULL</span>, <span class="literal">NULL</span>, DIGCF_PRESENT);</span><br><span class="line">    <span class="keyword">if</span> (hDevInfoSet == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(g_hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;获取设备信息集句柄出错！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;错误提示&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 枚举设备</span></span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;spDevInfoData, <span class="built_in">sizeof</span>(SP_DEVINFO_DATA));</span><br><span class="line">    spDevInfoData.cbSize = <span class="built_in">sizeof</span>(SP_DEVINFO_DATA);</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;spPropChangeParams, <span class="built_in">sizeof</span>(SP_PROPCHANGE_PARAMS));</span><br><span class="line">    spPropChangeParams.ClassInstallHeader.cbSize = <span class="built_in">sizeof</span>(SP_CLASSINSTALL_HEADER);</span><br><span class="line">    spPropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;</span><br><span class="line">    spPropChangeParams.StateChange = dwNewState;    <span class="comment">// 启用或禁用</span></span><br><span class="line">    spPropChangeParams.Scope = DICS_FLAG_GLOBAL;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">SetupDiEnumDeviceInfo</span>(hDevInfoSet, nDeviceIndex, &amp;spDevInfoData))</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_NO_MORE_ITEMS)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        nDeviceIndex++;</span><br><span class="line">        <span class="comment">// 安装该设备</span></span><br><span class="line">        <span class="built_in">SetupDiSetClassInstallParams</span>(hDevInfoSet, &amp;spDevInfoData, (PSP_CLASSINSTALL_HEADER)&amp;spPropChangeParams, <span class="built_in">sizeof</span>(spPropChangeParams));</span><br><span class="line">        <span class="built_in">SetupDiCallClassInstaller</span>(DIF_PROPERTYCHANGE, hDevInfoSet, &amp;spDevInfoData);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 销毁设备信息集句柄</span></span><br><span class="line">    <span class="built_in">SetupDiDestroyDeviceInfoList</span>(hDevInfoSet);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinInet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Wininet.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;\&quot;/manifestdependency:type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;*&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> TCHAR  szFile[MAX_PATH] = &#123; <span class="number">0</span> &#125;;      <span class="comment">// 返回用户选择的本地文件名的缓冲区</span></span><br><span class="line">    <span class="type">static</span> TCHAR  szFileTitle[MAX_PATH] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 返回用户所选本地文件的文件名和扩展名的缓冲区</span></span><br><span class="line">    OPENFILENAME  ofn = &#123; <span class="built_in">sizeof</span>(OPENFILENAME) &#125;;</span><br><span class="line">    ofn.hwndOwner = hwndDlg;</span><br><span class="line">    ofn.lpstrFilter = <span class="built_in">TEXT</span>(<span class="string">&quot;All(*.*)\0*.*\0&quot;</span>);</span><br><span class="line">    ofn.lpstrFile = szFile;</span><br><span class="line">    <span class="comment">//ofn.lpstrFile[0] = NULL;</span></span><br><span class="line">    ofn.nMaxFile = _countof(szFile);</span><br><span class="line">    ofn.lpstrFileTitle = szFileTitle;</span><br><span class="line">    ofn.nMaxFileTitle = _countof(szFileTitle);</span><br><span class="line">    ofn.lpstrInitialDir = <span class="built_in">TEXT</span>(<span class="string">&quot;C:\\&quot;</span>);</span><br><span class="line">    ofn.lpstrTitle = <span class="built_in">TEXT</span>(<span class="string">&quot;请选择要打开的文件&quot;</span>);</span><br><span class="line">    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_CREATEPROMPT;</span><br><span class="line">    <span class="type">static</span> HINTERNET hInternet = <span class="literal">NULL</span>;                           <span class="comment">// Internet初始化句柄</span></span><br><span class="line">    <span class="type">static</span> HINTERNET hConnect = <span class="literal">NULL</span>;                            <span class="comment">// FTP会话句柄</span></span><br><span class="line">    TCHAR            szCurrentDirectory[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    DWORD            dwCurrentDirectory = _countof(szCurrentDirectory);</span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="comment">// 打开并初始化WinINet库</span></span><br><span class="line">            hInternet = <span class="built_in">InternetOpen</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Mozilla/5.0&quot;</span>), INTERNET_OPEN_TYPE_DIRECT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 连接到指定站点的FTP、HTTP(或HTTPS)服务</span></span><br><span class="line">            hConnect = <span class="built_in">InternetConnect</span>(hInternet, <span class="built_in">TEXT</span>(<span class="string">&quot;127.0.0.1&quot;</span>), INTERNET_DEFAULT_FTP_PORT, <span class="built_in">TEXT</span>(<span class="string">&quot;admin&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;123456&quot;</span>), INTERNET_SERVICE_FTP, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_BROWSE: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetOpenFileName</span>(&amp;ofn))</span><br><span class="line">                        <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_FILE, szFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_PUTFILE: &#123;</span><br><span class="line">                    <span class="comment">// 获取本地文件路径</span></span><br><span class="line">                    <span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_FILE, szFile, _countof(szFile));</span><br><span class="line">                    <span class="comment">// 上传本地文件到FTP服务器上</span></span><br><span class="line">                    <span class="built_in">FtpPutFile</span>(hConnect, szFile, szFileTitle, FTP_TRANSFER_TYPE_BINARY, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_GETFILE: &#123;</span><br><span class="line">                    <span class="comment">// 从FTP服务器下载一个文件到程序当前目录</span></span><br><span class="line">                    <span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szFile, _countof(szFile));</span><br><span class="line">                    <span class="built_in">StringCchCopy</span>(_tcsrchr(szFile, <span class="built_in">TEXT</span>(<span class="string">&#x27;\\&#x27;</span>)) + <span class="number">1</span>, _tcslen(szFileTitle) + <span class="number">1</span>, szFileTitle);</span><br><span class="line">                    <span class="built_in">FtpGetFile</span>(hConnect, szFileTitle, szFile, FALSE, FILE_ATTRIBUTE_NORMAL, FTP_TRANSFER_TYPE_BINARY | INTERNET_FLAG_RESYNCHRONIZE, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_CREATEDIRECTORY: &#123;</span><br><span class="line">                    <span class="comment">// 在FTP服务器上创建一个新的目录</span></span><br><span class="line">                    <span class="built_in">FtpCreateDirectory</span>(hConnect, <span class="built_in">TEXT</span>(<span class="string">&quot;新建文件夹&quot;</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_REMOVEDIRECTORY: &#123;</span><br><span class="line">                    <span class="comment">// 删除FTP服务器上的一个目录，注意，只能删除非空目录，无法删除当前目录</span></span><br><span class="line">                    <span class="built_in">FtpSetCurrentDirectory</span>(hConnect, <span class="built_in">TEXT</span>(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">                    <span class="built_in">FtpRemoveDirectory</span>(hConnect, <span class="built_in">TEXT</span>(<span class="string">&quot;新建文件夹&quot;</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_SETDIRECTORY: &#123;</span><br><span class="line">                    <span class="comment">// 设置FTP会话的当前目录</span></span><br><span class="line">                    <span class="built_in">FtpSetCurrentDirectory</span>(hConnect, <span class="built_in">TEXT</span>(<span class="string">&quot;新建文件夹&quot;</span>));</span><br><span class="line">                    <span class="built_in">FtpGetCurrentDirectory</span>(hConnect, szCurrentDirectory, &amp;dwCurrentDirectory);</span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_DIRECTORY, szCurrentDirectory);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_GETDIRECTORY: &#123;</span><br><span class="line">                    <span class="comment">// 获取FTP会话的当前目录</span></span><br><span class="line">                    <span class="built_in">FtpGetCurrentDirectory</span>(hConnect, szCurrentDirectory, &amp;dwCurrentDirectory);</span><br><span class="line">                    <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_DIRECTORY, szCurrentDirectory);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_CLOSE: &#123;</span><br><span class="line">            <span class="comment">// 关闭相关句柄</span></span><br><span class="line">            <span class="built_in">InternetCloseHandle</span>(hConnect);</span><br><span class="line">            <span class="built_in">InternetCloseHandle</span>(hInternet);</span><br><span class="line">            <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HttpQueryInfo"><a href="#HttpQueryInfo" class="headerlink" title="HttpQueryInfo"></a>HttpQueryInfo</h3><p>用于获取与HTTP请求关联的标头信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLAPI <span class="title">HttpQueryInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_        HINTERNET hRequest,        <span class="comment">// HttpOpenRequest或InternetOpenUrl函数返回的Internet句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_        DWORD     dwInfoLevel,     <span class="comment">// 获取标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_       LPVOID    lpBuffer,        <span class="comment">// 接收所请求信息的缓冲区的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_     LPDWORD   lpdwBufferLength,<span class="comment">// 缓冲区的长度，以字节为单位</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_Inout_opt_ LPDWORD   lpdwIndex        <span class="comment">// 从0开始的标头索引，用于枚举具有相同名称的多个标头时</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>hRequest参数指定为HttpOpenRequest或InternetOpenUrl函数返回的Internet句柄。dwInfoLevel参数用于指定获取标志，可以是以下值的组合：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP_QUERY_CACHE_CONTROL</td>
<td>获取Cache-Control，缓存控制</td>
</tr>
<tr>
<td>HTTP_QUERY_CONNECTION</td>
<td>获取Connection，为特定连接指定的任何选项，控制不再转发给代理的标头</td>
</tr>
<tr>
<td>HTTP_QUERY_DATE</td>
<td>获取Date，创建报文的日期时间</td>
</tr>
<tr>
<td>HTTP_QUERY_TRANSFER_ENCODING</td>
<td>获取Transfer-Encoding，报文主体的传输编码方式</td>
</tr>
<tr>
<td>HTTP_QUERY_UPGRADE</td>
<td>获取Upgrade，服务器支持的其他通信协议</td>
</tr>
<tr>
<td>HTTP_QUERY_VIA</td>
<td>获取Via，代理服务器的相关信息</td>
</tr>
<tr>
<td>HTTP_QUERY_WARNING</td>
<td>获取Warning，警告信息</td>
</tr>
<tr>
<td>HTTP_QUERY_ACCEPT</td>
<td>获取Accept，文档类型</td>
</tr>
<tr>
<td>HTTP_QUERY_ACCEPT_CHARSET</td>
<td>获取Accept-Charset，字符集</td>
</tr>
<tr>
<td>HTTP_QUERY_ACCEPT_ENCODING</td>
<td>获取Accept-Encoding，内容编码</td>
</tr>
<tr>
<td>HTTP_QUERY_ACCEPT_LANGUAGE</td>
<td>获取Accept-Language，语言(自然语言)</td>
</tr>
<tr>
<td>HTTP_QUERY_AUTHORIZATION</td>
<td>获取Authorization，认证信息</td>
</tr>
<tr>
<td>HTTP_QUERY_EXPECT</td>
<td>获取Expect，客户端是否应期待100系列响应</td>
</tr>
<tr>
<td>HTTP_QUERY_FROM</td>
<td>获取From，电子邮件地址</td>
</tr>
<tr>
<td>HTTP_QUERY_HOST</td>
<td>获取Host，主机名和端口号</td>
</tr>
<tr>
<td>HTTP_QUERY_IF_MATCH</td>
<td>获取If-Match，服务器会比较If-Match和资源的ETag值，仅当两者一致时，才会执行请求</td>
</tr>
<tr>
<td>HTTP_QUERY_IF_NONE_MATCH</td>
<td>获取If-None-Match，服务器会比较If-Match和资源的ETag值，仅当两者不一致时，才会执行请求</td>
</tr>
<tr>
<td>HTTP_QUERY_IF_MODIFIED_SINCE</td>
<td>获取If-Modified-Since，比较资源的更新时间，在指定的日期时间之后如果资源发生了更新， 服务器会接受请求</td>
</tr>
<tr>
<td>HTTP_QUERY_IF_UNMODIFIED_SINCE</td>
<td>获取If-Unmodified-Since，比较资源的更新时间，在指定的日期时间之后没有发生更新的情况下， 服务器才会接受请求</td>
</tr>
<tr>
<td>HTTP_QUERY_IF_RANGE</td>
<td>获取If-Range，指定的If-Range值(ETag值或时间)和请求资源的ETag值或时间相一致时作为范围请求处理；反之，则返回全体资源</td>
</tr>
<tr>
<td>HTTP_QUERY_MAX_FORWARDS</td>
<td>获取Max-Forwards，可以将请求转发到下一个入站服务器的代理或网关的数量</td>
</tr>
<tr>
<td>HTTP_QUERY_PROXY_AUTHORIZATION</td>
<td>获取Proxy-Authorization，代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>HTTP_QUERY_RANGE</td>
<td>获取Range，实体的字节范围请求</td>
</tr>
<tr>
<td>HTTP_QUERY_REFERER</td>
<td>获取Referer，请求来源</td>
</tr>
<tr>
<td>HTTP_QUERY_USER_AGENT</td>
<td>获取User-Agent，HTTP客户端程序的信息</td>
</tr>
<tr>
<td>HTTP_QUERY_ACCEPT_RANGES</td>
<td>获取响应头的Accept-Ranges，是否接受字节范围请求</td>
</tr>
<tr>
<td>HTTP_QUERY_AGE</td>
<td>获取响应头的Age，资源创建经过的时间</td>
</tr>
<tr>
<td>HTTP_QUERY_ETAG</td>
<td>获取响应头的ETag，资源的匹配信息</td>
</tr>
<tr>
<td>HTTP_QUERY_LOCATION</td>
<td>获取响应头的Location，令客户端重定向至指定URL</td>
</tr>
<tr>
<td>HTTP_QUERY_PROXY_AUTHENTICATE</td>
<td>获取响应头的Proxy-Authenticate，把代理服务器所要求的认证信息发送给客户端</td>
</tr>
<tr>
<td>HTTP_QUERY_RETRY_AFTER</td>
<td>获取响应头的Retry-After，多久之后可以再次发送请求</td>
</tr>
<tr>
<td>HTTP_QUERY_SERVER</td>
<td>获取响应头的Server，HTTP服务器的安装信息</td>
</tr>
<tr>
<td>HTTP_QUERY_VARY</td>
<td>获取响应头的Vary，代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>HTTP_QUERY_WWW_AUTHENTICATE</td>
<td>获取响应头的WWW-Authenticate，访问请求指定资源的认证方案</td>
</tr>
<tr>
<td>HTTP_QUERY_ALLOW</td>
<td>获取Allow，服务器支持的HTTP请求方法</td>
</tr>
<tr>
<td>HTTP_QUERY_CONTENT_ENCODING</td>
<td>获取Content-Encoding，实体主体的内容编码方式</td>
</tr>
<tr>
<td>HTTP_QUERY_CONTENT_LANGUAGE</td>
<td>获取Content-Language，实体主体的语言(自然语言)</td>
</tr>
<tr>
<td>HTTP_QUERY_CONTENT_LENGTH</td>
<td>获取Content-Length，实体主体的大小(以字节为单位)</td>
</tr>
<tr>
<td>HTTP_QUERY_CONTENT_LOCATION</td>
<td>获取Content-Location，和Location不同， Content-Location表示的是实体主体返回的资源对应的URL</td>
</tr>
<tr>
<td>HTTP_QUERY_CONTENT_MD5</td>
<td>获取Content-MD5，为实体主体提供端到端消息完整性检查(MIC)</td>
</tr>
<tr>
<td>HTTP_QUERY_CONTENT_RANGE</td>
<td>获取Content-Range，完整实体主体中应插入部分实体主体的位置以及完整实体主体的总大小</td>
</tr>
<tr>
<td>HTTP_QUERY_CONTENT_TYPE</td>
<td>获取Content-Type，实体主体的文档类型</td>
</tr>
<tr>
<td>HTTP_QUERY_EXPIRES</td>
<td>获取Expires，实体主体过期的日期时间</td>
</tr>
<tr>
<td>HTTP_QUERY_LAST_MODIFIED</td>
<td>获取Last-Modified，资源的最后修改日期时间</td>
</tr>
<tr>
<td>HTTP_QUERY_COOKIE</td>
<td>获取Cookie，与请求关联的cookie</td>
</tr>
<tr>
<td>HTTP_QUERY_SET_COOKIE</td>
<td>获取Set-Cookie，为请求设置的cookie的值</td>
</tr>
<tr>
<td>HTTP_QUERY_RAW_HEADERS</td>
<td>获取服务器返回的所有标头，每个标头都以’\0’结尾，所有标头末尾有一个附加的’\0’</td>
</tr>
<tr>
<td>HTTP_QUERY_RAW_HEADERS_CRLF</td>
<td>获取服务器返回的所有标头，每个标头都以回车换行分隔</td>
</tr>
<tr>
<td>HTTP_QUERY_REQUEST_METHOD</td>
<td>获取请求方法，通常是GET或POST</td>
</tr>
<tr>
<td>HTTP_QUERY_STATUS_CODE</td>
<td>获取服务器返回的状态码</td>
</tr>
<tr>
<td>HTTP_QUERY_STATUS_TEXT</td>
<td>获取服务器在响应行上返回的任何附加文本</td>
</tr>
<tr>
<td>HTTP_QUERY_CONTENT_BASE</td>
<td>获取用于解析实体内的相对URL的基本URL</td>
</tr>
<tr>
<td>HTTP_QUERY_MIME_VERSION</td>
<td>获取用于构造消息的MIME协议的版本</td>
</tr>
<tr>
<td>HTTP_QUERY_PROXY_CONNECTION</td>
<td>获取代理连接标头</td>
</tr>
<tr>
<td>HTTP_QUERY_PUBLIC</td>
<td>获取服务器上可用的方法</td>
</tr>
<tr>
<td>HTTP_QUERY_UNLESS_MODIFIED_SINCE</td>
<td>获取Unless-Modified-Since标头</td>
</tr>
<tr>
<td>HTTP_QUERY_VERSION</td>
<td>获取服务器返回的最后一个响应代码</td>
</tr>
<tr>
<td>HTTP_QUERY_X_CONTENT_TYPE_OPTIONS</td>
<td>获取X-Content-Type-Options标头值</td>
</tr>
<tr>
<td>HTTP_QUERY_P3P</td>
<td>获取P3P标头值</td>
</tr>
<tr>
<td>HTTP_QUERY_X_P2P_PEERDIST</td>
<td>获取X-P2P-PeerDist标头值</td>
</tr>
<tr>
<td>HTTP_QUERY_TRANSLATE</td>
<td>获取translate标头值</td>
</tr>
<tr>
<td>HTTP_QUERY_X_UA_COMPATIBLE</td>
<td>获取X-UA-Compatible标头值</td>
</tr>
<tr>
<td>HTTP_QUERY_DEFAULT_STYLE</td>
<td>获取Default-Style标头值</td>
</tr>
<tr>
<td>HTTP_QUERY_X_FRAME_OPTIONS</td>
<td>获取X-Frame-Options标头值</td>
</tr>
<tr>
<td>HTTP_QUERY_X_XSS_PROTECTION</td>
<td>获取X-XSS-Protection标头值</td>
</tr>
<tr>
<td>HTTP_QUERY_FLAG_NUMBER</td>
<td>对于值为数字(例如状态代码)的标头，将数据作为32位数字返回</td>
</tr>
<tr>
<td>HTTP_QUERY_FLAG_REQUEST_HEADERS</td>
<td>仅查询请求头</td>
</tr>
<tr>
<td>HTTP_QUERY_FLAG_SYSTEMTIME</td>
<td>将标头值作为SYSTEMTIME结构返回，用于值为日期时间字符串的标头</td>
</tr>
<tr>
<td>HTTP_QUERY_CONTENT_ID</td>
<td>获取内容ID</td>
</tr>
<tr>
<td>HTTP_QUERY_CONTENT_TRANSFER_ENCODING</td>
<td>获取资源的附加内容编码</td>
</tr>
<tr>
<td>HTTP_QUERY_CUSTOM</td>
<td>获取lpBuffer指定的标头名称并将标头数据存储在lpBuffer中</td>
</tr>
<tr>
<td>HTTP_QUERY_PRAGMA</td>
<td>获取特定于实现的指令，这些指令可能应用于请求/响应链上的任何接收者</td>
</tr>
<tr>
<td>HTTP_QUERY_URI</td>
<td>获取部分或全部统一资源标识符(URI)，通过该标识符可以识别Request-URI资源</td>
</tr>
</tbody>
</table>
</div>
<p>lpBuffer参数指定为接收所请求信息的缓冲区的指针。lpdwBufferLength参数用于指定缓冲区的长度，以字节为单位。lpdwIndex参数指定为从0开始的标头索引，用于枚举具有相同名称的多个标头时。要枚举具有相同名称的多个标头，第1次调用HttpQueryInfo函数的时候可以将lpdwIndex参数指向的DWORD型变量的值设置为0，函数返回时，该参数指向的DWORD型变量的值会被设置为下一个标头的索引，程序可以通过lpdwIndex参数的返回值循环调用HttpQueryInfo函数，每次调用HttpQueryInfo函数都应该通过调用GetLastError函数获取错误代码，直到返回错误代码ERROR_HTTP_HEADER_NOT_FOUND。</p>
<h3 id="InternetSetOption"><a href="#InternetSetOption" class="headerlink" title="InternetSetOption"></a>InternetSetOption</h3><p>设置Internet选项：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLAPI <span class="title">InternetSetOption</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ HINTERNET hInternet,       <span class="comment">// Internet句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_     DWORD     dwOption,        <span class="comment">// 要设置的Internet选项</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPVOID    lpBuffer,        <span class="comment">// 包含Internet选项设置的缓冲区的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_     DWORD     dwBufferLength   <span class="comment">// 缓冲区的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>hInternet参数指定为要设置的Internet句柄。dwOption参数指定为要设置的Internet选项，可以是以下值之一(可以用于InternetSetOption和InternetQueryOption函数)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>INTERNET_OPTION_BYPASS_EDITED_ENTRY</td>
<td>设置或获取系统是否应该检查网络以获取较新的内容，并在发现较新的版本时覆盖已编辑的缓存条目</td>
</tr>
<tr>
<td>INTERNET_OPTION_CACHE_TIMESTAMPS</td>
<td>从Internet缓存中获取INTERNET_CACHE_TIMESTAMPS结构，该结构包含LastModified和Expires时间</td>
</tr>
<tr>
<td>INTERNET_OPTION_CALLBACK</td>
<td>设置或获取为Internet句柄定义的回调函数的地址</td>
</tr>
<tr>
<td>INTERNET_OPTION_CLIENT_CERT_CONTEXT</td>
<td>lpBuffer参数必须是指向CERT_CONTEXT结构的指针，而不是指向CERT_CONTEXT指针的指针。如果应用程序收到ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED，它必须在重试请求之前调用InternetErrorDlg或使用InternetSetOption提供证书，然后调用CertDuplicateCertificateContext，这样传递的证书上下文可以由应用程序独立释放，仅用于InternetSetOption函数</td>
</tr>
<tr>
<td>INTERNET_OPTION_CODEPAGE</td>
<td>默认情况下，Unicode URL的主机或授权部分根据IDN规范进行编码。当IDN被禁用时，在请求或连接句柄上设置该选项可以为URL的主机部分指定代码页编码方案，调用InternetSetOption时的lpBuffer参数包含所需的DBCS代码页；如果在lpBuffer参数中没有指定代码页，WinINet使用默认的系统代码页(CP_ACP)。注意：如果未禁用IDN，则忽略该选项</td>
</tr>
<tr>
<td>INTERNET_OPTION_CODEPAGE_PATH</td>
<td>默认情况下，URL的路径部分采用UTF8编码。WinINet对高位字符执行转义(%)编码，在请求或连接句柄上设置该选项会禁用UTF8编码并设置为指定的代码页。调用InternetSetOption时的lpBuffer参数指定为URL路径所需的DBCS代码页；如果在lpBuffer参数中没有指定代码页，WinINet使用默认的CP_UTF8</td>
</tr>
<tr>
<td>INTERNET_OPTION_CODEPAGE_EXTRA</td>
<td>默认情况下，URL的路径部分采用默认系统代码页(CP_ACP)，不会对额外部分执行转义(%)转换，在请求或连接句柄上设置该选项会禁用CP_ACP编码。调用InternetSetOption时的lpBuffer参数指定为URL额外部分所需的DBCS代码页；如果在lpBuffer参数中没有指定代码页，WinINet使用默认的系统代码页(CP_ACP)</td>
</tr>
<tr>
<td>INTERNET_OPTION_COMPRESSED_CONTENT_LENGTH</td>
<td>对于WinINet解压缩服务器提供的Content-Encoding请求，将服务器报告的响应正文的Content-Length作为ULONGLONG型，适用于Windows 10 1507及更高版本</td>
</tr>
<tr>
<td>INTERNET_OPTION_CONNECT_RETRIES</td>
<td>设置或获取WinINet尝试解析和连接到主机的次数，默认值为5</td>
</tr>
<tr>
<td>INTERNET_OPTION_CONNECT_TIMEOUT</td>
<td>设置或获取Internet连接请求的超时值(以毫秒为单位)，设置为0xFFFFFFFF表示禁用计时器</td>
</tr>
<tr>
<td>INTERNET_OPTION_CONNECTED_STATE</td>
<td>设置或获取连接状态</td>
</tr>
<tr>
<td>INTERNET_OPTION_CONTEXT_VALUE</td>
<td>设置或获取与Internet句柄关联的上下文值地址的DWORD_PTR</td>
</tr>
<tr>
<td>INTERNET_OPTION_DATA_RECEIVE_TIMEOUT</td>
<td>设置或获取对FTP事务数据通道请求的响应的超时值(以毫秒为单位)，仅用于FTP</td>
</tr>
<tr>
<td>INTERNET_OPTION_DATA_SEND_TIMEOUT</td>
<td>设置或获取对FTP事务数据通道请求的超时值(以毫秒为单位)，仅用于FTP</td>
</tr>
<tr>
<td>INTERNET_OPTION_DATAFILE_NAME</td>
<td>获取下载实体的文件名称</td>
</tr>
<tr>
<td>INTERNET_OPTION_DATAFILE_EXT</td>
<td>设置下载实体的文件扩展名</td>
</tr>
<tr>
<td>INTERNET_OPTION_DIAGNOSTIC_SOCKET_INFO</td>
<td>获取HTTP请求的数据的INTERNET_DIAGNOSTIC_SOCKET_INFO结构，Windows 7不再支持该选项</td>
</tr>
<tr>
<td>INTERNET_OPTION_DIGEST_AUTH_UNLOAD</td>
<td>注销摘要式身份验证SSPI包，清除为该进程创建的所有凭据，仅用于InternetSetOption函数</td>
</tr>
<tr>
<td>INTERNET_OPTION_ENABLE_HTTP_PROTOCOL</td>
<td>设置HTTP版本，可用的值仅有HTTP_PROTOCOL_FLAG_HTTP2(0x2)，仅用于Windows10 1507及更高版本</td>
</tr>
<tr>
<td>INTERNET_OPTION_ENABLE_REDIRECT_CACHE_READ</td>
<td>设置是否从WinINet缓存中为给定请求返回重定向，默认值为FALSE，仅用于Windows 8及更高版本</td>
</tr>
<tr>
<td>INTERNET_OPTION_ENCODE_EXTRA</td>
<td>设置或获取查询字符串中的非ASCII字符是否应进行%编码，默认值为FALSE，仅用于Windows 8.1及更高版本</td>
</tr>
<tr>
<td>INTERNET_OPTION_END_BROWSER_SESSION</td>
<td>从硬盘驱动器上的密码缓存中刷新未使用的条目，还重置同步模式为每个会话一次时使用的缓存时间，仅用于InternetSetOption函数</td>
</tr>
<tr>
<td>INTERNET_OPTION_ERROR_MASK</td>
<td>设置可以由客户端应用程序处理的错误掩码，可以是以下值的组合：INTERNET_ERROR_MASK_COMBINED_SEC_CERT表示所有证书错误都将使用相同的错误代码ERROR_INTERNET_SEC_CERT_ERRORS；INTERNET_ERROR_MASK_INSERT_CDROM表示客户端应用程序可以处理错误代码ERROR_INTERNET_INSERT_CDROM；INTERNET_ERROR_MASK_LOGIN_FAILURE_DISPLAY_ENTITY_BODY表示客户端应用程序可以处理错误代码ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY</td>
</tr>
<tr>
<td>INTERNET_OPTION_ENTERPRISE_CONTEXT</td>
<td>设置用于请求的企业ID，仅用于Windows 10 1507及更高版本</td>
</tr>
<tr>
<td>INTERNET_OPTION_EXTENDED_ERROR</td>
<td>获取Winsock错误代码，映射到线程上下文中最后返回的ERROR_INTERNET_*错误消息</td>
</tr>
<tr>
<td>INTERNET_OPTION_FROM_CACHE_TIMEOUT</td>
<td>设置或获取系统在检查缓存中是否有资源副本之前等待网络请求响应的时间</td>
</tr>
<tr>
<td>INTERNET_OPTION_HANDLE_TYPE</td>
<td>获取Internet句柄类型，例如INTERNET_HANDLE_TYPE_CONNECT_FTP、INTERNET_HANDLE_TYPE_CONNECT_HTTP等</td>
</tr>
<tr>
<td>INTERNET_OPTION_HSTS</td>
<td>设置或获取WinINet是否应遵循来自服务器的HTTP严格传输安全(HSTS)指令，如果启用，对具有WinINet缓存的HSTS策略的域的<a target="_blank" rel="noopener" href="https://方案请求将被重定向到匹配的https://URL。默认值为FALSE。仅用于Windows">https://方案请求将被重定向到匹配的https://URL。默认值为FALSE。仅用于Windows</a> 8.1及更高版本</td>
</tr>
<tr>
<td>INTERNET_OPTION_HTTP_DECODING</td>
<td>使WinINet能够对gzip和deflate编码方案执行解码</td>
</tr>
<tr>
<td>INTERNET_OPTION_HTTP_PROTOCOL_USED</td>
<td>获取HTTP版本，可用的值仅有HTTP_PROTOCOL_FLAG_HTTP2(0x2)，仅用于Windows 10 1507及更高版本</td>
</tr>
<tr>
<td>INTERNET_OPTION_HTTP_VERSION</td>
<td>设置或获取HTTP版本的HTTP_VERSION_INFO结构</td>
</tr>
<tr>
<td>INTERNET_OPTION_IDN</td>
<td>设置请求或连接句柄以启用或禁用IDN</td>
</tr>
<tr>
<td>INTERNET_OPTION_IGNORE_OFFLINE</td>
<td>设置或获取是否应忽略请求句柄的全局脱机标志</td>
</tr>
<tr>
<td>INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER</td>
<td>设置或获取HTTP/1.0服务器允许的最大连接数</td>
</tr>
<tr>
<td>INTERNET_OPTION_MAX_CONNS_PER_PROXY</td>
<td>设置或获取每个CERN代理允许的最大连接数</td>
</tr>
<tr>
<td>INTERNET_OPTION_MAX_CONNS_PER_SERVER</td>
<td>设置或获取每个服务器允许的最大连接数</td>
</tr>
<tr>
<td>INTERNET_OPTION_OPT_IN_WEAK_SIGNATURE</td>
<td>将弱签名(例如SHA-1)视为不安全签名，这将指示WinINet使用CERT_CHAIN_OPT_IN_WEAK_SIGNATURE参数调用CertGetCertificateChain</td>
</tr>
<tr>
<td>INTERNET_OPTION_PARENT_HANDLE</td>
<td>获取指定Internet句柄的父句柄</td>
</tr>
<tr>
<td>INTERNET_OPTION_PASSWORD</td>
<td>设置或获取与InternetConnect函数返回的Internet句柄关联的密码</td>
</tr>
<tr>
<td>INTERNET_OPTION_PER_CONNECTION_OPTION</td>
<td>设置或获取INTERNET_PER_CONN_OPTION_LIST结构，该结构指定特定连接的选项列表</td>
</tr>
<tr>
<td>INTERNET_OPTION_PROXY</td>
<td>设置或获取INTERNET_PROXY_INFO结构，该结构包含现有InternetOpen句柄的代理数据</td>
</tr>
<tr>
<td>INTERNET_OPTION_PROXY_PASSWORD</td>
<td>设置或获取用于访问代理的密码</td>
</tr>
<tr>
<td>INTERNET_OPTION_PROXY_SETTINGS_CHANGED</td>
<td>通知当前WinINet实例代理设置已更改，并且必须使用新设置进行更新。要通知所有可用的WinINet实例，需要将InternetSetOption的lpBuffer参数设置为NULL并将dwBufferLength设置为0</td>
</tr>
<tr>
<td>INTERNET_OPTION_PROXY_USERNAME</td>
<td>设置或获取用于访问代理的用户名</td>
</tr>
<tr>
<td>INTERNET_OPTION_READ_BUFFER_SIZE</td>
<td>设置或获取读缓冲区的大小，仅用于FTP</td>
</tr>
<tr>
<td>INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT或  INTERNET_OPTION_RECEIVE_TIMEOUT</td>
<td>设置或获取对请求响应的超时值(以毫秒为单位)</td>
</tr>
<tr>
<td>INTERNET_OPTION_REFRESH</td>
<td>从注册表中重新读取代理数据</td>
</tr>
<tr>
<td>INTERNET_OPTION_REQUEST_FLAGS</td>
<td>获取正在进行下载的状态的特殊状态标志，可以是以下值之一：INTERNET_REQFLAG_CACHE_WRITE_DISABLED表示无法缓存Internet请求(例如，HTTPS请求)；INTERNET_REQFLAG_FROM_CACHE表示响应来自缓存；INTERNET_REQFLAG_NET_TIMEOUT表示请求超时；INTERNET_REQFLAG_NO_HEADERS表示原始响应不包含标头；INTERNET_REQFLAG_VIA_PROXY表示请求是通过代理发出的</td>
</tr>
<tr>
<td>INTERNET_OPTION_REQUEST_PRIORITY</td>
<td>设置或获取竞争连接的请求的优先级</td>
</tr>
<tr>
<td>INTERNET_OPTION_RESET_URLCACHE_SESSION</td>
<td>为进程启动一个新的缓存会话</td>
</tr>
<tr>
<td>INTERNET_OPTION_SECONDARY_CACHE_KEY</td>
<td>设置或获取二级缓存键的字符串值，仅供内部使用</td>
</tr>
<tr>
<td>INTERNET_OPTION_SECURITY_CERTIFICATE</td>
<td>获取格式化字符串形式的SSL/PCT服务器证书</td>
</tr>
<tr>
<td>INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT</td>
<td>获取INTERNET_CERTIFICATE_INFO结构形式的SSL/PCT服务器证书</td>
</tr>
<tr>
<td>INTERNET_OPTION_SECURITY_FLAGS</td>
<td>设置或获取Internet句柄的安全标志，可以是以下值的组合：SECURITY_FLAG_FORTEZZA表示Fortezza已用于为指定的连接提供保密、身份验证和/或完整性；SECURITY_FLAG_IGNORE_CERT_CN_INVALID表示忽略ERROR_INTERNET_SEC_CERT_CN_INVALID错误消息；SECURITY_FLAG_IGNORE_CERT_DATE_INVALID表示忽略ERROR_INTERNET_SEC_CERT_DATE_INVALID错误消息；SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTP表示忽略ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR错误消息；SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTPS表示忽略ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR错误消息；SECURITY_FLAG_IGNORE_REVOCATION表示忽略证书吊销问题；SECURITY_FLAG_IGNORE_UNKNOWN_CA表示忽略未知的证书颁发机构问题；SECURITY_FLAG_IGNORE_WEAK_SIGNATURE表示忽略弱证书签名问题；SECURITY_FLAG_IGNORE_WRONG_USAGE表示忽略错误的使用问题；SECURITY_FLAG_SECURE表示使用安全传输；SECURITY_FLAG_STRENGTH_MEDIUM表示使用中等(56位)加密；SECURITY_FLAG_STRENGTH_STRONG表示使用强(128位)加密；SECURITY_FLAG_NORMALBITNESS或SECURITY_FLAG_STRENGTH_WEAK表示使用弱(40位)加密；SECURITY_FLAG_UNKNOWNBIT表示用于加密的位大小是未知的</td>
</tr>
<tr>
<td>INTERNET_OPTION_SECURITY_KEY_BITNESS</td>
<td>获取加密密钥的位大小，数值越大，使用的加密强度越大</td>
</tr>
<tr>
<td>INTERNET_OPTION_CONTROL_SEND_TIMEOUT或  INTERNET_OPTION_SEND_TIMEOUT</td>
<td>设置或获取发送请求的超时值</td>
</tr>
<tr>
<td>INTERNET_OPTION_SERVER_CERT_CHAIN_CONTEXT</td>
<td>以复制的PCCERT_CHAIN_CONTEXT的形式获取服务器的证书链上下文，可以将此复制的上下文传递给任何采用PCCERT_CHAIN_CONTEXT的加密API函数</td>
</tr>
<tr>
<td>INTERNET_OPTION_SETTINGS_CHANGED</td>
<td>通知系统注册表设置已更改</td>
</tr>
<tr>
<td>INTERNET_OPTION_SUPPRESS_SERVER_AUTH</td>
<td>设置HTTP请求对象，使其不会登录到源服务器，但会自动登录到HTTP代理服务器，该选项不同于请求标志INTERNET_FLAG_NO_AUTH，后者阻止对代理服务器和源服务器进行身份验证。设置该模式将禁止在与源服务器通信时使用任何凭据材料(先前提供的用户名/密码或客户端SSL证书)；但是，如果请求必须通过身份验证代理传输，WinINet仍将根据用户的Intranet区域设置对HTTP代理执行自动身份验证，默认的Intranet区域设置是允许使用用户的默认凭据自动登录。为了确保抑制所有识别信息，调用者应该将INTERNET_OPTION_SUPPRESS_SERVER_AUTHINTERNET_FLAG_NO_COOKIES请求标志结合起来，该选项只能在请求对象被发送之前设置，在请求发送后尝试设置该选项将返回ERROR_INTERNET_INCORRECT_HANDLE_STATE</td>
</tr>
<tr>
<td>INTERNET_OPTION_SUPPRESS_BEHAVIOR</td>
<td>设置在进程范围内抑制行为的通用选项，可以是以下值的组合：INTERNET_SUPPRESS_RESET_ALL表示禁用所有抑制，重新启用默认和配置的行为，该选项相当于分别设置INTERNET_SUPPRESS_COOKIE_POLICY_RESET和INTERNET_SUPPRESS_COOKIE_PERSIST_RESET；INTERNET_SUPPRESS_COOKIE_POLICY表示忽略任何已配置的cookie策略并允许设置cookie；INTERNET_SUPPRESS_COOKIE_POLICY_RESET表示禁用INTERNET_SUPPRESS_COOKIE_POLICY抑制，允许根据配置的cookie策略评估cookie；INTERNET_SUPPRESS_COOKIE_PERSIST表示抑制cookie的持久性，即使服务器已将它们指定为持久性；INTERNET_SUPPRESS_COOKIE_PERSIST_RESET表示禁用INTERNET_SUPPRESS_COOKIE_PERSIST抑制，重新启用cookie的持久性，但任何先前被抑制的cookie都不会持久化</td>
</tr>
<tr>
<td>INTERNET_OPTION_URL</td>
<td>获取下载资源的完整URL字符串</td>
</tr>
<tr>
<td>INTERNET_OPTION_USER_AGENT</td>
<td>设置或获取由InternetOpen函数提供并在后续HttpSendRequest函数中使用的Internet句柄上的用户代理字符串</td>
</tr>
<tr>
<td>INTERNET_OPTION_USERNAME</td>
<td>设置或获取与InternetConnect函数返回的Internet句柄关联的用户名字符串</td>
</tr>
<tr>
<td>INTERNET_OPTION_VERSION</td>
<td>获取包含Wininet.dll版本号的INTERNET_VERSION_INFO结构</td>
</tr>
<tr>
<td>INTERNET_OPTION_WRITE_BUFFER_SIZE</td>
<td>设置或获取写缓冲区大小(以字节为单位)，仅用于FTP</td>
</tr>
</tbody>
</table>
</div>
<p>lpBuffer参数指定为包含Internet选项设置的缓冲区的指针。dwBufferLength参数用于指定缓冲区的大小。如果lpBuffer参数指定的是一个字符串，则大小以字符为单位；如果lpBuffer参数指定的是字符串以外的任何数据，则大小以字节为单位。</p>
<h3 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinInet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Wininet.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;\&quot;/manifestdependency:type=&#x27;win32&#x27; name=&#x27;Microsoft.Windows.Common-Controls&#x27; version=&#x27;6.0.0.0&#x27; processorArchitecture=&#x27;*&#x27; publicKeyToken=&#x27;6595b64144ccf1df&#x27; language=&#x27;*&#x27;\&quot;&quot;</span>)</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DialogBoxParam</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDD_MAIN), <span class="literal">NULL</span>, DialogProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> HINTERNET hInternet = <span class="literal">NULL</span>;                                      <span class="comment">// Internet初始化句柄</span></span><br><span class="line">    HINTERNET        hConnect = <span class="literal">NULL</span>;                                       <span class="comment">// HTTP会话句柄</span></span><br><span class="line">    HINTERNET        hRequest = <span class="literal">NULL</span>;                                       <span class="comment">// HTTP请求句柄</span></span><br><span class="line">    TCHAR     szServerName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;                               <span class="comment">// 主机名或IP地址</span></span><br><span class="line">    LPCTSTR   arrszAcceptTypes[] = &#123; <span class="built_in">TEXT</span>(<span class="string">&quot;text/*&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;*/*&quot;</span>), <span class="literal">NULL</span> &#125;;   <span class="comment">// 文档类型</span></span><br><span class="line">    DWORD     dwNumberOfBytesAvailable = <span class="number">0</span>;      <span class="comment">// InternetQueryDataAvailable函数参数</span></span><br><span class="line">    LPVOID    lpBuf = <span class="literal">NULL</span>;                      <span class="comment">// 缓冲区指针</span></span><br><span class="line">    DWORD     dwNumberOfBytesRead = <span class="number">0</span>;           <span class="comment">// 实际读取到的字节数</span></span><br><span class="line">    BOOL      bRet = FALSE;                      <span class="comment">// InternetReadFile函数返回值</span></span><br><span class="line">    TCHAR     szFileLocal[MAX_PATH] = &#123; <span class="number">0</span> &#125;;     <span class="comment">// 本地文件名缓冲区</span></span><br><span class="line">    HANDLE    hFileLocal = INVALID_HANDLE_VALUE; <span class="comment">// 本地文件文件句柄</span></span><br><span class="line">    LPVOID lpBuffer = <span class="literal">NULL</span>;                      <span class="comment">// HttpQueryInfo函数所用的缓冲区指针</span></span><br><span class="line">    DWORD  dwBufferLength = <span class="number">0</span>;                   <span class="comment">// 缓冲区的长度</span></span><br><span class="line">    LPCSTR lpStrOptional = <span class="string">&quot;username=Admin&amp;password=123456&amp;remember=yes&amp;login=%E7%99%BB%E5%BD%95&quot;</span>;                      <span class="comment">// 请求主体</span></span><br><span class="line">    HINTERNET hFile = <span class="literal">NULL</span>;                      <span class="comment">// InternetOpenUrl函数返回的Internet文件句柄</span></span><br><span class="line">    <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_INITDIALOG: &#123;</span><br><span class="line">            <span class="built_in">SetDlgItemText</span>(hwndDlg, IDC_EDIT_HOST, <span class="built_in">TEXT</span>(<span class="string">&quot;www.httptest.com&quot;</span>));</span><br><span class="line">            <span class="comment">// 打开并初始化WinINet库</span></span><br><span class="line">            hInternet = <span class="built_in">InternetOpen</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Mozilla/5.0&quot;</span>), INTERNET_OPEN_TYPE_DIRECT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_GET: &#123;</span><br><span class="line">                    <span class="comment">// 连接到指定站点的HTTP服务，返回一个HTTP会话句柄</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_HOST, szServerName, _countof(szServerName)) &gt; <span class="number">0</span>)</span><br><span class="line">                        hConnect = <span class="built_in">InternetConnect</span>(hInternet, szServerName, INTERNET_DEFAULT_HTTP_PORT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, INTERNET_SERVICE_HTTP, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;请输入主机名或IP地址&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;错误提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 创建一个HTTP请求句柄</span></span><br><span class="line">                    hRequest = <span class="built_in">HttpOpenRequest</span>(hConnect, <span class="built_in">TEXT</span>(<span class="string">&quot;GET&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;index.html&quot;</span>), <span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;http://www.httptest.com/&quot;</span>), arrszAcceptTypes, INTERNET_FLAG_KEEP_CONNECTION, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">// 将一个或多个HTTP请求标头添加到HTTP请求句柄</span></span><br><span class="line">                    <span class="built_in">HttpAddRequestHeaders</span>(hRequest, <span class="built_in">TEXT</span>(<span class="string">&quot;Accept-Encoding:gzip, deflate\r\nAccept-Language:zh-CN\r\n\r\n&quot;</span>), <span class="number">-1</span>, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_COALESCE);</span><br><span class="line">                    <span class="comment">// 将指定的请求发送到HTTP服务器</span></span><br><span class="line">                    <span class="built_in">HttpSendRequest</span>(hRequest, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">// 创建本地文件</span></span><br><span class="line">                    <span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szFileLocal, _countof(szFileLocal));</span><br><span class="line">                    <span class="built_in">StringCchCopy</span>(_tcsrchr(szFileLocal, <span class="built_in">TEXT</span>(<span class="string">&#x27;\\&#x27;</span>)) + <span class="number">1</span>, _tcslen(<span class="built_in">TEXT</span>(<span class="string">&quot;index.html&quot;</span>)) + <span class="number">1</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;index.html&quot;</span>));</span><br><span class="line">                    hFileLocal = <span class="built_in">CreateFile</span>(szFileLocal, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// 循环读取数据</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        dwNumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">                        bRet = FALSE;</span><br><span class="line">                        <span class="comment">// 查询服务器上指定文件的可用数据量</span></span><br><span class="line">                        <span class="built_in">InternetQueryDataAvailable</span>(hRequest, &amp;dwNumberOfBytesAvailable, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">if</span> (dwNumberOfBytesAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            lpBuf = <span class="keyword">new</span> BYTE[dwNumberOfBytesAvailable];</span><br><span class="line">                            <span class="comment">// 从打开的Internet文件中读取数据</span></span><br><span class="line">                            bRet = <span class="built_in">InternetReadFile</span>(hRequest, lpBuf, dwNumberOfBytesAvailable, &amp;dwNumberOfBytesRead);</span><br><span class="line">                            <span class="comment">// 写入本地文件</span></span><br><span class="line">                            <span class="built_in">WriteFile</span>(hFileLocal, lpBuf, dwNumberOfBytesRead, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                            <span class="keyword">delete</span>[]lpBuf;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (bRet &amp;&amp; dwNumberOfBytesRead &gt; <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;下载index.html成功&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;操作成功&quot;</span>), MB_OK);</span><br><span class="line">                    <span class="comment">// 关闭本地文件句柄，关闭HTTP请求句柄，关闭HTTP会话句柄</span></span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFileLocal);</span><br><span class="line">                    <span class="built_in">InternetCloseHandle</span>(hRequest);</span><br><span class="line">                    <span class="built_in">InternetCloseHandle</span>(hConnect);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">case</span> IDC_BTN_POST: &#123;</span><br><span class="line">                    <span class="comment">// 连接到指定站点的HTTP服务，返回一个HTTP会话句柄</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetDlgItemText</span>(hwndDlg, IDC_EDIT_HOST, szServerName, _countof(szServerName)) &gt; <span class="number">0</span>)</span><br><span class="line">                        hConnect = <span class="built_in">InternetConnect</span>(hInternet, szServerName, INTERNET_DEFAULT_HTTP_PORT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, INTERNET_SERVICE_HTTP, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;请输入主机名或IP地址&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;错误提示&quot;</span>), MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// 创建一个HTTP请求句柄</span></span><br><span class="line">                    hRequest = <span class="built_in">HttpOpenRequest</span>(hConnect, <span class="built_in">TEXT</span>(<span class="string">&quot;POST&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;login.php&quot;</span>), <span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;http://www.httptest.com/login.html&quot;</span>), arrszAcceptTypes, INTERNET_FLAG_KEEP_CONNECTION, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">// 将一个或多个HTTP请求标头添加到HTTP请求句柄，POST请求主体长度为68个字节</span></span><br><span class="line">                    <span class="built_in">HttpAddRequestHeaders</span>(hRequest, <span class="built_in">TEXT</span>(<span class="string">&quot;Accept-Encoding:gzip, deflate\r\nAccept-Language:zh-CN\r\nContent-Type:application/x-www-form-urlencoded\r\nContent-Length:68\r\n\r\n&quot;</span>), <span class="number">-1</span>, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_COALESCE);</span><br><span class="line">                    <span class="comment">// 将指定的请求发送到HTTP服务器，附带POST请求主体</span></span><br><span class="line">                    <span class="built_in">HttpSendRequest</span>(hRequest, <span class="literal">NULL</span>, <span class="number">0</span>, (LPVOID)lpStrOptional, <span class="built_in">strlen</span>(lpStrOptional));</span><br><span class="line">                    <span class="comment">// 获取所有请求标头，每个标头都以回车换行分隔</span></span><br><span class="line">                    lpBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                    dwBufferLength = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">HttpQueryInfo</span>(hRequest, HTTP_QUERY_RAW_HEADERS_CRLF | HTTP_QUERY_FLAG_REQUEST_HEADERS, <span class="literal">NULL</span>, &amp;dwBufferLength, <span class="literal">NULL</span>);</span><br><span class="line">                    lpBuffer = <span class="keyword">new</span> BYTE[dwBufferLength + <span class="number">2</span>];</span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(lpBuffer, dwBufferLength + <span class="number">2</span>);</span><br><span class="line">                    <span class="built_in">HttpQueryInfo</span>(hRequest, HTTP_QUERY_RAW_HEADERS_CRLF | HTTP_QUERY_FLAG_REQUEST_HEADERS, lpBuffer, &amp;dwBufferLength, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">MessageBox</span>(hwndDlg, (LPCTSTR)lpBuffer, <span class="built_in">TEXT</span>(<span class="string">&quot;请求标头&quot;</span>), MB_OK);</span><br><span class="line">                    <span class="keyword">delete</span>[]lpBuffer;</span><br><span class="line">                    <span class="comment">// 获取服务器返回的所有标头，每个标头都以回车换行分隔</span></span><br><span class="line">                    lpBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                    dwBufferLength = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">HttpQueryInfo</span>(hRequest, HTTP_QUERY_RAW_HEADERS_CRLF, <span class="literal">NULL</span>, &amp;dwBufferLength, <span class="literal">NULL</span>);</span><br><span class="line">                    lpBuffer = <span class="keyword">new</span> BYTE[dwBufferLength + <span class="number">2</span>];</span><br><span class="line">                    <span class="built_in">ZeroMemory</span>(lpBuffer, dwBufferLength + <span class="number">2</span>);</span><br><span class="line">                    <span class="built_in">HttpQueryInfo</span>(hRequest, HTTP_QUERY_RAW_HEADERS_CRLF, lpBuffer, &amp;dwBufferLength, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">MessageBox</span>(hwndDlg, (LPCTSTR)lpBuffer, <span class="built_in">TEXT</span>(<span class="string">&quot;响应标头&quot;</span>), MB_OK);</span><br><span class="line">                    <span class="keyword">delete</span>[]lpBuffer;</span><br><span class="line">                    <span class="comment">// 关闭HTTP请求句柄，关闭HTTP会话句柄</span></span><br><span class="line">                    <span class="built_in">InternetCloseHandle</span>(hRequest);</span><br><span class="line">                    <span class="built_in">InternetCloseHandle</span>(hConnect);</span><br><span class="line">                    <span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">                    <span class="comment">//// 连接到指定站点的HTTP服务，返回一个HTTP会话句柄</span></span><br><span class="line">                    <span class="comment">//if (GetDlgItemText(hwndDlg, IDC_EDIT_HOST, szServerName, _countof(szServerName)) &gt; 0)</span></span><br><span class="line">                    <span class="comment">//&#123;</span></span><br><span class="line">                    <span class="comment">//   hConnect = InternetConnect(hInternet, szServerName, INTERNET_DEFAULT_HTTP_PORT,</span></span><br><span class="line">                    <span class="comment">//      NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);</span></span><br><span class="line">                    <span class="comment">//&#125;</span></span><br><span class="line">                    <span class="comment">//else</span></span><br><span class="line">                    <span class="comment">//&#123;</span></span><br><span class="line">                    <span class="comment">//   MessageBox(hwndDlg, TEXT(&quot;请输入主机名或IP地址&quot;), TEXT(&quot;错误提示&quot;), MB_OK);</span></span><br><span class="line">                    <span class="comment">//   return TRUE;</span></span><br><span class="line">                    <span class="comment">//&#125;</span></span><br><span class="line">                    <span class="comment">//// 创建一个HTTP请求句柄</span></span><br><span class="line">                    <span class="comment">//hRequest = HttpOpenRequest(hConnect, TEXT(&quot;GET&quot;), TEXT(&quot;index.php&quot;), NULL,</span></span><br><span class="line">                    <span class="comment">//   TEXT(&quot;http://www.httptest.com/login.php&quot;), arrszAcceptTypes, INTERNET_FLAG_KEEP_CONNECTION, 0);</span></span><br><span class="line">                    <span class="comment">//// 将一个或多个HTTP请求标头添加到HTTP请求句柄</span></span><br><span class="line">                    <span class="comment">//HttpAddRequestHeaders(hRequest,</span></span><br><span class="line">                    <span class="comment">//   TEXT(&quot;Accept-Encoding:gzip, deflate\r\nAccept-Language:zh-CN\r\n\r\n&quot;), -1,</span></span><br><span class="line">                    <span class="comment">//   HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_COALESCE);</span></span><br><span class="line">                    <span class="comment">//// 将指定的请求发送到HTTP服务器</span></span><br><span class="line">                    <span class="comment">//HttpSendRequest(hRequest, NULL, 0, NULL, 0);</span></span><br><span class="line">                    <span class="comment">//// 创建本地文件</span></span><br><span class="line">                    <span class="comment">//GetModuleFileName(NULL, szFileLocal, _countof(szFileLocal));</span></span><br><span class="line">                    <span class="comment">//StringCchCopy(_tcsrchr(szFileLocal, TEXT(&#x27;\\&#x27;)) + 1,</span></span><br><span class="line">                    <span class="comment">//   _tcslen(TEXT(&quot;index.php&quot;)) + 1, TEXT(&quot;index.php&quot;));</span></span><br><span class="line">                    <span class="comment">//hFileLocal = CreateFile(szFileLocal, GENERIC_READ | GENERIC_WRITE,</span></span><br><span class="line">                    <span class="comment">//   FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</span></span><br><span class="line">                    <span class="comment">//// 循环读取数据</span></span><br><span class="line">                    <span class="comment">//do</span></span><br><span class="line">                    <span class="comment">//&#123;</span></span><br><span class="line">                    <span class="comment">//   dwNumberOfBytesRead = 0;</span></span><br><span class="line">                    <span class="comment">//   bRet = FALSE;</span></span><br><span class="line">                    <span class="comment">//   // 查询服务器上指定文件的可用数据量</span></span><br><span class="line">                    <span class="comment">//   InternetQueryDataAvailable(hRequest, &amp;dwNumberOfBytesAvailable, 0, 0);</span></span><br><span class="line">                    <span class="comment">//   if (dwNumberOfBytesAvailable &gt; 0)</span></span><br><span class="line">                    <span class="comment">//   &#123;</span></span><br><span class="line">                    <span class="comment">//      lpBuf = new BYTE[dwNumberOfBytesAvailable];</span></span><br><span class="line">                    <span class="comment">//      // 从打开的Internet文件中读取数据</span></span><br><span class="line">                    <span class="comment">//      bRet = InternetReadFile(hRequest, lpBuf,</span></span><br><span class="line">                    <span class="comment">//         dwNumberOfBytesAvailable, &amp;dwNumberOfBytesRead);</span></span><br><span class="line">                    <span class="comment">//      // 写入本地文件</span></span><br><span class="line">                    <span class="comment">//      WriteFile(hFileLocal, lpBuf, dwNumberOfBytesRead, NULL, NULL);</span></span><br><span class="line">                    <span class="comment">//      delete[]lpBuf;</span></span><br><span class="line">                    <span class="comment">//   &#125;</span></span><br><span class="line">                    <span class="comment">//&#125; while (bRet &amp;&amp; dwNumberOfBytesRead &gt; 0);</span></span><br><span class="line">                    <span class="comment">//MessageBox(hwndDlg, TEXT(&quot;下载index.php成功&quot;), TEXT(&quot;操作成功&quot;), MB_OK);</span></span><br><span class="line">                    <span class="comment">//// 关闭本地文件句柄，关闭HTTP请求句柄，关闭HTTP会话句柄</span></span><br><span class="line">                    <span class="comment">//CloseHandle(hFileLocal);</span></span><br><span class="line">                    <span class="comment">//InternetCloseHandle(hRequest);</span></span><br><span class="line">                    <span class="comment">//InternetCloseHandle(hConnect);</span></span><br><span class="line">                    <span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">                    <span class="comment">// 打开指定URL的HTTP资源</span></span><br><span class="line">                    hFile = <span class="built_in">InternetOpenUrl</span>(hInternet, <span class="built_in">TEXT</span>(<span class="string">&quot;http://www.httptest.com/index.php&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;Accept-Encoding:gzip, deflate\r\nAccept-Language:zh-CN\r\n\r\n&quot;</span>), _tcslen(<span class="built_in">TEXT</span>(<span class="string">&quot;Accept-Encoding:gzip, deflate\r\nAccept-Language:zh-CN\r\n\r\n&quot;</span>)), INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP | INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS | INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_NO_AUTH | INTERNET_FLAG_RESYNCHRONIZE, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">// 创建本地文件</span></span><br><span class="line">                    <span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szFileLocal, _countof(szFileLocal));</span><br><span class="line">                    <span class="built_in">StringCchCopy</span>(_tcsrchr(szFileLocal, <span class="built_in">TEXT</span>(<span class="string">&#x27;\\&#x27;</span>)) + <span class="number">1</span>, _tcslen(<span class="built_in">TEXT</span>(<span class="string">&quot;index.php&quot;</span>)) + <span class="number">1</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;index.php&quot;</span>));</span><br><span class="line">                    hFileLocal = <span class="built_in">CreateFile</span>(szFileLocal, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// 循环读取数据</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        dwNumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">                        bRet = FALSE;</span><br><span class="line">                        <span class="comment">// 查询服务器上指定文件的可用数据量</span></span><br><span class="line">                        <span class="built_in">InternetQueryDataAvailable</span>(hFile, &amp;dwNumberOfBytesAvailable, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">if</span> (dwNumberOfBytesAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            lpBuf = <span class="keyword">new</span> BYTE[dwNumberOfBytesAvailable];</span><br><span class="line">                            <span class="comment">// 从打开的Internet文件中读取数据</span></span><br><span class="line">                            bRet = <span class="built_in">InternetReadFile</span>(hFile, lpBuf, dwNumberOfBytesAvailable, &amp;dwNumberOfBytesRead);</span><br><span class="line">                            <span class="comment">// 写入本地文件</span></span><br><span class="line">                            <span class="built_in">WriteFile</span>(hFileLocal, lpBuf, dwNumberOfBytesRead, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                            <span class="keyword">delete</span>[]lpBuf;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (bRet &amp;&amp; dwNumberOfBytesRead &gt; <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">MessageBox</span>(hwndDlg, <span class="built_in">TEXT</span>(<span class="string">&quot;下载index.php成功&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;操作成功&quot;</span>), MB_OK);</span><br><span class="line">                    <span class="comment">// 关闭本地文件句柄，关闭Internet文件句柄</span></span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hFileLocal);</span><br><span class="line">                    <span class="built_in">InternetCloseHandle</span>(hFile);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">case</span> WM_CLOSE: &#123;</span><br><span class="line">            <span class="built_in">InternetCloseHandle</span>(hInternet);</span><br><span class="line">            <span class="built_in">EndDialog</span>(hwndDlg, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://Monoceros.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://monoceros.github.io/2024/07/26/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">http://monoceros.github.io/2024/07/26/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Monoceros.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/">逆向工程</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/31/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/" title="WindowsAPI查缺补漏-PE文件格式解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">WindowsAPI查缺补漏-PE文件格式解析</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/25/Windows%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2-%E5%9E%AB%E7%89%87/" title="Windows软件调试初探-垫片"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Windows软件调试初探-垫片</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/16/Angr%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/" title="Angr做题笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-16</div><div class="title">Angr做题笔记</div></div></a></div><div><a href="/2023/10/29/Angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%AC%94%E8%AE%B0/" title="Angr符号执行笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">Angr符号执行笔记</div></div></a></div><div><a href="/2023/11/09/C-%E7%97%85%E6%AF%92%E6%8A%80%E6%9C%AF/" title="C++病毒技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-09</div><div class="title">C++病毒技术</div></div></a></div><div><a href="/2023/11/15/CvxPy%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/" title="CvxPy整数规划笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">CvxPy整数规划笔记</div></div></a></div><div><a href="/2023/10/21/IDA%E5%9C%A8Kali-Linux%E4%B8%8B%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/" title="IDA在Kali Linux下的远程动态调试笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-21</div><div class="title">IDA在Kali Linux下的远程动态调试笔记</div></div></a></div><div><a href="/2023/10/29/IDA%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/" title="IDA脚本编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">IDA脚本编程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">智邮普创工作室安全组/Nepnep联合战队</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">258</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">QQ:1295625063（不找对象）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">WindowsAPI查缺补漏-WinSock网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%8E%E7%A2%8E%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">碎碎念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.</span> <span class="toc-text">地址表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">WinSock网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WSAStartup"><span class="toc-number">1.3.1.</span> <span class="toc-text">WSAStartup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WSACleanup"><span class="toc-number">1.3.2.</span> <span class="toc-text">WSACleanup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket"><span class="toc-number">1.3.3.</span> <span class="toc-text">socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#closesocket"><span class="toc-number">1.3.4.</span> <span class="toc-text">closesocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind"><span class="toc-number">1.3.5.</span> <span class="toc-text">bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getsockname"><span class="toc-number">1.3.6.</span> <span class="toc-text">getsockname</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listen"><span class="toc-number">1.3.7.</span> <span class="toc-text">listen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#accept"><span class="toc-number">1.3.8.</span> <span class="toc-text">accept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#send-recv"><span class="toc-number">1.3.9.</span> <span class="toc-text">send&#x2F;recv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#connect"><span class="toc-number">1.3.10.</span> <span class="toc-text">connect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendto"><span class="toc-number">1.3.11.</span> <span class="toc-text">sendto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recvfrom"><span class="toc-number">1.3.12.</span> <span class="toc-text">recvfrom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9ATCP"><span class="toc-number">1.3.13.</span> <span class="toc-text">例子：TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9AUDP"><span class="toc-number">1.3.14.</span> <span class="toc-text">例子：UDP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5I-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">异步I&#x2F;O模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">非阻塞模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ioctlsocket"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">ioctlsocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">select模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WSAAsyncSelect%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">WSAAsyncSelect模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WSAAsyncSelect"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">WSAAsyncSelect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WSAEventSelect%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">WSAEventSelect模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WSAEventSelect"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">WSAEventSelect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSACreateEvent"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">WSACreateEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSAResetEvent"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">WSAResetEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSASetEvent"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">WSASetEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSACloseEvent"><span class="toc-number">1.4.4.5.</span> <span class="toc-text">WSACloseEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSAWaitForMultipleEvents"><span class="toc-number">1.4.4.6.</span> <span class="toc-text">WSAWaitForMultipleEvents</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSAEnumNetworkEvents"><span class="toc-number">1.4.4.7.</span> <span class="toc-text">WSAEnumNetworkEvents</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-3"><span class="toc-number">1.4.4.8.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Overlapped%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.5.</span> <span class="toc-text">Overlapped模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WSASocket"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">WSASocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcceptEx"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">AcceptEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSAIoctl"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">WSAIoctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GetAcceptExSockaddrs"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">GetAcceptExSockaddrs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSASend-WSARecv"><span class="toc-number">1.4.5.5.</span> <span class="toc-text">WSASend&#x2F;WSARecv</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSAGetOverlappedResult"><span class="toc-number">1.4.5.6.</span> <span class="toc-text">WSAGetOverlappedResult</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-4"><span class="toc-number">1.4.5.7.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3IOCP%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.6.</span> <span class="toc-text">I&#x2F;O完成端口IOCP模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateIoCompletionPort"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">CreateIoCompletionPort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GetQueuedCompletionStatus"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">GetQueuedCompletionStatus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PostQueuedCompletionStatus"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">PostQueuedCompletionStatus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GetQueuedCompletionStatusEx"><span class="toc-number">1.4.6.4.</span> <span class="toc-text">GetQueuedCompletionStatusEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%901"><span class="toc-number">1.4.6.5.</span> <span class="toc-text">例子1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%902"><span class="toc-number">1.4.6.6.</span> <span class="toc-text">例子2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.5.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%8E%E7%A2%8E%E5%BF%B5-1"><span class="toc-number">1.5.1.</span> <span class="toc-text">碎碎念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.2.</span> <span class="toc-text">工作对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TrySubmitThreadpoolCallback"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">TrySubmitThreadpoolCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateThreadpoolWork"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">CreateThreadpoolWork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SubmitThreadpoolWork"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">SubmitThreadpoolWork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WaitForThreadpoolWorkCallbacks"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">WaitForThreadpoolWorkCallbacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CloseThreadpoolWork"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">CloseThreadpoolWork</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.3.</span> <span class="toc-text">计时器对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateThreadpoolTimer"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">CreateThreadpoolTimer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetThreadpoolTimer"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">SetThreadpoolTimer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WaitForThreadpoolTimerCallbacks"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">WaitForThreadpoolTimerCallbacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CloseThreadpoolTimer"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">CloseThreadpoolTimer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IsThreadpoolTimerSet"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">IsThreadpoolTimerSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.4.</span> <span class="toc-text">内核对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateThreadpoolWait"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">CreateThreadpoolWait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetThreadpoolWait"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">SetThreadpoolWait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WaitForThreadpoolWaitCallbacks"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">WaitForThreadpoolWaitCallbacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CloseThreadpoolWait"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">CloseThreadpoolWait</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0I-O%E5%AE%8C%E6%88%90%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.5.</span> <span class="toc-text">线程池I&#x2F;O完成对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateThreadpoolIo"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">CreateThreadpoolIo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StartThreadpoolIo"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">StartThreadpoolIo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CancelThreadpoolIo"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">CancelThreadpoolIo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WaitForThreadpoolIoCallbacks"><span class="toc-number">1.5.5.4.</span> <span class="toc-text">WaitForThreadpoolIoCallbacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CloseThreadpoolIo"><span class="toc-number">1.5.5.5.</span> <span class="toc-text">CloseThreadpoolIo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%97%B6"><span class="toc-number">1.5.6.</span> <span class="toc-text">回调函数返回时</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WhenCallbackReturns"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">*WhenCallbackReturns</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CallbackMayRunLong"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">CallbackMayRunLong</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DisassociateCurrentThreadFromCallback"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">DisassociateCurrentThreadFromCallback</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.7.</span> <span class="toc-text">新线程池对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateThreadpool"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">CreateThreadpool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetThreadpoolThreadMinimum-SetThreadpoolThreadMaximum"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">SetThreadpoolThreadMinimum&#x2F;SetThreadpoolThreadMaximum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InitializzeThreadpoolEnvironment"><span class="toc-number">1.5.7.3.</span> <span class="toc-text">InitializzeThreadpoolEnvironment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetThreadpoolCallbackPool"><span class="toc-number">1.5.7.4.</span> <span class="toc-text">SetThreadpoolCallbackPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DestroyThreadpoolEnvironment"><span class="toc-number">1.5.7.5.</span> <span class="toc-text">DestroyThreadpoolEnvironment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CloseThreadpool"><span class="toc-number">1.5.7.6.</span> <span class="toc-text">CloseThreadpool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetThreadpoolCallbackRunsLong"><span class="toc-number">1.5.7.7.</span> <span class="toc-text">SetThreadpoolCallbackRunsLong</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetThreadpoolCallbackLibrary"><span class="toc-number">1.5.7.8.</span> <span class="toc-text">SetThreadpoolCallbackLibrary</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B8%85%E7%90%86%E7%BB%84"><span class="toc-number">1.5.8.</span> <span class="toc-text">线程池清理组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateThreadpoolCleanupGroup"><span class="toc-number">1.5.8.1.</span> <span class="toc-text">CreateThreadpoolCleanupGroup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetThreadpoolCallbackCleanupGroup"><span class="toc-number">1.5.8.2.</span> <span class="toc-text">SetThreadpoolCallbackCleanupGroup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CloseThreadpoolCleanupGroupMembers"><span class="toc-number">1.5.8.3.</span> <span class="toc-text">CloseThreadpoolCleanupGroupMembers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CloseThreadpoolCleanupGroup"><span class="toc-number">1.5.8.4.</span> <span class="toc-text">CloseThreadpoolCleanupGroup</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%901-1"><span class="toc-number">1.5.9.</span> <span class="toc-text">例子1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%902-1"><span class="toc-number">1.5.10.</span> <span class="toc-text">例子2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPHelper"><span class="toc-number">1.6.</span> <span class="toc-text">IPHelper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%82%E9%85%8D%E5%99%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">1.6.1.</span> <span class="toc-text">获取本地计算机网络适配器信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GetAdaptersInfo"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">GetAdaptersInfo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GetAdaptersAddress"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">GetAdaptersAddress</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-5"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">1.6.2.</span> <span class="toc-text">杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConnectEx"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">ConnectEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gethostname"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">gethostname</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gethostbyname"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">gethostbyname</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransmitFile"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">TransmitFile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLDownloadToFile"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">URLDownloadToFile</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%A0%A1%E5%AF%B9"><span class="toc-number">1.7.</span> <span class="toc-text">时间校对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.8.</span> <span class="toc-text">系统网络连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UuidFromString"><span class="toc-number">1.8.1.</span> <span class="toc-text">UuidFromString</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetupDiGetClassDevs"><span class="toc-number">1.8.2.</span> <span class="toc-text">SetupDiGetClassDevs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetupDiEnumDeviceInfo"><span class="toc-number">1.8.3.</span> <span class="toc-text">SetupDiEnumDeviceInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetupDiSetClassInstallParams"><span class="toc-number">1.8.4.</span> <span class="toc-text">SetupDiSetClassInstallParams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetupDiCallClassInstaller"><span class="toc-number">1.8.5.</span> <span class="toc-text">SetupDiCallClassInstaller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetupDiDestroyDeviceInfoList"><span class="toc-number">1.8.6.</span> <span class="toc-text">SetupDiDestroyDeviceInfoList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-6"><span class="toc-number">1.8.7.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FTP"><span class="toc-number">1.9.</span> <span class="toc-text">FTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">1.10.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HttpQueryInfo"><span class="toc-number">1.10.1.</span> <span class="toc-text">HttpQueryInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InternetSetOption"><span class="toc-number">1.10.2.</span> <span class="toc-text">InternetSetOption</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-7"><span class="toc-number">1.10.3.</span> <span class="toc-text">例子</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/31/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/" title="WindowsAPI查缺补漏-PE文件格式解析">WindowsAPI查缺补漏-PE文件格式解析</a><time datetime="2024-07-31T00:51:12.000Z" title="发表于 2024-07-31 08:51:12">2024-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/26/WindowsAPI%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="WindowsAPI查缺补漏-WinSock网络编程">WindowsAPI查缺补漏-WinSock网络编程</a><time datetime="2024-07-26T07:48:34.000Z" title="发表于 2024-07-26 15:48:34">2024-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/25/Windows%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2-%E5%9E%AB%E7%89%87/" title="Windows软件调试初探-垫片">Windows软件调试初探-垫片</a><time datetime="2024-07-25T12:51:47.000Z" title="发表于 2024-07-25 20:51:47">2024-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/25/Windows%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2-%E7%89%B9%E6%AE%8A%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/" title="Windows软件调试初探-特殊过程调用">Windows软件调试初探-特殊过程调用</a><time datetime="2024-07-25T00:55:09.000Z" title="发表于 2024-07-25 08:55:09">2024-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/23/Windows%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" title="Windows软件调试初探-启动过程">Windows软件调试初探-启动过程</a><time datetime="2024-07-23T14:58:16.000Z" title="发表于 2024-07-23 22:58:16">2024-07-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>