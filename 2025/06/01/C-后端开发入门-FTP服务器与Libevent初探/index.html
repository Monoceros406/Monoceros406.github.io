<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++后端开发入门-FTP服务器与Libevent初探 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="C++后端开发入门-FTP服务器与Libevent初探环境准备安装Libevent： 1sudo apt install libevent-dev  安装后需要在Visual Studio 2022的“跨平台”下的远程标头IntelliSense管理器中将目标主机更新，并在项目属性链接器的“库依赖项”中添加“event”表示链接libevent.so，换作命令行为： 1gcc test.c -o">
<meta property="og:type" content="article">
<meta property="og:title" content="C++后端开发入门-FTP服务器与Libevent初探">
<meta property="og:url" content="https://monoceros406.github.io/2025/06/01/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8ELibevent%E5%88%9D%E6%8E%A2/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="C++后端开发入门-FTP服务器与Libevent初探环境准备安装Libevent： 1sudo apt install libevent-dev  安装后需要在Visual Studio 2022的“跨平台”下的远程标头IntelliSense管理器中将目标主机更新，并在项目属性链接器的“库依赖项”中添加“event”表示链接libevent.so，换作命令行为： 1gcc test.c -o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://monoceros406.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-06-01T02:37:07.000Z">
<meta property="article:modified_time" content="2025-06-08T09:31:30.668Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="后端开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://monoceros406.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://monoceros406.github.io/2025/06/01/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8ELibevent%E5%88%9D%E6%8E%A2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++后端开发入门-FTP服务器与Libevent初探',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-08 17:31:30'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="The Blog of Monoceros406" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">330</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/ycy')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++后端开发入门-FTP服务器与Libevent初探</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-01T02:37:07.000Z" title="发表于 2025-06-01 10:37:07">2025-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-08T09:31:30.668Z" title="更新于 2025-06-08 17:31:30">2025-06-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++后端开发入门-FTP服务器与Libevent初探"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-后端开发入门-FTP服务器与Libevent初探"><a href="#C-后端开发入门-FTP服务器与Libevent初探" class="headerlink" title="C++后端开发入门-FTP服务器与Libevent初探"></a>C++后端开发入门-FTP服务器与Libevent初探</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>安装Libevent：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libevent-dev</span><br></pre></td></tr></table></figure>

<p>安装后需要在Visual Studio 2022的“跨平台”下的远程标头IntelliSense管理器中将目标主机更新，并在项目属性链接器的“库依赖项”中添加“event”表示链接libevent.so，换作命令行为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span> -I /usr/include -levent</span><br></pre></td></tr></table></figure>

<h2 id="Libevent入门"><a href="#Libevent入门" class="headerlink" title="Libevent入门"></a>Libevent入门</h2><p>用<code>event_init</code>初始化Libevent：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event-config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">event_base</span> *<span class="built_in">event_init</span>(<span class="type">void</span>);</span><br></pre></td></tr></table></figure>

<p>用<code>event_set</code>初始化event事件，设置回调函数和关注的事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> evutil_socket_t int</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_set</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> event *ev, <span class="comment">//执行要初始化的event对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">evutil_socket_t</span> fd, <span class="comment">//该event绑定的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">short</span> event, <span class="comment">//该fd上关注的事件类型 如EV_READ EV_WRITE EV_SIGNAL等</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (*cb)(<span class="type">evutil_socket_t</span>, <span class="type">short</span>, <span class="type">void</span> *), <span class="comment">//回调函数 参数依次为fd event arg</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *arg <span class="comment">//传递给回调函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> evtimer_set(ev, cb, arg)    event_set((ev), -1, 0, (cb), (arg))</span></span><br></pre></td></tr></table></figure>

<p>用<code>event_base_set</code>设置event要注册到哪个event_base实例上。Libevent不管理event事件集合，要应用程序自行管理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_base_set</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> event_base *,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> event *</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用<code>event_add</code>添加事件。对于定时事件，Libevent用一个小根堆维护，键为超时事件。对于信号和I&#x2F;O事件，Libevent将其放到等待链表中，后者是个双向链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_add</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> event *ev,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> timeval *timeout <span class="comment">//定时值</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用<code>event_dispatch</code>进入无限循环，等待就绪事件并执行回调函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_base_dispatch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> event_base *</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用<code>event_new</code>创建事件对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event</span> *<span class="built_in">event_new</span>(</span><br><span class="line">    <span class="keyword">struct</span> event_base *, <span class="comment">//关联的event_base</span></span><br><span class="line">    <span class="type">evutil_socket_t</span>, <span class="comment">//监控的文件描述符 超时事件设为-1</span></span><br><span class="line">    <span class="type">short</span>, <span class="comment">//事件类型标志</span></span><br><span class="line">    event_callback_fn, <span class="comment">//事件触发时的回调函数</span></span><br><span class="line">    <span class="type">void</span> * <span class="comment">//传给回调函数的参数 如EV_READ监控读事件 EV_PERSIST持久化事件（触发后不自动删除）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>用<code>event_config_new</code>创建一个event_config对象，用<code>event_config_set_flag</code>设置event_base运行时特性，用<code>event_config_free</code>释放一个event_config对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event_config</span> *<span class="built_in">event_config_new</span>(<span class="type">void</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_config_set_flag</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> event_config *cfg, <span class="comment">//event_config</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> flag <span class="comment">//标志 如EVENT_BASE_FLAG_NOLOCK禁用线程锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_config_free</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> event_config *cfg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用<code>event_base_new_with_config</code>创建自定义配置event_base。用<code>event_base_dispatch</code>启动事件循环。用<code>event_base_free</code>释放event_base：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event_base</span> *<span class="built_in">event_base_new_with_config</span>(</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> event_config *</span><br><span class="line">);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_base_dispatch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> event_base *</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_base_free</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> event_base *</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用<code>evconnlistener_new_bind</code>创建监听事件，并监听给定地址上的TCP连接。用<code>evconnlistener_free</code>释放一个监听器对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">evconnlistener</span> *<span class="built_in">evconnlistener_new_bind</span>(</span><br><span class="line">    <span class="keyword">struct</span> event_base *base, <span class="comment">//Libevent上下文</span></span><br><span class="line">    evconnlistener_cb cb, <span class="comment">//回调函数</span></span><br><span class="line">    <span class="type">void</span> *ptr, <span class="comment">//回调函数参数</span></span><br><span class="line">    <span class="type">unsigned</span> flags, <span class="comment">//监听器属性 如LEV_OPT_REUSEABLE端口复用 LEV_OPT_CLOSE_ON_FREE释放资源时关闭套接字</span></span><br><span class="line">    <span class="type">int</span> backlog, <span class="comment">//未连接队列长度 -1默认</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="comment">//绑定的地址端口</span></span><br><span class="line">    <span class="type">int</span> socklen <span class="comment">//套接字地址结构字节长度</span></span><br><span class="line">);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">evconnlistener_free</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> evconnlistener *lev</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用<code>bufferevent_socket_new</code>创建一个基于套接字的bufferevent，将指定文件描述符封装为带有读写缓冲区的高级事件对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bufferevent</span> *<span class="built_in">bufferevent_socket_new</span>(</span><br><span class="line">    <span class="keyword">struct</span> event_base *base, <span class="comment">//关联的event_base</span></span><br><span class="line">    <span class="type">evutil_socket_t</span> fd, <span class="comment">//需监听的套接字文件描述符</span></span><br><span class="line">    <span class="type">int</span> options <span class="comment">//选项</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>用<code>bufferevent_set_timeouts</code>设置bufferevent读写超时时间，超时后触发相应超时时间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferevent_set_timeouts</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> bufferevent *bufev, <span class="comment">//bufferevent</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> timeval *timeout_read, <span class="comment">//读超时时间 NULL不设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> timeval *timeout_write <span class="comment">//写超时时间 NULL不设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用<code>bufferevent_socket_new</code>建立异步非阻塞TCP连接：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> bufferevent *, <span class="comment">//bufferevent对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *, <span class="comment">//目标地址结构体</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> <span class="comment">//地址结构体长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用<code>bufferevent_setcb</code>设置bufferevent的回调函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bufferevent_setcb</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> bufferevent *bufev, <span class="comment">//bufferevent</span></span></span></span><br><span class="line"><span class="params"><span class="function">    bufferevent_data_cb readcb, <span class="comment">//数据可读时调用的回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    bufferevent_data_cb writecb, <span class="comment">//数据可写时调用的回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    bufferevent_event_cb eventcb, <span class="comment">//发生错误时调用的回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *cbarg <span class="comment">//回调函数上下文</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>分别用<code>bufferevent_read</code>和<code>bufferevent_write</code>从bufferevent输入&#x2F;输出缓冲区中读取&#x2F;写入数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">bufferevent_read</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> bufferevent* bufev, <span class="comment">//bufferevent</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* data, <span class="comment">//读到该缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> size <span class="comment">//最多size字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功返回实际读取字节数 失败-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferevent_write</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> bufferevent* bufev,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">void</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> size</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用<code>bufferevent_trigger</code>可手动触发某bufferevent回调函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bufferevent_trigger</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> bufferevent* bufev, <span class="comment">//bufferevent</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">short</span> iotype, <span class="comment">//要触发的回调事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> options <span class="comment">//传递给回调函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用<code>evutil_inet_pton</code>将点分十进制字符串转为二进制IP地址，是<code>inet_pton</code>的封装：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">evutil_inet_pton</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> af, <span class="comment">//地址族 AF_INET或AF_INET6等</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *src, <span class="comment">//字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *dst <span class="comment">//二进制地址 in_addr或in6_addr型</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//成功1 src不包含有效地址返回0 af不支持返回-1并设置errno</span></span><br></pre></td></tr></table></figure>

<p>用<code>evutil_socketpair</code>在本地创建一对全双工的用于进程间通信的套接字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">evutil_socketpair</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> d, <span class="comment">//地址族</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> type, <span class="comment">//套接字类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> protocol, <span class="comment">//协议 默认0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">evutil_socket_t</span> sv[<span class="number">2</span>] <span class="comment">//返回的套接字对 分别读和写</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用<code>evutil_make_socket_nonblocking</code>将一个套接字设为非阻塞模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">evutil_make_socket_nonblocking</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">evutil_socket_t</span> sock</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event-config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">event</span> ev;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">time_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">short</span> event, <span class="type">void</span>* argc)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;timer wakeup!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">event_add</span>(&amp;ev, &amp;tv);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event_base</span>* base = <span class="built_in">event_init</span>();</span><br><span class="line">    tv.tv_sec = <span class="number">10</span>;</span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">evtimer_set</span>(&amp;ev, time_cb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">event_base_set</span>(base, &amp;ev);</span><br><span class="line">    <span class="built_in">event_add</span>(&amp;ev, &amp;tv);</span><br><span class="line">    <span class="built_in">event_base_dispatch</span>(base);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="FTP协议入门"><a href="#FTP协议入门" class="headerlink" title="FTP协议入门"></a>FTP协议入门</h2><p>FTP工作方式分为主动方式PORT和被动方式PASV，主动方式可避免服务端防火墙干扰，被动方式可避免客户端防火墙干扰。</p>
<p>主动模式时客户端开启一个大于1024的随机端口，与服务器21号端口建立TCP控制连接。当用户需要传输数据时，客户端在控制通道中用PORT命令向服务器发送本地IP地址和端口号，服务器20号端口主动连接客户端发来的指定端口，在这条数据连接上进行文件下载上传。</p>
<p>被动模式时客户端开启一个大于1024的随机端口，与服务器21号端口建立TCP控制连接。当用户需要传输数据时，客户端向服务器发送PASV命令通知服务器采用被动传输方式。服务器收到PASV命令后开启一个大于1024的随机端口，并将IP地址和该端口号通过控制连接发送给客户端，客户端与服务器该端口建立TCP数据连接，进行文件下载上传。</p>
<p>FTP命令根据功能不同分为访问控制命令、传输参数命令和FTP服务命令，都是以网络虚拟终端NVT的ASCI文本形式发送，以ASCII回车或换行符结束。</p>
<p>常见控制命令如下：</p>
<table>
<thead>
<tr>
<th>控制命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>USER username</td>
<td>登录用户，username是登录用户名</td>
</tr>
<tr>
<td>CWD pathname</td>
<td>改变工作路径，pathname是指定目录路径名</td>
</tr>
<tr>
<td>CDUP</td>
<td>回到上一层目录</td>
</tr>
</tbody></table>
<p>常用传输参数命令如下：</p>
<table>
<thead>
<tr>
<th>传输参数命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>PORT h1,h2,h3,h4,p1,p2</td>
<td>主动传输方式，h1~h4为IP地址，p1*256+p2为端口号</td>
</tr>
<tr>
<td>PASV</td>
<td>被动传输方式</td>
</tr>
</tbody></table>
<p>常用服务命令如下：</p>
<table>
<thead>
<tr>
<th>服务命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>LIST pathname</td>
<td>请求服务器发送列表信息，如指定目录文件列表</td>
</tr>
<tr>
<td>RETR pathname</td>
<td>请求服务器向客户端发送指定文件</td>
</tr>
<tr>
<td>STOR pathname</td>
<td>客户端向服务器上传指定文件，已存在则替换，不存在则新建</td>
</tr>
<tr>
<td>PWD</td>
<td>返回当前工作目录名</td>
</tr>
</tbody></table>
<p>每条FTP指令至少产生一个FTP回应，一个FTP回应包含一个FTP应答码和一段文本说明，文本说明由服务器随便设定。FTP应答码由3位数字组成，第一位表示相应是成功&#x2F;失败&#x2F;不完全的，第二位表示该相应针对哪部分，第三位为附加信息。</p>
<p>常见FTP应答码第一位含义如下：</p>
<table>
<thead>
<tr>
<th>应答码第一位</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>确定预备应答。操作目前为止正常但尚未完成。</td>
</tr>
<tr>
<td>2</td>
<td>确定完成应答。操作成功完成。</td>
</tr>
<tr>
<td>4</td>
<td>暂时拒绝完成应答。操作执行失败，未接受命令，可稍后继续发送命令。</td>
</tr>
<tr>
<td>5</td>
<td>永久拒绝完成应答。命令不被接受且不再重试。</td>
</tr>
</tbody></table>
<p>常见FTP应答码第二位含义如下：</p>
<table>
<thead>
<tr>
<th>应答码第二位</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>格式错误</td>
</tr>
<tr>
<td>2</td>
<td>控制或数据连接</td>
</tr>
<tr>
<td>3</td>
<td>认证和账户登录过程</td>
</tr>
<tr>
<td>5</td>
<td>文件系统状态</td>
</tr>
</tbody></table>
<p>常用FTP应答码例子如下：</p>
<table>
<thead>
<tr>
<th>应答码例子</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>指令成功</td>
</tr>
<tr>
<td>501</td>
<td>参数或变量语法错误</td>
</tr>
<tr>
<td>226</td>
<td>关闭数据连接，请求文件操作成功</td>
</tr>
<tr>
<td>150</td>
<td>文件状态良好，打开数据连接</td>
</tr>
</tbody></table>
<h2 id="FTP服务器原理"><a href="#FTP服务器原理" class="headerlink" title="FTP服务器原理"></a>FTP服务器原理</h2><p>本小节用的这个项目<a target="_blank" rel="noopener" href="https://github.com/BigCJL/libevent-Ftp_Server">https://github.com/BigCJL/libevent-Ftp_Server</a> 。服务端启动后Windows客户端资源管理器中打开报错，不知道为啥，反正命令行ftp工具能连上，一些手写的Windows客户端也能连上，据说Filezilla等也能连上。</p>
<p>主程序Ftp_Server.cpp内容如下，创建监听事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpServerCMD.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpFactory.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPORT 21</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listen_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener* e, <span class="type">evutil_socket_t</span> s, <span class="keyword">struct</span> sockaddr* a, <span class="type">int</span> socklen, <span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;listen_cb&quot;</span> &lt;&lt; endl;</span><br><span class="line">    XTask* task = XFtpFactory::<span class="built_in">Get</span>()-&gt;<span class="built_in">CreateTask</span>();</span><br><span class="line">    task-&gt;sock = s;</span><br><span class="line">    XThreadPool::<span class="built_in">Get</span>()-&gt;<span class="built_in">Dispatch</span>(task);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="comment">//初始化socket库,这是windows特有的操作</span></span><br><span class="line">    WSADATA wsa;</span><br><span class="line">    <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//忽略管道信号 发送数据给已关闭的socket</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGPIPE, SIG_IGN) == SIG_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    XThreadPool::<span class="built_in">Get</span>()-&gt;<span class="built_in">Init</span>(<span class="number">10</span>); <span class="comment">//1. 初始化线程池</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test_thread_pool_server\n&quot;</span>;</span><br><span class="line">    event_base* base = <span class="built_in">event_base_new</span>(); <span class="comment">//创建libevent的上下文</span></span><br><span class="line">    <span class="keyword">if</span> (base)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;event_base_new success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    sockaddr_in sin; <span class="comment">//监听端口 socket,bind,listen 三步全部包含在内了</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sin, <span class="number">0</span>, <span class="built_in">sizeof</span>(sin));</span><br><span class="line">    sin.sin_family = AF_INET;</span><br><span class="line">    sin.sin_port = <span class="built_in">htons</span>(SPORT);</span><br><span class="line">    evconnlistener* ev = <span class="built_in">evconnlistener_new_bind</span>(base, listen_cb, base, LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, <span class="number">10</span>, (sockaddr*)&amp;sin, <span class="built_in">sizeof</span>(sin));</span><br><span class="line">    <span class="keyword">if</span> (base) <span class="comment">//事件分发处理</span></span><br><span class="line">        <span class="built_in">event_base_dispatch</span>(base);</span><br><span class="line">    <span class="keyword">if</span> (ev)</span><br><span class="line">        <span class="built_in">evconnlistener_free</span>(ev);</span><br><span class="line">    <span class="keyword">if</span> (base)</span><br><span class="line">        <span class="built_in">event_base_free</span>(base);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>XFtpFactory提供一个创建任务的函数<code>CreateTask</code>，<code>Dispatch</code>用于线程池中分配任务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XFtpFactory.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XTask.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XFtpFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> XFtpFactory* <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> XFtpFactory f;</span><br><span class="line">        <span class="keyword">return</span> &amp;f;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">XTask* <span class="title">CreateTask</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">XFtpFactory</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XFtpFactory.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpFactory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpServerCMD.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpUSER.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpLIST.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpPORT.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpRETR.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpSTOR.h&quot;</span></span></span><br><span class="line"><span class="function">XTask* <span class="title">XFtpFactory::CreateTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    XFtpServerCMD* x = <span class="keyword">new</span> <span class="built_in">XFtpServerCMD</span>();</span><br><span class="line">    x-&gt;<span class="built_in">Reg</span>(<span class="string">&quot;USER&quot;</span>, <span class="keyword">new</span> <span class="built_in">XFtpUSER</span>()); <span class="comment">//注册ftp消息处理对象</span></span><br><span class="line">    XFtpLIST* list = <span class="keyword">new</span> <span class="built_in">XFtpLIST</span>();</span><br><span class="line">    x-&gt;<span class="built_in">Reg</span>(<span class="string">&quot;PWD&quot;</span>, list);</span><br><span class="line">    x-&gt;<span class="built_in">Reg</span>(<span class="string">&quot;LIST&quot;</span>, list);</span><br><span class="line">    x-&gt;<span class="built_in">Reg</span>(<span class="string">&quot;CWD&quot;</span>, list);</span><br><span class="line">    x-&gt;<span class="built_in">Reg</span>(<span class="string">&quot;CDUP&quot;</span>, list);</span><br><span class="line">    x-&gt;<span class="built_in">Reg</span>(<span class="string">&quot;PORT&quot;</span>, <span class="keyword">new</span> <span class="built_in">XFtpPORT</span>());</span><br><span class="line">    x-&gt;<span class="built_in">Reg</span>(<span class="string">&quot;RETR&quot;</span>, <span class="keyword">new</span> <span class="built_in">XFtpRETR</span>());</span><br><span class="line">    x-&gt;<span class="built_in">Reg</span>(<span class="string">&quot;RETR&quot;</span>, <span class="keyword">new</span> <span class="built_in">XFtpSTOR</span>());</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line">XFtpFactory::<span class="built_in">XFtpFactory</span>() &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>XFtpServerCMD类是命令处理器，在XFtpFactory的<code>CreatTask</code>函数中实例化了命令处理器并向其添加命令。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XFtpServerCMD.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpTask.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XFtpServerCMD</span> : <span class="keyword">public</span> XFtpTask&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>; <span class="comment">//初始化任务</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Read</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Event</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reg</span><span class="params">(std::string s, XFtpTask* call)</span></span>; <span class="comment">//注册命令处理对象(开销要不要考虑？线程互斥要不要考虑？),注册时 还未分发到线程(Dispatch)</span></span><br><span class="line">    ~<span class="built_in">XFtpServerCMD</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, XFtpTask*&gt;calls; <span class="comment">//注册的处理对象</span></span><br><span class="line">    std::map&lt;XFtpTask*, <span class="type">int</span>&gt;calls_del; <span class="comment">//用来做空间清理</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XFtpServerCMD.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpServerCMD.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpServerCMD::Reg</span><span class="params">(std::string cmd, XFtpTask* call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!call) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;XFtpServerCMD::Reg call is null&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (cmd.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;XFtpServerCMD::Reg cmd is null&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (calls.<span class="built_in">find</span>(cmd) != calls.<span class="built_in">end</span>()) &#123; <span class="comment">//已经注册的是否覆盖？ -&gt;不覆盖，提示错误</span></span><br><span class="line">        cout &lt;&lt; cmd &lt;&lt; <span class="string">&quot; is already register&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    calls[cmd] = call;</span><br><span class="line">    calls_del[call] = <span class="number">0</span>; <span class="comment">//用来做空间清理</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpServerCMD::Read</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span> </span>&#123; <span class="comment">//子线程XThread event事件分发</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">bufferevent_read</span>(bev, data, <span class="built_in">sizeof</span>(data) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        data[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Recv CMD:&quot;</span> &lt;&lt; data &lt;&lt; flush;</span><br><span class="line">        string type = <span class="string">&quot;&quot;</span>; <span class="comment">//分发到处理对象 分析出类型 USER anonymous</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] == <span class="string">&#x27; &#x27;</span> || data[i] == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            type += data[i];</span><br><span class="line">        &#125;;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;type is [&quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (calls.<span class="built_in">find</span>(type) != calls.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            XFtpTask* t = calls[type];</span><br><span class="line">            t-&gt;ip = ip;</span><br><span class="line">            t-&gt;port = port;</span><br><span class="line">            t-&gt;base = base;</span><br><span class="line">            t-&gt;cmdTask = <span class="keyword">this</span>;   <span class="comment">//用来处理回复命令和目录</span></span><br><span class="line">            t-&gt;<span class="built_in">Parse</span>(type, data);</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="string">&quot;PORT&quot;</span>) &#123;  <span class="comment">//这样做代码耦合度变高,暂时按这个方案</span></span><br><span class="line">                ip = t-&gt;ip;</span><br><span class="line">                port = t-&gt;port;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            string msg = <span class="string">&quot;200 OK\r\n&quot;</span>; <span class="comment">//如果没找到消息命令的类型,回复一个OK</span></span><br><span class="line">            <span class="built_in">bufferevent_write</span>(bev, msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpServerCMD::Event</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (what &amp; (BEV_EVENT_EOF | BEV_EVENT_ERROR | BEV_EVENT_TIMEOUT)) &#123; <span class="comment">//如果对方网络断掉或者机器死机，有可能收不到BEV_EVENT_EOF的数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BEV_EVENT_EOF | BEV_EVENT_ERROR&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">XFtpServerCMD::Init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化任务 运行在子线程中</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;XFtpServerCMD::Init&quot;</span> &lt;&lt; endl;</span><br><span class="line">    bufferevent* bev = <span class="built_in">bufferevent_socket_new</span>(base, sock, BEV_OPT_CLOSE_ON_FREE);  <span class="comment">//监听socket bufferevent base socket base在子线程里的Setup初始化了</span></span><br><span class="line">    <span class="keyword">if</span> (!bev) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;bev = bev;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">SetCallback</span>(bev);</span><br><span class="line">    timeval rt = &#123; <span class="number">60</span>,<span class="number">0</span> &#125;; <span class="comment">//添加超时 </span></span><br><span class="line">    <span class="built_in">bufferevent_set_timeouts</span>(bev, &amp;rt, <span class="number">0</span>);</span><br><span class="line">    string msg = <span class="string">&quot;220 thist is libevent Ftp_Server, Welcome!\r\n&quot;</span>; <span class="comment">//发送欢迎消息 这里说明建立了一个连接</span></span><br><span class="line">    <span class="built_in">bufferevent_write</span>(bev, msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">XFtpServerCMD::~<span class="built_in">XFtpServerCMD</span>() &#123;</span><br><span class="line">    <span class="built_in">Close</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ptr = calls_del.<span class="built_in">begin</span>(); ptr != calls_del.<span class="built_in">end</span>(); ptr++) &#123;</span><br><span class="line">        ptr-&gt;first-&gt;<span class="built_in">Close</span>();</span><br><span class="line">        <span class="keyword">delete</span> ptr-&gt;first;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>XFtpUSER类用于实现USER命令，可根据需要实现具体登录认证，但这里不实现，默认都可以登录。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XFtpUSER.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpTask.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XFtpUSER</span> : <span class="keyword">public</span> XFtpTask &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Parse</span><span class="params">(std::string type, std::string msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XFtpUSER.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpUSER.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpUSER::Parse</span><span class="params">(std::string type, std::string msg)</span> </span>&#123; <span class="comment">//解析协议</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;XFtpUSER::Parse &quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">ResCMD</span>(<span class="string">&quot;230 Login successful \r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>XFtpPORT类用于实现PORT命令，解析IP地址和端口号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XFtpPORT.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpTask.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XFtpPORT</span> :<span class="keyword">public</span> XFtpTask &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Parse</span><span class="params">(std::string type, std::string msg)</span></span>; <span class="comment">//解析协议</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XFtpPORT.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpPORT.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpPORT::Parse</span><span class="params">(std::string type, std::string msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//PORT 127,0,0,1,70,96\r\n</span></span><br><span class="line">    <span class="comment">//PORT n1.n2.n3.n4,n5,n6\r\n</span></span><br><span class="line">    <span class="comment">//port = n5*256 + n6</span></span><br><span class="line">    vector&lt;string&gt; vals; <span class="comment">//只获取ip和端口，不连接 取出ip</span></span><br><span class="line">    string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; msg.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg[i] == <span class="string">&#x27;,&#x27;</span> || msg[i] == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">            vals.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        tmp += msg[i];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (vals.<span class="built_in">size</span>() != <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">ResCMD</span>(<span class="string">&quot;501 Syntax error in parameters or arguments.&quot;</span>); <span class="comment">//PORT格式有误</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ip = vals[<span class="number">0</span>] + <span class="string">&quot;.&quot;</span> + vals[<span class="number">1</span>] + <span class="string">&quot;.&quot;</span> + vals[<span class="number">2</span>] + <span class="string">&quot;.&quot;</span> + vals[<span class="number">3</span>];</span><br><span class="line">    port = <span class="built_in">atoi</span>(vals[<span class="number">4</span>].<span class="built_in">c_str</span>()) * <span class="number">256</span> + <span class="built_in">atoi</span>(vals[<span class="number">5</span>].<span class="built_in">c_str</span>()); <span class="comment">//port = n5*256 + n6</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Port ip is &quot;</span> &lt;&lt; ip &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;PORT port is &quot;</span> &lt;&lt; port &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">ResCMD</span>(<span class="string">&quot;200 PORT command successful.\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后续命令用XFtpLIST列表类实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XFtpLIST.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpTask.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XFtpLIST</span> : <span class="keyword">public</span> XFtpTask &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Parse</span><span class="params">(std::string type, std::string msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Event</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetListData</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XFtpLIST.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpLIST.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;io.h&gt;</span>  <span class="comment">//用于遍历当前目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpLIST::Write</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ResCMD</span>(<span class="string">&quot;226 Transfer complete\r\n&quot;</span>); <span class="comment">//4 226 Transfer complete 发送完成</span></span><br><span class="line">    <span class="built_in">Close</span>(); <span class="comment">//5 关闭连接</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpLIST::Event</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (what &amp; (BEV_EVENT_EOF | BEV_EVENT_ERROR | BEV_EVENT_TIMEOUT)) &#123; <span class="comment">//如果对方网络断掉或者机器死机，有可能收不到BEV_EVENT_EOF的数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BEV_EVENT_EOF | BEV_EVENT_ERROR&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (what &amp; BEV_EVENT_CONNECTED)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;XFtpLIST BEV_EVENT_CONNECTED&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpLIST::Parse</span><span class="params">(std::string type, std::string msg)</span> </span>&#123; <span class="comment">// 解析协议</span></span><br><span class="line">    string resmsg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="string">&quot;PWD&quot;</span>) &#123;</span><br><span class="line">        resmsg = <span class="string">&quot;257 \&quot;&quot;</span>; <span class="comment">//257 &quot;/&quot; is current directory</span></span><br><span class="line">        resmsg += cmdTask-&gt;curDir;</span><br><span class="line">        resmsg += <span class="string">&quot;\&quot; is current dir.\r\n&quot;</span>;</span><br><span class="line">        <span class="built_in">ResCMD</span>(resmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;LIST&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">//1 连接数据通道 2 150发送成功 3 发送目录数据通道 4 发送完成226 5 关闭连接</span></span><br><span class="line">            <span class="comment">//命令通道回复消息，使用数据通道发送目录</span></span><br><span class="line">            <span class="comment">//-rwxrwxrwx 1 root group 64463 Mar 14 09:53 101.jgp\r\n</span></span><br><span class="line">            <span class="built_in">ConnectPORT</span>(); <span class="comment">//1 连接数据通道</span></span><br><span class="line">            <span class="built_in">ResCMD</span>(<span class="string">&quot;150 Here comes thre directory listing.\r\n&quot;</span>); <span class="comment">//2 150</span></span><br><span class="line">            string listdata = <span class="built_in">GetListData</span>(cmdTask-&gt;rootDir + cmdTask-&gt;curDir); <span class="comment">//string listdata = &quot;-rwxrwxrwx 1 root group 64463 Mar 14 09:53 101.jgp\r\n&quot;;</span></span><br><span class="line">            <span class="built_in">Send</span>(listdata); <span class="comment">// 3 数据通道发送</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (type == <span class="string">&quot;CWD&quot;</span>) &#123;  <span class="comment">//切换目录</span></span><br><span class="line">                <span class="type">int</span> pos = msg.<span class="built_in">rfind</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>; <span class="comment">//取出命令中的路径 CWD test\r\n</span></span><br><span class="line">                string path = msg.<span class="built_in">substr</span>(pos, msg.<span class="built_in">size</span>() - pos - <span class="number">2</span>); <span class="comment">//去掉结尾的\r\n</span></span><br><span class="line">                <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>)  <span class="comment">//绝对路径</span></span><br><span class="line">                    cmdTask-&gt;curDir = path;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cmdTask-&gt;curDir[cmdTask-&gt;curDir.<span class="built_in">size</span>() - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                        cmdTask-&gt;curDir += <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">                    cmdTask-&gt;curDir += path + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="built_in">ResCMD</span>(<span class="string">&quot;250 Directory success changed.\r\n&quot;</span>); <span class="comment">// /test/</span></span><br><span class="line">                <span class="comment">//cmdTask-&gt;curDir +=</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> (type == <span class="string">&quot;CDUP&quot;</span>) &#123; <span class="comment">//回到上层路径</span></span><br><span class="line">                    string path = cmdTask-&gt;curDir;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (path[path.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>) <span class="comment">//统一去掉结尾的 /</span></span><br><span class="line">                        path = path.<span class="built_in">substr</span>(<span class="number">0</span>, path.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">                    <span class="type">int</span> pos = path.<span class="built_in">rfind</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                    path = path.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">                    cmdTask-&gt;curDir = path;</span><br><span class="line">                    <span class="built_in">ResCMD</span>(<span class="string">&quot;250 Directory success changed.\r\n&quot;</span>);</span><br><span class="line">                &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">XFtpLIST::GetListData</span><span class="params">(std::string path)</span> </span>&#123;</span><br><span class="line">    string data = <span class="string">&quot;&quot;</span>; <span class="comment">//&quot;-rwxrwxrwx 1 root group 64463 Mar 14 09:53 101.jgp\r\n&quot;;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="type">_finddata_t</span> file; <span class="comment">//存储文件信息</span></span><br><span class="line">    path += <span class="string">&quot;/*.*&quot;</span>; <span class="comment">//目录上下文</span></span><br><span class="line">    <span class="type">intptr_t</span> dir = _findfirst(path.<span class="built_in">c_str</span>(), &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (dir &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (file.attrib &amp; _A_SUBDIR) &#123;<span class="comment">//是否是目录,去掉. ..</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(file.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(file.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tmp = <span class="string">&quot;drwxrwxrwx 1 root group&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp = <span class="string">&quot;-rwxrwxrwx 1 root group&quot;</span>;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%u&quot;</span>, file.size);</span><br><span class="line">        tmp += buf;</span><br><span class="line">        <span class="built_in">strftime</span>(buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>, <span class="string">&quot;%b %d %H:%M &quot;</span>, <span class="built_in">localtime</span>(&amp;file.time_write)); <span class="comment">//日期时间</span></span><br><span class="line">        tmp += buf;</span><br><span class="line">        tmp += file.name;</span><br><span class="line">        data += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">        data += tmp;</span><br><span class="line">    &#125; <span class="keyword">while</span> (_findnext(dir, &amp;file) == <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    string cmd = <span class="string">&quot;ls -l &quot;</span>;</span><br><span class="line">    cmd += path;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Popen:&quot;</span> &lt;&lt; cmd &lt;&lt; endl;</span><br><span class="line">    FILE* f = <span class="built_in">popen</span>(cmd.<span class="built_in">c_str</span>(), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!f)</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">fread</span>(buffer, <span class="number">1</span>, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, f);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        data += buffer;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">pclose</span>(f);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>XFtpRETR类如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XFtpRETR.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpTask.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XFtpRETR</span> :<span class="keyword">public</span> XFtpTask &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Parse</span><span class="params">(std::string type, std::string msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Event</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XFtpRETR.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpRETR.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpRETR::Write</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fp)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="built_in">sizeof</span>(buf), fp);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ResCMD</span>(<span class="string">&quot;226 Transfer complete\r\n&quot;</span>);</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; len &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; flush;</span><br><span class="line">    <span class="built_in">Send</span>(buf, len);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpRETR::Event</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (what &amp; (BEV_EVENT_EOF | BEV_EVENT_ERROR | BEV_EVENT_TIMEOUT)) &#123;<span class="comment">//如果对方网络断掉或者机器死机，有可能收不到BEV_EVENT_EOF的数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BEV_EVENT_EOF | BEV_EVENT_ERROR&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (what &amp; BEV_EVENT_CONNECTED)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;XFtpLIST BEV_EVENT_CONNECTED&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpRETR::Parse</span><span class="params">(std::string type, std::string msg)</span> </span>&#123; <span class="comment">//解析协议</span></span><br><span class="line">    <span class="type">int</span> pos = msg.<span class="built_in">rfind</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>; <span class="comment">//文件名</span></span><br><span class="line">    string filename = msg.<span class="built_in">substr</span>(pos, msg.<span class="built_in">size</span>() - pos - <span class="number">2</span>);</span><br><span class="line">    string path = cmdTask-&gt;rootDir;</span><br><span class="line">    path += cmdTask-&gt;curDir;</span><br><span class="line">    path += <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    path += filename;</span><br><span class="line">    fp = <span class="built_in">fopen</span>(path.<span class="built_in">c_str</span>(), <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="built_in">ConnectPORT</span>(); <span class="comment">//连接数据通道</span></span><br><span class="line">        <span class="built_in">ResCMD</span>(<span class="string">&quot;150 File OK\r\n&quot;</span>); <span class="comment">//发送开始下载文件的指令</span></span><br><span class="line">        <span class="built_in">bufferevent_trigger</span>(bev, EV_WRITE, <span class="number">0</span>); <span class="comment">//触发写入事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">ResCMD</span>(<span class="string">&quot;450 file open failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>XFtpSTOR类如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XFtpSTOR.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpTask.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XFtpSTOR</span> :<span class="keyword">public</span> XFtpTask &#123; <span class="comment">//上传文件</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Parse</span><span class="params">(std::string type, std::string msg)</span></span>; <span class="comment">//解析协议</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Read</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Event</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XFtpSTOR.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpSTOR.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpSTOR::Parse</span><span class="params">(std::string type, std::string msg)</span> </span>&#123; <span class="comment">//解析协议</span></span><br><span class="line">    <span class="type">int</span> pos = msg.<span class="built_in">rfind</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>; <span class="comment">//文件名</span></span><br><span class="line">    string filename = msg.<span class="built_in">substr</span>(pos, msg.<span class="built_in">size</span>() - pos - <span class="number">2</span>);</span><br><span class="line">    string path = cmdTask-&gt;rootDir;</span><br><span class="line">    path += cmdTask-&gt;curDir;</span><br><span class="line">    path += filename;</span><br><span class="line">    fp = <span class="built_in">fopen</span>(path.<span class="built_in">c_str</span>(), <span class="string">&quot;wb&quot;</span>);   <span class="comment">//写入二进制</span></span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="built_in">ConnectPORT</span>(); <span class="comment">//连接数据通道</span></span><br><span class="line">        <span class="built_in">ResCMD</span>(<span class="string">&quot;125 File OK\r\n&quot;</span>); <span class="comment">//发送开始接收文件的指令</span></span><br><span class="line">        <span class="built_in">bufferevent_trigger</span>(bev, EV_READ, <span class="number">0</span>); <span class="comment">//触发读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">ResCMD</span>(<span class="string">&quot;450 file open failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpSTOR::Read</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fp)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">bufferevent_read</span>(bev, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">fwrite</span>(buf, <span class="number">1</span>, len, fp);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; len &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; flush;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpSTOR::Event</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (what &amp; (BEV_EVENT_EOF | BEV_EVENT_ERROR | BEV_EVENT_TIMEOUT)) &#123; <span class="comment">//如果对方网络断掉或者机器死机，有可能收不到BEV_EVENT_EOF的数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BEV_EVENT_EOF | BEV_EVENT_ERROR&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        <span class="built_in">ResCMD</span>(<span class="string">&quot;226 Transfer complete\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (what &amp; BEV_EVENT_CONNECTED)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;XFtpLIST BEV_EVENT_CONNECTED&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>XFtpTask类如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XFtpTask.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XTask.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XFtpTask</span> : <span class="keyword">public</span> XTask &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string curDir = <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    std::string rootDir = <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    std::string ip = <span class="string">&quot;&quot;</span>; <span class="comment">//PORT 数据通道的ip和端口</span></span><br><span class="line">    <span class="type">int</span> port = <span class="number">0</span>;</span><br><span class="line">    XFtpTask* cmdTask = <span class="number">0</span>; <span class="comment">//命令通道</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Parse</span><span class="params">(std::string type, std::string msg)</span> </span>&#123;&#125; <span class="comment">//解析协议</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ResCMD</span><span class="params">(std::string msg)</span></span>; <span class="comment">//回复cmd消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string data)</span></span>; <span class="comment">//用来发送建立了连接的数据通道</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">int</span> datasize)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ConnectPORT</span><span class="params">()</span></span>; <span class="comment">//连接数据通道</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Read</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Event</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetCallback</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ReadCB</span><span class="params">(bufferevent* bev, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">WriteCB</span><span class="params">(bufferevent* bev, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">EventCB</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bufferevent</span>* bev = <span class="number">0</span>; <span class="comment">//命令bev</span></span><br><span class="line">    FILE* fp = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XFtpTask.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XFtpTask.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpTask::Send</span><span class="params">(std::string data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Send</span>(data.<span class="built_in">c_str</span>(), data.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpTask::Send</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">int</span> datasize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bev)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">bufferevent_write</span>(bev, data, datasize);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpTask::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bev) &#123;  <span class="comment">//防止二次释放 内存</span></span><br><span class="line">        <span class="built_in">bufferevent_free</span>(bev);</span><br><span class="line">        bev = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">        fp = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpTask::ConnectPORT</span><span class="params">()</span> </span>&#123; <span class="comment">//连接数据通道</span></span><br><span class="line">    <span class="keyword">if</span> (ip.<span class="built_in">empty</span>() || port &lt;= <span class="number">0</span> || !base) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConnectPORT failed ip or port is null&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    bev = <span class="built_in">bufferevent_socket_new</span>(base, <span class="number">-1</span>, BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line">    sockaddr_in sin;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sin, <span class="number">0</span>, <span class="built_in">sizeof</span>(sin));</span><br><span class="line">    sin.sin_family = AF_INET;</span><br><span class="line">    sin.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    <span class="built_in">evutil_inet_pton</span>(AF_INET, ip.<span class="built_in">c_str</span>(), &amp;sin.sin_addr.s_addr);</span><br><span class="line">    <span class="built_in">SetCallback</span>(bev); <span class="comment">//设置回调和权限码</span></span><br><span class="line">    timeval rt = &#123; <span class="number">60</span>,<span class="number">0</span> &#125;; <span class="comment">//添加超时</span></span><br><span class="line">    <span class="built_in">bufferevent_set_timeouts</span>(bev, &amp;rt, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">bufferevent_socket_connect</span>(bev, (sockaddr*)&amp;sin, <span class="built_in">sizeof</span>(sin));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpTask::ResCMD</span><span class="params">(string msg)</span> </span>&#123; <span class="comment">//回复cmd消息</span></span><br><span class="line">    <span class="keyword">if</span> (!cmdTask || !cmdTask-&gt;bev)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ResCMD:&quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (msg[msg.<span class="built_in">size</span>() - <span class="number">1</span>] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        msg += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="built_in">bufferevent_write</span>(cmdTask-&gt;bev, msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpTask::SetCallback</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bufferevent_setcb</span>(bev, ReadCB, WriteCB, EventCB, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">bufferevent_enable</span>(bev, EV_READ | EV_WRITE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpTask::ReadCB</span><span class="params">(bufferevent* bev, <span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    XFtpTask* t = <span class="built_in">static_cast</span>&lt;XFtpTask*&gt;(arg);<span class="comment">//cpp风格强制转换</span></span><br><span class="line">    t-&gt;<span class="built_in">Read</span>(bev);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpTask::WriteCB</span><span class="params">(bufferevent* bev, <span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    XFtpTask* t = <span class="built_in">static_cast</span>&lt;XFtpTask*&gt;(arg);</span><br><span class="line">    t-&gt;<span class="built_in">Write</span>(bev);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XFtpTask::EventCB</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what, <span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    XFtpTask* t = <span class="built_in">static_cast</span>&lt;XFtpTask*&gt;(arg);</span><br><span class="line">    t-&gt;<span class="built_in">Event</span>(bev, what);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>XTask类如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XTask.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XTask</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event_base</span>* base = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">int</span> thread_id = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//初始化任务</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XTask.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XTask.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>XThread类如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XThread.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XTask.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>; <span class="comment">//启动线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span></span>; <span class="comment">//线程入口函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Setup</span><span class="params">()</span></span>; <span class="comment">//安装线程 初始化event_base和管道监听事件用于激活线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> which)</span></span>; <span class="comment">//收到主线程发出的激活消息（线程池的分发）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Activate</span><span class="params">()</span></span>; <span class="comment">//线程激活</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(XTask* t)</span></span>; <span class="comment">//添加处理的任务 一个线程同时可以处理多个任务，共用一个event_base</span></span><br><span class="line">    <span class="built_in">XThread</span>();</span><br><span class="line">    ~<span class="built_in">XThread</span>();</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>; <span class="comment">//线程编号</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> notify_send_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event_base</span>* base = <span class="number">0</span>;</span><br><span class="line">    std::list&lt;XTask*&gt; tasks; <span class="comment">//任务列表</span></span><br><span class="line">    std::mutex tasks_mutex; <span class="comment">//线程安全 互斥</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XThread.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XTask.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">NotifyCallback</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> which, <span class="type">void</span>* arg)</span> </span>&#123; <span class="comment">//激活线程任务的回调函数</span></span><br><span class="line">    XThread* t = (XThread*)arg;</span><br><span class="line">    t-&gt;<span class="built_in">Notify</span>(fd, which);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XThread::Notify</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">//水平触发！只要没有接收完全 会再次进来</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="type">int</span> re = <span class="built_in">recv</span>(fd, buf, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> re = <span class="built_in">read</span>(fd, buf, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (re &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; id &lt;&lt; <span class="string">&quot; thread &quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    XTask* task = <span class="literal">nullptr</span>;</span><br><span class="line">    tasks_mutex.<span class="built_in">lock</span>(); <span class="comment">//获取任务 并初始化任务</span></span><br><span class="line">    <span class="keyword">if</span> (tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        tasks_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    task = tasks.<span class="built_in">front</span>();  <span class="comment">//先进先出</span></span><br><span class="line">    tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">    tasks_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    task-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XThread::AddTask</span><span class="params">(XTask* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    t-&gt;base = <span class="keyword">this</span>-&gt;base;</span><br><span class="line">    tasks_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    tasks.<span class="built_in">push_back</span>(t);</span><br><span class="line">    tasks_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XThread::Activate</span><span class="params">()</span> </span>&#123;<span class="comment">//线程激活</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="type">int</span> re = <span class="built_in">send</span>(<span class="keyword">this</span>-&gt;notify_send_fd, <span class="string">&quot;c&quot;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> re = <span class="built_in">write</span>(<span class="keyword">this</span>-&gt;notify_send_fd, <span class="string">&quot;c&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (re &lt;= <span class="number">0</span>)</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;XThread::Activate() failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XThread::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Setup</span>();</span><br><span class="line">    <span class="function">thread <span class="title">th</span><span class="params">(&amp;XThread::Main, <span class="keyword">this</span>)</span></span>; <span class="comment">//启动线程</span></span><br><span class="line">    th.<span class="built_in">detach</span>(); <span class="comment">//断开与主线程联系</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">XThread::Setup</span><span class="params">()</span> </span>&#123; <span class="comment">//windows用配对的socket(模拟管道) linux用管道</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="type">evutil_socket_t</span> fds[<span class="number">2</span>]; <span class="comment">//创建一个socketpair 可以互相通信 fds[0] 读; fds[1] 写</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">evutil_socketpair</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>, fds) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;evutil_socketpair failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">evutil_make_socket_nonblocking</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">evutil_make_socket_nonblocking</span>(fds[<span class="number">1</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>]; <span class="comment">//创建的管道 不能用send recv读取 read write</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(fds)) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;pipe failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    notify_send_fd = fds[<span class="number">1</span>]; <span class="comment">//读取绑定到event事件中，写入要保存</span></span><br><span class="line">    event_config* ev_conf = <span class="built_in">event_config_new</span>(); <span class="comment">//创建libevent上下文(无锁)</span></span><br><span class="line">    <span class="built_in">event_config_set_flag</span>(ev_conf, EVENT_BASE_FLAG_NOLOCK);</span><br><span class="line">    <span class="keyword">this</span>-&gt;base = <span class="built_in">event_base_new_with_config</span>(ev_conf);</span><br><span class="line">    <span class="built_in">event_config_free</span>(ev_conf);</span><br><span class="line">    <span class="keyword">if</span> (!base) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;event_base_new_with_config failed in thread!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    event* ev = <span class="built_in">event_new</span>(base, fds[<span class="number">0</span>], EV_READ | EV_PERSIST, NotifyCallback, <span class="keyword">this</span>); <span class="comment">//添加管道监听事件 用于激活线程执行任务</span></span><br><span class="line">    <span class="built_in">event_add</span>(ev, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XThread::Main</span><span class="params">()</span> </span>&#123; <span class="comment">//线程入口函数</span></span><br><span class="line">    cout &lt;&lt; id &lt;&lt; <span class="string">&quot; XThread::Main() begin&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">event_base_dispatch</span>(base);</span><br><span class="line">    <span class="built_in">event_base_free</span>(base);</span><br><span class="line">    cout &lt;&lt; id &lt;&lt; <span class="string">&quot; XThread::Main() end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line">XThread::<span class="built_in">XThread</span>() &#123;&#125;;</span><br><span class="line">XThread::~<span class="built_in">XThread</span>() &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>XThreadPool类如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XThreadPool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XTask.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XThread</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> XThreadPool* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="comment">//单件模式</span></span><br><span class="line">        <span class="type">static</span> XThreadPool p;</span><br><span class="line">        <span class="keyword">return</span> &amp;p;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> threadCount)</span></span>; <span class="comment">//初始化所有线程 并启动线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dispatch</span><span class="params">(XTask* task)</span></span>; <span class="comment">//分发线程</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> threadCount = <span class="number">0</span>; <span class="comment">//线程数量</span></span><br><span class="line">    <span class="type">int</span> lastThread = <span class="number">-1</span>;</span><br><span class="line">    std::vector&lt;XThread*&gt; threads; <span class="comment">//线程池线程</span></span><br><span class="line">    <span class="built_in">XThreadPool</span>() &#123;&#125;;   <span class="comment">//小技巧 构造函数私有 避免多次实例化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XThreadPool.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XThreadPool::Dispatch</span><span class="params">(XTask* task)</span> </span>&#123; <span class="comment">//分发线程</span></span><br><span class="line">    <span class="keyword">if</span> (!task) <span class="comment">//轮询</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> tid = (lastThread + <span class="number">1</span>) % threadCount;</span><br><span class="line">    lastThread = tid;</span><br><span class="line">    XThread* t = threads[tid];</span><br><span class="line">    t-&gt;<span class="built_in">AddTask</span>(task);</span><br><span class="line">    t-&gt;<span class="built_in">Activate</span>(); <span class="comment">//激活线程</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XThreadPool::Init</span><span class="params">(<span class="type">int</span> threadCount)</span> </span>&#123; <span class="comment">//初始化所有线程 并启动线程</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;threadCount = threadCount;</span><br><span class="line">    <span class="keyword">this</span>-&gt;lastThread = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        XThread* t = <span class="keyword">new</span> <span class="built_in">XThread</span>();</span><br><span class="line">        t-&gt;id = i + <span class="number">1</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Create thread &quot;</span> &lt;&lt; t-&gt;id &lt;&lt; endl;</span><br><span class="line">        t-&gt;<span class="built_in">Start</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;threads.<span class="built_in">push_back</span>(t);</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(<span class="number">10</span>ms);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Makefile如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GCC ?= g++</span><br><span class="line">CCMODE = PROGRAM</span><br><span class="line">INCLUDES =  -I/opt/libevent/<span class="keyword">include</span>/</span><br><span class="line">CFLAGS =  -Wall <span class="variable">$(MACRO)</span> </span><br><span class="line">TARGET = ftpSrv</span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span>   </span><br><span class="line">LIBS = -L /opt/libevent/lib/  -levent -lpthread</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CCMODE)</span>,PROGRAM)</span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(LINKS)</span> <span class="variable">$(SRCS)</span> </span><br><span class="line">    <span class="variable">$(GCC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDES)</span> -o <span class="variable">$(TARGET)</span>  <span class="variable">$(SRCS)</span> <span class="variable">$(LIBS)</span></span><br><span class="line">    @chmod +x <span class="variable">$(TARGET)</span></span><br><span class="line">    @echo make <span class="variable">$(TARGET)</span> ok.</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:install</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io/2025/06/01/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8ELibevent%E5%88%9D%E6%8E%A2/">https://monoceros406.github.io/2025/06/01/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8ELibevent%E5%88%9D%E6%8E%A2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://monoceros406.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/06/02/%E5%9F%BA%E7%A1%80%E5%8A%B3%E5%8A%A8%E6%B3%95%E5%85%A5%E9%97%A8/" title="基础劳动法入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基础劳动法入门</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/31/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="C++后端开发入门-HTTP服务器编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++后端开发入门-HTTP服务器编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/15/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Linux-C学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-15</div><div class="title">Linux-C学习笔记</div></div></a></div><div><a href="/2023/10/15/MySQL%E7%AC%94%E8%AE%B0/" title="MySQL笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">MySQL笔记</div></div></a></div><div><a href="/2023/12/02/PHP%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" title="PHP入门笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-02</div><div class="title">PHP入门笔记</div></div></a></div><div><a href="/2025/05/05/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="C++后端开发入门-环境配置与多线程编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-05</div><div class="title">C++后端开发入门-环境配置与多线程编程</div></div></a></div><div><a href="/2025/05/19/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="C++后端开发入门-TCP服务器编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-19</div><div class="title">C++后端开发入门-TCP服务器编程</div></div></a></div><div><a href="/2025/05/25/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-UDP%E4%B8%8E%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/" title="C++后端开发入门-UDP与原始套接字编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-25</div><div class="title">C++后端开发入门-UDP与原始套接字编程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">Windows系统安全爱好者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">330</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://monoceros406.github.io/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哪里排版出锅了请告诉我QwQ  QQ:1295625063</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8ELibevent%E5%88%9D%E6%8E%A2"><span class="toc-number">1.</span> <span class="toc-text">C++后端开发入门-FTP服务器与Libevent初探</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Libevent%E5%85%A5%E9%97%A8"><span class="toc-number">1.2.</span> <span class="toc-text">Libevent入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FTP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8"><span class="toc-number">1.3.</span> <span class="toc-text">FTP协议入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">FTP服务器原理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/15/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E6%97%B6%E9%97%B4/" title="Linux编程入门-时间">Linux编程入门-时间</a><time datetime="2025-06-15T12:50:21.000Z" title="发表于 2025-06-15 20:50:21">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/15/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8/" title="Linux编程入门-用户管理与安全">Linux编程入门-用户管理与安全</a><time datetime="2025-06-15T02:58:13.000Z" title="发表于 2025-06-15 10:58:13">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/15/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="Linux编程入门-内存管理">Linux编程入门-内存管理</a><time datetime="2025-06-15T01:00:35.000Z" title="发表于 2025-06-15 09:00:35">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/14/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E8%BF%9B%E7%A8%8B/" title="Linux编程入门-进程">Linux编程入门-进程</a><time datetime="2025-06-14T14:02:30.000Z" title="发表于 2025-06-14 22:02:30">2025-06-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/08/Linux%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6I-O/" title="Linux编程入门-文件I/O">Linux编程入门-文件I/O</a><time datetime="2025-06-08T00:27:36.000Z" title="发表于 2025-06-08 08:27:36">2025-06-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>