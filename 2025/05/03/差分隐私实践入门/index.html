<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>差分隐私实践入门 | The Blog of Monoceros406</title><meta name="author" content="Monoceros406"><meta name="copyright" content="Monoceros406"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="差分隐私实践入门去标识去标识与关联攻击去标识（或匿名、假名）是指从数据集中删除标识信息的过程。例如有CSV数据集如下，第一行为表头： 1234Name,DOB,SSN,Zip,Workclass,Education,Education-Num,Marital Status,Occupation,Relationship,Race,Sex,Hours per week,Country,Target,">
<meta property="og:type" content="article">
<meta property="og:title" content="差分隐私实践入门">
<meta property="og:url" content="https://monoceros406.github.io/2025/05/03/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="The Blog of Monoceros406">
<meta property="og:description" content="差分隐私实践入门去标识去标识与关联攻击去标识（或匿名、假名）是指从数据集中删除标识信息的过程。例如有CSV数据集如下，第一行为表头： 1234Name,DOB,SSN,Zip,Workclass,Education,Education-Num,Marital Status,Occupation,Relationship,Race,Sex,Hours per week,Country,Target,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://monoceros406.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-05-03T08:15:35.000Z">
<meta property="article:modified_time" content="2025-05-11T01:57:43.416Z">
<meta property="article:author" content="Monoceros406">
<meta property="article:tag" content="密码学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://monoceros406.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://monoceros406.github.io/2025/05/03/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '差分隐私实践入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-11 09:57:43'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="The Blog of Monoceros406" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">320</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/ycy')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of Monoceros406"><span class="site-name">The Blog of Monoceros406</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">差分隐私实践入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-03T08:15:35.000Z" title="发表于 2025-05-03 16:15:35">2025-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-11T01:57:43.416Z" title="更新于 2025-05-11 09:57:43">2025-05-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="差分隐私实践入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="差分隐私实践入门"><a href="#差分隐私实践入门" class="headerlink" title="差分隐私实践入门"></a>差分隐私实践入门</h1><h2 id="去标识"><a href="#去标识" class="headerlink" title="去标识"></a>去标识</h2><h3 id="去标识与关联攻击"><a href="#去标识与关联攻击" class="headerlink" title="去标识与关联攻击"></a>去标识与关联攻击</h3><p>去标识（或匿名、假名）是指从数据集中删除标识信息的过程。例如有CSV数据集如下，第一行为表头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name,DOB,SSN,Zip,Workclass,Education,Education-Num,Marital Status,Occupation,Relationship,Race,Sex,Hours per week,Country,Target,Age,Capital Gain,Capital Loss</span><br><span class="line">Karrie Trusslove,9/7/1967,732-14-6110,64152,State-gov,Bachelors,13,Never-married,Adm-clerical,Not-in-family,White,Male,40,United-States,&lt;=50K,56,2174,0</span><br><span class="line">Brandise Tripony,6/7/1988,150-19-2766,61523,Self-emp-not-inc,Bachelors,13,Married-civ-spouse,Exec-managerial,Husband,White,Male,13,United-States,&lt;=50K,35,0,0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接下来导入并去标识：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(adult.head())</span><br><span class="line"></span><br><span class="line">adult_data=adult.copy().drop(columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;SSN&#x27;</span>])</span><br><span class="line">adult_pii=adult[[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;SSN&#x27;</span>,<span class="string">&#x27;DOB&#x27;</span>,<span class="string">&#x27;Zip&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(adult_data.head(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">               Name        DOB          SSN    Zip         Workclass  Education  ...  Hours per week        Country Target Age Capital Gain Capital Loss</span><br><span class="line">0  Karrie Trusslove   9/7/1967  732-14-6110  64152         State-gov  Bachelors  ...              40  United-States  &lt;=50K  56         2174            0        </span><br><span class="line">1  Brandise Tripony   6/7/1988  150-19-2766  61523  Self-emp-not-inc  Bachelors  ...              13  United-States  &lt;=50K  35            0            0        </span><br><span class="line">2     Brenn McNeely   8/6/1991  725-59-9860  95668           Private    HS-grad  ...              40  United-States  &lt;=50K  32            0            0        </span><br><span class="line">3       Dorry Poter   4/6/2009  659-57-4974  25503           Private       11th  ...              40  United-States  &lt;=50K  14            0            0        </span><br><span class="line">4       Dick Honnan  9/16/1951  220-93-3811  75387           Private  Bachelors  ...              40           Cuba  &lt;=50K  72            0            0        </span><br><span class="line"></span><br><span class="line">[5 rows x 18 columns]</span><br><span class="line">        DOB    Zip  Workclass  Education  Education-Num Marital Status  ... Hours per week        Country Target Age  Capital Gain Capital Loss</span><br><span class="line">0  9/7/1967  64152  State-gov  Bachelors             13  Never-married  ...             40  United-States  &lt;=50K  56          2174            0</span><br><span class="line"></span><br><span class="line">[1 rows x 16 columns]</span><br></pre></td></tr></table></figure>

<p>当尝试攻击的数据集与知道的一些辅助信息之间存在一些重叠列，可用这些列来实施一次简单的关联攻击：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">karries_row=adult_pii[adult_pii[<span class="string">&#x27;Name&#x27;</span>]==<span class="string">&#x27;Karrie Trusslove&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(pandas.merge(karries_row,adult_data,left_on=[<span class="string">&#x27;DOB&#x27;</span>,<span class="string">&#x27;Zip&#x27;</span>],right_on=[<span class="string">&#x27;DOB&#x27;</span>,<span class="string">&#x27;Zip&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>另一种防止隐私泄露的方法是只发布聚合数据，如只发布数据集平均年龄：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(adult[<span class="string">&#x27;Age&#x27;</span>].mean())</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41.77250253355035</span><br></pre></td></tr></table></figure>

<p>一般要将数据分组，给出给个分组的聚合统计信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(adult[[<span class="string">&#x27;Education&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>]].groupby(<span class="string">&#x27;Education&#x27;</span>,as_index=<span class="literal">False</span>).mean().head(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  Education        Age</span><br><span class="line">0      10th  42.032154</span><br><span class="line">1      11th  42.057021</span><br><span class="line">2      12th  41.879908</span><br></pre></td></tr></table></figure>

<p>如果某分组个体较少，聚合统计结果将难以达到隐私保护目的。此时采用差分攻击，对数据集中某个大分组执行两次求和问询。第一次对整个数据集进行问询，第二次除一条记录外所有记录进行问询。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(adult[<span class="string">&#x27;Age&#x27;</span>].<span class="built_in">sum</span>()-adult[adult[<span class="string">&#x27;Name&#x27;</span>]!=<span class="string">&#x27;Karrie Trusslove&#x27;</span>][<span class="string">&#x27;Age&#x27;</span>].<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">56</span><br></pre></td></tr></table></figure>

<h2 id="k-匿名性"><a href="#k-匿名性" class="headerlink" title="$k$-匿名性"></a>$k$-匿名性</h2><p>对于特定的$k$，若对于任意记录$r_1\in D$，存在至少$k-1$条其他的记录$r_2,\cdots,r_k\in D$，使得$\displaystyle\prod_{\operatorname{qi}(D)}r_1&#x3D;\prod_{\operatorname{qi}(D)}r_2,\cdots,\prod_{\operatorname{qi}(D)}r_k$，其中$\operatorname{qi}(D)$是$D$的准标识，$\displaystyle\prod_{\operatorname{qi}(D)}r$标识包含准标识的列$r$，则称数据集$D$满足$k$-匿名性。</p>
<p>换句话说，一部分辅助数据不应该“过多地”缩小个题所属记录的可能范围，目的是保证每个个题都能“融入人群”。</p>
<p>把数据集按照数据集各列中的特定子集分组，即按照准标识分组，是每个分组中的个体都拥有相同的准标识。若数据集中每个个体所属分组大小都至少为$k$，则称此数据集满足$k$-匿名性。虽攻击者仍可将攻击范围缩小至特定分组中，但无法进一步确定分组中哪个个体才是攻击目标。</p>
<p>此时求$k$：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot</span><br><span class="line">matplotlib.pyplot.style.use(<span class="string">&#x27;seaborn-whitegrid&#x27;</span>)</span><br><span class="line">raw_data=&#123;</span><br><span class="line">    <span class="string">&#x27;first_name&#x27;</span>:[<span class="string">&#x27;Jason&#x27;</span>,<span class="string">&#x27;Molly&#x27;</span>,<span class="string">&#x27;Tina&#x27;</span>,<span class="string">&#x27;Jake&#x27;</span>,<span class="string">&#x27;Amy&#x27;</span>], </span><br><span class="line">    <span class="string">&#x27;last_name&#x27;</span>:[<span class="string">&#x27;Miller&#x27;</span>,<span class="string">&#x27;Jacobson&#x27;</span>,<span class="string">&#x27;Ali&#x27;</span>,<span class="string">&#x27;Milner&#x27;</span>,<span class="string">&#x27;Cooze&#x27;</span>], </span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:[<span class="number">42</span>,<span class="number">52</span>,<span class="number">36</span>,<span class="number">24</span>,<span class="number">73</span>], </span><br><span class="line">    <span class="string">&#x27;preTestScore&#x27;</span>:[<span class="number">4</span>,<span class="number">24</span>,<span class="number">31</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="string">&#x27;postTestScore&#x27;</span>:[<span class="number">25</span>,<span class="number">94</span>,<span class="number">57</span>,<span class="number">62</span>,<span class="number">70</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#df = pd.DataFrame(raw_data, columns = [&#x27;first_name&#x27;, &#x27;last_name&#x27;, &#x27;age&#x27;, &#x27;preTestScore&#x27;, &#x27;postTestScore&#x27;])</span></span><br><span class="line">df=pandas.DataFrame(raw_data,columns=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;preTestScore&#x27;</span>,<span class="string">&#x27;postTestScore&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isKAnonymized</span>(<span class="params">df,k</span>):</span><br><span class="line">    <span class="keyword">for</span> index,row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">        query=<span class="string">&#x27; &amp; &#x27;</span>.join([<span class="string">f&#x27;<span class="subst">&#123;col&#125;</span>==<span class="subst">&#123;row[col]&#125;</span>&#x27;</span> <span class="keyword">for</span> col <span class="keyword">in</span> df.columns])</span><br><span class="line">        rows=df.query(query)</span><br><span class="line">        <span class="keyword">if</span> rows.shape[<span class="number">0</span>]&lt;k:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(isKAnonymized(df,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(isKAnonymized(df,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>结果如下，说明满足$1$-匿名性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   age  preTestScore  postTestScore</span><br><span class="line">0   42             4             25</span><br><span class="line">1   52            24             94</span><br><span class="line">2   36            31             57</span><br><span class="line">3   24             2             62</span><br><span class="line">4   73             3             70</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>可通过泛化数据的方式对数据集进行修改，使其满足特定取值$k$下的$k$-匿名性。泛化指的是将数据修改为不那么特殊的数据，使其更可能与数据集中其他个体的数据相匹配。例如精确到个位的年龄可通过四舍五入泛化为精确到十位；将邮政编码最右侧数字替换为$0$来泛化邮政编码等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generalize</span>(<span class="params">df,depths</span>): <span class="comment">#depths称为查找表 存储每一列要用0替换多少位数字</span></span><br><span class="line">    <span class="keyword">return</span> df.apply(<span class="keyword">lambda</span> x:x.apply(<span class="keyword">lambda</span> y:<span class="built_in">int</span>(<span class="built_in">int</span>(y/(<span class="number">10</span>**depths[x.name]))*(<span class="number">10</span>**depths[x.name]))))</span><br><span class="line">depths=&#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;preTestScore&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;postTestScore&#x27;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">df2=generalize(df,depths) <span class="comment">#一层泛化 四舍五入到十位</span></span><br><span class="line"><span class="built_in">print</span>(df2)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   age  preTestScore  postTestScore</span><br><span class="line">0   40             0             20</span><br><span class="line">1   50            20             90</span><br><span class="line">2   30            30             50</span><br><span class="line">3   20             0             60</span><br><span class="line">4   70             0             70</span><br></pre></td></tr></table></figure>

<p>尽管还是无法满足$2$-匿名性，但二层泛化会删除所有数据。在拥有更多个体的数据集中，通常需要更少的泛化处理即可使数据集满足所需$k$取值下的$k$-匿名性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">adult_data=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(adult_data.head())</span><br><span class="line">df=adult_data[[<span class="string">&#x27;Age&#x27;</span>,<span class="string">&#x27;Education-Num&#x27;</span>]]</span><br><span class="line">df.columns=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;edu&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(isKAnonymized(df.head(<span class="number">100</span>),<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(isKAnonymized(df.head(<span class="number">100</span>),<span class="number">2</span>))</span><br><span class="line">depths=&#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;edu&#x27;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">df2=generalize(df.head(<span class="number">100</span>),depths)</span><br><span class="line"><span class="built_in">print</span>(isKAnonymized(df2,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">               Name        DOB          SSN    Zip         Workclass  Education  ...  Hours per week        Country Target Age Capital Gain Capital Loss</span><br><span class="line">0  Karrie Trusslove   9/7/1967  732-14-6110  64152         State-gov  Bachelors  ...              40  United-States  &lt;=50K  56         2174            0        </span><br><span class="line">1  Brandise Tripony   6/7/1988  150-19-2766  61523  Self-emp-not-inc  Bachelors  ...              13  United-States  &lt;=50K  35            0            0        </span><br><span class="line">2     Brenn McNeely   8/6/1991  725-59-9860  95668           Private    HS-grad  ...              40  United-States  &lt;=50K  32            0            0        </span><br><span class="line">3       Dorry Poter   4/6/2009  659-57-4974  25503           Private       11th  ...              40  United-States  &lt;=50K  14            0            0        </span><br><span class="line">4       Dick Honnan  9/16/1951  220-93-3811  75387           Private  Bachelors  ...              40           Cuba  &lt;=50K  72            0            0        </span><br><span class="line"></span><br><span class="line">[5 rows x 18 columns]</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>可见还是不满足$2$-匿名性，根本原因是数据集包含异常值，包含一些与其他个体差异非常大的个体，即使泛化处理后也很难使这些异常个体融入任何分组中。在这里，非常低和非常高的年龄在数据集中过于稀少，进一步泛化每一行数据又会过分泛化年龄在$[20,40]$范围内的数据，损害结果数据可用性。实际上，实现满足$k$-匿名性的最优泛化方法被证明是个NP-困难问题。</p>
<p>异常值问题的一个简单解决方案是将数据集中每个个体年龄限制在一个特定范围内，从而完全消除数据集中的异常值。但这种方法会损害数据可用性，因为要用假年龄值替代真实年龄值。在这里将所有年龄取值都限制在$60$岁及以下，且不再考虑受教育年数这一列数据，都替换成一个非常大的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">depths=&#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;edu&#x27;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">dfp=df.clip(upper=numpy.array([<span class="number">60</span>,<span class="number">100000000</span>]),axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">dfp=dfp.clip(lower=numpy.array([<span class="number">10</span>,<span class="number">3</span>]),axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">df2=generalize(dfp.head(<span class="number">500</span>),depths)</span><br><span class="line"><span class="built_in">print</span>(isKAnonymized(df2,<span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<p>结果可见满足$7$-匿名性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="差分隐私"><a href="#差分隐私" class="headerlink" title="差分隐私"></a>差分隐私</h2><p>满足差分隐私的函数称为机制，若对所有邻近数据集$x$和$x’$，以及所有可能的输出$S$，机制$F$均满足$\dfrac{\operatorname{Pr}(F(x)&#x3D;S)}{\operatorname{Pr}(F(x’)&#x3D;S)}\leqslant e^{\epsilon}$，则称机制$F$满足差分隐私。</p>
<p>差分隐私不是数据具有的属性，而是算法具有的属性，我们可证明一个算法满足差分隐私。若想证明一个数据集满足差分隐私，需要证明产生此数据集的算法满足差分隐私。</p>
<p>若两个数据集中只有一个个体的数据项不同，则认为这两个数据集是临近数据集。$\operatorname{F}$是个随机函数，给定相同输入一般也包含多个可能的输出，概率分布一般不是点分布。$F$引入的随机性应该足够大，使得观察$F$的输出无法判断输入是$x$还是$x’$。假设某数据在$x$中但不在$x’$中，如果攻击者无法确定输入是$x$还是$x’$，则无法判断输入是否包含该数据，更不用说判断该数据是什么了。</p>
<p>参数$\epsilon$称为隐私参数（或隐私预算），$\epsilon$较小时意味着$F$需要为相似的输入提供非常相似的输出，因此提更高等级的隐私性。实际中一般设为约等于$1$或更小的值，大于$10$的值一般意味着大概率无法提供足够的隐私性。</p>
<p>差分隐私一般用于回复特定问询，如数据集中有多少个体年龄大于等于$40$岁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(adult[adult[<span class="string">&#x27;Age&#x27;</span>]&gt;=<span class="number">40</span>].shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17450</span><br></pre></td></tr></table></figure>

<p>使这个问询满足差分隐私的最简单方法实在回复结果上增加随机噪声，既需要增加足够大的噪声，又不能加得太多，否则问询结果就无意义了。此时一些基础机制具体描述了应增加何种类型的噪声，以及噪声量应该有多大。</p>
<p>根据拉普拉斯机制，对于可以输出一个数值型结果的函数$f(x)$，定义$F(x)&#x3D;f(x)+\operatorname{Lap}\left(\dfrac{s}{\epsilon}\right)$，其中$s$是$f$的敏感度，$\operatorname{Lap}(S)$表示以均值为$0$、放缩系数为$S$的拉普拉斯分布采样。</p>
<p>函数$f$的敏感度是指当输入由数据集$x$变化为邻近数据集$x’$后，$f$的输出变化量。计数问询的敏感度总为$1$，因为当问询数据集中满足特定属性的数据量时，如果只修改数据集中的一个数据项，则问询的输出变化量最多为$1$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sensitivity=<span class="number">1</span></span><br><span class="line">epsilon=<span class="number">0.1</span></span><br><span class="line"><span class="built_in">print</span>(adult[adult[<span class="string">&#x27;Age&#x27;</span>]&gt;=<span class="number">40</span>].shape[<span class="number">0</span>]+numpy.random.laplace(loc=<span class="number">0</span>,scale=sensitivity/epsilon))</span><br></pre></td></tr></table></figure>

<p>结果不唯一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17432.36769513577</span><br></pre></td></tr></table></figure>

<p>此时构造一个恶意的计数问询，确定某个人的收入是否大于$50000$$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">karries_row=adult[adult[<span class="string">&#x27;Name&#x27;</span>]==<span class="string">&#x27;Karrie Trusslove&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(karries_row[karries_row[<span class="string">&#x27;Target&#x27;</span>]==<span class="string">&#x27;&lt;=50K&#x27;</span>].shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">sensitivity=<span class="number">1</span></span><br><span class="line">epsilon=<span class="number">0.1</span></span><br><span class="line">karries_row=adult[adult[<span class="string">&#x27;Name&#x27;</span>]==<span class="string">&#x27;Karrie Trusslove&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(karries_row[karries_row[<span class="string">&#x27;Target&#x27;</span>]==<span class="string">&#x27;&lt;=50K&#x27;</span>].shape[<span class="number">0</span>]+numpy.random.laplace(loc=<span class="number">0</span>,scale=sensitivity/epsilon))</span><br></pre></td></tr></table></figure>

<p>结果不唯一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">13.558463386047062</span><br></pre></td></tr></table></figure>

<h2 id="差分隐私的性质"><a href="#差分隐私的性质" class="headerlink" title="差分隐私的性质"></a>差分隐私的性质</h2><p>差分隐私的一个性质是串行组合性。如果$F_1(x)$满足$\epsilon_1$-差分隐私，$F_2(x)$满足$\epsilon_2$-差分隐私，则同时发布两个结果的机制$G(x)&#x3D;(F_1(x),F_2(x))$满足$(\epsilon_1+\epsilon_2)$-差分隐私。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">epsilon1=<span class="number">1</span></span><br><span class="line">epsilon2=<span class="number">1</span></span><br><span class="line">epsilon_total=<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F1</span>():</span><br><span class="line">    <span class="keyword">return</span> numpy.random.laplace(loc=<span class="number">0</span>,scale=<span class="number">1</span>/epsilon1)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F2</span>():</span><br><span class="line">    <span class="keyword">return</span> numpy.random.laplace(loc=<span class="number">0</span>,scale=<span class="number">1</span>/epsilon2)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F3</span>():</span><br><span class="line">    <span class="keyword">return</span> numpy.random.laplace(loc=<span class="number">0</span>,scale=<span class="number">1</span>/epsilon_total)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F_combined</span>(): <span class="comment">#满足2-差分隐私</span></span><br><span class="line">    <span class="keyword">return</span> (F1()+F2())/<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>串行组合性给出了多次发布后总$\epsilon$的上界，实际发布的积累隐私消耗量可能会更低一些，所以<code>F_combined</code>噪声值分布图可能比<code>F3</code>更平一些。</p>
<p>差分隐私的另一个性质为并行组合性。如果$F(x)$满足$\epsilon$-差分隐私，将数据集$X$切分为$k$个互不相交的子数据块$\displaystyle\bigcup_{i&#x3D;1}^kx_i&#x3D;X$，则发布所有结果$F(x_1),F(x_2),\cdots,F(x_k)$的机制满足$\epsilon$-差分隐私。</p>
<p>直方图应用并行组合性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(adult[<span class="string">&#x27;Education&#x27;</span>].value_counts().to_frame().head(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">epsilon = <span class="number">1</span></span><br><span class="line">f=<span class="keyword">lambda</span> x:x+numpy.random.laplace(loc=<span class="number">0</span>,scale=<span class="number">1</span>/epsilon)</span><br><span class="line">s=adult[<span class="string">&#x27;Education&#x27;</span>].value_counts().apply(f)</span><br><span class="line"><span class="built_in">print</span>(s.to_frame().head(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">              count</span><br><span class="line">Education</span><br><span class="line">HS-grad       10501</span><br><span class="line">Some-college   7291</span><br><span class="line">Bachelors      5355</span><br><span class="line">Masters        1723</span><br><span class="line">Assoc-voc      1383</span><br><span class="line">                     count</span><br><span class="line">Education</span><br><span class="line">HS-grad       10501.113144</span><br><span class="line">Some-college   7290.343125</span><br><span class="line">Bachelors      5355.624063</span><br><span class="line">Masters        1725.033860</span><br><span class="line">Assoc-voc      1382.385230</span><br></pre></td></tr></table></figure>

<p>列联表（或交叉列表、交叉表）应用并行组合性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(pandas.crosstab(adult[<span class="string">&#x27;Education&#x27;</span>],adult[<span class="string">&#x27;Sex&#x27;</span>]).head(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">epsilon=<span class="number">1</span></span><br><span class="line">ct=pandas.crosstab(adult[<span class="string">&#x27;Education&#x27;</span>],adult[<span class="string">&#x27;Sex&#x27;</span>])</span><br><span class="line">f=<span class="keyword">lambda</span> x:x+numpy.random.laplace(loc=<span class="number">0</span>,scale=<span class="number">1</span>/epsilon)</span><br><span class="line"><span class="built_in">print</span>(ct.applymap(f).head(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sex        Female  Male</span><br><span class="line">Education</span><br><span class="line">10th          295   638</span><br><span class="line">11th          432   743</span><br><span class="line">12th          144   289</span><br><span class="line">1st-4th        46   122</span><br><span class="line">5th-6th        84   249</span><br><span class="line">Sex            Female        Male</span><br><span class="line">Education</span><br><span class="line">10th       295.088175  639.521246</span><br><span class="line">11th       434.281535  742.165123</span><br><span class="line">12th       144.187342  288.693666</span><br><span class="line">1st-4th     46.075385  121.528562</span><br><span class="line">5th-6th     84.914934  247.715513</span><br></pre></td></tr></table></figure>

<p>但若为列联表每增加一个属性后，将数据集分割称更多数据块，每个数据块包含的数据行数会变少，每个计数结果都会变小。真实计数值的缩小对差分隐私计数结果的准确性造成巨大影响。较大的计数结果表示一个强信号，不太可能被一个相对较弱的噪声所淹没；反之较小的计数结果表示一个弱信号，强度甚至可能接近噪声值，就无法从结果中获得任何有用信息了。</p>
<p>另一个差分隐私的性质为后处理性，即不可能通过某种方式对差分隐私保护下的数据进行后处理，来降低差分隐私的隐私保护程度。若$F(x)$满足$\epsilon$-差分隐私，则对于任意确定或随机函数$g$，$g(F(x))$也满足$\epsilon$-差分隐私。还可以对计算结果进行后处理，以降低噪声量、改善输出成果。</p>
<p>后处理性的另一个含义是，差分隐私可抵抗基于辅助数据的隐私攻击方式。如$g$可能包含关于数据集元素的辅助数据，$g$期望利用该信息实施关联攻击，但后处理性意味着攻击效果会被隐私参数$\epsilon$约束。</p>
<h2 id="敏感度"><a href="#敏感度" class="headerlink" title="敏感度"></a>敏感度</h2><p>在拉普拉斯机制中，使问询满足差分隐私所需噪声量取决于问询的敏感度。给定一个将数据集$\mathcal D$映射为实数的函数$f:\mathcal D\rightarrow\mathbb R$，$f$的全局敏感度为$\displaystyle\operatorname{GS}(f)&#x3D;\max_{x,x’:d(x,x’)\leqslant1}\left|f(x)-f(x’)\right|$。即对于任意两个邻近数据集$x$和$x’$，$f(x)$和$f(x’)$最多相差$\operatorname{GS}(f)$。其中$d(x,x’)$表示两个数据集$x$和$x’$之间的距离。若两个数据集之间距离小于等于$1$，则称这两个数据集是邻近集。</p>
<p>对于距离$d(x,x’)$，这里使用两个数据集的对称差$d(x,x’)&#x3D;|x-x’\cup x’-x|$。即如果$x’$是通过在$x$中添加或删除一行来构造的，则$d(x,x’)&#x3D;1$；如果$x’$是通过在$x$中修改一行来构造的，则$d(x,x’)&#x3D;2$。</p>
<p>当$x$变化$1$，$f(x)$变化的值即为全局敏感度。当$f(x)$的变化取决于$x$，则称全局敏感度是无界的。</p>
<p>计数问询计算数据集中满足特定属性的行数，敏感度总等于$1$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(adult.shape[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(adult[adult[<span class="string">&#x27;Education-Num&#x27;</span>]&gt;<span class="number">10</span>].shape[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(adult[adult[<span class="string">&#x27;Education-Num&#x27;</span>]&lt;=<span class="number">10</span>].shape[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(adult[adult[<span class="string">&#x27;Name&#x27;</span>]==<span class="string">&#x27;Joe Near&#x27;</span>].shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">32563</span><br><span class="line">10517</span><br><span class="line">22046</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>求和问询计算数据集行中的属性值总和。想数据集添加一个新数据会使问询增加一个新个体的年龄，因此敏感度取决于添加的具体数据是什么。此时敏感度很难找到一个确切的数，例如敏感度设为$125$，有可能年龄会有$126$岁的人。对于收入等其他属性来说，更难找到一个合理的上界。当待求和的属性值不存在上下界时，称求和问询具有无界敏感度。存在上下界时求和问询敏感度等于上下界的差。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(adult[adult[<span class="string">&#x27;Education-Num&#x27;</span>]&gt;<span class="number">10</span>][<span class="string">&#x27;Age&#x27;</span>].<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">441431</span><br></pre></td></tr></table></figure>

<p>均值问询计算指定列属性值的平均值，可拆分成求和问询除以计数问询，两者敏感度都可计算。可以分别计算使用拉普拉斯机制的两个问询的噪声回复并做触发，即可得到差分隐私均值，并应用串行组合性计算两个问询的总隐私消耗量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(adult[adult[<span class="string">&#x27;Education-Num&#x27;</span>]&gt;<span class="number">10</span>][<span class="string">&#x27;Age&#x27;</span>].mean())</span><br><span class="line"><span class="built_in">print</span>(adult[adult[<span class="string">&#x27;Education-Num&#x27;</span>]&gt;<span class="number">10</span>][<span class="string">&#x27;Age&#x27;</span>].<span class="built_in">sum</span>()/adult[adult[<span class="string">&#x27;Education-Num&#x27;</span>]&gt;<span class="number">10</span>][<span class="string">&#x27;Age&#x27;</span>].shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">41.973091185699346</span><br><span class="line">41.973091185699346</span><br></pre></td></tr></table></figure>

<p>差分隐私的拉普拉斯机制无法直接应用于无界敏感度问询，通常用裁剪技术将此类问询转换为等价的有界敏感度问询，即强制设置属性值的上下界。例如$125$岁以上的年龄被裁剪到恰好为$125$岁。对裁剪数据执行求和问询的敏感度等于上下界的差。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(adult[<span class="string">&#x27;Age&#x27;</span>].clip(lower=<span class="number">0</span>,upper=<span class="number">125</span>).<span class="built_in">sum</span>()) <span class="comment">#敏感度125</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1360238</span><br></pre></td></tr></table></figure>

<p>裁剪边界的上下界越接近，敏感度越低，差分隐私所需噪声就越小。过分裁剪会从数据中移除很多信息，给准确度带来损失，影响超过降低敏感度改善噪声所带来的准确度提升效果。</p>
<p>一般来说，要将裁剪边界设置为尽可能100%保留数据集所有信息，然而某些领域很难做到这一点。通过直方图寻找数据集的上界不满足差分隐私，因为边界可能会泄露数据的一些相关信息。一般根据数据集先天满足的一些属性来确定裁剪边界，即无需查看数据本身即可获得此属性。</p>
<p>也可先将敏感度下界设为$0$，逐渐增加上界，直至问询输出不再变化。问询结果应当开始逐渐增大，之后趋于平缓，最后噪声淹没信号，波动非常剧烈。</p>
<h2 id="近似差分隐私"><a href="#近似差分隐私" class="headerlink" title="近似差分隐私"></a>近似差分隐私</h2><p>近似差分隐私（或$(\epsilon,\delta)$-差分隐私）定义为$\operatorname{Pr}(F(x)&#x3D;S)\leqslant e^{\epsilon}\operatorname{Pr}(F(x’)&#x3D;S)+\delta$。隐私参数$\delta$表示不满足此近似差分隐私定义的失败概率。此时有$1-\delta$的概率获得等价于纯粹差分隐私的隐私保护程度，有$\delta$概率不满足隐私参数为$\epsilon$的纯粹差分隐私。要求$\delta$很小，通常$\delta\leqslant\dfrac{1}{(\#\mathcal D)^2}$。</p>
<p>近似差分隐私同样满足串并行组合性和后处理性。但对于串行组合性，若$F_1(x)$和$F_2(x)$分别满足$(\epsilon_1,\delta_1)$-差分隐私和$(\epsilon_2,\delta_2)$-差分隐私，则发布两个结果的机制$G(x)&#x3D;(F_1(x),F_2(x))$满足$(\epsilon_1+\epsilon_2,\delta_1+\delta_2)$-差分隐私。</p>
<p>高斯机制无法满足纯粹$\epsilon$-差分隐私，但可以满足$(\epsilon,\delta)$-差分隐私。对于返回数值的函数$f(x)$，应用$F(x)&#x3D;f(x)+\mathcal N\left(0,\sigma^2\right)$，得到满足$(\epsilon,\delta)$-差分隐私的$F(x)$。这里$s$是$f$的敏感度，$\mathcal N\left(0,\sigma^2\right)$表示均值为$0$，方差为$\sigma^2$的高斯分布采样结果，其中$\sigma^2&#x3D;\dfrac{2s^2\ln\left(\dfrac{1.25}{\delta}\right)}{\epsilon^2}$。</p>
<p>给定长度为$k$的向量$\overrightarrow V$，其L1范数定义为$\displaystyle\left|\left|\overrightarrow V\right|\right|_1&#x3D;\sum_{i&#x3D;1}^k\overrightarrow{V_i}$，二维空间中$\left|\left|\overrightarrow{V_1}-\overrightarrow{V_2}\right|\right|_1$就是他们的曼哈顿距离。L2范数定义为$\left|\left|\overrightarrow V\right|\right|_2&#x3D;\sqrt{\displaystyle\sum_{i&#x3D;1}^k\overrightarrow{V_i^2}}$，二维空间中$\left|\left|\overrightarrow{V_1}-\overrightarrow{V_2}\right|\right|_2$就是他们的欧几里得距离。有$\left|\left|\overrightarrow{V_1}-\overrightarrow{V_2}\right|\right|_1\geqslant\left|\left|\overrightarrow{V_1}-\overrightarrow{V_2}\right|\right|_2$。</p>
<p>拉普拉斯机制和高斯机制都可以扩展到形式为$f:\mathcal D\rightarrow{\mathbb R}^k$的向量值函数。向量值拉普拉斯机制需要使用L1敏感度，而向量值高斯机制可以使用L1或L2敏感度。</p>
<p>向量值函数$f$的L1敏感度为$\displaystyle\operatorname{GS}_1&#x3D;\max_{d(x,x’)\leqslant1}\left|\left|f(x)-f\left(x’\right)\right|\right|_1$，若$f$返回一个长度为$k$的向量，且向量中各个元素的敏感度均为$1$，则$f$的L1敏感度为$k$。向量值函数$f$的L2敏感度为$\displaystyle\operatorname{GS}_2&#x3D;\max_{d(x,x’)\leqslant1}\left|\left|f(x)-f\left(x’\right)\right|\right|_2$，若$f$返回一个长度为$k$的向量，且向量中各个元素的敏感度均为$1$，则$f$的L2敏感度为$\sqrt k$。</p>
<p>向量拉普拉斯机制和向量高斯机制发布的都是$f(x)+\left(Y_1,Y_2,\cdots,Y_k\right)$，$Y_i$是独立同分布噪声。</p>
<p>高级组合定理通常用$k$-折叠适应性组合机制来描述，后者指的是将一系列机制$m_1,m_2,\cdots,m_k$组合起来，这些机制满足：</p>
<ul>
<li>适应性：可根据所有前述机制$m_1,m_2,\cdots,m_{i-1}$的输出来选择下一个机制$m_i$。</li>
<li>组合性：每个机制$m_i$的输入既包括隐私数据集，也包括前述机制的所有输出。</li>
</ul>
<p>如果$k$-折叠适应性组合$m_1,m_2,\cdots,m_k$中的每个机制$m_i$都满足$(\epsilon,\delta)$-差分隐私，则$\forall\delta’\geqslant0$，整个$k$-折叠适应性组合满足$\left(\epsilon’,k\delta+\delta’\right)$-差分隐私，其中$\epsilon’&#x3D;2\epsilon\sqrt{2k\ln\left(\dfrac{1}{\delta’}\right)}$。当待组合的机制满足纯粹$\epsilon$-差分隐私时，有$\delta&#x3D;0$。</p>
<p>对于相同机制，应用高级组合性得到的$\epsilon’$下届远低于应用串行组合性得到的下界，意味着串行组合性得到的隐私消耗量下界是宽松的，高级组合性得到的下界稍显紧致一些。事实证明当$k&lt;70$时，标准的串行组合性比高级组合性得到的总隐私消耗量更小。当$k&gt;100$时，高级组合性可显露出巨大的优势。</p>
<h2 id="局部敏感度"><a href="#局部敏感度" class="headerlink" title="局部敏感度"></a>局部敏感度</h2><p>全局敏感度定义考察的是任意两个邻近数据集，但由于将在实际数据集上执行差分隐私机制，应该只需要考虑此数据集的邻近数据集。由此得到函数$f:\mathcal D\rightarrow\mathbb R$在$x:\mathcal D$的局部敏感度定义为$\displaystyle\operatorname{LS}(f,x)&#x3D;\max_{x’:d(x,x’)\leqslant1}\left|f(x)-f\left(x’\right)\right|$。</p>
<p>建议—测试—发布框架先询问数据分析者函数的建议局部敏感度上界，然后执行满足差分隐私的测试，检验所问询的数据集是否远离了局部敏感度高于建议边界的数据集。若测试通过，该框架发布噪声结果，并将噪声量校准到建议的边界。建议—测试—发布框架具体如下，满足$(\epsilon,\delta)$-差分隐私：</p>
<ul>
<li>建议一个局部敏感度的目标边界$b$。</li>
<li>若$D(f,x,b)+\operatorname{Lap}\left(\dfrac{1}{\epsilon}\right)&lt;\dfrac{\ln\left(\dfrac{2}{\delta}\right)}{2\epsilon}$，返回$\bot$。</li>
<li>否则返回$f(x)+\operatorname{Lap}\left(\dfrac{b}{\epsilon}\right)$。</li>
</ul>
<p>这里用$A(f,x,k)$表示通过从数据集$x$执行$k$步可得到$f$的最大局部敏感度，即$\displaystyle A(f,x,k)&#x3D;\max_{y:d(x,y)\leqslant k}\operatorname{LS}(f,y)$。然后定义$k$距离局部敏感度表示需要多少步才能实现比给定上界$b$更大的局部敏感度，即$D(f,x,b)&#x3D;\underset{k}{\operatorname{argmin}}(A(f,x,k)&gt;b)$，$D(f,x,b)$的全局敏感度为$1$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">laplace_mech</span>(<span class="params">v,sensitivity,epsilon</span>):</span><br><span class="line">    <span class="keyword">return</span> v+numpy.random.laplace(loc=<span class="number">0</span>,scale=sensitivity/epsilon)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ls_at_distance</span>(<span class="params">df,u,k</span>):</span><br><span class="line">    <span class="keyword">return</span> numpy.<span class="built_in">abs</span>(u/(<span class="built_in">len</span>(df)-k+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dist_to_high_ls</span>(<span class="params">df,u,b</span>):</span><br><span class="line">    k=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> ls_at_distance(df,u,k)&lt;b:</span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ptr_avg</span>(<span class="params">df,u,b,epsilon,delta,logging=<span class="literal">False</span></span>):</span><br><span class="line">    df_clipped=df.clip(upper=u)</span><br><span class="line">    k=dist_to_high_ls(df_clipped,u,b)</span><br><span class="line">    noisy_distance=laplace_mech(k,<span class="number">1</span>,epsilon)</span><br><span class="line">    threshold=numpy.log(<span class="number">2</span>/delta)/(<span class="number">2</span>*epsilon)</span><br><span class="line">    <span class="keyword">if</span> logging:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;噪声距离：<span class="subst">&#123;noisy_distance&#125;</span>，门限值：<span class="subst">&#123;threshold&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> noisy_distance&gt;=threshold:</span><br><span class="line">        <span class="keyword">return</span> laplace_mech(df_clipped.mean(),b,epsilon)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line">df=adult[<span class="string">&#x27;Age&#x27;</span>]</span><br><span class="line">u=<span class="number">100</span> <span class="comment">#年龄上界</span></span><br><span class="line">epsilon=<span class="number">1</span></span><br><span class="line">delta=<span class="number">1</span>/(<span class="built_in">len</span>(df)**<span class="number">2</span>)</span><br><span class="line">b=<span class="number">0.005</span> <span class="comment">#建议敏感度</span></span><br><span class="line"><span class="built_in">print</span>(ptr_avg(df,u,b,epsilon,delta,logging=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">噪声距离：12563.298110920712，门限值：10.737505543744179</span><br><span class="line">41.79231612235209</span><br></pre></td></tr></table></figure>

<p>采样—聚合框架：对任何函数$f:\mathcal D\rightarrow\mathbb R$，令裁剪上下界分别为$u$和$l$，则下述框架满足$\epsilon$-框架：</p>
<ul>
<li>将数据集$X\in\mathcal D$拆分成不相交的数据块$x_1,x_2,\cdots,x_k$。</li>
<li>计算每个数据块的裁剪回复值$a_i&#x3D;\max(l,\min(u,f(x_i)))$。</li>
<li>计算平均回复值并增加噪声$\displaystyle A&#x3D;\left(\dfrac{1}{k}\sum_{i&#x3D;1}^ka_i\right)+\operatorname{Lap}\left(\dfrac{u-l}{k\epsilon}\right)$。</li>
</ul>
<p>分块数量$k$越大，噪声均值敏感度越小，噪声量越小，但回复值$f(x_i)$偏离正确回复值$f(X)$越远。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">laplace_mech</span>(<span class="params">v,sensitivity,epsilon</span>):</span><br><span class="line">    <span class="keyword">return</span> v+numpy.random.laplace(loc=<span class="number">0</span>,scale=sensitivity/epsilon)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="keyword">return</span> df.mean()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">saa_avg_age</span>(<span class="params">k,epsilon,logging=<span class="literal">False</span></span>):</span><br><span class="line">    df=adult[<span class="string">&#x27;Age&#x27;</span>]</span><br><span class="line">    chunk_size=<span class="built_in">int</span>(numpy.ceil(df.shape[<span class="number">0</span>]/k)) <span class="comment">#计算每个数据块应包含的行数</span></span><br><span class="line">    <span class="keyword">if</span> logging:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Chunk size: <span class="subst">&#123;chunk_size&#125;</span>&#x27;</span>)</span><br><span class="line">    xs=[df[i:i+chunk_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,df.shape[<span class="number">0</span>],chunk_size)] <span class="comment">#将df拆分为数据块</span></span><br><span class="line">    answers=[f(x_i) <span class="keyword">for</span> x_i <span class="keyword">in</span> xs] <span class="comment">#在每个x_i上执行f 并裁剪输出值</span></span><br><span class="line">    u=<span class="number">80</span></span><br><span class="line">    l=<span class="number">20</span></span><br><span class="line">    clipped_answers=numpy.clip(answers,l,u)</span><br><span class="line">    noisy_mean=laplace_mech(numpy.mean(clipped_answers),(u-l)/k,epsilon) <span class="comment">#计算输出均值 并增加噪声</span></span><br><span class="line">    <span class="keyword">return</span> noisy_mean</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(saa_avg_age(<span class="number">600</span>,<span class="number">1</span>,logging=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chunk size: 55</span><br><span class="line">41.74177911583807</span><br></pre></td></tr></table></figure>

<h2 id="差分隐私变体"><a href="#差分隐私变体" class="headerlink" title="差分隐私变体"></a>差分隐私变体</h2><p>散度是度量两种概率分布差异的方法，最大散度是Kullback-Leibler散度的最坏情况，两个概率分布$Y$和$Z$的最大散度定义为$\displaystyle D_{\infty}(Y\mid\mid Z)&#x3D;\max_{S\subseteq\operatorname{Supp}(Y)}\ln\dfrac{\operatorname{Pr}(Y\in S)}{\operatorname{Pr}(Z\in S)}$。如果证明$D_{\infty}(F(x)\mid\mid F(x’))\leqslant\epsilon$则$F$满足$\epsilon$-差分隐私。</p>
<p>概率分布$P$和$Q$的$\alpha$阶Rényi散度定义为$D_{\infty}(P\mid\mid Q)&#x3D;\dfrac{1}{\alpha-1}\ln \left(E_{x\sim Q}\left(\dfrac{P(x)}{Q(x)}\right)^{\alpha}\right)$，其中$P(x)$和$Q(x)$为在点$x$处的概率密度。</p>
<p>Rényi差分隐私RDP：若对于所有邻近数据集$x$和$x’$，随机机制$F$满足$D_{\alpha}(F(x)\mid\mid F(x’))\leqslant\overline{\epsilon}$，则称此机制$F$满足$(\alpha,\epsilon)$-RDP，这里$\overline{\epsilon}$和之前的$\epsilon$没啥关系。若$F$满足$(\alpha,\overline{\epsilon})$-RDP，则对任意$\delta&gt;0$，$F$满足$(\epsilon,\delta)$-差分隐私，其中$\epsilon&#x3D;\overline{\epsilon}+\dfrac{\ln\left(\dfrac{1}{\delta}\right)}{\alpha-1}$。实现Rényi差分隐私的基本机制的高斯机制。</p>
<p>对于一个L2敏感度为$\Delta f$的函数$f:\mathcal D\rightarrow\mathbb{R}^k$，可构造$(\alpha,\overline{\epsilon})$-RDP机制：$F(x)&#x3D;f(x)+\mathcal N(\sigma^2),\sigma^2&#x3D;\dfrac{\Delta f^2\alpha}{2\overline{\epsilon}}$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian_mech_RDP_vec</span>(<span class="params">vec,sensitivity,alpha,epsilon_bar</span>):</span><br><span class="line">    sigma=numpy.sqrt((sensitivity**<span class="number">2</span>*alpha)/(<span class="number">2</span>*epsilon_bar))</span><br><span class="line">    <span class="keyword">return</span> [v+numpy.random.normal(loc=<span class="number">0</span>,scale=sigma) <span class="keyword">for</span> v <span class="keyword">in</span> vec]</span><br></pre></td></tr></table></figure>

<p>Rényi差分隐私的串行组合性描述为：如果$F_1$和$F_2$分别满足$(\alpha,\overline{\epsilon_1})$-RDP和$(\alpha,\overline{\epsilon_2})$-RDP，则组合机制满足$(\alpha,\overline{\epsilon_1}+\overline{\epsilon_2})$-RDP。当给定噪声等级$\sigma^2$时，用Rényi差分隐私的串行组合性来限制重复应用高斯机制的隐私消耗量，再将隐私定义转换为$(\epsilon,\delta)$-差分隐私，总隐私消耗量比直接在$(\epsilon,\delta)$中应用串行组合定理或高级组合定理得到的总隐私消耗量要低得多。</p>
<p>零集中差分隐私zCDP：如果对于所有邻近数据集$x$和$x’$，以及所有的$\alpha\in(1,\infty)$，随机机制$F$满足$D_{\alpha}(F(x)\mid\mid F(x’))\leqslant\rho\alpha$，则称$F$满足$\rho$-zCDP。若$F$满足$\rho$-zCDP，则对于任意给定的$\delta&gt;0$，$F$满足$(\epsilon,\delta)$-差分隐私，其中$\epsilon&#x3D;\rho+2\sqrt{\rho\ln\left(\dfrac{1}{\delta}\right)}$。零集中差分隐私也是根据Rényi散度定义的差分隐私变体。</p>
<p>对于一个L2敏感度为$\Delta f$的函数$f:\mathcal D\rightarrow\mathbb{R}^k$，可构造$\rho$-zCDP机制：$F(x)&#x3D;f(x)+\mathcal N(\sigma^2),\sigma^2&#x3D;\dfrac{\Delta f^2}{2\rho}$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian_mech_zCDP_vec</span>(<span class="params">vec,sensitivity,rho</span>):</span><br><span class="line">    sigma=numpy.sqrt((sensitivity**<span class="number">2</span>)/(<span class="number">2</span>*rho))</span><br><span class="line">    <span class="keyword">return</span> [v+numpy.random.normal(loc=<span class="number">0</span>,scale=sigma) <span class="keyword">for</span> v <span class="keyword">in</span> vec]</span><br></pre></td></tr></table></figure>

<p>零集中差分隐私的串行组合性描述为：若$F_1$和$F_2$分别满足$\rho_1$-zCDP和$\rho_2$-zCDP，则组合机制满足$(\rho_1+\rho_2)$-zCDP。</p>
<p>Rényi差分隐私和零集中差分隐私为同一算法提供了更加进制的隐私消耗量上界，因此使用高斯机制构造迭代算法时有限考虑使用这些差分隐私变体。</p>
<h2 id="指数机制"><a href="#指数机制" class="headerlink" title="指数机制"></a>指数机制</h2><p>对于非数值型回复，无法直接在结果上增加噪声，还要保证回复过程满足差分隐私。指数机制可以从备选回复集合中选出最佳回复的同时，保证回复过程满足差分隐私。分析者需要定义一个备选回复集合$\mathcal R$，并指定一个全局敏感度为$\Delta u$评分函数$u:\mathcal D\times\mathcal R\rightarrow\mathbb R$，输出备选回复集合中每个回复的分数，分数最高的就是最佳回复$r\in\mathcal R$，各个回复的输出概率与$\exp\left(\dfrac{\epsilon u(x,r)}{2\Delta u}\right)$成正比。指数机制通过返回分数近似最大的回复来实现差分隐私保护，即返回的结果所对应的分数可能不是备选回复集合中分数最高的那个结果。</p>
<p>无论$\mathcal R$中包含多少个备选输出，指数机制的总隐私消耗量仍然为$\epsilon$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">data,option</span>):</span><br><span class="line">    <span class="keyword">return</span> data.value_counts()[option]/<span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(score(adult[<span class="string">&#x27;Marital Status&#x27;</span>], <span class="string">&#x27;Never-married&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exponential</span>(<span class="params">x,R,u,sensitivity,epsilon</span>):</span><br><span class="line">    scores=[u(x,r) <span class="keyword">for</span> r <span class="keyword">in</span> R] <span class="comment">#计算R中每个回复的分数</span></span><br><span class="line">    probabilities=[numpy.exp(epsilon*score/(<span class="number">2</span>*sensitivity)) <span class="keyword">for</span> score <span class="keyword">in</span> scores] <span class="comment">#根据分数计算每个回复的输出概率</span></span><br><span class="line">    probabilities=probabilities/numpy.linalg.norm(probabilities,<span class="built_in">ord</span>=<span class="number">1</span>) <span class="comment">#对概率进行归一化处理 使概率和等于1</span></span><br><span class="line">    <span class="keyword">return</span> numpy.random.choice(R,<span class="number">1</span>,p=probabilities)[<span class="number">0</span>] <span class="comment">#根据概率分布选择回复结果</span></span><br><span class="line">options=adult[<span class="string">&#x27;Marital Status&#x27;</span>].unique()</span><br><span class="line"><span class="built_in">print</span>(exponential(adult[<span class="string">&#x27;Marital Status&#x27;</span>],options,score,<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">r=[exponential(adult[<span class="string">&#x27;Marital Status&#x27;</span>],options,score,<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]</span><br><span class="line"><span class="built_in">print</span>(pandas.Series(r).value_counts())</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10.684</span><br><span class="line">Married-civ-spouse</span><br><span class="line">Married-civ-spouse    181</span><br><span class="line">Never-married          18</span><br><span class="line">Divorced                1</span><br><span class="line">Name: count, dtype: int64</span><br></pre></td></tr></table></figure>

<p>基于拉普拉斯机制，报告噪声最大值算法如下：</p>
<ul>
<li>对于每个$r\in\mathcal R$，计算噪声分数$u(x,r)+\operatorname{Lap}\left(\dfrac{\Delta u}{\epsilon}\right)$。</li>
<li>输出噪声分数最大的元素$r\in\mathcal R$。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">data,option</span>):</span><br><span class="line">    <span class="keyword">return</span> data.value_counts()[option]/<span class="number">1000</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">laplace_mech</span>(<span class="params">v,sensitivity,epsilon</span>):</span><br><span class="line">    <span class="keyword">return</span> v+numpy.random.laplace(loc=<span class="number">0</span>,scale=sensitivity/epsilon)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">report_noisy_max</span>(<span class="params">x,R,u,sensitivity,epsilon</span>):</span><br><span class="line">    scores=[u(x,r) <span class="keyword">for</span> r <span class="keyword">in</span> R] <span class="comment">#计算R中每个回复的分数</span></span><br><span class="line">    noisy_scores=[laplace_mech(score,sensitivity,epsilon) <span class="keyword">for</span> score <span class="keyword">in</span> scores] <span class="comment">#为每个分数增加噪声</span></span><br><span class="line">    max_idx=numpy.argmax(noisy_scores) <span class="comment">#找到最大分数对应的回复索引号</span></span><br><span class="line">    <span class="keyword">return</span> R[max_idx] <span class="comment">#返回此索引号对应的回复</span></span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line">options=adult[<span class="string">&#x27;Marital Status&#x27;</span>].unique()</span><br><span class="line"><span class="built_in">print</span>(report_noisy_max(adult[<span class="string">&#x27;Marital Status&#x27;</span>],options,score,<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">r=[report_noisy_max(adult[<span class="string">&#x27;Marital Status&#x27;</span>],options,score,<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]</span><br><span class="line"><span class="built_in">print</span>(pandas.Series(r).value_counts())</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Married-civ-spouse</span><br><span class="line">Married-civ-spouse    197</span><br><span class="line">Never-married           3</span><br><span class="line">Name: count, dtype: int64</span><br></pre></td></tr></table></figure>

<h2 id="稀疏向量技术"><a href="#稀疏向量技术" class="headerlink" title="稀疏向量技术"></a>稀疏向量技术</h2><p>稀疏向量技术SVT可节省隐私消耗量，适用于在数据集上执行敏感度为$1$的问询流。稀疏向量技术只发布问询流中第一个通过测试的问询索引号，优势在于无论总共收到多少问询，消耗的总隐私消耗量时固定的。</p>
<p>稀疏向量技术最基础的实例是高于阈值算法。算法输入敏感度为$1$的问询流、数据集$\mathcal D$、阈值$T$和隐私参数$\epsilon$，算法满足$\epsilon$-差分隐私。下面场景基于选择求和问询的裁剪边界：获得多个不同裁剪边界并分别计算噪声裁剪边界，选择一个尽可能低且不会导致最终回复结果改变太大的一个裁剪边界。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">above_threshold</span>(<span class="params">queries,df,T,epsilon</span>):</span><br><span class="line">    T_hat=T+numpy.random.laplace(loc=<span class="number">0</span>,scale=<span class="number">2</span>/epsilon) <span class="comment">#噪声阈值  </span></span><br><span class="line">    <span class="keyword">for</span> idx,q <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries):</span><br><span class="line">        nu_i=numpy.random.laplace(loc=<span class="number">0</span>,scale=<span class="number">4</span>/epsilon)</span><br><span class="line">        <span class="keyword">if</span> q(df)+nu_i&gt;=T_hat:</span><br><span class="line">            <span class="keyword">return</span> idx <span class="comment">#第一个噪声问询回复大于噪声阈值的问询索引号</span></span><br><span class="line">    <span class="keyword">return</span> random.randint(<span class="number">0</span>,<span class="built_in">len</span>(queries)-<span class="number">1</span>) <span class="comment">#返回错误的索引号</span></span><br></pre></td></tr></table></figure>

<p>高于阈值算法之所以满足差分隐私，是因为有可能返回错误的索引号，索引号对应的问询回复结果可能未超过给定阈值，索引号对应的问询有可能不是第一个回复结果超过阈值的问询。</p>
<p>对于上述选择求和问询的裁剪边界的场景，使用稀疏向量技术能获得更好的效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">age_sum_query</span>(<span class="params">df,b</span>):</span><br><span class="line">    <span class="keyword">return</span> df[<span class="string">&#x27;Age&#x27;</span>].clip(lower=<span class="number">0</span>,upper=b).<span class="built_in">sum</span>()</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(age_sum_query(adult,<span class="number">30</span>))</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">879648</span><br></pre></td></tr></table></figure>

<p>接下来定义一个求和差问询流，并基于稀疏向量技术，应用高于阈值确定<code>b</code>的最佳取值的问询索引号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">auto_avg</span>(<span class="params">df,epsilon</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_query</span>(<span class="params">b</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> df:df.clip(lower=<span class="number">0</span>,upper=b).<span class="built_in">sum</span>()-df.clip(lower=<span class="number">0</span>,upper=b+<span class="number">1</span>).<span class="built_in">sum</span>()</span><br><span class="line">    bs=<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">150000</span>,<span class="number">5</span>) <span class="comment">#构造问询流</span></span><br><span class="line">    queries=[create_query(b) <span class="keyword">for</span> b <span class="keyword">in</span> bs]</span><br><span class="line">    epsilon_svt=epsilon/<span class="number">3</span> <span class="comment">#使用1/3的隐私预算执行高于阈值 得到一个好的裁剪参数</span></span><br><span class="line">    final_b=bs[above_threshold(queries,df,<span class="number">0</span>,epsilon_svt)]</span><br><span class="line">    epsilon_sum=epsilon/<span class="number">3</span> <span class="comment">#分别使用1/3的隐私预算来获得噪声求和值与噪声计数值</span></span><br><span class="line">    epsilon_count=epsilon/<span class="number">3</span></span><br><span class="line">    noisy_sum=laplace_mech(df.clip(lower=<span class="number">0</span>,upper=final_b).<span class="built_in">sum</span>(),final_b,epsilon_sum)</span><br><span class="line">    noisy_count=laplace_mech(<span class="built_in">len</span>(df),<span class="number">1</span>,epsilon_count)</span><br><span class="line">    <span class="keyword">return</span> noisy_sum/noisy_count</span><br><span class="line"><span class="built_in">print</span>(auto_avg(adult[<span class="string">&#x27;Age&#x27;</span>],<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(auto_avg(adult[<span class="string">&#x27;Capital Gain&#x27;</span>],<span class="number">1</span>)) <span class="comment">#可对不同尺度的数据使用相同的auto_avg函数</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">41.773740796468665</span><br><span class="line">1113.791301048865</span><br></pre></td></tr></table></figure>

<p>无论备选列表有多长，都能获得准确的结果，并消耗相同的隐私预算。该算法用了三次差分隐私机制，一次高于阈值算法，两次拉普拉斯机制，每个机制消耗$\dfrac{1}{3}\epsilon$的隐私预算，此算法满足$\epsilon$-差分隐私。</p>
<p>上述场景中只返回第一个超过阈值的问询索引号，有些场景中需要找到所有超过阈值的问询索引号。该任务可用稀疏算法挖成，但必须消耗更高的隐私预算。实现方法为：</p>
<ul>
<li>从问询流$q&#x3D;\lbrace q_1,q_2,\cdots,q_k\rbrace$开始。</li>
<li>在问询流$q$上执行高于阈值算法，得到第一个超过阈值的问询索引号$i$。</li>
<li>用$q’&#x3D;\lbrace q_{i+1},\cdots,q_k\rbrace$重启算法，转到第一步。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">age_sum_query</span>(<span class="params">df,b</span>):</span><br><span class="line">    <span class="keyword">return</span> df[<span class="string">&#x27;Age&#x27;</span>].clip(lower=<span class="number">0</span>,upper=b).<span class="built_in">sum</span>()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_query</span>(<span class="params">b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> df:age_sum_query(df,b)-age_sum_query(df,b+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">above_threshold_fail_signal</span>(<span class="params">queries,df,T,epsilon</span>):</span><br><span class="line">    T_hat=T+numpy.random.laplace(loc=<span class="number">0</span>,scale = <span class="number">2</span>/epsilon)   </span><br><span class="line">    <span class="keyword">for</span> idx,q <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries):</span><br><span class="line">        nu_i=numpy.random.laplace(loc=<span class="number">0</span>,scale = <span class="number">4</span>/epsilon)</span><br><span class="line">        <span class="keyword">if</span> q(df)+nu_i&gt;=T_hat:</span><br><span class="line">            <span class="keyword">return</span> idx</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sparse</span>(<span class="params">queries,df,c,T,epsilon</span>):</span><br><span class="line">    idxs=[]</span><br><span class="line">    pos=<span class="number">0</span></span><br><span class="line">    epsilon_i=epsilon/c</span><br><span class="line">    <span class="keyword">while</span> pos&lt;<span class="built_in">len</span>(queries) <span class="keyword">and</span> <span class="built_in">len</span>(idxs)&lt;c: <span class="comment">#如果我们执行完问询流中的所有问询 或者我们找到了c个超过阈值的问询回复 则停止</span></span><br><span class="line">        next_idx=above_threshold_fail_signal(queries[pos:],df,T,epsilon_i) <span class="comment">#执行高于阈值 寻找下一个超过阈值的问询回复</span></span><br><span class="line">        <span class="keyword">if</span> next_idx==<span class="literal">None</span>: <span class="comment">#如果高于阈值执行完了最后一个问询 则返回所有超过阈值的问询索引号</span></span><br><span class="line">            <span class="keyword">return</span> idxs</span><br><span class="line">        pos=next_idx+pos <span class="comment">#否则 使pos指向问询流中剩余的问询</span></span><br><span class="line">        idxs.append(pos) <span class="comment">#添加高于阈值找到的问询索引号</span></span><br><span class="line">        pos=pos+<span class="number">1</span> <span class="comment">#移动到问询流中的下一个问询</span></span><br><span class="line">    <span class="keyword">return</span> idxs</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line">bs=<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">150</span>,<span class="number">5</span>)</span><br><span class="line">queries=[create_query(b) <span class="keyword">for</span> b <span class="keyword">in</span> bs]</span><br><span class="line">epsilon=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(sparse(queries,adult,<span class="number">3</span>,<span class="number">0</span>,epsilon))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[15, 17, 18]</span><br></pre></td></tr></table></figure>

<p>稀疏算法每次消耗$\dfrac{\epsilon}{c}$的隐私预算来调用高于阈值算法，满足$\epsilon$-差分隐私。</p>
<p>范围问询问的是“数据集中有多少行的值落在范围$(a,b)$中？”，是一种计数问询，敏感度为$1$。随机生成一组针对年龄列的范围问询，回复结果可能相差甚远，部分询问可能值匹配很少的数据行，计数值很小，另一部分可能匹配大量数据行，计数值很大。多数情况下，小计数值的差分隐私回复结果会很不准确，实际意义不大。要做的事了解那些问询结果事有价值的，并仅为这些偶价值的问询结果支付隐私预算。</p>
<p>此时确定一个阈值，并得到范围问询流中回复结果超过此阈值的问询索引号，认为这些问询是有价值的问询，随后用拉普拉斯机制得到这些有价值问询的差分隐私回复结果。</p>
<p>例如使用一般隐私预算来确定阈值为$10000$的前$c$个问询，另一半隐私预算用于获取这些问询的噪声回复结果。若高于阈值的问询数量远小于总问询数量，使用此方法可获得更准确的回复结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">laplace_mech</span>(<span class="params">v,sensitivity,epsilon</span>):</span><br><span class="line">    <span class="keyword">return</span> v+numpy.random.laplace(loc=<span class="number">0</span>,scale=sensitivity/epsilon)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">age_range_query</span>(<span class="params">df,lower,upper</span>):</span><br><span class="line">    df1=df[df[<span class="string">&#x27;Age&#x27;</span>]&gt;lower]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(df1[df1[<span class="string">&#x27;Age&#x27;</span>]&lt;upper])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_age_range_query</span>():</span><br><span class="line">    lower=numpy.random.randint(<span class="number">30</span>,<span class="number">50</span>)</span><br><span class="line">    upper=numpy.random.randint(lower,<span class="number">70</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> df:age_range_query(df,lower,upper)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">above_threshold_fail_signal</span>(<span class="params">queries,df,T,epsilon</span>):</span><br><span class="line">    T_hat=T+numpy.random.laplace(loc=<span class="number">0</span>,scale = <span class="number">2</span>/epsilon)   </span><br><span class="line">    <span class="keyword">for</span> idx,q <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries):</span><br><span class="line">        nu_i=numpy.random.laplace(loc=<span class="number">0</span>,scale = <span class="number">4</span>/epsilon)</span><br><span class="line">        <span class="keyword">if</span> q(df)+nu_i&gt;=T_hat:</span><br><span class="line">            <span class="keyword">return</span> idx</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sparse</span>(<span class="params">queries,df,c,T,epsilon</span>):</span><br><span class="line">    idxs=[]</span><br><span class="line">    pos=<span class="number">0</span></span><br><span class="line">    epsilon_i=epsilon/c</span><br><span class="line">    <span class="keyword">while</span> pos&lt;<span class="built_in">len</span>(queries) <span class="keyword">and</span> <span class="built_in">len</span>(idxs)&lt;c:</span><br><span class="line">        next_idx=above_threshold_fail_signal(queries[pos:],df,T,epsilon_i)</span><br><span class="line">        <span class="keyword">if</span> next_idx==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> idxs</span><br><span class="line">        pos=next_idx+pos</span><br><span class="line">        idxs.append(pos)</span><br><span class="line">        pos=pos+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> idxs</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_query_svt</span>(<span class="params">queries,df,c,T,epsilon</span>):</span><br><span class="line">    sparse_epsilon=epsilon/<span class="number">2</span> <span class="comment">#得到有价值的问询</span></span><br><span class="line">    indices=sparse(queries,adult,c,T,sparse_epsilon)</span><br><span class="line">    laplace_epsilon=epsilon/(<span class="number">2</span>*c) <span class="comment">#为每个有价值的问询执行拉普拉斯机制</span></span><br><span class="line">    results=[laplace_mech(queries[i](df),<span class="number">1</span>,laplace_epsilon) <span class="keyword">for</span> i <span class="keyword">in</span> indices]</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line">range_queries=[create_age_range_query() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">results=[q(adult) <span class="keyword">for</span> q <span class="keyword">in</span> range_queries]</span><br><span class="line"><span class="built_in">print</span>(results)</span><br><span class="line"><span class="built_in">print</span>(range_query_svt(range_queries,adult,<span class="number">5</span>,<span class="number">10000</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 5798, 4748, 7870, 13678, 8474, 13678, 11064, 16800, 11558]</span><br><span class="line">[13678.488637395474, 13684.047786305475, 11061.639560389842, 16810.671437590594, 11554.188968324295]</span><br></pre></td></tr></table></figure>

<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>一类监督学习问题：给定一组带标签的训练样本$\lbrace(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)\rbrace$，其中$x_i$称为特征向量，$y_i$为标签，要训练一个模型$\theta$。该模型可预测没有在训练集中出现过的新特征向量对应的标签。一般每个$x_i$都是一个描述训练样本特征的实数向量，$y_i$是从预先定义好的类型集合中选取的，每个类型一般用一个整数来表示，要预先从全部样本中提取所有可能的类型，构成类型合集。二分类器的类型集合应包含两个类型，用$0&#x2F;1$或$1&#x2F;-1$表示。</p>
<p>训练模型时，从所有可用数据中选择一些来构造一组训练样本，留出一些作为测试样本。训练完模型应试验在非训练样本上的表现如何。若一个模型在未知新样本上表现很好，则称其泛化能力号。泛化能力不去的模型称其在训练数据上发生了过拟合。</p>
<p>给定一个包含$k$维特征向量$x_1,x_2,\cdots,x_k$的无标签样本，线性模型预测此样本的标签时，将计算$\displaystyle\sum_{i&#x3D;1}^kw_ix_i+\beta$并用其符号作为预测标签，附属为$-1$，正数为$1$。$w_1,w_2,\cdots,w_k$称为模型的权重（或系数），$\beta$被称为偏差项（或截距），后续不考虑训练偏差项。</p>
<p>构建一个二分器的简单方法是使用逻辑回归，下面训练集包含$80%$的样本，测试集包含剩余$20%$的样本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">X=numpy.load(<span class="string">&#x27;adult_processed_x.npy&#x27;</span>)</span><br><span class="line">y=numpy.load(<span class="string">&#x27;adult_processed_y.npy&#x27;</span>)</span><br><span class="line">training_size=<span class="built_in">int</span>(X.shape[<span class="number">0</span>]*<span class="number">0.8</span>)</span><br><span class="line">X_train=X[:training_size]</span><br><span class="line">X_test=X[training_size:]</span><br><span class="line">y_train=y[:training_size]</span><br><span class="line">y_test=y[training_size:]</span><br><span class="line"><span class="built_in">print</span>(y_test.shape)</span><br><span class="line">model=LogisticRegression().fit(X_train[:<span class="number">1000</span>],y_train[:<span class="number">1000</span>])</span><br><span class="line"><span class="built_in">print</span>(model.predict(X_test))</span><br><span class="line"><span class="built_in">print</span>(numpy.<span class="built_in">sum</span>(model.predict(X_test)==y_test)/X_test.shape[<span class="number">0</span>]) <span class="comment">#准确率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">xi,theta,bias=<span class="number">0</span></span>): <span class="comment">#手动构造线性模型</span></span><br><span class="line">    label=numpy.sign(xi@theta+bias)</span><br><span class="line">    <span class="keyword">return</span> label</span><br><span class="line"><span class="built_in">print</span>(numpy.<span class="built_in">sum</span>(predict(X_test,model.coef_[<span class="number">0</span>],model.intercept_[<span class="number">0</span>])==y_test)/X_test.shape[<span class="number">0</span>]) <span class="comment">#获得权重和偏差项</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(9044,)</span><br><span class="line">[-1. -1. -1. ... -1. -1. -1.]</span><br><span class="line">0.8243034055727554</span><br><span class="line">0.8243034055727554</span><br></pre></td></tr></table></figure>

<p>损失函数衡量模型预测结果有多差，训练算法的目标是使损失函数达到最小值，损失值低的模型具有更好的预测能力。对于每个预测正确的样本，简单损失函数返回$0$，预测错误的返回$1$。二分类器常用对率损失函数，度量模型还有多远距离才能正确预测出标签。下面尝试对率损失函数，但权重全部简单设为$0$，所以样本全部预测错误，整个训练集平均损失值等于单个样本损失值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">theta,xi,yi</span>):</span><br><span class="line">    exponent=-yi*(xi.dot(theta))</span><br><span class="line">    <span class="keyword">return</span> numpy.log(<span class="number">1</span>+numpy.exp(exponent))</span><br><span class="line">theta=numpy.zeros(X_train.shape[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(loss(theta,X_train[<span class="number">0</span>],y_train[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(numpy.mean([loss(theta,x_i,y_i) <span class="keyword">for</span> x_i,y_i <span class="keyword">in</span> <span class="built_in">zip</span>(X_train,y_train)]))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.6931471805599453</span><br><span class="line">0.6931471805599453</span><br></pre></td></tr></table></figure>

<p>为了降低损失值，采用负梯度修改模型，这一过程称为梯度下降。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gradient</span>(<span class="params">theta,xi,yi</span>): <span class="comment">#梯度函数</span></span><br><span class="line">    exponent=yi*(xi.dot(theta))</span><br><span class="line">    <span class="keyword">return</span> -(yi*xi)/(<span class="number">1</span>+numpy.exp(exponent))</span><br><span class="line">theta=theta-gradient(theta,X_train[<span class="number">0</span>],y_train[<span class="number">0</span>]) <span class="comment">#本例只计算了训练集中第一个样本的梯度</span></span><br><span class="line"><span class="built_in">print</span>(theta)</span><br><span class="line"><span class="built_in">print</span>(y_train[<span class="number">0</span>],predict(theta,X_train[<span class="number">0</span>])) <span class="comment">#更新后的模型具备分类样本的能力</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">theta</span>): <span class="comment">#度量准确性</span></span><br><span class="line">    <span class="keyword">return</span> numpy.<span class="built_in">sum</span>(predict(X_test,theta)==y_test)/X_test.shape[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(accuracy(theta))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ 0.          0.          0.          0.         -0.5         0.</span><br><span class="line">  0.          0.         -0.5         0.          0.          0.</span><br><span class="line">  0.          0.          0.          0.          0.          0.</span><br><span class="line">  0.          0.          0.          0.          0.          0.</span><br><span class="line">  0.         -0.5         0.          0.          0.          0.</span><br><span class="line">  0.          0.         -0.5         0.          0.          0.</span><br><span class="line">  0.          0.          0.          0.          0.          0.</span><br><span class="line">  0.          0.         -0.5         0.          0.          0.</span><br><span class="line">  0.          0.          0.          0.          0.          0.</span><br><span class="line"> -0.5         0.         -0.5         0.          0.          0.</span><br><span class="line">  0.          0.          0.          0.          0.          0.</span><br><span class="line">  0.          0.          0.          0.          0.          0.</span><br><span class="line">  0.          0.          0.          0.          0.          0.</span><br><span class="line">  0.          0.          0.          0.          0.          0.</span><br><span class="line">  0.          0.          0.          0.          0.          0.</span><br><span class="line">  0.          0.          0.          0.          0.         -0.5</span><br><span class="line">  0.          0.         -0.25       -0.0606146  -0.21875     0.</span><br><span class="line">  0.         -0.17676768]</span><br><span class="line">-1.0 -1.0</span><br><span class="line">0.7585139318885449</span><br></pre></td></tr></table></figure>

<p>接下来把单样本梯度替换成所有训练样本的平均梯度，再定义一个可多次执行梯度下降的迭代算法，这就是常用的梯度下降算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">avg_grad</span>(<span class="params">theta,X,y</span>):</span><br><span class="line">    grads=[gradient(theta,xi,yi) <span class="keyword">for</span> xi,yi <span class="keyword">in</span> <span class="built_in">zip</span>(X,y)]</span><br><span class="line">    <span class="keyword">return</span> numpy.mean(grads,axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent</span>(<span class="params">iterations</span>):</span><br><span class="line">    theta=numpy.zeros(X_train.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">        theta=theta-avg_grad(theta,X_train,y_train)</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line">avg_grad(theta,X_train,y_train)</span><br><span class="line">theta=gradient_descent(<span class="number">10</span>) <span class="comment">#可增大 100达到82%左右</span></span><br><span class="line"><span class="built_in">print</span>(accuracy(theta))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.7787483414418399</span><br></pre></td></tr></table></figure>

<p>接下来要设计一种算法为训练数据提供差分隐私保护，使最终训练得到的模型不会泄露与单个训练样本相关的任何信息。噪声梯度下降是在每轮模型更新前在梯度上增加噪声。</p>
<p>梯度是均值问询的结果，是每个样本梯度的均值。最好拆成一个求和问询和一个计数问询，这里计算每个样本梯度噪声和，除以噪声梯度值。此外需要限制每个样本梯度的敏感度，这里用类似采样—聚合框架的方法，裁剪梯度函数输出值，强制限定敏感度上限，称为梯度裁剪。</p>
<p>为了使输出向量的L2范数落在期望的范围内，通过缩放向量来做到裁剪向量，例如把向量中元素都除以向量的L2范数，则所得向量的L2范数为$1$。若将梯度表示为$\nabla(\theta;X,y)$，则梯度敏感度为$\left|\left|\operatorname{L2\_clip}(\nabla(\theta;X,y),b)-\operatorname{L2\_clip}(\nabla(\theta;X’,y),0)\right|\right|_2$，最差情况下$\left|\left|\operatorname{L2\_clip}(\nabla(\theta;X,y),b)\right|\right|_2&#x3D;b,\operatorname{L2\_clip}(\nabla(\theta;X’,y),0)&#x3D;\overrightarrow0$，两者L2范数差为$b$，做到了用裁剪参数$b$限定了梯度的L2敏感度上界。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">laplace_mech</span>(<span class="params">v,sensitivity,epsilon</span>):</span><br><span class="line">    <span class="keyword">return</span> v+numpy.random.laplace(loc=<span class="number">0</span>,scale=sensitivity/epsilon)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian_mech_vec</span>(<span class="params">v,sensitivity,epsilon,delta</span>):</span><br><span class="line">    <span class="keyword">return</span> v+numpy.random.normal(loc=<span class="number">0</span>,scale=sensitivity*numpy.sqrt(<span class="number">2</span>*numpy.log(<span class="number">1.25</span>/delta))/epsilon,size=<span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">L2_clip</span>(<span class="params">v,b</span>):</span><br><span class="line">    norm = numpy.linalg.norm(v,<span class="built_in">ord</span>=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> norm&gt;b:</span><br><span class="line">        <span class="keyword">return</span> b*(v/norm)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_sum</span>(<span class="params">theta,X,y,b</span>):</span><br><span class="line">    gradients=[L2_clip(gradient(theta,x_i,y_i),b) <span class="keyword">for</span> x_i,y_i <span class="keyword">in</span> <span class="built_in">zip</span>(X,y)]</span><br><span class="line">    <span class="keyword">return</span> numpy.<span class="built_in">sum</span>(gradients,axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">noisy_gradient_descent</span>(<span class="params">iterations,epsilon,delta</span>):</span><br><span class="line">    theta=numpy.zeros(X_train.shape[<span class="number">1</span>])</span><br><span class="line">    sensitivity=<span class="number">5.0</span></span><br><span class="line">    noisy_count=laplace_mech(X_train.shape[<span class="number">0</span>],<span class="number">1</span>,epsilon)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">        grad_sum=gradient_sum(theta,X_train,y_train,sensitivity)</span><br><span class="line">        noisy_grad_sum=gaussian_mech_vec(grad_sum,sensitivity,epsilon,delta)</span><br><span class="line">        noisy_avg_grad=noisy_grad_sum/noisy_count</span><br><span class="line">        theta=theta-noisy_avg_grad</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line">theta=noisy_gradient_descent(<span class="number">10</span>,<span class="number">0.1</span>,<span class="number">1e-5</span>)</span><br><span class="line"><span class="built_in">print</span>(accuracy(theta))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.7793011941618753</span><br></pre></td></tr></table></figure>

<p>该算法每轮迭代满足$(\epsilon,\delta)$-差分隐私，且额外执行一次噪声计数问询得到满足$\epsilon$-差分隐私的噪声计数值。若执行$k$轮迭代，算法满足$((k+1)\epsilon,k\delta)$-差分隐私，可用高级组合性来分析总隐私消耗量。还可以将算法转为Rényi差分隐私或零集中差分隐私，得到更紧致的总隐私消耗量。</p>
<p>对率损失函数等梯度函数是Lipschitz连续的，这些梯度函数的全局敏感度是有界的。即如果$||x_i||_2\leqslant b$，则$||\nabla(\theta;x_i,y_i)||_2\leqslant b$。这样可通过裁剪训练样本，即梯度函数输入，来获得梯度函数的L2敏感度上界，不需要裁剪梯度函数输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_sum</span>(<span class="params">theta,X,y,b</span>):</span><br><span class="line">    gradients=[gradient(theta,x_i,y_i) <span class="keyword">for</span> x_i,y_i <span class="keyword">in</span> <span class="built_in">zip</span>(X,y)]</span><br><span class="line">    <span class="keyword">return</span> numpy.<span class="built_in">sum</span>(gradients,axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">noisy_gradient_descent</span>(<span class="params">iterations,epsilon,delta</span>):</span><br><span class="line">    theta=numpy.zeros(X_train.shape[<span class="number">1</span>])</span><br><span class="line">    sensitivity=<span class="number">5.0</span></span><br><span class="line">    noisy_count=laplace_mech(X_train.shape[<span class="number">0</span>],<span class="number">1</span>,epsilon)</span><br><span class="line">    clipped_X=[L2_clip(x_i,sensitivity) <span class="keyword">for</span> x_i <span class="keyword">in</span> X_train]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">        grad_sum=gradient_sum(theta,clipped_X,y_train,sensitivity)</span><br><span class="line">        noisy_grad_sum=gaussian_mech_vec(grad_sum,sensitivity,epsilon,delta)</span><br><span class="line">        noisy_avg_grad=noisy_grad_sum/noisy_count</span><br><span class="line">        theta=theta-noisy_avg_grad</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line">theta=noisy_gradient_descent(<span class="number">10</span>,<span class="number">0.1</span>,<span class="number">1e-5</span>)</span><br><span class="line"><span class="built_in">print</span>(accuracy(theta))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.7826183104820875</span><br></pre></td></tr></table></figure>

<p>更小的$\epsilon$会带来准确率更低的模型。更多的迭代次数意味更大的隐私消耗量，而在标准梯度下降算法中，更多迭代次数以为产出更好的模型。在差分隐私保护下，当总隐私预算保持不变时，更多迭代次数可能导致模型变得更糟糕，不得不使用更小的$\epsilon$支持更多轮迭代，这带来更大的噪声。</p>
<h2 id="本地差分隐私"><a href="#本地差分隐私" class="headerlink" title="本地差分隐私"></a>本地差分隐私</h2><p>在中心模型中，原始敏感数据被汇总到单个数据集中，假定分析者是恶意的，单存在一个可信数据管理者，由他持有数据集并能正确执行分析者指定的差分隐私机制。在本地模型中，数据在离开数据主题控制前就已经满足差分隐私，如在将数据发送给数据管理者之前，用户就在自己设备上为自己数据添加噪声，数据管理者不需要可信，因为收集的是已经满足差分隐私的数据。</p>
<p>但在相同隐私预算下，对于相同问询，本地模型问询结果准确性通常比中心模型低几个数量级，意味着只有较少类型的问询适用于本地差分隐私。只有当数据量较大，参与者数量较多，差分隐私本地模型分析结果准确率才可满足实际要求。</p>
<p>随机应答是一种本地差分隐私机制，允许用户用错误的回复来应答调研中的敏感问题，引入的不确定性是差分隐私机制可提供隐私保护的根本原因，但算法输出结果仍释放足够信号帮助推断相关信息。在此过程中，数据主体按下述方法用“是”或“不是”回答一个问题：</p>
<ul>
<li>掷一枚硬币。</li>
<li>若硬币正面向上，如实回答问题。</li>
<li>若硬币反面向上，再掷一枚硬币。</li>
<li>若第二枚硬币也是正面向上，回答“是”，否则回答“不是”。</li>
</ul>
<p>该随机应答算法满足$\epsilon$-差分隐私，其中$\epsilon&#x3D;\ln3$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy,pandas</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rand_resp_sales</span>(<span class="params">response</span>):</span><br><span class="line">    truthful_response=response==<span class="string">&#x27;Sales&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> numpy.random.randint(<span class="number">0</span>,<span class="number">2</span>)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> truthful_response</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> numpy.random.randint(<span class="number">0</span>,<span class="number">2</span>)==<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(pandas.Series([rand_resp_sales(<span class="string">&#x27;Sales&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]).value_counts())</span><br><span class="line"></span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line">responses=[rand_resp_sales(r) <span class="keyword">for</span> r <span class="keyword">in</span> adult[<span class="string">&#x27;Occupation&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(pandas.Series(responses).value_counts())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(adult[adult[<span class="string">&#x27;Occupation&#x27;</span>]==<span class="string">&#x27;Sales&#x27;</span>])) <span class="comment">#“是”的数量</span></span><br><span class="line"></span><br><span class="line">responses=[rand_resp_sales(r) <span class="keyword">for</span> r <span class="keyword">in</span> adult[<span class="string">&#x27;Occupation&#x27;</span>]]</span><br><span class="line">fake_yesses=<span class="built_in">len</span>(responses)/<span class="number">4</span> <span class="comment">#1/4的“是”来自随机结果 都是假的</span></span><br><span class="line">num_yesses=numpy.<span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">if</span> r <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> r <span class="keyword">in</span> responses]) <span class="comment">#“是”总人数</span></span><br><span class="line">true_yesses=num_yesses-fake_yesses <span class="comment">#真实“是”的人数</span></span><br><span class="line">rr_result = true_yesses*<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(rr_result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">laplace_mech</span>(<span class="params">v,sensitivity,epsilon</span>):</span><br><span class="line">    <span class="keyword">return</span> v+numpy.random.laplace(loc=<span class="number">0</span>,scale=sensitivity/epsilon)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pct_error</span>(<span class="params">orig,priv</span>):</span><br><span class="line">    <span class="keyword">return</span> numpy.<span class="built_in">abs</span>(orig-priv)/orig*<span class="number">100.0</span></span><br><span class="line">true_result=numpy.<span class="built_in">sum</span>(adult[<span class="string">&#x27;Occupation&#x27;</span>]==<span class="string">&#x27;Sales&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(true_result)</span><br><span class="line"><span class="built_in">print</span>(pct_error(true_result,rr_result)) <span class="comment">#错误率</span></span><br><span class="line"><span class="built_in">print</span>(pct_error(true_result,laplace_mech(true_result,<span class="number">1</span>,<span class="number">1</span>))) <span class="comment">#中心模型拉普拉斯机制错误率</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">True     148</span><br><span class="line">False     52</span><br><span class="line">Name: count, dtype: int64</span><br><span class="line">False    22735</span><br><span class="line">True      9828</span><br><span class="line">Name: count, dtype: int64</span><br><span class="line">3650</span><br><span class="line">3606.5</span><br><span class="line">3650</span><br><span class="line">1.1917808219178083</span><br><span class="line">0.006456525121655132</span><br></pre></td></tr></table></figure>

<p>一元编码方法解决本地差分隐私的直方图问询问题。首先定义应大于，即直方图包含的标签。然后下面三个函数实现了一元编码机制：</p>
<ul>
<li>编码函数<code>encode </code>：编码应答值。</li>
<li>扰动函数<code>perturb</code>：扰动编码后的应答值。</li>
<li>聚合函数<code>aggregate</code>：根据扰动应答值重构最终结果。</li>
</ul>
<p>若应答域大小为$k$，将每个应答值编码为长度为$k$的比特向量，除应答者只为对应比特值为$1$以外，其他未知编码均为$0$，这种方法称为独热编码。</p>
<p>用扰动函数反转应答向量中各个比特值，满足差分隐私。翻转一个比特位的概率由$p$和$q$共同决定，即$\operatorname{Pr}(B’[i]&#x3D;1)&#x3D;\begin{cases}p&amp;:B[i]&#x3D;1\\q&amp;:B[i]&#x3D;0\end{cases}$。$\epsilon$可通过$p$和$q$计算得到$\epsilon&#x3D;\ln\dfrac{p(1-q)}{(1-p)q}$。</p>
<p>聚合函数需要考虑每个标签的“假”应答数量，得到聚合结果$A[i]&#x3D;\dfrac{\displaystyle\sum_j B_j’[i]-nq}{p-q}$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line">domain=adult[<span class="string">&#x27;Occupation&#x27;</span>].dropna().unique()</span><br><span class="line"><span class="built_in">print</span>(domain)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">response</span>):</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span> <span class="keyword">if</span> d == response <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> d <span class="keyword">in</span> domain]</span><br><span class="line"><span class="built_in">print</span>(encode(<span class="string">&#x27;Sales&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perturb_bit</span>(<span class="params">bit</span>):</span><br><span class="line">    p=<span class="number">.75</span></span><br><span class="line">    q=<span class="number">.25</span></span><br><span class="line">    sample=numpy.random.random()</span><br><span class="line">    <span class="keyword">if</span> bit==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> sample&lt;=p:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> bit==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> sample&lt;=q:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perturb</span>(<span class="params">encoded_response</span>):</span><br><span class="line">    <span class="keyword">return</span> [perturb_bit(b) <span class="keyword">for</span> b <span class="keyword">in</span> encoded_response]</span><br><span class="line"><span class="built_in">print</span>(perturb(encode(<span class="string">&#x27;Sales&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unary_epsilon</span>(<span class="params">p,q</span>):</span><br><span class="line">    <span class="keyword">return</span> numpy.log((p*(<span class="number">1</span>-q))/((<span class="number">1</span>-p)*q))</span><br><span class="line"><span class="built_in">print</span>(unary_epsilon(<span class="number">.75</span>,<span class="number">.25</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aggregate</span>(<span class="params">responses</span>):</span><br><span class="line">    p=<span class="number">.75</span></span><br><span class="line">    q=<span class="number">.25</span></span><br><span class="line">    sums=numpy.<span class="built_in">sum</span>(responses,axis=<span class="number">0</span>)</span><br><span class="line">    n=<span class="built_in">len</span>(responses)</span><br><span class="line">    <span class="keyword">return</span> [(v-n*q)/(p-q) <span class="keyword">for</span> v <span class="keyword">in</span> sums]</span><br><span class="line">responses=[perturb(encode(r)) <span class="keyword">for</span> r <span class="keyword">in</span> adult[<span class="string">&#x27;Occupation&#x27;</span>]]</span><br><span class="line">counts=aggregate(responses)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(domain,counts)))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;Adm-clerical&#x27; &#x27;Exec-managerial&#x27; &#x27;Handlers-cleaners&#x27; &#x27;Prof-specialty&#x27;</span><br><span class="line"> &#x27;Other-service&#x27; &#x27;Sales&#x27; &#x27;Craft-repair&#x27; &#x27;Transport-moving&#x27;</span><br><span class="line"> &#x27;Farming-fishing&#x27; &#x27;Machine-op-inspct&#x27; &#x27;Tech-support&#x27; &#x27;Protective-serv&#x27;</span><br><span class="line"> &#x27;Baby&#x27; &#x27;Armed-Forces&#x27; &#x27;Priv-house-serv&#x27;]</span><br><span class="line">[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">2.1972245773362196</span><br><span class="line">[(&#x27;Adm-clerical&#x27;, 3518.5), (&#x27;Exec-managerial&#x27;, 3718.5), (&#x27;Handlers-cleaners&#x27;, 1432.5), (&#x27;Prof-specialty&#x27;, 4076.5), (&#x27;Other-service&#x27;, 3512.5), (&#x27;Sales&#x27;, 3630.5), (&#x27;Craft-repair&#x27;, 4174.5), (&#x27;Transport-moving&#x27;, 1630.5), (&#x27;Farming-fishing&#x27;, 780.5), (&#x27;Machine-op-inspct&#x27;, 1806.5), (&#x27;Tech-support&#x27;, 1076.5), (&#x27;Protective-serv&#x27;, 766.5), (&#x27;Baby&#x27;, -217.5), (&#x27;Armed-Forces&#x27;, -45.5), (&#x27;Priv-house-serv&#x27;, 68.5)]</span><br></pre></td></tr></table></figure>

<h2 id="合成数据"><a href="#合成数据" class="headerlink" title="合成数据"></a>合成数据</h2><p>合成数据生成算法的输入是一个原始数据集，输出是维度相同的合成数据集，期望合成数据集的数据与原始数据集的对应数据满足相同性质，且保留列之间的相关性。合成表示与原始数据维数不同，但可用于回答原始数据的问询，如直方图等。</p>
<p>为了满足差分隐私，在直方图每个计数值上单独增加拉普拉斯噪声即可，满足$\epsilon$-差分隐私。</p>
<p>对于拉普拉斯机制，计数值随着年龄范围增大而增大，更大分组意味着更强的信号，统计结果信噪比贬低，相对误差降低。对于合成表示，相对误差与问询范围无关，因为信号变强了，很多小分组的噪声也加在一起，噪声也变大了。</p>
<p>合成表示的下一步是合成数据，方法是将合成表示视为一个可用于估计原始数据潜在分布的概率分布函数，进而根据此概率分布采样，得到合成数据集。这里只考虑单列数据，其概率称为单维边际分布。先对直方图每个属性值计数，随后归一化计数结果，使所有计数结果和为$1$，得到概率值。</p>
<p>为了生成包含更多数据列的合成数据集，如考虑年龄和职业两列，可采用二维边缘分布。沿用之前的做法，在各个计数值上增加噪声后归一化处理，得到的计数结果视为概率值，每个计数结果对应的是年龄和职业一对属性值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas,numpy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_query</span>(<span class="params">df,col,a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(df[(df[col]&gt;=a)&amp;(df[col]&lt;b)])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_query_synth</span>(<span class="params">syn_rep,a,b</span>):</span><br><span class="line">    total=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        total+=syn_rep[i]</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">adult=pandas.read_csv(<span class="string">&quot;adult_with_pii.csv&quot;</span>)</span><br><span class="line">bins=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>))</span><br><span class="line">counts=[range_query(adult,<span class="string">&#x27;Age&#x27;</span>,b,b+<span class="number">1</span>) <span class="keyword">for</span> b <span class="keyword">in</span> bins]</span><br><span class="line"><span class="built_in">print</span>(range_query_synth(counts,<span class="number">21</span>,<span class="number">33</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">laplace_mech</span>(<span class="params">v, sensitivity, epsilon</span>):</span><br><span class="line">    <span class="keyword">return</span> v + numpy.random.laplace(loc=<span class="number">0</span>, scale=sensitivity / epsilon)</span><br><span class="line">epsilon = <span class="number">1</span></span><br><span class="line">dp_syn_rep = [laplace_mech(c, <span class="number">1</span>, epsilon) <span class="keyword">for</span> c <span class="keyword">in</span> counts]</span><br><span class="line"><span class="built_in">print</span>(range_query_synth(dp_syn_rep, <span class="number">21</span>, <span class="number">33</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pct_error</span>(<span class="params">orig, priv</span>):</span><br><span class="line">    <span class="keyword">return</span> numpy.<span class="built_in">abs</span>(orig - priv)/orig * <span class="number">100.0</span></span><br><span class="line">true_answer = range_query(adult, <span class="string">&#x27;Age&#x27;</span>, <span class="number">30</span>, <span class="number">31</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;合成表示误差率：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pct_error(true_answer, range_query_synth(dp_syn_rep, <span class="number">30</span>, <span class="number">31</span>))))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拉普拉斯机制误差率：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pct_error(true_answer, laplace_mech(true_answer, <span class="number">1</span>, epsilon))))</span><br><span class="line">true_answer = range_query(adult, <span class="string">&#x27;Age&#x27;</span>, <span class="number">30</span>, <span class="number">71</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;合成表示误差率：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pct_error(true_answer, range_query_synth(dp_syn_rep, <span class="number">30</span>, <span class="number">71</span>))))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拉普拉斯机制误差率：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pct_error(true_answer, laplace_mech(true_answer, <span class="number">1</span>, epsilon))))</span><br><span class="line"></span><br><span class="line">dp_syn_rep_nn = numpy.clip(dp_syn_rep, <span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">syn_normalized = dp_syn_rep_nn / numpy.<span class="built_in">sum</span>(dp_syn_rep_nn)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_samples</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> numpy.random.choice(bins, n, p=syn_normalized) <span class="comment">#加权采样</span></span><br><span class="line">syn_data = pandas.DataFrame(gen_samples(<span class="number">5</span>), columns=[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(syn_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄均值合成结果：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(numpy.mean(syn_data[<span class="string">&#x27;Age&#x27;</span>])))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄均值真实结果：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(numpy.mean(adult[<span class="string">&#x27;Age&#x27;</span>])))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;误差率：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pct_error(numpy.mean(syn_data[<span class="string">&#x27;Age&#x27;</span>]), numpy.mean(adult[<span class="string">&#x27;Age&#x27;</span>]))))</span><br><span class="line">n = laplace_mech(<span class="built_in">len</span>(adult), <span class="number">1</span>, <span class="number">1.0</span>)</span><br><span class="line">syn_data = pandas.DataFrame(gen_samples(<span class="built_in">int</span>(n)), columns=[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄范围问询合成结果：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(range_query(syn_data, <span class="string">&#x27;Age&#x27;</span>, <span class="number">20</span>, <span class="number">65</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄范围问询真实结果：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(range_query(adult, <span class="string">&#x27;Age&#x27;</span>, <span class="number">20</span>, <span class="number">65</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;误差率：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pct_error(range_query(adult, <span class="string">&#x27;Age&#x27;</span>, <span class="number">20</span>, <span class="number">65</span>), range_query(syn_data, <span class="string">&#x27;Age&#x27;</span>, <span class="number">20</span>, <span class="number">65</span>))))</span><br><span class="line"></span><br><span class="line">ct=pandas.crosstab(adult[<span class="string">&#x27;Age&#x27;</span>],adult[<span class="string">&#x27;Occupation&#x27;</span>])</span><br><span class="line">dp_ct=ct.applymap(<span class="keyword">lambda</span> x:<span class="built_in">max</span>(laplace_mech(x,<span class="number">1</span>,<span class="number">1</span>),<span class="number">0</span>))</span><br><span class="line">dp_vals=dp_ct.stack().reset_index().values.tolist()</span><br><span class="line">probs=[p <span class="keyword">for</span> _,_,p <span class="keyword">in</span> dp_vals]</span><br><span class="line">vals=[(a,b) <span class="keyword">for</span> a,b,_ <span class="keyword">in</span> dp_vals]</span><br><span class="line">probs_norm=probs/numpy.<span class="built_in">sum</span>(probs)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(vals,probs_norm))[<span class="number">0</span>])</span><br><span class="line">indices=<span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(vals))</span><br><span class="line">n=laplace_mech(<span class="built_in">len</span>(adult),<span class="number">1</span>,<span class="number">1.0</span>)</span><br><span class="line">gen_indices=numpy.random.choice(indices,<span class="built_in">int</span>(n),p=probs_norm)</span><br><span class="line">syn_data=[vals[i] <span class="keyword">for</span> i <span class="keyword">in</span> gen_indices]</span><br><span class="line">syn_df=pandas.DataFrame(syn_data,columns=[<span class="string">&#x27;Age&#x27;</span>,<span class="string">&#x27;Occupation&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(syn_df.head())</span><br><span class="line">real_answer=range_query(adult,<span class="string">&#x27;Age&#x27;</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line">syn_answer=range_query(syn_df,<span class="string">&#x27;Age&#x27;</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;误差率：&#x27;</span>,pct_error(real_answer,syn_answer))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">6245</span><br><span class="line">6243.090943873088</span><br><span class="line">合成表示误差率：0.34286383388197766</span><br><span class="line">拉普拉斯机制误差率：0.3164829375822671</span><br><span class="line">合成表示误差率：0.013231792885249637</span><br><span class="line">拉普拉斯机制误差率：0.002105545219908062</span><br><span class="line">   Age</span><br><span class="line">0   34</span><br><span class="line">1   48</span><br><span class="line">2   68</span><br><span class="line">3   60</span><br><span class="line">4   21</span><br><span class="line">年龄均值合成结果：46.2</span><br><span class="line">年龄均值真实结果：41.77250253355035</span><br><span class="line">误差率：9.583327849458119</span><br><span class="line">年龄范围问询合成结果：23575</span><br><span class="line">年龄范围问询真实结果：23574</span><br><span class="line">误差率：0.004241961482989734</span><br><span class="line">((1, &#x27;Adm-clerical&#x27;), 1.080324441269666e-05)</span><br><span class="line">   Age       Occupation</span><br><span class="line">0   45            Sales</span><br><span class="line">1   29  Exec-managerial</span><br><span class="line">2   38            Sales</span><br><span class="line">3   45     Tech-support</span><br><span class="line">4   15  Farming-fishing</span><br><span class="line">误差率： 0.42024832855778416</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io">Monoceros406</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://monoceros406.github.io/2025/05/03/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8/">https://monoceros406.github.io/2025/05/03/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://monoceros406.github.io" target="_blank">The Blog of Monoceros406</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/05/05/Qt6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%85%A5%E9%97%A8/" title="Qt6开发入门-环境配置与入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Qt6开发入门-环境配置与入门</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/26/%E5%85%AC%E5%91%8A-%E6%97%A0%E9%99%90%E6%9C%9F%E5%81%9C%E6%9B%B4/" title="公告-无限期停更"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">公告-无限期停更</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/31/Crypto%E5%85%A5%E9%97%A8-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%88%9D%E6%8E%A2/" title="Crypto入门-分组密码初探"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="title">Crypto入门-分组密码初探</div></div></a></div><div><a href="/2024/03/31/Crypto%E5%85%A5%E9%97%A8-%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E7%9B%B8%E5%85%B3%E5%85%A5%E9%97%A8/" title="Crypto入门-离散对数相关入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="title">Crypto入门-离散对数相关入门</div></div></a></div><div><a href="/2024/02/23/Crypto%E5%85%A5%E9%97%A8-RSA/" title="Crypto入门-RSA"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-23</div><div class="title">Crypto入门-RSA</div></div></a></div><div><a href="/2024/03/31/Crypto%E5%85%A5%E9%97%A8-%E6%B5%81%E5%AF%86%E7%A0%81%E5%88%9D%E6%8E%A2/" title="Crypto入门-流密码初探"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="title">Crypto入门-流密码初探</div></div></a></div><div><a href="/2024/03/31/Crypto%E5%85%A5%E9%97%A8-%E5%AF%86%E7%A0%81%E5%AD%A6%E6%9D%82%E8%B0%88/" title="Crypto入门-密码学杂谈"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="title">Crypto入门-密码学杂谈</div></div></a></div><div><a href="/2024/02/23/Crypto%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E5%A4%8D%E7%9B%98/" title="Crypto入门-基础数论复盘"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-23</div><div class="title">Crypto入门-基础数论复盘</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Monoceros406</div><div class="author-info__description">Windows系统安全爱好者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">320</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Monoceros406"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Monoceros406" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:monoceros406@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://monoceros406.github.io/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哪里排版出锅了请告诉我QwQ  QQ:1295625063</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">差分隐私实践入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%BB%E6%A0%87%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">去标识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E6%A0%87%E8%AF%86%E4%B8%8E%E5%85%B3%E8%81%94%E6%94%BB%E5%87%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">去标识与关联攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">聚合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#k-%E5%8C%BF%E5%90%8D%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">$k$-匿名性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81"><span class="toc-number">1.3.</span> <span class="toc-text">差分隐私</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.4.</span> <span class="toc-text">差分隐私的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%8F%E6%84%9F%E5%BA%A6"><span class="toc-number">1.5.</span> <span class="toc-text">敏感度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%91%E4%BC%BC%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81"><span class="toc-number">1.6.</span> <span class="toc-text">近似差分隐私</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%BA%A6"><span class="toc-number">1.7.</span> <span class="toc-text">局部敏感度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E5%8F%98%E4%BD%93"><span class="toc-number">1.8.</span> <span class="toc-text">差分隐私变体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.</span> <span class="toc-text">指数机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E5%90%91%E9%87%8F%E6%8A%80%E6%9C%AF"><span class="toc-number">1.10.</span> <span class="toc-text">稀疏向量技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.11.</span> <span class="toc-text">机器学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81"><span class="toc-number">1.12.</span> <span class="toc-text">本地差分隐私</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90%E6%95%B0%E6%8D%AE"><span class="toc-number">1.13.</span> <span class="toc-text">合成数据</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/19/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="C-后端开发入门-TCP服务器编程">C-后端开发入门-TCP服务器编程</a><time datetime="2025-05-19T06:13:56.000Z" title="发表于 2025-05-19 14:13:56">2025-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/11/Qt6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E7%AE%80%E4%BB%8B/" title="Qt6开发入门-常用控件简介">Qt6开发入门-常用控件简介</a><time datetime="2025-05-11T03:15:46.000Z" title="发表于 2025-05-11 11:15:46">2025-05-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/11/Qt6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-Qt%E6%A1%86%E6%9E%B6%E7%BB%BC%E8%BF%B0/" title="Qt6开发入门-Qt框架综述">Qt6开发入门-Qt框架综述</a><time datetime="2025-05-11T01:55:46.000Z" title="发表于 2025-05-11 09:55:46">2025-05-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/05/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="C++后端开发入门-环境配置与多线程编程">C++后端开发入门-环境配置与多线程编程</a><time datetime="2025-05-05T14:17:09.000Z" title="发表于 2025-05-05 22:17:09">2025-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/05/Qt6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%85%A5%E9%97%A8/" title="Qt6开发入门-环境配置与入门">Qt6开发入门-环境配置与入门</a><time datetime="2025-05-05T13:30:44.000Z" title="发表于 2025-05-05 21:30:44">2025-05-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Monoceros406</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>